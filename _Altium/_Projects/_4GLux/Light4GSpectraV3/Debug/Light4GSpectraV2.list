
Light4GSpectraV2.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   00000194  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         0000f39c  080001a0  080001a0  000101a0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000c70  0800f53c  0800f53c  0001f53c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM          00000008  080101ac  080101ac  000201ac  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .init_array   00000004  080101b4  080101b4  000201b4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  5 .fini_array   00000004  080101b8  080101b8  000201b8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  6 .data         00000248  20000000  080101bc  00030000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .bss          0000c3f8  20000248  08010404  00030248  2**2
                  ALLOC
  8 ._user_heap_stack 00000600  2000c640  08010404  0003c640  2**0
                  ALLOC
  9 .ARM.attributes 00000030  00000000  00000000  00030248  2**0
                  CONTENTS, READONLY
 10 .debug_info   0007d4fe  00000000  00000000  00030278  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_abbrev 0000bb3a  00000000  00000000  000ad776  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0001b66b  00000000  00000000  000b92b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_aranges 00002208  00000000  00000000  000d4920  2**3
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000032f0  00000000  00000000  000d6b28  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_line   0001910e  00000000  00000000  000d9e18  2**0
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0000b311  00000000  00000000  000f2f26  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .comment      0000007c  00000000  00000000  000fe237  2**0
                  CONTENTS, READONLY
 18 .debug_frame  000076d0  00000000  00000000  000fe2b4  2**2
                  CONTENTS, READONLY, DEBUGGING
 19 .stab         00000084  00000000  00000000  00105984  2**2
                  CONTENTS, READONLY, DEBUGGING
 20 .stabstr      00000117  00000000  00000000  00105a08  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001a0 <__do_global_dtors_aux>:
 80001a0:	b510      	push	{r4, lr}
 80001a2:	4c05      	ldr	r4, [pc, #20]	; (80001b8 <__do_global_dtors_aux+0x18>)
 80001a4:	7823      	ldrb	r3, [r4, #0]
 80001a6:	b933      	cbnz	r3, 80001b6 <__do_global_dtors_aux+0x16>
 80001a8:	4b04      	ldr	r3, [pc, #16]	; (80001bc <__do_global_dtors_aux+0x1c>)
 80001aa:	b113      	cbz	r3, 80001b2 <__do_global_dtors_aux+0x12>
 80001ac:	4804      	ldr	r0, [pc, #16]	; (80001c0 <__do_global_dtors_aux+0x20>)
 80001ae:	f3af 8000 	nop.w
 80001b2:	2301      	movs	r3, #1
 80001b4:	7023      	strb	r3, [r4, #0]
 80001b6:	bd10      	pop	{r4, pc}
 80001b8:	20000248 	.word	0x20000248
 80001bc:	00000000 	.word	0x00000000
 80001c0:	0800f524 	.word	0x0800f524

080001c4 <frame_dummy>:
 80001c4:	b508      	push	{r3, lr}
 80001c6:	4b03      	ldr	r3, [pc, #12]	; (80001d4 <frame_dummy+0x10>)
 80001c8:	b11b      	cbz	r3, 80001d2 <frame_dummy+0xe>
 80001ca:	4903      	ldr	r1, [pc, #12]	; (80001d8 <frame_dummy+0x14>)
 80001cc:	4803      	ldr	r0, [pc, #12]	; (80001dc <frame_dummy+0x18>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	bd08      	pop	{r3, pc}
 80001d4:	00000000 	.word	0x00000000
 80001d8:	2000024c 	.word	0x2000024c
 80001dc:	0800f524 	.word	0x0800f524

080001e0 <strcmp>:
 80001e0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80001e4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80001e8:	2a01      	cmp	r2, #1
 80001ea:	bf28      	it	cs
 80001ec:	429a      	cmpcs	r2, r3
 80001ee:	d0f7      	beq.n	80001e0 <strcmp>
 80001f0:	1ad0      	subs	r0, r2, r3
 80001f2:	4770      	bx	lr

080001f4 <strlen>:
 80001f4:	4603      	mov	r3, r0
 80001f6:	f813 2b01 	ldrb.w	r2, [r3], #1
 80001fa:	2a00      	cmp	r2, #0
 80001fc:	d1fb      	bne.n	80001f6 <strlen+0x2>
 80001fe:	1a18      	subs	r0, r3, r0
 8000200:	3801      	subs	r0, #1
 8000202:	4770      	bx	lr
	...

08000210 <memchr>:
 8000210:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000214:	2a10      	cmp	r2, #16
 8000216:	db2b      	blt.n	8000270 <memchr+0x60>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	d008      	beq.n	8000230 <memchr+0x20>
 800021e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000222:	3a01      	subs	r2, #1
 8000224:	428b      	cmp	r3, r1
 8000226:	d02d      	beq.n	8000284 <memchr+0x74>
 8000228:	f010 0f07 	tst.w	r0, #7
 800022c:	b342      	cbz	r2, 8000280 <memchr+0x70>
 800022e:	d1f6      	bne.n	800021e <memchr+0xe>
 8000230:	b4f0      	push	{r4, r5, r6, r7}
 8000232:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000236:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800023a:	f022 0407 	bic.w	r4, r2, #7
 800023e:	f07f 0700 	mvns.w	r7, #0
 8000242:	2300      	movs	r3, #0
 8000244:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000248:	3c08      	subs	r4, #8
 800024a:	ea85 0501 	eor.w	r5, r5, r1
 800024e:	ea86 0601 	eor.w	r6, r6, r1
 8000252:	fa85 f547 	uadd8	r5, r5, r7
 8000256:	faa3 f587 	sel	r5, r3, r7
 800025a:	fa86 f647 	uadd8	r6, r6, r7
 800025e:	faa5 f687 	sel	r6, r5, r7
 8000262:	b98e      	cbnz	r6, 8000288 <memchr+0x78>
 8000264:	d1ee      	bne.n	8000244 <memchr+0x34>
 8000266:	bcf0      	pop	{r4, r5, r6, r7}
 8000268:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800026c:	f002 0207 	and.w	r2, r2, #7
 8000270:	b132      	cbz	r2, 8000280 <memchr+0x70>
 8000272:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000276:	3a01      	subs	r2, #1
 8000278:	ea83 0301 	eor.w	r3, r3, r1
 800027c:	b113      	cbz	r3, 8000284 <memchr+0x74>
 800027e:	d1f8      	bne.n	8000272 <memchr+0x62>
 8000280:	2000      	movs	r0, #0
 8000282:	4770      	bx	lr
 8000284:	3801      	subs	r0, #1
 8000286:	4770      	bx	lr
 8000288:	2d00      	cmp	r5, #0
 800028a:	bf06      	itte	eq
 800028c:	4635      	moveq	r5, r6
 800028e:	3803      	subeq	r0, #3
 8000290:	3807      	subne	r0, #7
 8000292:	f015 0f01 	tst.w	r5, #1
 8000296:	d107      	bne.n	80002a8 <memchr+0x98>
 8000298:	3001      	adds	r0, #1
 800029a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800029e:	bf02      	ittt	eq
 80002a0:	3001      	addeq	r0, #1
 80002a2:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 80002a6:	3001      	addeq	r0, #1
 80002a8:	bcf0      	pop	{r4, r5, r6, r7}
 80002aa:	3801      	subs	r0, #1
 80002ac:	4770      	bx	lr
 80002ae:	bf00      	nop

080002b0 <__aeabi_drsub>:
 80002b0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002b4:	e002      	b.n	80002bc <__adddf3>
 80002b6:	bf00      	nop

080002b8 <__aeabi_dsub>:
 80002b8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002bc <__adddf3>:
 80002bc:	b530      	push	{r4, r5, lr}
 80002be:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002c2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002c6:	ea94 0f05 	teq	r4, r5
 80002ca:	bf08      	it	eq
 80002cc:	ea90 0f02 	teqeq	r0, r2
 80002d0:	bf1f      	itttt	ne
 80002d2:	ea54 0c00 	orrsne.w	ip, r4, r0
 80002d6:	ea55 0c02 	orrsne.w	ip, r5, r2
 80002da:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80002de:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80002e2:	f000 80e2 	beq.w	80004aa <__adddf3+0x1ee>
 80002e6:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80002ea:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80002ee:	bfb8      	it	lt
 80002f0:	426d      	neglt	r5, r5
 80002f2:	dd0c      	ble.n	800030e <__adddf3+0x52>
 80002f4:	442c      	add	r4, r5
 80002f6:	ea80 0202 	eor.w	r2, r0, r2
 80002fa:	ea81 0303 	eor.w	r3, r1, r3
 80002fe:	ea82 0000 	eor.w	r0, r2, r0
 8000302:	ea83 0101 	eor.w	r1, r3, r1
 8000306:	ea80 0202 	eor.w	r2, r0, r2
 800030a:	ea81 0303 	eor.w	r3, r1, r3
 800030e:	2d36      	cmp	r5, #54	; 0x36
 8000310:	bf88      	it	hi
 8000312:	bd30      	pophi	{r4, r5, pc}
 8000314:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000318:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800031c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000320:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000324:	d002      	beq.n	800032c <__adddf3+0x70>
 8000326:	4240      	negs	r0, r0
 8000328:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800032c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000330:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000334:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000338:	d002      	beq.n	8000340 <__adddf3+0x84>
 800033a:	4252      	negs	r2, r2
 800033c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000340:	ea94 0f05 	teq	r4, r5
 8000344:	f000 80a7 	beq.w	8000496 <__adddf3+0x1da>
 8000348:	f1a4 0401 	sub.w	r4, r4, #1
 800034c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000350:	db0d      	blt.n	800036e <__adddf3+0xb2>
 8000352:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000356:	fa22 f205 	lsr.w	r2, r2, r5
 800035a:	1880      	adds	r0, r0, r2
 800035c:	f141 0100 	adc.w	r1, r1, #0
 8000360:	fa03 f20e 	lsl.w	r2, r3, lr
 8000364:	1880      	adds	r0, r0, r2
 8000366:	fa43 f305 	asr.w	r3, r3, r5
 800036a:	4159      	adcs	r1, r3
 800036c:	e00e      	b.n	800038c <__adddf3+0xd0>
 800036e:	f1a5 0520 	sub.w	r5, r5, #32
 8000372:	f10e 0e20 	add.w	lr, lr, #32
 8000376:	2a01      	cmp	r2, #1
 8000378:	fa03 fc0e 	lsl.w	ip, r3, lr
 800037c:	bf28      	it	cs
 800037e:	f04c 0c02 	orrcs.w	ip, ip, #2
 8000382:	fa43 f305 	asr.w	r3, r3, r5
 8000386:	18c0      	adds	r0, r0, r3
 8000388:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 800038c:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000390:	d507      	bpl.n	80003a2 <__adddf3+0xe6>
 8000392:	f04f 0e00 	mov.w	lr, #0
 8000396:	f1dc 0c00 	rsbs	ip, ip, #0
 800039a:	eb7e 0000 	sbcs.w	r0, lr, r0
 800039e:	eb6e 0101 	sbc.w	r1, lr, r1
 80003a2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003a6:	d31b      	bcc.n	80003e0 <__adddf3+0x124>
 80003a8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003ac:	d30c      	bcc.n	80003c8 <__adddf3+0x10c>
 80003ae:	0849      	lsrs	r1, r1, #1
 80003b0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003b4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003b8:	f104 0401 	add.w	r4, r4, #1
 80003bc:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003c0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003c4:	f080 809a 	bcs.w	80004fc <__adddf3+0x240>
 80003c8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003cc:	bf08      	it	eq
 80003ce:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80003d2:	f150 0000 	adcs.w	r0, r0, #0
 80003d6:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80003da:	ea41 0105 	orr.w	r1, r1, r5
 80003de:	bd30      	pop	{r4, r5, pc}
 80003e0:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80003e4:	4140      	adcs	r0, r0
 80003e6:	eb41 0101 	adc.w	r1, r1, r1
 80003ea:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80003ee:	f1a4 0401 	sub.w	r4, r4, #1
 80003f2:	d1e9      	bne.n	80003c8 <__adddf3+0x10c>
 80003f4:	f091 0f00 	teq	r1, #0
 80003f8:	bf04      	itt	eq
 80003fa:	4601      	moveq	r1, r0
 80003fc:	2000      	moveq	r0, #0
 80003fe:	fab1 f381 	clz	r3, r1
 8000402:	bf08      	it	eq
 8000404:	3320      	addeq	r3, #32
 8000406:	f1a3 030b 	sub.w	r3, r3, #11
 800040a:	f1b3 0220 	subs.w	r2, r3, #32
 800040e:	da0c      	bge.n	800042a <__adddf3+0x16e>
 8000410:	320c      	adds	r2, #12
 8000412:	dd08      	ble.n	8000426 <__adddf3+0x16a>
 8000414:	f102 0c14 	add.w	ip, r2, #20
 8000418:	f1c2 020c 	rsb	r2, r2, #12
 800041c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000420:	fa21 f102 	lsr.w	r1, r1, r2
 8000424:	e00c      	b.n	8000440 <__adddf3+0x184>
 8000426:	f102 0214 	add.w	r2, r2, #20
 800042a:	bfd8      	it	le
 800042c:	f1c2 0c20 	rsble	ip, r2, #32
 8000430:	fa01 f102 	lsl.w	r1, r1, r2
 8000434:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000438:	bfdc      	itt	le
 800043a:	ea41 010c 	orrle.w	r1, r1, ip
 800043e:	4090      	lslle	r0, r2
 8000440:	1ae4      	subs	r4, r4, r3
 8000442:	bfa2      	ittt	ge
 8000444:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000448:	4329      	orrge	r1, r5
 800044a:	bd30      	popge	{r4, r5, pc}
 800044c:	ea6f 0404 	mvn.w	r4, r4
 8000450:	3c1f      	subs	r4, #31
 8000452:	da1c      	bge.n	800048e <__adddf3+0x1d2>
 8000454:	340c      	adds	r4, #12
 8000456:	dc0e      	bgt.n	8000476 <__adddf3+0x1ba>
 8000458:	f104 0414 	add.w	r4, r4, #20
 800045c:	f1c4 0220 	rsb	r2, r4, #32
 8000460:	fa20 f004 	lsr.w	r0, r0, r4
 8000464:	fa01 f302 	lsl.w	r3, r1, r2
 8000468:	ea40 0003 	orr.w	r0, r0, r3
 800046c:	fa21 f304 	lsr.w	r3, r1, r4
 8000470:	ea45 0103 	orr.w	r1, r5, r3
 8000474:	bd30      	pop	{r4, r5, pc}
 8000476:	f1c4 040c 	rsb	r4, r4, #12
 800047a:	f1c4 0220 	rsb	r2, r4, #32
 800047e:	fa20 f002 	lsr.w	r0, r0, r2
 8000482:	fa01 f304 	lsl.w	r3, r1, r4
 8000486:	ea40 0003 	orr.w	r0, r0, r3
 800048a:	4629      	mov	r1, r5
 800048c:	bd30      	pop	{r4, r5, pc}
 800048e:	fa21 f004 	lsr.w	r0, r1, r4
 8000492:	4629      	mov	r1, r5
 8000494:	bd30      	pop	{r4, r5, pc}
 8000496:	f094 0f00 	teq	r4, #0
 800049a:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 800049e:	bf06      	itte	eq
 80004a0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004a4:	3401      	addeq	r4, #1
 80004a6:	3d01      	subne	r5, #1
 80004a8:	e74e      	b.n	8000348 <__adddf3+0x8c>
 80004aa:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004ae:	bf18      	it	ne
 80004b0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004b4:	d029      	beq.n	800050a <__adddf3+0x24e>
 80004b6:	ea94 0f05 	teq	r4, r5
 80004ba:	bf08      	it	eq
 80004bc:	ea90 0f02 	teqeq	r0, r2
 80004c0:	d005      	beq.n	80004ce <__adddf3+0x212>
 80004c2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004c6:	bf04      	itt	eq
 80004c8:	4619      	moveq	r1, r3
 80004ca:	4610      	moveq	r0, r2
 80004cc:	bd30      	pop	{r4, r5, pc}
 80004ce:	ea91 0f03 	teq	r1, r3
 80004d2:	bf1e      	ittt	ne
 80004d4:	2100      	movne	r1, #0
 80004d6:	2000      	movne	r0, #0
 80004d8:	bd30      	popne	{r4, r5, pc}
 80004da:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80004de:	d105      	bne.n	80004ec <__adddf3+0x230>
 80004e0:	0040      	lsls	r0, r0, #1
 80004e2:	4149      	adcs	r1, r1
 80004e4:	bf28      	it	cs
 80004e6:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80004ea:	bd30      	pop	{r4, r5, pc}
 80004ec:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80004f0:	bf3c      	itt	cc
 80004f2:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80004f6:	bd30      	popcc	{r4, r5, pc}
 80004f8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80004fc:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000500:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000504:	f04f 0000 	mov.w	r0, #0
 8000508:	bd30      	pop	{r4, r5, pc}
 800050a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800050e:	bf1a      	itte	ne
 8000510:	4619      	movne	r1, r3
 8000512:	4610      	movne	r0, r2
 8000514:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000518:	bf1c      	itt	ne
 800051a:	460b      	movne	r3, r1
 800051c:	4602      	movne	r2, r0
 800051e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000522:	bf06      	itte	eq
 8000524:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000528:	ea91 0f03 	teqeq	r1, r3
 800052c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000530:	bd30      	pop	{r4, r5, pc}
 8000532:	bf00      	nop

08000534 <__aeabi_ui2d>:
 8000534:	f090 0f00 	teq	r0, #0
 8000538:	bf04      	itt	eq
 800053a:	2100      	moveq	r1, #0
 800053c:	4770      	bxeq	lr
 800053e:	b530      	push	{r4, r5, lr}
 8000540:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000544:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000548:	f04f 0500 	mov.w	r5, #0
 800054c:	f04f 0100 	mov.w	r1, #0
 8000550:	e750      	b.n	80003f4 <__adddf3+0x138>
 8000552:	bf00      	nop

08000554 <__aeabi_i2d>:
 8000554:	f090 0f00 	teq	r0, #0
 8000558:	bf04      	itt	eq
 800055a:	2100      	moveq	r1, #0
 800055c:	4770      	bxeq	lr
 800055e:	b530      	push	{r4, r5, lr}
 8000560:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000564:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000568:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800056c:	bf48      	it	mi
 800056e:	4240      	negmi	r0, r0
 8000570:	f04f 0100 	mov.w	r1, #0
 8000574:	e73e      	b.n	80003f4 <__adddf3+0x138>
 8000576:	bf00      	nop

08000578 <__aeabi_f2d>:
 8000578:	0042      	lsls	r2, r0, #1
 800057a:	ea4f 01e2 	mov.w	r1, r2, asr #3
 800057e:	ea4f 0131 	mov.w	r1, r1, rrx
 8000582:	ea4f 7002 	mov.w	r0, r2, lsl #28
 8000586:	bf1f      	itttt	ne
 8000588:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 800058c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 8000590:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 8000594:	4770      	bxne	lr
 8000596:	f092 0f00 	teq	r2, #0
 800059a:	bf14      	ite	ne
 800059c:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005a0:	4770      	bxeq	lr
 80005a2:	b530      	push	{r4, r5, lr}
 80005a4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005a8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005ac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005b0:	e720      	b.n	80003f4 <__adddf3+0x138>
 80005b2:	bf00      	nop

080005b4 <__aeabi_ul2d>:
 80005b4:	ea50 0201 	orrs.w	r2, r0, r1
 80005b8:	bf08      	it	eq
 80005ba:	4770      	bxeq	lr
 80005bc:	b530      	push	{r4, r5, lr}
 80005be:	f04f 0500 	mov.w	r5, #0
 80005c2:	e00a      	b.n	80005da <__aeabi_l2d+0x16>

080005c4 <__aeabi_l2d>:
 80005c4:	ea50 0201 	orrs.w	r2, r0, r1
 80005c8:	bf08      	it	eq
 80005ca:	4770      	bxeq	lr
 80005cc:	b530      	push	{r4, r5, lr}
 80005ce:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80005d2:	d502      	bpl.n	80005da <__aeabi_l2d+0x16>
 80005d4:	4240      	negs	r0, r0
 80005d6:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80005da:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005de:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005e2:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80005e6:	f43f aedc 	beq.w	80003a2 <__adddf3+0xe6>
 80005ea:	f04f 0203 	mov.w	r2, #3
 80005ee:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005f2:	bf18      	it	ne
 80005f4:	3203      	addne	r2, #3
 80005f6:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80005fa:	bf18      	it	ne
 80005fc:	3203      	addne	r2, #3
 80005fe:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000602:	f1c2 0320 	rsb	r3, r2, #32
 8000606:	fa00 fc03 	lsl.w	ip, r0, r3
 800060a:	fa20 f002 	lsr.w	r0, r0, r2
 800060e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000612:	ea40 000e 	orr.w	r0, r0, lr
 8000616:	fa21 f102 	lsr.w	r1, r1, r2
 800061a:	4414      	add	r4, r2
 800061c:	e6c1      	b.n	80003a2 <__adddf3+0xe6>
 800061e:	bf00      	nop

08000620 <__aeabi_dmul>:
 8000620:	b570      	push	{r4, r5, r6, lr}
 8000622:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000626:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800062a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800062e:	bf1d      	ittte	ne
 8000630:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000634:	ea94 0f0c 	teqne	r4, ip
 8000638:	ea95 0f0c 	teqne	r5, ip
 800063c:	f000 f8de 	bleq	80007fc <__aeabi_dmul+0x1dc>
 8000640:	442c      	add	r4, r5
 8000642:	ea81 0603 	eor.w	r6, r1, r3
 8000646:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 800064a:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800064e:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 8000652:	bf18      	it	ne
 8000654:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 8000658:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 800065c:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8000660:	d038      	beq.n	80006d4 <__aeabi_dmul+0xb4>
 8000662:	fba0 ce02 	umull	ip, lr, r0, r2
 8000666:	f04f 0500 	mov.w	r5, #0
 800066a:	fbe1 e502 	umlal	lr, r5, r1, r2
 800066e:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 8000672:	fbe0 e503 	umlal	lr, r5, r0, r3
 8000676:	f04f 0600 	mov.w	r6, #0
 800067a:	fbe1 5603 	umlal	r5, r6, r1, r3
 800067e:	f09c 0f00 	teq	ip, #0
 8000682:	bf18      	it	ne
 8000684:	f04e 0e01 	orrne.w	lr, lr, #1
 8000688:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 800068c:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 8000690:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 8000694:	d204      	bcs.n	80006a0 <__aeabi_dmul+0x80>
 8000696:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 800069a:	416d      	adcs	r5, r5
 800069c:	eb46 0606 	adc.w	r6, r6, r6
 80006a0:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006a4:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006a8:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006ac:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006b0:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80006b4:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80006b8:	bf88      	it	hi
 80006ba:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80006be:	d81e      	bhi.n	80006fe <__aeabi_dmul+0xde>
 80006c0:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80006c4:	bf08      	it	eq
 80006c6:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80006ca:	f150 0000 	adcs.w	r0, r0, #0
 80006ce:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80006d2:	bd70      	pop	{r4, r5, r6, pc}
 80006d4:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80006d8:	ea46 0101 	orr.w	r1, r6, r1
 80006dc:	ea40 0002 	orr.w	r0, r0, r2
 80006e0:	ea81 0103 	eor.w	r1, r1, r3
 80006e4:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80006e8:	bfc2      	ittt	gt
 80006ea:	ebd4 050c 	rsbsgt	r5, r4, ip
 80006ee:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80006f2:	bd70      	popgt	{r4, r5, r6, pc}
 80006f4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006f8:	f04f 0e00 	mov.w	lr, #0
 80006fc:	3c01      	subs	r4, #1
 80006fe:	f300 80ab 	bgt.w	8000858 <__aeabi_dmul+0x238>
 8000702:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000706:	bfde      	ittt	le
 8000708:	2000      	movle	r0, #0
 800070a:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800070e:	bd70      	pople	{r4, r5, r6, pc}
 8000710:	f1c4 0400 	rsb	r4, r4, #0
 8000714:	3c20      	subs	r4, #32
 8000716:	da35      	bge.n	8000784 <__aeabi_dmul+0x164>
 8000718:	340c      	adds	r4, #12
 800071a:	dc1b      	bgt.n	8000754 <__aeabi_dmul+0x134>
 800071c:	f104 0414 	add.w	r4, r4, #20
 8000720:	f1c4 0520 	rsb	r5, r4, #32
 8000724:	fa00 f305 	lsl.w	r3, r0, r5
 8000728:	fa20 f004 	lsr.w	r0, r0, r4
 800072c:	fa01 f205 	lsl.w	r2, r1, r5
 8000730:	ea40 0002 	orr.w	r0, r0, r2
 8000734:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000738:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800073c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000740:	fa21 f604 	lsr.w	r6, r1, r4
 8000744:	eb42 0106 	adc.w	r1, r2, r6
 8000748:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800074c:	bf08      	it	eq
 800074e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000752:	bd70      	pop	{r4, r5, r6, pc}
 8000754:	f1c4 040c 	rsb	r4, r4, #12
 8000758:	f1c4 0520 	rsb	r5, r4, #32
 800075c:	fa00 f304 	lsl.w	r3, r0, r4
 8000760:	fa20 f005 	lsr.w	r0, r0, r5
 8000764:	fa01 f204 	lsl.w	r2, r1, r4
 8000768:	ea40 0002 	orr.w	r0, r0, r2
 800076c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000770:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 8000774:	f141 0100 	adc.w	r1, r1, #0
 8000778:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 800077c:	bf08      	it	eq
 800077e:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000782:	bd70      	pop	{r4, r5, r6, pc}
 8000784:	f1c4 0520 	rsb	r5, r4, #32
 8000788:	fa00 f205 	lsl.w	r2, r0, r5
 800078c:	ea4e 0e02 	orr.w	lr, lr, r2
 8000790:	fa20 f304 	lsr.w	r3, r0, r4
 8000794:	fa01 f205 	lsl.w	r2, r1, r5
 8000798:	ea43 0302 	orr.w	r3, r3, r2
 800079c:	fa21 f004 	lsr.w	r0, r1, r4
 80007a0:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007a4:	fa21 f204 	lsr.w	r2, r1, r4
 80007a8:	ea20 0002 	bic.w	r0, r0, r2
 80007ac:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007b0:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007b4:	bf08      	it	eq
 80007b6:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007ba:	bd70      	pop	{r4, r5, r6, pc}
 80007bc:	f094 0f00 	teq	r4, #0
 80007c0:	d10f      	bne.n	80007e2 <__aeabi_dmul+0x1c2>
 80007c2:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80007c6:	0040      	lsls	r0, r0, #1
 80007c8:	eb41 0101 	adc.w	r1, r1, r1
 80007cc:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80007d0:	bf08      	it	eq
 80007d2:	3c01      	subeq	r4, #1
 80007d4:	d0f7      	beq.n	80007c6 <__aeabi_dmul+0x1a6>
 80007d6:	ea41 0106 	orr.w	r1, r1, r6
 80007da:	f095 0f00 	teq	r5, #0
 80007de:	bf18      	it	ne
 80007e0:	4770      	bxne	lr
 80007e2:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80007e6:	0052      	lsls	r2, r2, #1
 80007e8:	eb43 0303 	adc.w	r3, r3, r3
 80007ec:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80007f0:	bf08      	it	eq
 80007f2:	3d01      	subeq	r5, #1
 80007f4:	d0f7      	beq.n	80007e6 <__aeabi_dmul+0x1c6>
 80007f6:	ea43 0306 	orr.w	r3, r3, r6
 80007fa:	4770      	bx	lr
 80007fc:	ea94 0f0c 	teq	r4, ip
 8000800:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000804:	bf18      	it	ne
 8000806:	ea95 0f0c 	teqne	r5, ip
 800080a:	d00c      	beq.n	8000826 <__aeabi_dmul+0x206>
 800080c:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000810:	bf18      	it	ne
 8000812:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000816:	d1d1      	bne.n	80007bc <__aeabi_dmul+0x19c>
 8000818:	ea81 0103 	eor.w	r1, r1, r3
 800081c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 8000820:	f04f 0000 	mov.w	r0, #0
 8000824:	bd70      	pop	{r4, r5, r6, pc}
 8000826:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800082a:	bf06      	itte	eq
 800082c:	4610      	moveq	r0, r2
 800082e:	4619      	moveq	r1, r3
 8000830:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000834:	d019      	beq.n	800086a <__aeabi_dmul+0x24a>
 8000836:	ea94 0f0c 	teq	r4, ip
 800083a:	d102      	bne.n	8000842 <__aeabi_dmul+0x222>
 800083c:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 8000840:	d113      	bne.n	800086a <__aeabi_dmul+0x24a>
 8000842:	ea95 0f0c 	teq	r5, ip
 8000846:	d105      	bne.n	8000854 <__aeabi_dmul+0x234>
 8000848:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 800084c:	bf1c      	itt	ne
 800084e:	4610      	movne	r0, r2
 8000850:	4619      	movne	r1, r3
 8000852:	d10a      	bne.n	800086a <__aeabi_dmul+0x24a>
 8000854:	ea81 0103 	eor.w	r1, r1, r3
 8000858:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800085c:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 8000860:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000864:	f04f 0000 	mov.w	r0, #0
 8000868:	bd70      	pop	{r4, r5, r6, pc}
 800086a:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 800086e:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 8000872:	bd70      	pop	{r4, r5, r6, pc}

08000874 <__aeabi_ddiv>:
 8000874:	b570      	push	{r4, r5, r6, lr}
 8000876:	f04f 0cff 	mov.w	ip, #255	; 0xff
 800087a:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 800087e:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 8000882:	bf1d      	ittte	ne
 8000884:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000888:	ea94 0f0c 	teqne	r4, ip
 800088c:	ea95 0f0c 	teqne	r5, ip
 8000890:	f000 f8a7 	bleq	80009e2 <__aeabi_ddiv+0x16e>
 8000894:	eba4 0405 	sub.w	r4, r4, r5
 8000898:	ea81 0e03 	eor.w	lr, r1, r3
 800089c:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008a0:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008a4:	f000 8088 	beq.w	80009b8 <__aeabi_ddiv+0x144>
 80008a8:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008ac:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008b0:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80008b4:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80008b8:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80008bc:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80008c0:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80008c4:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80008c8:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80008cc:	429d      	cmp	r5, r3
 80008ce:	bf08      	it	eq
 80008d0:	4296      	cmpeq	r6, r2
 80008d2:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80008d6:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80008da:	d202      	bcs.n	80008e2 <__aeabi_ddiv+0x6e>
 80008dc:	085b      	lsrs	r3, r3, #1
 80008de:	ea4f 0232 	mov.w	r2, r2, rrx
 80008e2:	1ab6      	subs	r6, r6, r2
 80008e4:	eb65 0503 	sbc.w	r5, r5, r3
 80008e8:	085b      	lsrs	r3, r3, #1
 80008ea:	ea4f 0232 	mov.w	r2, r2, rrx
 80008ee:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80008f2:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80008f6:	ebb6 0e02 	subs.w	lr, r6, r2
 80008fa:	eb75 0e03 	sbcs.w	lr, r5, r3
 80008fe:	bf22      	ittt	cs
 8000900:	1ab6      	subcs	r6, r6, r2
 8000902:	4675      	movcs	r5, lr
 8000904:	ea40 000c 	orrcs.w	r0, r0, ip
 8000908:	085b      	lsrs	r3, r3, #1
 800090a:	ea4f 0232 	mov.w	r2, r2, rrx
 800090e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000912:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000916:	bf22      	ittt	cs
 8000918:	1ab6      	subcs	r6, r6, r2
 800091a:	4675      	movcs	r5, lr
 800091c:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 8000920:	085b      	lsrs	r3, r3, #1
 8000922:	ea4f 0232 	mov.w	r2, r2, rrx
 8000926:	ebb6 0e02 	subs.w	lr, r6, r2
 800092a:	eb75 0e03 	sbcs.w	lr, r5, r3
 800092e:	bf22      	ittt	cs
 8000930:	1ab6      	subcs	r6, r6, r2
 8000932:	4675      	movcs	r5, lr
 8000934:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000938:	085b      	lsrs	r3, r3, #1
 800093a:	ea4f 0232 	mov.w	r2, r2, rrx
 800093e:	ebb6 0e02 	subs.w	lr, r6, r2
 8000942:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000946:	bf22      	ittt	cs
 8000948:	1ab6      	subcs	r6, r6, r2
 800094a:	4675      	movcs	r5, lr
 800094c:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 8000950:	ea55 0e06 	orrs.w	lr, r5, r6
 8000954:	d018      	beq.n	8000988 <__aeabi_ddiv+0x114>
 8000956:	ea4f 1505 	mov.w	r5, r5, lsl #4
 800095a:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 800095e:	ea4f 1606 	mov.w	r6, r6, lsl #4
 8000962:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 8000966:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 800096a:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 800096e:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 8000972:	d1c0      	bne.n	80008f6 <__aeabi_ddiv+0x82>
 8000974:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 8000978:	d10b      	bne.n	8000992 <__aeabi_ddiv+0x11e>
 800097a:	ea41 0100 	orr.w	r1, r1, r0
 800097e:	f04f 0000 	mov.w	r0, #0
 8000982:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 8000986:	e7b6      	b.n	80008f6 <__aeabi_ddiv+0x82>
 8000988:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800098c:	bf04      	itt	eq
 800098e:	4301      	orreq	r1, r0
 8000990:	2000      	moveq	r0, #0
 8000992:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000996:	bf88      	it	hi
 8000998:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800099c:	f63f aeaf 	bhi.w	80006fe <__aeabi_dmul+0xde>
 80009a0:	ebb5 0c03 	subs.w	ip, r5, r3
 80009a4:	bf04      	itt	eq
 80009a6:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009aa:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009ae:	f150 0000 	adcs.w	r0, r0, #0
 80009b2:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80009b6:	bd70      	pop	{r4, r5, r6, pc}
 80009b8:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80009bc:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80009c0:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80009c4:	bfc2      	ittt	gt
 80009c6:	ebd4 050c 	rsbsgt	r5, r4, ip
 80009ca:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80009ce:	bd70      	popgt	{r4, r5, r6, pc}
 80009d0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80009d4:	f04f 0e00 	mov.w	lr, #0
 80009d8:	3c01      	subs	r4, #1
 80009da:	e690      	b.n	80006fe <__aeabi_dmul+0xde>
 80009dc:	ea45 0e06 	orr.w	lr, r5, r6
 80009e0:	e68d      	b.n	80006fe <__aeabi_dmul+0xde>
 80009e2:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80009e6:	ea94 0f0c 	teq	r4, ip
 80009ea:	bf08      	it	eq
 80009ec:	ea95 0f0c 	teqeq	r5, ip
 80009f0:	f43f af3b 	beq.w	800086a <__aeabi_dmul+0x24a>
 80009f4:	ea94 0f0c 	teq	r4, ip
 80009f8:	d10a      	bne.n	8000a10 <__aeabi_ddiv+0x19c>
 80009fa:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80009fe:	f47f af34 	bne.w	800086a <__aeabi_dmul+0x24a>
 8000a02:	ea95 0f0c 	teq	r5, ip
 8000a06:	f47f af25 	bne.w	8000854 <__aeabi_dmul+0x234>
 8000a0a:	4610      	mov	r0, r2
 8000a0c:	4619      	mov	r1, r3
 8000a0e:	e72c      	b.n	800086a <__aeabi_dmul+0x24a>
 8000a10:	ea95 0f0c 	teq	r5, ip
 8000a14:	d106      	bne.n	8000a24 <__aeabi_ddiv+0x1b0>
 8000a16:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a1a:	f43f aefd 	beq.w	8000818 <__aeabi_dmul+0x1f8>
 8000a1e:	4610      	mov	r0, r2
 8000a20:	4619      	mov	r1, r3
 8000a22:	e722      	b.n	800086a <__aeabi_dmul+0x24a>
 8000a24:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a28:	bf18      	it	ne
 8000a2a:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a2e:	f47f aec5 	bne.w	80007bc <__aeabi_dmul+0x19c>
 8000a32:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a36:	f47f af0d 	bne.w	8000854 <__aeabi_dmul+0x234>
 8000a3a:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a3e:	f47f aeeb 	bne.w	8000818 <__aeabi_dmul+0x1f8>
 8000a42:	e712      	b.n	800086a <__aeabi_dmul+0x24a>

08000a44 <__aeabi_d2uiz>:
 8000a44:	004a      	lsls	r2, r1, #1
 8000a46:	d211      	bcs.n	8000a6c <__aeabi_d2uiz+0x28>
 8000a48:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a4c:	d211      	bcs.n	8000a72 <__aeabi_d2uiz+0x2e>
 8000a4e:	d50d      	bpl.n	8000a6c <__aeabi_d2uiz+0x28>
 8000a50:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000a54:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000a58:	d40e      	bmi.n	8000a78 <__aeabi_d2uiz+0x34>
 8000a5a:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000a5e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000a62:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000a66:	fa23 f002 	lsr.w	r0, r3, r2
 8000a6a:	4770      	bx	lr
 8000a6c:	f04f 0000 	mov.w	r0, #0
 8000a70:	4770      	bx	lr
 8000a72:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000a76:	d102      	bne.n	8000a7e <__aeabi_d2uiz+0x3a>
 8000a78:	f04f 30ff 	mov.w	r0, #4294967295
 8000a7c:	4770      	bx	lr
 8000a7e:	f04f 0000 	mov.w	r0, #0
 8000a82:	4770      	bx	lr

08000a84 <__aeabi_d2f>:
 8000a84:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a88:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000a8c:	bf24      	itt	cs
 8000a8e:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000a92:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000a96:	d90d      	bls.n	8000ab4 <__aeabi_d2f+0x30>
 8000a98:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000a9c:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000aa0:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000aa4:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000aa8:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000aac:	bf08      	it	eq
 8000aae:	f020 0001 	biceq.w	r0, r0, #1
 8000ab2:	4770      	bx	lr
 8000ab4:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000ab8:	d121      	bne.n	8000afe <__aeabi_d2f+0x7a>
 8000aba:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000abe:	bfbc      	itt	lt
 8000ac0:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000ac4:	4770      	bxlt	lr
 8000ac6:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000aca:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000ace:	f1c2 0218 	rsb	r2, r2, #24
 8000ad2:	f1c2 0c20 	rsb	ip, r2, #32
 8000ad6:	fa10 f30c 	lsls.w	r3, r0, ip
 8000ada:	fa20 f002 	lsr.w	r0, r0, r2
 8000ade:	bf18      	it	ne
 8000ae0:	f040 0001 	orrne.w	r0, r0, #1
 8000ae4:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000ae8:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000aec:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000af0:	ea40 000c 	orr.w	r0, r0, ip
 8000af4:	fa23 f302 	lsr.w	r3, r3, r2
 8000af8:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000afc:	e7cc      	b.n	8000a98 <__aeabi_d2f+0x14>
 8000afe:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000b02:	d107      	bne.n	8000b14 <__aeabi_d2f+0x90>
 8000b04:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000b08:	bf1e      	ittt	ne
 8000b0a:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000b0e:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000b12:	4770      	bxne	lr
 8000b14:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000b18:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000b1c:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000b20:	4770      	bx	lr
 8000b22:	bf00      	nop

08000b24 <__aeabi_uldivmod>:
 8000b24:	b953      	cbnz	r3, 8000b3c <__aeabi_uldivmod+0x18>
 8000b26:	b94a      	cbnz	r2, 8000b3c <__aeabi_uldivmod+0x18>
 8000b28:	2900      	cmp	r1, #0
 8000b2a:	bf08      	it	eq
 8000b2c:	2800      	cmpeq	r0, #0
 8000b2e:	bf1c      	itt	ne
 8000b30:	f04f 31ff 	movne.w	r1, #4294967295
 8000b34:	f04f 30ff 	movne.w	r0, #4294967295
 8000b38:	f000 b97a 	b.w	8000e30 <__aeabi_idiv0>
 8000b3c:	f1ad 0c08 	sub.w	ip, sp, #8
 8000b40:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 8000b44:	f000 f806 	bl	8000b54 <__udivmoddi4>
 8000b48:	f8dd e004 	ldr.w	lr, [sp, #4]
 8000b4c:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 8000b50:	b004      	add	sp, #16
 8000b52:	4770      	bx	lr

08000b54 <__udivmoddi4>:
 8000b54:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000b58:	468c      	mov	ip, r1
 8000b5a:	460d      	mov	r5, r1
 8000b5c:	4604      	mov	r4, r0
 8000b5e:	9e08      	ldr	r6, [sp, #32]
 8000b60:	2b00      	cmp	r3, #0
 8000b62:	d151      	bne.n	8000c08 <__udivmoddi4+0xb4>
 8000b64:	428a      	cmp	r2, r1
 8000b66:	4617      	mov	r7, r2
 8000b68:	d96d      	bls.n	8000c46 <__udivmoddi4+0xf2>
 8000b6a:	fab2 fe82 	clz	lr, r2
 8000b6e:	f1be 0f00 	cmp.w	lr, #0
 8000b72:	d00b      	beq.n	8000b8c <__udivmoddi4+0x38>
 8000b74:	f1ce 0c20 	rsb	ip, lr, #32
 8000b78:	fa01 f50e 	lsl.w	r5, r1, lr
 8000b7c:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000b80:	fa02 f70e 	lsl.w	r7, r2, lr
 8000b84:	ea4c 0c05 	orr.w	ip, ip, r5
 8000b88:	fa00 f40e 	lsl.w	r4, r0, lr
 8000b8c:	ea4f 4a17 	mov.w	sl, r7, lsr #16
 8000b90:	0c25      	lsrs	r5, r4, #16
 8000b92:	fbbc f8fa 	udiv	r8, ip, sl
 8000b96:	fa1f f987 	uxth.w	r9, r7
 8000b9a:	fb0a cc18 	mls	ip, sl, r8, ip
 8000b9e:	ea45 450c 	orr.w	r5, r5, ip, lsl #16
 8000ba2:	fb08 f309 	mul.w	r3, r8, r9
 8000ba6:	42ab      	cmp	r3, r5
 8000ba8:	d90a      	bls.n	8000bc0 <__udivmoddi4+0x6c>
 8000baa:	19ed      	adds	r5, r5, r7
 8000bac:	f108 32ff 	add.w	r2, r8, #4294967295
 8000bb0:	f080 8123 	bcs.w	8000dfa <__udivmoddi4+0x2a6>
 8000bb4:	42ab      	cmp	r3, r5
 8000bb6:	f240 8120 	bls.w	8000dfa <__udivmoddi4+0x2a6>
 8000bba:	f1a8 0802 	sub.w	r8, r8, #2
 8000bbe:	443d      	add	r5, r7
 8000bc0:	1aed      	subs	r5, r5, r3
 8000bc2:	b2a4      	uxth	r4, r4
 8000bc4:	fbb5 f0fa 	udiv	r0, r5, sl
 8000bc8:	fb0a 5510 	mls	r5, sl, r0, r5
 8000bcc:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
 8000bd0:	fb00 f909 	mul.w	r9, r0, r9
 8000bd4:	45a1      	cmp	r9, r4
 8000bd6:	d909      	bls.n	8000bec <__udivmoddi4+0x98>
 8000bd8:	19e4      	adds	r4, r4, r7
 8000bda:	f100 33ff 	add.w	r3, r0, #4294967295
 8000bde:	f080 810a 	bcs.w	8000df6 <__udivmoddi4+0x2a2>
 8000be2:	45a1      	cmp	r9, r4
 8000be4:	f240 8107 	bls.w	8000df6 <__udivmoddi4+0x2a2>
 8000be8:	3802      	subs	r0, #2
 8000bea:	443c      	add	r4, r7
 8000bec:	eba4 0409 	sub.w	r4, r4, r9
 8000bf0:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000bf4:	2100      	movs	r1, #0
 8000bf6:	2e00      	cmp	r6, #0
 8000bf8:	d061      	beq.n	8000cbe <__udivmoddi4+0x16a>
 8000bfa:	fa24 f40e 	lsr.w	r4, r4, lr
 8000bfe:	2300      	movs	r3, #0
 8000c00:	6034      	str	r4, [r6, #0]
 8000c02:	6073      	str	r3, [r6, #4]
 8000c04:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c08:	428b      	cmp	r3, r1
 8000c0a:	d907      	bls.n	8000c1c <__udivmoddi4+0xc8>
 8000c0c:	2e00      	cmp	r6, #0
 8000c0e:	d054      	beq.n	8000cba <__udivmoddi4+0x166>
 8000c10:	2100      	movs	r1, #0
 8000c12:	e886 0021 	stmia.w	r6, {r0, r5}
 8000c16:	4608      	mov	r0, r1
 8000c18:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c1c:	fab3 f183 	clz	r1, r3
 8000c20:	2900      	cmp	r1, #0
 8000c22:	f040 808e 	bne.w	8000d42 <__udivmoddi4+0x1ee>
 8000c26:	42ab      	cmp	r3, r5
 8000c28:	d302      	bcc.n	8000c30 <__udivmoddi4+0xdc>
 8000c2a:	4282      	cmp	r2, r0
 8000c2c:	f200 80fa 	bhi.w	8000e24 <__udivmoddi4+0x2d0>
 8000c30:	1a84      	subs	r4, r0, r2
 8000c32:	eb65 0503 	sbc.w	r5, r5, r3
 8000c36:	2001      	movs	r0, #1
 8000c38:	46ac      	mov	ip, r5
 8000c3a:	2e00      	cmp	r6, #0
 8000c3c:	d03f      	beq.n	8000cbe <__udivmoddi4+0x16a>
 8000c3e:	e886 1010 	stmia.w	r6, {r4, ip}
 8000c42:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000c46:	b912      	cbnz	r2, 8000c4e <__udivmoddi4+0xfa>
 8000c48:	2701      	movs	r7, #1
 8000c4a:	fbb7 f7f2 	udiv	r7, r7, r2
 8000c4e:	fab7 fe87 	clz	lr, r7
 8000c52:	f1be 0f00 	cmp.w	lr, #0
 8000c56:	d134      	bne.n	8000cc2 <__udivmoddi4+0x16e>
 8000c58:	1beb      	subs	r3, r5, r7
 8000c5a:	0c3a      	lsrs	r2, r7, #16
 8000c5c:	fa1f fc87 	uxth.w	ip, r7
 8000c60:	2101      	movs	r1, #1
 8000c62:	fbb3 f8f2 	udiv	r8, r3, r2
 8000c66:	0c25      	lsrs	r5, r4, #16
 8000c68:	fb02 3318 	mls	r3, r2, r8, r3
 8000c6c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000c70:	fb0c f308 	mul.w	r3, ip, r8
 8000c74:	42ab      	cmp	r3, r5
 8000c76:	d907      	bls.n	8000c88 <__udivmoddi4+0x134>
 8000c78:	19ed      	adds	r5, r5, r7
 8000c7a:	f108 30ff 	add.w	r0, r8, #4294967295
 8000c7e:	d202      	bcs.n	8000c86 <__udivmoddi4+0x132>
 8000c80:	42ab      	cmp	r3, r5
 8000c82:	f200 80d1 	bhi.w	8000e28 <__udivmoddi4+0x2d4>
 8000c86:	4680      	mov	r8, r0
 8000c88:	1aed      	subs	r5, r5, r3
 8000c8a:	b2a3      	uxth	r3, r4
 8000c8c:	fbb5 f0f2 	udiv	r0, r5, r2
 8000c90:	fb02 5510 	mls	r5, r2, r0, r5
 8000c94:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 8000c98:	fb0c fc00 	mul.w	ip, ip, r0
 8000c9c:	45a4      	cmp	ip, r4
 8000c9e:	d907      	bls.n	8000cb0 <__udivmoddi4+0x15c>
 8000ca0:	19e4      	adds	r4, r4, r7
 8000ca2:	f100 33ff 	add.w	r3, r0, #4294967295
 8000ca6:	d202      	bcs.n	8000cae <__udivmoddi4+0x15a>
 8000ca8:	45a4      	cmp	ip, r4
 8000caa:	f200 80b8 	bhi.w	8000e1e <__udivmoddi4+0x2ca>
 8000cae:	4618      	mov	r0, r3
 8000cb0:	eba4 040c 	sub.w	r4, r4, ip
 8000cb4:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
 8000cb8:	e79d      	b.n	8000bf6 <__udivmoddi4+0xa2>
 8000cba:	4631      	mov	r1, r6
 8000cbc:	4630      	mov	r0, r6
 8000cbe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000cc2:	f1ce 0420 	rsb	r4, lr, #32
 8000cc6:	fa05 f30e 	lsl.w	r3, r5, lr
 8000cca:	fa07 f70e 	lsl.w	r7, r7, lr
 8000cce:	fa20 f804 	lsr.w	r8, r0, r4
 8000cd2:	0c3a      	lsrs	r2, r7, #16
 8000cd4:	fa25 f404 	lsr.w	r4, r5, r4
 8000cd8:	ea48 0803 	orr.w	r8, r8, r3
 8000cdc:	fbb4 f1f2 	udiv	r1, r4, r2
 8000ce0:	ea4f 4518 	mov.w	r5, r8, lsr #16
 8000ce4:	fb02 4411 	mls	r4, r2, r1, r4
 8000ce8:	fa1f fc87 	uxth.w	ip, r7
 8000cec:	ea45 4504 	orr.w	r5, r5, r4, lsl #16
 8000cf0:	fb01 f30c 	mul.w	r3, r1, ip
 8000cf4:	42ab      	cmp	r3, r5
 8000cf6:	fa00 f40e 	lsl.w	r4, r0, lr
 8000cfa:	d909      	bls.n	8000d10 <__udivmoddi4+0x1bc>
 8000cfc:	19ed      	adds	r5, r5, r7
 8000cfe:	f101 30ff 	add.w	r0, r1, #4294967295
 8000d02:	f080 808a 	bcs.w	8000e1a <__udivmoddi4+0x2c6>
 8000d06:	42ab      	cmp	r3, r5
 8000d08:	f240 8087 	bls.w	8000e1a <__udivmoddi4+0x2c6>
 8000d0c:	3902      	subs	r1, #2
 8000d0e:	443d      	add	r5, r7
 8000d10:	1aeb      	subs	r3, r5, r3
 8000d12:	fa1f f588 	uxth.w	r5, r8
 8000d16:	fbb3 f0f2 	udiv	r0, r3, r2
 8000d1a:	fb02 3310 	mls	r3, r2, r0, r3
 8000d1e:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 8000d22:	fb00 f30c 	mul.w	r3, r0, ip
 8000d26:	42ab      	cmp	r3, r5
 8000d28:	d907      	bls.n	8000d3a <__udivmoddi4+0x1e6>
 8000d2a:	19ed      	adds	r5, r5, r7
 8000d2c:	f100 38ff 	add.w	r8, r0, #4294967295
 8000d30:	d26f      	bcs.n	8000e12 <__udivmoddi4+0x2be>
 8000d32:	42ab      	cmp	r3, r5
 8000d34:	d96d      	bls.n	8000e12 <__udivmoddi4+0x2be>
 8000d36:	3802      	subs	r0, #2
 8000d38:	443d      	add	r5, r7
 8000d3a:	1aeb      	subs	r3, r5, r3
 8000d3c:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
 8000d40:	e78f      	b.n	8000c62 <__udivmoddi4+0x10e>
 8000d42:	f1c1 0720 	rsb	r7, r1, #32
 8000d46:	fa22 f807 	lsr.w	r8, r2, r7
 8000d4a:	408b      	lsls	r3, r1
 8000d4c:	fa05 f401 	lsl.w	r4, r5, r1
 8000d50:	ea48 0303 	orr.w	r3, r8, r3
 8000d54:	fa20 fe07 	lsr.w	lr, r0, r7
 8000d58:	ea4f 4c13 	mov.w	ip, r3, lsr #16
 8000d5c:	40fd      	lsrs	r5, r7
 8000d5e:	ea4e 0e04 	orr.w	lr, lr, r4
 8000d62:	fbb5 f9fc 	udiv	r9, r5, ip
 8000d66:	ea4f 441e 	mov.w	r4, lr, lsr #16
 8000d6a:	fb0c 5519 	mls	r5, ip, r9, r5
 8000d6e:	fa1f f883 	uxth.w	r8, r3
 8000d72:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 8000d76:	fb09 f408 	mul.w	r4, r9, r8
 8000d7a:	42ac      	cmp	r4, r5
 8000d7c:	fa02 f201 	lsl.w	r2, r2, r1
 8000d80:	fa00 fa01 	lsl.w	sl, r0, r1
 8000d84:	d908      	bls.n	8000d98 <__udivmoddi4+0x244>
 8000d86:	18ed      	adds	r5, r5, r3
 8000d88:	f109 30ff 	add.w	r0, r9, #4294967295
 8000d8c:	d243      	bcs.n	8000e16 <__udivmoddi4+0x2c2>
 8000d8e:	42ac      	cmp	r4, r5
 8000d90:	d941      	bls.n	8000e16 <__udivmoddi4+0x2c2>
 8000d92:	f1a9 0902 	sub.w	r9, r9, #2
 8000d96:	441d      	add	r5, r3
 8000d98:	1b2d      	subs	r5, r5, r4
 8000d9a:	fa1f fe8e 	uxth.w	lr, lr
 8000d9e:	fbb5 f0fc 	udiv	r0, r5, ip
 8000da2:	fb0c 5510 	mls	r5, ip, r0, r5
 8000da6:	ea4e 4405 	orr.w	r4, lr, r5, lsl #16
 8000daa:	fb00 f808 	mul.w	r8, r0, r8
 8000dae:	45a0      	cmp	r8, r4
 8000db0:	d907      	bls.n	8000dc2 <__udivmoddi4+0x26e>
 8000db2:	18e4      	adds	r4, r4, r3
 8000db4:	f100 35ff 	add.w	r5, r0, #4294967295
 8000db8:	d229      	bcs.n	8000e0e <__udivmoddi4+0x2ba>
 8000dba:	45a0      	cmp	r8, r4
 8000dbc:	d927      	bls.n	8000e0e <__udivmoddi4+0x2ba>
 8000dbe:	3802      	subs	r0, #2
 8000dc0:	441c      	add	r4, r3
 8000dc2:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 8000dc6:	eba4 0408 	sub.w	r4, r4, r8
 8000dca:	fba0 8902 	umull	r8, r9, r0, r2
 8000dce:	454c      	cmp	r4, r9
 8000dd0:	46c6      	mov	lr, r8
 8000dd2:	464d      	mov	r5, r9
 8000dd4:	d315      	bcc.n	8000e02 <__udivmoddi4+0x2ae>
 8000dd6:	d012      	beq.n	8000dfe <__udivmoddi4+0x2aa>
 8000dd8:	b156      	cbz	r6, 8000df0 <__udivmoddi4+0x29c>
 8000dda:	ebba 030e 	subs.w	r3, sl, lr
 8000dde:	eb64 0405 	sbc.w	r4, r4, r5
 8000de2:	fa04 f707 	lsl.w	r7, r4, r7
 8000de6:	40cb      	lsrs	r3, r1
 8000de8:	431f      	orrs	r7, r3
 8000dea:	40cc      	lsrs	r4, r1
 8000dec:	6037      	str	r7, [r6, #0]
 8000dee:	6074      	str	r4, [r6, #4]
 8000df0:	2100      	movs	r1, #0
 8000df2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000df6:	4618      	mov	r0, r3
 8000df8:	e6f8      	b.n	8000bec <__udivmoddi4+0x98>
 8000dfa:	4690      	mov	r8, r2
 8000dfc:	e6e0      	b.n	8000bc0 <__udivmoddi4+0x6c>
 8000dfe:	45c2      	cmp	sl, r8
 8000e00:	d2ea      	bcs.n	8000dd8 <__udivmoddi4+0x284>
 8000e02:	ebb8 0e02 	subs.w	lr, r8, r2
 8000e06:	eb69 0503 	sbc.w	r5, r9, r3
 8000e0a:	3801      	subs	r0, #1
 8000e0c:	e7e4      	b.n	8000dd8 <__udivmoddi4+0x284>
 8000e0e:	4628      	mov	r0, r5
 8000e10:	e7d7      	b.n	8000dc2 <__udivmoddi4+0x26e>
 8000e12:	4640      	mov	r0, r8
 8000e14:	e791      	b.n	8000d3a <__udivmoddi4+0x1e6>
 8000e16:	4681      	mov	r9, r0
 8000e18:	e7be      	b.n	8000d98 <__udivmoddi4+0x244>
 8000e1a:	4601      	mov	r1, r0
 8000e1c:	e778      	b.n	8000d10 <__udivmoddi4+0x1bc>
 8000e1e:	3802      	subs	r0, #2
 8000e20:	443c      	add	r4, r7
 8000e22:	e745      	b.n	8000cb0 <__udivmoddi4+0x15c>
 8000e24:	4608      	mov	r0, r1
 8000e26:	e708      	b.n	8000c3a <__udivmoddi4+0xe6>
 8000e28:	f1a8 0802 	sub.w	r8, r8, #2
 8000e2c:	443d      	add	r5, r7
 8000e2e:	e72b      	b.n	8000c88 <__udivmoddi4+0x134>

08000e30 <__aeabi_idiv0>:
 8000e30:	4770      	bx	lr
 8000e32:	bf00      	nop

08000e34 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8000e34:	b510      	push	{r4, lr}
  /*Configure the SysTick to have interrupt in 1ms time basis*/
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 8000e36:	4b08      	ldr	r3, [pc, #32]	; (8000e58 <HAL_InitTick+0x24>)
{
 8000e38:	4604      	mov	r4, r0
  HAL_SYSTICK_Config(SystemCoreClock/1000);
 8000e3a:	6818      	ldr	r0, [r3, #0]
 8000e3c:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8000e40:	fbb0 f0f3 	udiv	r0, r0, r3
 8000e44:	f000 fdd0 	bl	80019e8 <HAL_SYSTICK_Config>

  /*Configure the SysTick IRQ priority */
  HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority ,0);
 8000e48:	2200      	movs	r2, #0
 8000e4a:	4621      	mov	r1, r4
 8000e4c:	f04f 30ff 	mov.w	r0, #4294967295
 8000e50:	f000 fd8a 	bl	8001968 <HAL_NVIC_SetPriority>

  /* Return function status */
  return HAL_OK;
}
 8000e54:	2000      	movs	r0, #0
 8000e56:	bd10      	pop	{r4, pc}
 8000e58:	20000024 	.word	0x20000024

08000e5c <HAL_Init>:
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000e5c:	4a07      	ldr	r2, [pc, #28]	; (8000e7c <HAL_Init+0x20>)
{
 8000e5e:	b508      	push	{r3, lr}
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8000e60:	6813      	ldr	r3, [r2, #0]
 8000e62:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000e66:	6013      	str	r3, [r2, #0]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8000e68:	2003      	movs	r0, #3
 8000e6a:	f000 fd6b 	bl	8001944 <HAL_NVIC_SetPriorityGrouping>
  HAL_InitTick(TICK_INT_PRIORITY);
 8000e6e:	2000      	movs	r0, #0
 8000e70:	f7ff ffe0 	bl	8000e34 <HAL_InitTick>
  HAL_MspInit();
 8000e74:	f009 fac8 	bl	800a408 <HAL_MspInit>
}
 8000e78:	2000      	movs	r0, #0
 8000e7a:	bd08      	pop	{r3, pc}
 8000e7c:	40022000 	.word	0x40022000

08000e80 <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick++;
 8000e80:	4a02      	ldr	r2, [pc, #8]	; (8000e8c <HAL_IncTick+0xc>)
 8000e82:	6813      	ldr	r3, [r2, #0]
 8000e84:	3301      	adds	r3, #1
 8000e86:	6013      	str	r3, [r2, #0]
 8000e88:	4770      	bx	lr
 8000e8a:	bf00      	nop
 8000e8c:	200003d0 	.word	0x200003d0

08000e90 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 8000e90:	4b01      	ldr	r3, [pc, #4]	; (8000e98 <HAL_GetTick+0x8>)
 8000e92:	6818      	ldr	r0, [r3, #0]
}
 8000e94:	4770      	bx	lr
 8000e96:	bf00      	nop
 8000e98:	200003d0 	.word	0x200003d0

08000e9c <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8000e9c:	b538      	push	{r3, r4, r5, lr}
 8000e9e:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 8000ea0:	f7ff fff6 	bl	8000e90 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 8000ea4:	1c63      	adds	r3, r4, #1
  uint32_t tickstart = HAL_GetTick();
 8000ea6:	4605      	mov	r5, r0
  {
    wait++;
 8000ea8:	bf18      	it	ne
 8000eaa:	3401      	addne	r4, #1
  } 

  while((HAL_GetTick() - tickstart) < wait)
 8000eac:	f7ff fff0 	bl	8000e90 <HAL_GetTick>
 8000eb0:	1b40      	subs	r0, r0, r5
 8000eb2:	4284      	cmp	r4, r0
 8000eb4:	d8fa      	bhi.n	8000eac <HAL_Delay+0x10>
  {
  }
}
 8000eb6:	bd38      	pop	{r3, r4, r5, pc}

08000eb8 <LL_ADC_SetChannelSamplingTime>:
  *             can be replaced by 3.5 ADC clock cycles.
  *             Refer to function @ref LL_ADC_SetSamplingTimeCommonConfig().
  * @retval None
  */
__STATIC_INLINE void LL_ADC_SetChannelSamplingTime(ADC_TypeDef *ADCx, uint32_t Channel, uint32_t SamplingTime)
{
 8000eb8:	b570      	push	{r4, r5, r6, lr}
__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
{
  uint32_t result;

#if       (__CORTEX_M >= 0x03U) || (__CORTEX_SC >= 300U)
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8000eba:	f04f 7600 	mov.w	r6, #33554432	; 0x2000000
 8000ebe:	fa96 f6a6 	rbit	r6, r6
  
  MODIFY_REG(*preg,
             ADC_SMPR1_SMP0 << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS),
             SamplingTime   << ((Channel & ADC_CHANNEL_SMPx_BITOFFSET_MASK) >> ADC_CHANNEL_SMPx_BITOFFSET_POS));
#else
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SMPR1, __ADC_MASK_SHIFT(Channel, ADC_CHANNEL_SMPRX_REGOFFSET_MASK));
 8000ec2:	fab6 f386 	clz	r3, r6
 8000ec6:	f001 7600 	and.w	r6, r1, #33554432	; 0x2000000
 8000eca:	40de      	lsrs	r6, r3
 8000ecc:	3014      	adds	r0, #20
  
  MODIFY_REG(*preg,
 8000ece:	f001 71f8 	and.w	r1, r1, #32505856	; 0x1f00000
 8000ed2:	f04f 73f8 	mov.w	r3, #32505856	; 0x1f00000
 8000ed6:	fa93 f5a3 	rbit	r5, r3
 8000eda:	fab5 f585 	clz	r5, r5
 8000ede:	fa93 f3a3 	rbit	r3, r3
 8000ee2:	2407      	movs	r4, #7
 8000ee4:	fa21 f505 	lsr.w	r5, r1, r5
 8000ee8:	fa04 f505 	lsl.w	r5, r4, r5
 8000eec:	fab3 f383 	clz	r3, r3
 8000ef0:	f850 4026 	ldr.w	r4, [r0, r6, lsl #2]
 8000ef4:	40d9      	lsrs	r1, r3
 8000ef6:	ea24 0405 	bic.w	r4, r4, r5
 8000efa:	fa02 f101 	lsl.w	r1, r2, r1
 8000efe:	4321      	orrs	r1, r4
 8000f00:	f840 1026 	str.w	r1, [r0, r6, lsl #2]
 8000f04:	bd70      	pop	{r4, r5, r6, pc}
	...

08000f08 <HAL_ADC_Init>:
  *         without  disabling the other ADCs.
  * @param hadc ADC handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_Init(ADC_HandleTypeDef* hadc)
{
 8000f08:	b537      	push	{r0, r1, r2, r4, r5, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpCFGR = 0U;
  __IO uint32_t wait_loop_index = 0;
 8000f0a:	2300      	movs	r3, #0
 8000f0c:	9301      	str	r3, [sp, #4]
  
  /* Check ADC handle */
  if(hadc == NULL)
 8000f0e:	4604      	mov	r4, r0
 8000f10:	2800      	cmp	r0, #0
 8000f12:	f000 80b4 	beq.w	800107e <HAL_ADC_Init+0x176>
  /* DISCEN and CONT bits cannot be set at the same time */
  assert_param(!((hadc->Init.DiscontinuousConvMode == ENABLE) && (hadc->Init.ContinuousConvMode == ENABLE)));
  
  /* Actions performed only if ADC is coming from state reset:                */
  /* - Initialization of ADC MSP                                              */
  if(hadc->State == HAL_ADC_STATE_RESET)
 8000f16:	6dc5      	ldr	r5, [r0, #92]	; 0x5c
 8000f18:	b925      	cbnz	r5, 8000f24 <HAL_ADC_Init+0x1c>
    
    /* Init the low level hardware */
    hadc->MspInitCallback(hadc);
#else
    /* Init the low level hardware */
    HAL_ADC_MspInit(hadc);
 8000f1a:	f008 fcb3 	bl	8009884 <HAL_ADC_MspInit>
#endif /* USE_HAL_ADC_REGISTER_CALLBACKS */
    
    /* Set ADC error code to none */
    ADC_CLEAR_ERRORCODE(hadc);
 8000f1e:	6625      	str	r5, [r4, #96]	; 0x60
    
    /* Initialize Lock */
    hadc->Lock = HAL_UNLOCKED;
 8000f20:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
  }
  
  /* - Exit from deep-power-down mode and ADC voltage regulator enable        */
  if(LL_ADC_IsDeepPowerDownEnabled(hadc->Instance) != 0U)
 8000f24:	6823      	ldr	r3, [r4, #0]
  * @param  ADCx ADC instance
  * @retval 0: deep power down is disabled, 1: deep power down is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsDeepPowerDownEnabled(ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_DEEPPWD) == (ADC_CR_DEEPPWD));
 8000f26:	689a      	ldr	r2, [r3, #8]
 8000f28:	0090      	lsls	r0, r2, #2
  CLEAR_BIT(ADCx->CR, (ADC_CR_DEEPPWD | ADC_CR_BITS_PROPERTY_RS));
 8000f2a:	bf41      	itttt	mi
 8000f2c:	689a      	ldrmi	r2, [r3, #8]
 8000f2e:	f022 4220 	bicmi.w	r2, r2, #2684354560	; 0xa0000000
 8000f32:	f022 023f 	bicmi.w	r2, r2, #63	; 0x3f
 8000f36:	609a      	strmi	r2, [r3, #8]
  * @param  ADCx ADC instance
  * @retval 0: internal regulator is disabled, 1: internal regulator is enabled.
  */
__STATIC_INLINE uint32_t LL_ADC_IsInternalRegulatorEnabled(ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADVREGEN) == (ADC_CR_ADVREGEN));
 8000f38:	689a      	ldr	r2, [r3, #8]
    /* System was in deep power down mode, calibration must
     be relaunched or a previously saved calibration factor 
     re-applied once the ADC voltage regulator is enabled */    
  }
  
  if(LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0U)
 8000f3a:	00d1      	lsls	r1, r2, #3
 8000f3c:	d576      	bpl.n	800102c <HAL_ADC_Init+0x124>
 8000f3e:	689a      	ldr	r2, [r3, #8]
  }
  
  /* Verification that ADC voltage regulator is correctly enabled, whether    */
  /* or not ADC is coming from state reset (if any potential problem of       */
  /* clocking, voltage regulator would not be enabled).                       */
  if(LL_ADC_IsInternalRegulatorEnabled(hadc->Instance) == 0U)
 8000f40:	00d2      	lsls	r2, r2, #3
 8000f42:	f140 808a 	bpl.w	800105a <HAL_ADC_Init+0x152>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 8000f46:	2000      	movs	r0, #0
  
  /* Configuration of ADC parameters if previous preliminary actions are      */ 
  /* correctly completed and if there is no conversion on going on regular    */
  /* group (ADC may already be enabled at this point if HAL_ADC_Init() is     */
  /* called to update a parameter on the fly).                                */
  if(   (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL))
 8000f48:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8000f4a:	06d5      	lsls	r5, r2, #27
 8000f4c:	f100 8093 	bmi.w	8001076 <HAL_ADC_Init+0x16e>
  * @param  ADCx ADC instance
  * @retval 0: no conversion is on going on ADC group regular.
  */
__STATIC_INLINE uint32_t LL_ADC_REG_IsConversionOngoing(ADC_TypeDef *ADCx)
{
  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART));
 8000f50:	689a      	ldr	r2, [r3, #8]
     && (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8000f52:	0751      	lsls	r1, r2, #29
 8000f54:	f100 808f 	bmi.w	8001076 <HAL_ADC_Init+0x16e>
    )
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 8000f58:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8000f5a:	f422 7281 	bic.w	r2, r2, #258	; 0x102
 8000f5e:	f042 0202 	orr.w	r2, r2, #2
 8000f62:	65e2      	str	r2, [r4, #92]	; 0x5c
    /* Configuration of common ADC parameters                                 */
    
    /* Parameters update conditioned to ADC state:                            */
    /* Parameters that can be updated only when ADC is disabled:              */
    /*  - clock configuration                                                 */
    if ((ADC_IS_ENABLE(hadc) == RESET)   &&
 8000f64:	689a      	ldr	r2, [r3, #8]
 8000f66:	f002 0203 	and.w	r2, r2, #3
 8000f6a:	2a01      	cmp	r2, #1
 8000f6c:	f040 8089 	bne.w	8001082 <HAL_ADC_Init+0x17a>
 8000f70:	681a      	ldr	r2, [r3, #0]
 8000f72:	07d2      	lsls	r2, r2, #31
 8000f74:	f140 8085 	bpl.w	8001082 <HAL_ADC_Init+0x17a>
    /*  - overrun                                  Init.Overrun               */
    /*  - discontinuous mode                       Init.DiscontinuousConvMode */
    /*  - discontinuous mode channel count         Init.NbrOfDiscConversion   */
    tmpCFGR  = (ADC_CFGR_CONTINUOUS(hadc->Init.ContinuousConvMode)           |
                hadc->Init.Overrun                                           |
                hadc->Init.DataAlign                                         |
 8000f78:	68e5      	ldr	r5, [r4, #12]
 8000f7a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
                hadc->Init.Resolution                                        |
                ADC_CFGR_REG_DISCONTINUOUS(hadc->Init.DiscontinuousConvMode)  );
 8000f7c:	6a61      	ldr	r1, [r4, #36]	; 0x24
                hadc->Init.DataAlign                                         |
 8000f7e:	432a      	orrs	r2, r5
 8000f80:	68a5      	ldr	r5, [r4, #8]
 8000f82:	432a      	orrs	r2, r5
    tmpCFGR  = (ADC_CFGR_CONTINUOUS(hadc->Init.ContinuousConvMode)           |
 8000f84:	69e5      	ldr	r5, [r4, #28]
    
    if (hadc->Init.DiscontinuousConvMode == ENABLE)
 8000f86:	2901      	cmp	r1, #1
                hadc->Init.DataAlign                                         |
 8000f88:	ea42 3245 	orr.w	r2, r2, r5, lsl #13
    tmpCFGR  = (ADC_CFGR_CONTINUOUS(hadc->Init.ContinuousConvMode)           |
 8000f8c:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
    {
      tmpCFGR |= ADC_CFGR_DISCONTINUOUS_NUM(hadc->Init.NbrOfDiscConversion);
 8000f90:	bf02      	ittt	eq
 8000f92:	6aa1      	ldreq	r1, [r4, #40]	; 0x28
 8000f94:	f101 31ff 	addeq.w	r1, r1, #4294967295
 8000f98:	ea42 4241 	orreq.w	r2, r2, r1, lsl #17
    /* Enable external trigger if trigger selection is different of software  */
    /* start.                                                                 */
    /* Note: This configuration keeps the hardware feature of parameter       */
    /*       ExternalTrigConvEdge "trigger edge none" equivalent to           */
    /*       software start.                                                  */
    if (hadc->Init.ExternalTrigConv != ADC_SOFTWARE_START)
 8000f9c:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
 8000f9e:	b121      	cbz	r1, 8000faa <HAL_ADC_Init+0xa2>
    {
      tmpCFGR |= (  (hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
                  | hadc->Init.ExternalTrigConvEdge
 8000fa0:	6b25      	ldr	r5, [r4, #48]	; 0x30
      tmpCFGR |= (  (hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8000fa2:	f401 7170 	and.w	r1, r1, #960	; 0x3c0
                  | hadc->Init.ExternalTrigConvEdge
 8000fa6:	4329      	orrs	r1, r5
      tmpCFGR |= (  (hadc->Init.ExternalTrigConv & ADC_CFGR_EXTSEL)
 8000fa8:	430a      	orrs	r2, r1
                 );
    }
    
    /* Update Configuration Register CFGR */
    MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_1, tmpCFGR); 
 8000faa:	68dd      	ldr	r5, [r3, #12]
 8000fac:	4939      	ldr	r1, [pc, #228]	; (8001094 <HAL_ADC_Init+0x18c>)
 8000fae:	4029      	ands	r1, r5
 8000fb0:	430a      	orrs	r2, r1
 8000fb2:	60da      	str	r2, [r3, #12]
    /* Parameters that can be updated when ADC is disabled or enabled without */
    /* conversion on going on regular and injected groups:                    */
    /*  - DMA continuous request          Init.DMAContinuousRequests          */
    /*  - LowPowerAutoWait feature        Init.LowPowerAutoWait               */
    /*  - Oversampling parameters         Init.Oversampling                   */
    if (ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(hadc) == RESET)
 8000fb4:	689a      	ldr	r2, [r3, #8]
 8000fb6:	f012 0f0c 	tst.w	r2, #12
 8000fba:	d120      	bne.n	8000ffe <HAL_ADC_Init+0xf6>
    {
      tmpCFGR = ( ADC_CFGR_DFSDM(hadc)                                 |
                  ADC_CFGR_AUTOWAIT(hadc->Init.LowPowerAutoWait)       |
                  ADC_CFGR_DMACONTREQ(hadc->Init.DMAContinuousRequests) );
 8000fbc:	6b62      	ldr	r2, [r4, #52]	; 0x34
                  ADC_CFGR_AUTOWAIT(hadc->Init.LowPowerAutoWait)       |
 8000fbe:	69a5      	ldr	r5, [r4, #24]
      
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);                    
 8000fc0:	68d9      	ldr	r1, [r3, #12]
                  ADC_CFGR_DMACONTREQ(hadc->Init.DMAContinuousRequests) );
 8000fc2:	0052      	lsls	r2, r2, #1
      tmpCFGR = ( ADC_CFGR_DFSDM(hadc)                                 |
 8000fc4:	ea42 3285 	orr.w	r2, r2, r5, lsl #14
 8000fc8:	6d25      	ldr	r5, [r4, #80]	; 0x50
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);                    
 8000fca:	f421 4180 	bic.w	r1, r1, #16384	; 0x4000
      tmpCFGR = ( ADC_CFGR_DFSDM(hadc)                                 |
 8000fce:	432a      	orrs	r2, r5
      MODIFY_REG(hadc->Instance->CFGR, ADC_CFGR_FIELDS_2, tmpCFGR);                    
 8000fd0:	f021 0106 	bic.w	r1, r1, #6
 8000fd4:	430a      	orrs	r2, r1
 8000fd6:	60da      	str	r2, [r3, #12]
      
      if (hadc->Init.OversamplingMode == ENABLE)
 8000fd8:	6be2      	ldr	r2, [r4, #60]	; 0x3c
 8000fda:	2a01      	cmp	r2, #1
 8000fdc:	d147      	bne.n	800106e <HAL_ADC_Init+0x166>
        /* Configuration of Oversampler:                                      */
        /*  - Oversampling Ratio                                              */
        /*  - Right bit shift                                                 */
        /*  - Triggered mode                                                  */
        /*  - Oversampling mode (continued/resumed)                           */
        MODIFY_REG(hadc->Instance->CFGR2,
 8000fde:	6c65      	ldr	r5, [r4, #68]	; 0x44
 8000fe0:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8000fe2:	6919      	ldr	r1, [r3, #16]
 8000fe4:	432a      	orrs	r2, r5
 8000fe6:	6ca5      	ldr	r5, [r4, #72]	; 0x48
 8000fe8:	f042 0201 	orr.w	r2, r2, #1
 8000fec:	432a      	orrs	r2, r5
 8000fee:	6ce5      	ldr	r5, [r4, #76]	; 0x4c
 8000ff0:	f421 61ff 	bic.w	r1, r1, #2040	; 0x7f8
 8000ff4:	432a      	orrs	r2, r5
 8000ff6:	f021 0104 	bic.w	r1, r1, #4
 8000ffa:	430a      	orrs	r2, r1
                  );
      }
      else
      {
        /* Disable ADC oversampling scope on ADC group regular */
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 8000ffc:	611a      	str	r2, [r3, #16]
    /*   Note: Scan mode is not present by hardware on this device, but       */
    /*   emulated by software for alignment over all STM32 devices.           */
    /* - if scan mode is enabled, regular channels sequence length is set to  */
    /*   parameter "NbrOfConversion".                                         */

    if (hadc->Init.ScanConvMode == ADC_SCAN_ENABLE)
 8000ffe:	6922      	ldr	r2, [r4, #16]
 8001000:	2a01      	cmp	r2, #1
    {
      /* Set number of ranks in regular group sequencer */
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 8001002:	bf05      	ittet	eq
 8001004:	6b19      	ldreq	r1, [r3, #48]	; 0x30
 8001006:	6a22      	ldreq	r2, [r4, #32]
    }
    else
    {
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8001008:	6b1a      	ldrne	r2, [r3, #48]	; 0x30
      MODIFY_REG(hadc->Instance->SQR1, ADC_SQR1_L, (hadc->Init.NbrOfConversion - (uint8_t)1));
 800100a:	f102 32ff 	addeq.w	r2, r2, #4294967295
 800100e:	bf06      	itte	eq
 8001010:	f021 010f 	biceq.w	r1, r1, #15
 8001014:	430a      	orreq	r2, r1
      CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_L);
 8001016:	f022 020f 	bicne.w	r2, r2, #15
 800101a:	631a      	str	r2, [r3, #48]	; 0x30
    }
    
    /* Initialize the ADC state */
    /* Clear HAL_ADC_STATE_BUSY_INTERNAL bit, set HAL_ADC_STATE_READY bit */
    ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL, HAL_ADC_STATE_READY);
 800101c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800101e:	f023 0303 	bic.w	r3, r3, #3
 8001022:	f043 0301 	orr.w	r3, r3, #1
 8001026:	65e3      	str	r3, [r4, #92]	; 0x5c
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Return function status */
  return tmp_hal_status;
}
 8001028:	b003      	add	sp, #12
 800102a:	bd30      	pop	{r4, r5, pc}
  MODIFY_REG(ADCx->CR,
 800102c:	689a      	ldr	r2, [r3, #8]
    wait_loop_index = (LL_ADC_DELAY_INTERNAL_REGUL_STAB_US * (SystemCoreClock / (1000000 * 2)));
 800102e:	491a      	ldr	r1, [pc, #104]	; (8001098 <HAL_ADC_Init+0x190>)
 8001030:	f022 4210 	bic.w	r2, r2, #2415919104	; 0x90000000
 8001034:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8001038:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800103c:	609a      	str	r2, [r3, #8]
 800103e:	4a17      	ldr	r2, [pc, #92]	; (800109c <HAL_ADC_Init+0x194>)
 8001040:	6812      	ldr	r2, [r2, #0]
 8001042:	fbb2 f1f1 	udiv	r1, r2, r1
 8001046:	220a      	movs	r2, #10
 8001048:	434a      	muls	r2, r1
      wait_loop_index--;
 800104a:	9201      	str	r2, [sp, #4]
    while(wait_loop_index != 0)
 800104c:	9a01      	ldr	r2, [sp, #4]
 800104e:	2a00      	cmp	r2, #0
 8001050:	f43f af75 	beq.w	8000f3e <HAL_ADC_Init+0x36>
      wait_loop_index--;
 8001054:	9a01      	ldr	r2, [sp, #4]
 8001056:	3a01      	subs	r2, #1
 8001058:	e7f7      	b.n	800104a <HAL_ADC_Init+0x142>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800105a:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 800105c:	f042 0210 	orr.w	r2, r2, #16
 8001060:	65e2      	str	r2, [r4, #92]	; 0x5c
    SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001062:	6e22      	ldr	r2, [r4, #96]	; 0x60
 8001064:	f042 0201 	orr.w	r2, r2, #1
 8001068:	6622      	str	r2, [r4, #96]	; 0x60
    tmp_hal_status = HAL_ERROR;
 800106a:	2001      	movs	r0, #1
 800106c:	e76c      	b.n	8000f48 <HAL_ADC_Init+0x40>
        CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSE);
 800106e:	691a      	ldr	r2, [r3, #16]
 8001070:	f022 0201 	bic.w	r2, r2, #1
 8001074:	e7c2      	b.n	8000ffc <HAL_ADC_Init+0xf4>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001076:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8001078:	f043 0310 	orr.w	r3, r3, #16
 800107c:	65e3      	str	r3, [r4, #92]	; 0x5c
    return HAL_ERROR;
 800107e:	2001      	movs	r0, #1
 8001080:	e7d2      	b.n	8001028 <HAL_ADC_Init+0x120>
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_CKMODE | ADC_CCR_PRESC, CommonClock);
 8001082:	4907      	ldr	r1, [pc, #28]	; (80010a0 <HAL_ADC_Init+0x198>)
 8001084:	6865      	ldr	r5, [r4, #4]
 8001086:	688a      	ldr	r2, [r1, #8]
 8001088:	f422 127c 	bic.w	r2, r2, #4128768	; 0x3f0000
 800108c:	432a      	orrs	r2, r5
 800108e:	608a      	str	r2, [r1, #8]
 8001090:	e772      	b.n	8000f78 <HAL_ADC_Init+0x70>
 8001092:	bf00      	nop
 8001094:	fff0c007 	.word	0xfff0c007
 8001098:	001e8480 	.word	0x001e8480
 800109c:	20000024 	.word	0x20000024
 80010a0:	50040300 	.word	0x50040300

080010a4 <HAL_ADC_PollForConversion>:
  * @param hadc ADC handle
  * @param Timeout Timeout value in millisecond.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_PollForConversion(ADC_HandleTypeDef* hadc, uint32_t Timeout)
{
 80010a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* If end of conversion selected to end of sequence conversions */
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 80010a6:	6945      	ldr	r5, [r0, #20]
 80010a8:	2d08      	cmp	r5, #8
{
 80010aa:	4604      	mov	r4, r0
 80010ac:	460e      	mov	r6, r1
  if (hadc->Init.EOCSelection == ADC_EOC_SEQ_CONV)
 80010ae:	d00a      	beq.n	80010c6 <HAL_ADC_PollForConversion+0x22>
    /* For code simplicity sake, this particular case is generalized to       */
    /* ADC configured in DMA mode and and polling for end of each conversion. */
    if(ADC_IS_DUAL_REGULAR_CONVERSION_ENABLE(hadc) == RESET)
    {
      /* Check ADC DMA mode in independant mode */
      if(READ_BIT(hadc->Instance->CFGR, ADC_CFGR_DMAEN) != RESET)
 80010b0:	6803      	ldr	r3, [r0, #0]
 80010b2:	68db      	ldr	r3, [r3, #12]
 80010b4:	07dd      	lsls	r5, r3, #31
 80010b6:	d505      	bpl.n	80010c4 <HAL_ADC_PollForConversion+0x20>
      {
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 80010b8:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 80010ba:	f043 0320 	orr.w	r3, r3, #32
 80010be:	65c3      	str	r3, [r0, #92]	; 0x5c
        return HAL_ERROR;
 80010c0:	2001      	movs	r0, #1
 80010c2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      }
      else
      {
        tmp_Flag_End = (ADC_FLAG_EOC);
 80010c4:	2504      	movs	r5, #4
      }
    }
  }
  
  /* Get tick count */
  tickstart = HAL_GetTick();
 80010c6:	f7ff fee3 	bl	8000e90 <HAL_GetTick>
 80010ca:	4607      	mov	r7, r0
  
  /* Wait until End of unitary conversion or sequence conversions flag is raised */
  while(HAL_IS_BIT_CLR(hadc->Instance->ISR, tmp_Flag_End))
 80010cc:	6823      	ldr	r3, [r4, #0]
 80010ce:	681a      	ldr	r2, [r3, #0]
 80010d0:	4215      	tst	r5, r2
 80010d2:	d01d      	beq.n	8001110 <HAL_ADC_PollForConversion+0x6c>
      }
    }
  }
  
  /* Update ADC state machine */
  SET_BIT(hadc->State, HAL_ADC_STATE_REG_EOC);
 80010d4:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80010d6:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 80010da:	65e2      	str	r2, [r4, #92]	; 0x5c
  
  /* Determine whether any further conversion upcoming on group regular       */
  /* by external trigger, continuous mode or scan sequence on going.          */
  if(ADC_IS_SOFTWARE_START_REGULAR(hadc)        && 
 80010dc:	68da      	ldr	r2, [r3, #12]
 80010de:	f412 6f40 	tst.w	r2, #3072	; 0xc00
 80010e2:	d10f      	bne.n	8001104 <HAL_ADC_PollForConversion+0x60>
 80010e4:	69e2      	ldr	r2, [r4, #28]
 80010e6:	b96a      	cbnz	r2, 8001104 <HAL_ADC_PollForConversion+0x60>
     (hadc->Init.ContinuousConvMode == DISABLE)   )
  {
    /* Check whether end of sequence is reached */
    if( __HAL_ADC_GET_FLAG(hadc, ADC_FLAG_EOS) )
 80010e8:	681a      	ldr	r2, [r3, #0]
 80010ea:	0711      	lsls	r1, r2, #28
 80010ec:	d50a      	bpl.n	8001104 <HAL_ADC_PollForConversion+0x60>
    {
      /* Set ADC state */
      CLEAR_BIT(hadc->State, HAL_ADC_STATE_REG_BUSY);
 80010ee:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80010f0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80010f4:	65e2      	str	r2, [r4, #92]	; 0x5c
      
      if (HAL_IS_BIT_CLR(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80010f6:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 80010f8:	04d2      	lsls	r2, r2, #19
      { 
        SET_BIT(hadc->State, HAL_ADC_STATE_READY);
 80010fa:	bf5e      	ittt	pl
 80010fc:	6de2      	ldrpl	r2, [r4, #92]	; 0x5c
 80010fe:	f042 0201 	orrpl.w	r2, r2, #1
 8001102:	65e2      	strpl	r2, [r4, #92]	; 0x5c
    tmpADC_Master = ADC_MASTER_REGISTER(hadc);
    tmp_cfgr = READ_REG(tmpADC_Master->CFGR);
  }
  
  /* Clear polled flag */
  if (tmp_Flag_End == ADC_FLAG_EOS)
 8001104:	2d08      	cmp	r5, #8
    tmp_cfgr = READ_REG(hadc->Instance->CFGR);  
 8001106:	68d8      	ldr	r0, [r3, #12]
  if (tmp_Flag_End == ADC_FLAG_EOS)
 8001108:	d114      	bne.n	8001134 <HAL_ADC_PollForConversion+0x90>
  {
    __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_EOS);  
 800110a:	601d      	str	r5, [r3, #0]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
    }
  }
  
  /* Return function status */
  return HAL_OK;
 800110c:	2000      	movs	r0, #0
}
 800110e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if(Timeout != HAL_MAX_DELAY)
 8001110:	1c70      	adds	r0, r6, #1
 8001112:	d0dc      	beq.n	80010ce <HAL_ADC_PollForConversion+0x2a>
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 8001114:	b946      	cbnz	r6, 8001128 <HAL_ADC_PollForConversion+0x84>
        SET_BIT(hadc->State, HAL_ADC_STATE_TIMEOUT);
 8001116:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8001118:	f043 0304 	orr.w	r3, r3, #4
 800111c:	65e3      	str	r3, [r4, #92]	; 0x5c
        __HAL_UNLOCK(hadc);
 800111e:	2300      	movs	r3, #0
 8001120:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
        return HAL_TIMEOUT;
 8001124:	2003      	movs	r0, #3
 8001126:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if((Timeout == 0) || ((HAL_GetTick()-tickstart) > Timeout))
 8001128:	f7ff feb2 	bl	8000e90 <HAL_GetTick>
 800112c:	1bc0      	subs	r0, r0, r7
 800112e:	4286      	cmp	r6, r0
 8001130:	d2cc      	bcs.n	80010cc <HAL_ADC_PollForConversion+0x28>
 8001132:	e7f0      	b.n	8001116 <HAL_ADC_PollForConversion+0x72>
    if (READ_BIT(tmp_cfgr, ADC_CFGR_AUTDLY) == RESET)
 8001134:	f410 4080 	ands.w	r0, r0, #16384	; 0x4000
 8001138:	d1e8      	bne.n	800110c <HAL_ADC_PollForConversion+0x68>
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS));
 800113a:	220c      	movs	r2, #12
 800113c:	601a      	str	r2, [r3, #0]
 800113e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001140 <HAL_ADC_GetValue>:

  /* Note: EOC flag is not cleared here by software because automatically     */
  /*       cleared by hardware when reading register DR.                      */
  
  /* Return ADC converted value */ 
  return hadc->Instance->DR;
 8001140:	6803      	ldr	r3, [r0, #0]
 8001142:	6c18      	ldr	r0, [r3, #64]	; 0x40
}
 8001144:	4770      	bx	lr
	...

08001148 <HAL_ADC_ConfigChannel>:
  * @param hadc ADC handle
  * @param sConfig Structure of ADC channel assigned to ADC group regular.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADC_ConfigChannel(ADC_HandleTypeDef* hadc, ADC_ChannelConfTypeDef* sConfig)
{
 8001148:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
  uint32_t tmpOffsetShifted;
  __IO uint32_t wait_loop_index = 0;
 800114a:	2300      	movs	r3, #0
 800114c:	9301      	str	r3, [sp, #4]
  {
    assert_param(IS_ADC_DIFF_CHANNEL(hadc, sConfig->Channel));
  }
  
  /* Process locked */
  __HAL_LOCK(hadc);
 800114e:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
 8001152:	2b01      	cmp	r3, #1
{
 8001154:	4605      	mov	r5, r0
 8001156:	460c      	mov	r4, r1
  __HAL_LOCK(hadc);
 8001158:	f000 8188 	beq.w	800146c <HAL_ADC_ConfigChannel+0x324>
 800115c:	2301      	movs	r3, #1
 800115e:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
  /* Parameters update conditioned to ADC state:                              */
  /* Parameters that can be updated when ADC is disabled or enabled without   */
  /* conversion on going on regular group:                                    */
  /*  - Channel number                                                        */
  /*  - Channel rank                                                          */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8001162:	6800      	ldr	r0, [r0, #0]
  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART));
 8001164:	6882      	ldr	r2, [r0, #8]
 8001166:	0751      	lsls	r1, r2, #29
 8001168:	f100 817a 	bmi.w	8001460 <HAL_ADC_ConfigChannel+0x318>
    /* Correspondance for compatibility with legacy definition of             */
    /* sequencer ranks in direct number format. This correspondance can       */
    /* be done only on ranks 1 to 5 due to literal values.                    */
    /* Note: Sequencer ranks in direct number format are no more used         */
    /*       and are detected by activating USE_FULL_ASSERT feature.          */
    if (sConfig->Rank <= 5U)
 800116c:	6863      	ldr	r3, [r4, #4]
 800116e:	2b05      	cmp	r3, #5
 8001170:	d808      	bhi.n	8001184 <HAL_ADC_ConfigChannel+0x3c>
    {
      switch (sConfig->Rank)
 8001172:	3b02      	subs	r3, #2
 8001174:	2b03      	cmp	r3, #3
 8001176:	d86e      	bhi.n	8001256 <HAL_ADC_ConfigChannel+0x10e>
 8001178:	e8df f003 	tbb	[pc, r3]
 800117c:	6a686602 	.word	0x6a686602
      {
        case 2U: sConfig->Rank = ADC_REGULAR_RANK_2; break;
 8001180:	230c      	movs	r3, #12
        case 3U: sConfig->Rank = ADC_REGULAR_RANK_3; break;
        case 4U: sConfig->Rank = ADC_REGULAR_RANK_4; break;
        case 5U: sConfig->Rank = ADC_REGULAR_RANK_5; break;
        /* case 1U */
        default: sConfig->Rank = ADC_REGULAR_RANK_1;
 8001182:	6063      	str	r3, [r4, #4]
      }
    }
    #endif
    
    /* Set ADC group regular sequence: channel on the selected scan sequence rank */
    LL_ADC_REG_SetSequencerRanks(hadc->Instance, sConfig->Rank, sConfig->Channel);
 8001184:	6861      	ldr	r1, [r4, #4]
 8001186:	f44f 7340 	mov.w	r3, #768	; 0x300
 800118a:	fa93 f3a3 	rbit	r3, r3
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->SQR1, __ADC_MASK_SHIFT(Rank, ADC_REG_SQRX_REGOFFSET_MASK));
 800118e:	fab3 f383 	clz	r3, r3
 8001192:	f401 7640 	and.w	r6, r1, #768	; 0x300
 8001196:	40de      	lsrs	r6, r3
 8001198:	f100 0730 	add.w	r7, r0, #48	; 0x30
  MODIFY_REG(*preg,
 800119c:	f001 011f 	and.w	r1, r1, #31
 80011a0:	231f      	movs	r3, #31
 80011a2:	fa03 f201 	lsl.w	r2, r3, r1
 80011a6:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
 80011aa:	ea23 0302 	bic.w	r3, r3, r2
 80011ae:	6822      	ldr	r2, [r4, #0]
 80011b0:	f3c2 6284 	ubfx	r2, r2, #26, #5
 80011b4:	408a      	lsls	r2, r1
 80011b6:	4313      	orrs	r3, r2
 80011b8:	f847 3026 	str.w	r3, [r7, r6, lsl #2]
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated when ADC is disabled or enabled without   */
    /* conversion on going on regular group:                                    */
    /*  - Channel sampling time                                                 */
    /*  - Channel offset                                                        */
    if (ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(hadc) == RESET)
 80011bc:	6882      	ldr	r2, [r0, #8]
 80011be:	f012 020c 	ands.w	r2, r2, #12
 80011c2:	d126      	bne.n	8001212 <HAL_ADC_ConfigChannel+0xca>
    {
#if defined(ADC_SMPR1_SMPPLUS)
      /* Manage specific case of sampling time 3.5 cycles replacing 2.5 cyles */
      if(sConfig->SamplingTime == ADC_SAMPLETIME_3CYCLES_5)
 80011c4:	68a3      	ldr	r3, [r4, #8]
 80011c6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80011ca:	d146      	bne.n	800125a <HAL_ADC_ConfigChannel+0x112>
      {
        /* Set sampling time of the selected ADC channel */
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, LL_ADC_SAMPLINGTIME_2CYCLES_5);
 80011cc:	6821      	ldr	r1, [r4, #0]
 80011ce:	f7ff fe73 	bl	8000eb8 <LL_ADC_SetChannelSamplingTime>
        
        /* Set ADC sampling time common configuration */
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_3C5_REPL_2C5);
 80011d2:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 80011d4:	6953      	ldr	r3, [r2, #20]
 80011d6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80011da:	6153      	str	r3, [r2, #20]

      /* Shift the offset with respect to the selected ADC resolution. */
      /* Offset has to be left-aligned on bit 11, the LSB (right bits) are set to 0 */
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfig->Offset);
     
      if(sConfig->OffsetNumber != ADC_OFFSET_NONE)
 80011dc:	6926      	ldr	r6, [r4, #16]
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfig->Offset);
 80011de:	f8d5 e000 	ldr.w	lr, [r5]
 80011e2:	6823      	ldr	r3, [r4, #0]
 80011e4:	f8de 100c 	ldr.w	r1, [lr, #12]
      if(sConfig->OffsetNumber != ADC_OFFSET_NONE)
 80011e8:	2e04      	cmp	r6, #4
 80011ea:	f10e 0260 	add.w	r2, lr, #96	; 0x60
 80011ee:	d03d      	beq.n	800126c <HAL_ADC_ConfigChannel+0x124>
      tmpOffsetShifted = ADC_OFFSET_SHIFT_RESOLUTION(hadc, sConfig->Offset);
 80011f0:	f3c1 01c1 	ubfx	r1, r1, #3, #2
 80011f4:	0048      	lsls	r0, r1, #1
 80011f6:	6961      	ldr	r1, [r4, #20]
  MODIFY_REG(*preg,
 80011f8:	f003 43f8 	and.w	r3, r3, #2080374784	; 0x7c000000
 80011fc:	4081      	lsls	r1, r0
 80011fe:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001202:	4319      	orrs	r1, r3
 8001204:	f852 0026 	ldr.w	r0, [r2, r6, lsl #2]
 8001208:	4bbd      	ldr	r3, [pc, #756]	; (8001500 <HAL_ADC_ConfigChannel+0x3b8>)
 800120a:	4003      	ands	r3, r0
 800120c:	4319      	orrs	r1, r3
 800120e:	f842 1026 	str.w	r1, [r2, r6, lsl #2]
    }
    
    /* Parameters update conditioned to ADC state:                              */
    /* Parameters that can be updated only when ADC is disabled:                */
    /*  - Single or differential mode                                           */
    if (ADC_IS_ENABLE(hadc) == RESET)
 8001212:	6828      	ldr	r0, [r5, #0]
 8001214:	6883      	ldr	r3, [r0, #8]
 8001216:	f003 0303 	and.w	r3, r3, #3
 800121a:	2b01      	cmp	r3, #1
 800121c:	f040 8128 	bne.w	8001470 <HAL_ADC_ConfigChannel+0x328>
 8001220:	6803      	ldr	r3, [r0, #0]
 8001222:	07da      	lsls	r2, r3, #31
 8001224:	f140 8124 	bpl.w	8001470 <HAL_ADC_ConfigChannel+0x328>
    /* HAL_ADC_DeInit().                                                      */
       
    /* Configuration of common ADC parameters                                 */
    /* If the requested internal measurement path has already been enabled,   */
    /* bypass the configuration processing.                                   */
    if (( (sConfig->Channel == ADC_CHANNEL_TEMPSENSOR) &&
 8001228:	6823      	ldr	r3, [r4, #0]
 800122a:	4ab6      	ldr	r2, [pc, #728]	; (8001504 <HAL_ADC_ConfigChannel+0x3bc>)
 800122c:	4293      	cmp	r3, r2
 800122e:	f040 80c7 	bne.w	80013c0 <HAL_ADC_ConfigChannel+0x278>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001232:	4ab5      	ldr	r2, [pc, #724]	; (8001508 <HAL_ADC_ConfigChannel+0x3c0>)
 8001234:	6893      	ldr	r3, [r2, #8]
 8001236:	021b      	lsls	r3, r3, #8
 8001238:	f140 80f4 	bpl.w	8001424 <HAL_ADC_ConfigChannel+0x2dc>
  HAL_StatusTypeDef tmp_hal_status = HAL_OK;
 800123c:	2000      	movs	r0, #0
    
    tmp_hal_status = HAL_ERROR;
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 800123e:	2300      	movs	r3, #0
 8001240:	f885 3058 	strb.w	r3, [r5, #88]	; 0x58
  
  /* Return function status */
  return tmp_hal_status;
}
 8001244:	b003      	add	sp, #12
 8001246:	bdf0      	pop	{r4, r5, r6, r7, pc}
        case 3U: sConfig->Rank = ADC_REGULAR_RANK_3; break;
 8001248:	2312      	movs	r3, #18
 800124a:	e79a      	b.n	8001182 <HAL_ADC_ConfigChannel+0x3a>
        case 4U: sConfig->Rank = ADC_REGULAR_RANK_4; break;
 800124c:	2318      	movs	r3, #24
 800124e:	e798      	b.n	8001182 <HAL_ADC_ConfigChannel+0x3a>
        case 5U: sConfig->Rank = ADC_REGULAR_RANK_5; break;
 8001250:	f44f 7380 	mov.w	r3, #256	; 0x100
 8001254:	e795      	b.n	8001182 <HAL_ADC_ConfigChannel+0x3a>
        default: sConfig->Rank = ADC_REGULAR_RANK_1;
 8001256:	2306      	movs	r3, #6
 8001258:	e793      	b.n	8001182 <HAL_ADC_ConfigChannel+0x3a>
        LL_ADC_SetChannelSamplingTime(hadc->Instance, sConfig->Channel, sConfig->SamplingTime);
 800125a:	461a      	mov	r2, r3
 800125c:	6821      	ldr	r1, [r4, #0]
 800125e:	f7ff fe2b 	bl	8000eb8 <LL_ADC_SetChannelSamplingTime>
        LL_ADC_SetSamplingTimeCommonConfig(hadc->Instance, LL_ADC_SAMPLINGTIME_COMMON_DEFAULT);
 8001262:	682a      	ldr	r2, [r5, #0]
  MODIFY_REG(ADCx->SMPR1, ADC_SMPR1_SMPPLUS, SamplingTimeCommonConfig);
 8001264:	6953      	ldr	r3, [r2, #20]
 8001266:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 800126a:	e7b6      	b.n	80011da <HAL_ADC_ConfigChannel+0x92>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 800126c:	f8de 1060 	ldr.w	r1, [lr, #96]	; 0x60
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001270:	f3c3 0012 	ubfx	r0, r3, #0, #19
 8001274:	f3c1 6784 	ubfx	r7, r1, #26, #5
 8001278:	f10e 0664 	add.w	r6, lr, #100	; 0x64
 800127c:	2800      	cmp	r0, #0
 800127e:	d13a      	bne.n	80012f6 <HAL_ADC_ConfigChannel+0x1ae>
 8001280:	f3c3 6084 	ubfx	r0, r3, #26, #5
 8001284:	4287      	cmp	r7, r0
 8001286:	f040 8127 	bne.w	80014d8 <HAL_ADC_ConfigChannel+0x390>
  MODIFY_REG(*preg,
 800128a:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 800128e:	f8ce 1060 	str.w	r1, [lr, #96]	; 0x60
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001292:	6823      	ldr	r3, [r4, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001294:	f8de 1064 	ldr.w	r1, [lr, #100]	; 0x64
 8001298:	f3c3 0712 	ubfx	r7, r3, #0, #19
 800129c:	f3c1 6084 	ubfx	r0, r1, #26, #5
 80012a0:	bb9f      	cbnz	r7, 800130a <HAL_ADC_ConfigChannel+0x1c2>
 80012a2:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80012a6:	4283      	cmp	r3, r0
 80012a8:	f040 811b 	bne.w	80014e2 <HAL_ADC_ConfigChannel+0x39a>
  MODIFY_REG(*preg,
 80012ac:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80012b0:	6031      	str	r1, [r6, #0]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80012b2:	6823      	ldr	r3, [r4, #0]
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80012b4:	6891      	ldr	r1, [r2, #8]
 80012b6:	f3c3 0712 	ubfx	r7, r3, #0, #19
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80012ba:	f102 0608 	add.w	r6, r2, #8
 80012be:	f3c1 6084 	ubfx	r0, r1, #26, #5
 80012c2:	bb77      	cbnz	r7, 8001322 <HAL_ADC_ConfigChannel+0x1da>
 80012c4:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80012c8:	4283      	cmp	r3, r0
 80012ca:	f040 8111 	bne.w	80014f0 <HAL_ADC_ConfigChannel+0x3a8>
  MODIFY_REG(*preg,
 80012ce:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80012d2:	6031      	str	r1, [r6, #0]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80012d4:	6823      	ldr	r3, [r4, #0]
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80012d6:	f102 000c 	add.w	r0, r2, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80012da:	68d2      	ldr	r2, [r2, #12]
 80012dc:	f3c3 0612 	ubfx	r6, r3, #0, #19
 80012e0:	f3c2 6184 	ubfx	r1, r2, #26, #5
 80012e4:	bb4e      	cbnz	r6, 800133a <HAL_ADC_ConfigChannel+0x1f2>
 80012e6:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80012ea:	428b      	cmp	r3, r1
  MODIFY_REG(*preg,
 80012ec:	bf04      	itt	eq
 80012ee:	f022 4200 	biceq.w	r2, r2, #2147483648	; 0x80000000
 80012f2:	6002      	streq	r2, [r0, #0]
 80012f4:	e78d      	b.n	8001212 <HAL_ADC_ConfigChannel+0xca>
 80012f6:	fa93 f0a3 	rbit	r0, r3
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_1)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80012fa:	fab0 f080 	clz	r0, r0
 80012fe:	4287      	cmp	r7, r0
 8001300:	d0c3      	beq.n	800128a <HAL_ADC_ConfigChannel+0x142>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001302:	f8de 1064 	ldr.w	r1, [lr, #100]	; 0x64
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001306:	f3c1 6084 	ubfx	r0, r1, #26, #5
 800130a:	fa93 f3a3 	rbit	r3, r3
 800130e:	fab3 f383 	clz	r3, r3
 8001312:	4283      	cmp	r3, r0
 8001314:	d0ca      	beq.n	80012ac <HAL_ADC_ConfigChannel+0x164>
 8001316:	6891      	ldr	r1, [r2, #8]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001318:	6823      	ldr	r3, [r4, #0]
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 800131a:	f102 0608 	add.w	r6, r2, #8
 800131e:	f3c1 6084 	ubfx	r0, r1, #26, #5
 8001322:	fa93 f3a3 	rbit	r3, r3
 8001326:	fab3 f383 	clz	r3, r3
 800132a:	4283      	cmp	r3, r0
 800132c:	d0cf      	beq.n	80012ce <HAL_ADC_ConfigChannel+0x186>
 800132e:	f102 000c 	add.w	r0, r2, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 8001332:	68d2      	ldr	r2, [r2, #12]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 8001334:	6823      	ldr	r3, [r4, #0]
 8001336:	f3c2 6184 	ubfx	r1, r2, #26, #5
 800133a:	fa93 f3a3 	rbit	r3, r3
 800133e:	fab3 f383 	clz	r3, r3
 8001342:	e7d2      	b.n	80012ea <HAL_ADC_ConfigChannel+0x1a2>
 8001344:	fa93 f2a3 	rbit	r2, r3
        LL_ADC_SetChannelSamplingTime(hadc->Instance, __LL_ADC_DECIMAL_NB_TO_CHANNEL(__LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel) + 1), sConfig->SamplingTime);
 8001348:	fab2 f282 	clz	r2, r2
 800134c:	3201      	adds	r2, #1
 800134e:	2a09      	cmp	r2, #9
 8001350:	d90d      	bls.n	800136e <HAL_ADC_ConfigChannel+0x226>
 8001352:	fa93 f2a3 	rbit	r2, r3
 8001356:	fab2 f282 	clz	r2, r2
 800135a:	3201      	adds	r2, #1
 800135c:	0696      	lsls	r6, r2, #26
 800135e:	fa93 f1a3 	rbit	r1, r3
 8001362:	fab1 f181 	clz	r1, r1
 8001366:	1c4a      	adds	r2, r1, #1
 8001368:	2101      	movs	r1, #1
 800136a:	4091      	lsls	r1, r2
 800136c:	e016      	b.n	800139c <HAL_ADC_ConfigChannel+0x254>
 800136e:	fa93 f2a3 	rbit	r2, r3
 8001372:	fab2 f282 	clz	r2, r2
 8001376:	3201      	adds	r2, #1
 8001378:	0692      	lsls	r2, r2, #26
 800137a:	fa93 f1a3 	rbit	r1, r3
 800137e:	fab1 f181 	clz	r1, r1
 8001382:	1c4e      	adds	r6, r1, #1
 8001384:	2101      	movs	r1, #1
 8001386:	40b1      	lsls	r1, r6
 8001388:	e097      	b.n	80014ba <HAL_ADC_ConfigChannel+0x372>
 800138a:	fa93 f1a3 	rbit	r1, r3
 800138e:	fab1 f181 	clz	r1, r1
 8001392:	3101      	adds	r1, #1
 8001394:	e098      	b.n	80014c8 <HAL_ADC_ConfigChannel+0x380>
 8001396:	4616      	mov	r6, r2
 8001398:	fa01 f10e 	lsl.w	r1, r1, lr
 800139c:	ea41 0206 	orr.w	r2, r1, r6
 80013a0:	b94f      	cbnz	r7, 80013b6 <HAL_ADC_ConfigChannel+0x26e>
 80013a2:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80013a6:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80013aa:	f1a3 011b 	sub.w	r1, r3, #27
 80013ae:	0509      	lsls	r1, r1, #20
 80013b0:	f041 7100 	orr.w	r1, r1, #33554432	; 0x2000000
 80013b4:	e08b      	b.n	80014ce <HAL_ADC_ConfigChannel+0x386>
 80013b6:	fa93 f3a3 	rbit	r3, r3
 80013ba:	fab3 f383 	clz	r3, r3
 80013be:	e7f2      	b.n	80013a6 <HAL_ADC_ConfigChannel+0x25e>
          ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_TEMPSENSOR) == 0U)) ||
 80013c0:	4a52      	ldr	r2, [pc, #328]	; (800150c <HAL_ADC_ConfigChannel+0x3c4>)
 80013c2:	4293      	cmp	r3, r2
 80013c4:	d115      	bne.n	80013f2 <HAL_ADC_ConfigChannel+0x2aa>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80013c6:	4a50      	ldr	r2, [pc, #320]	; (8001508 <HAL_ADC_ConfigChannel+0x3c0>)
 80013c8:	6890      	ldr	r0, [r2, #8]
        ( (sConfig->Channel == ADC_CHANNEL_VBAT)       &&
 80013ca:	f010 7080 	ands.w	r0, r0, #16777216	; 0x1000000
 80013ce:	f47f af35 	bne.w	800123c <HAL_ADC_ConfigChannel+0xf4>
        if (ADC_BATTERY_VOLTAGE_INSTANCE(hadc))
 80013d2:	6829      	ldr	r1, [r5, #0]
 80013d4:	4b4e      	ldr	r3, [pc, #312]	; (8001510 <HAL_ADC_ConfigChannel+0x3c8>)
 80013d6:	4299      	cmp	r1, r3
 80013d8:	f47f af30 	bne.w	800123c <HAL_ADC_ConfigChannel+0xf4>
 80013dc:	6891      	ldr	r1, [r2, #8]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80013de:	6893      	ldr	r3, [r2, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80013e0:	f001 71e0 	and.w	r1, r1, #29360128	; 0x1c00000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 80013e4:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 80013e8:	430b      	orrs	r3, r1
 80013ea:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80013ee:	6093      	str	r3, [r2, #8]
 80013f0:	e725      	b.n	800123e <HAL_ADC_ConfigChannel+0xf6>
          ((LL_ADC_GetCommonPathInternalCh(__LL_ADC_COMMON_INSTANCE(hadc->Instance)) & LL_ADC_PATH_INTERNAL_VBAT) == 0U))       ||
 80013f2:	4a48      	ldr	r2, [pc, #288]	; (8001514 <HAL_ADC_ConfigChannel+0x3cc>)
 80013f4:	4293      	cmp	r3, r2
 80013f6:	f47f af21 	bne.w	800123c <HAL_ADC_ConfigChannel+0xf4>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 80013fa:	4a43      	ldr	r2, [pc, #268]	; (8001508 <HAL_ADC_ConfigChannel+0x3c0>)
 80013fc:	6890      	ldr	r0, [r2, #8]
        ( (sConfig->Channel == ADC_CHANNEL_VREFINT)    &&
 80013fe:	f410 0080 	ands.w	r0, r0, #4194304	; 0x400000
 8001402:	f47f af1b 	bne.w	800123c <HAL_ADC_ConfigChannel+0xf4>
        if (ADC_VREFINT_INSTANCE(hadc))
 8001406:	6829      	ldr	r1, [r5, #0]
 8001408:	4b41      	ldr	r3, [pc, #260]	; (8001510 <HAL_ADC_ConfigChannel+0x3c8>)
 800140a:	4299      	cmp	r1, r3
 800140c:	f47f af16 	bne.w	800123c <HAL_ADC_ConfigChannel+0xf4>
 8001410:	6891      	ldr	r1, [r2, #8]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8001412:	6893      	ldr	r3, [r2, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001414:	f001 71e0 	and.w	r1, r1, #29360128	; 0x1c00000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8001418:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 800141c:	430b      	orrs	r3, r1
 800141e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001422:	e7e4      	b.n	80013ee <HAL_ADC_ConfigChannel+0x2a6>
        if (ADC_TEMPERATURE_SENSOR_INSTANCE(hadc)) 
 8001424:	6829      	ldr	r1, [r5, #0]
 8001426:	4b3a      	ldr	r3, [pc, #232]	; (8001510 <HAL_ADC_ConfigChannel+0x3c8>)
 8001428:	4299      	cmp	r1, r3
 800142a:	f47f af07 	bne.w	800123c <HAL_ADC_ConfigChannel+0xf4>
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 800142e:	6891      	ldr	r1, [r2, #8]
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8001430:	6893      	ldr	r3, [r2, #8]
  return (uint32_t)(READ_BIT(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN));
 8001432:	f001 71e0 	and.w	r1, r1, #29360128	; 0x1c00000
  MODIFY_REG(ADCxy_COMMON->CCR, ADC_CCR_VREFEN | ADC_CCR_TSEN | ADC_CCR_VBATEN, PathInternal);
 8001436:	f023 73e0 	bic.w	r3, r3, #29360128	; 0x1c00000
 800143a:	430b      	orrs	r3, r1
 800143c:	f443 0300 	orr.w	r3, r3, #8388608	; 0x800000
 8001440:	6093      	str	r3, [r2, #8]
          wait_loop_index = (LL_ADC_DELAY_TEMPSENSOR_STAB_US * (SystemCoreClock / (1000000 * 2)));
 8001442:	4b35      	ldr	r3, [pc, #212]	; (8001518 <HAL_ADC_ConfigChannel+0x3d0>)
 8001444:	4a35      	ldr	r2, [pc, #212]	; (800151c <HAL_ADC_ConfigChannel+0x3d4>)
 8001446:	681b      	ldr	r3, [r3, #0]
 8001448:	fbb3 f2f2 	udiv	r2, r3, r2
 800144c:	2378      	movs	r3, #120	; 0x78
 800144e:	4353      	muls	r3, r2
            wait_loop_index--;
 8001450:	9301      	str	r3, [sp, #4]
          while(wait_loop_index != 0)
 8001452:	9b01      	ldr	r3, [sp, #4]
 8001454:	2b00      	cmp	r3, #0
 8001456:	f43f aef1 	beq.w	800123c <HAL_ADC_ConfigChannel+0xf4>
            wait_loop_index--;
 800145a:	9b01      	ldr	r3, [sp, #4]
 800145c:	3b01      	subs	r3, #1
 800145e:	e7f7      	b.n	8001450 <HAL_ADC_ConfigChannel+0x308>
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_CONFIG);
 8001460:	6dea      	ldr	r2, [r5, #92]	; 0x5c
 8001462:	f042 0220 	orr.w	r2, r2, #32
 8001466:	65ea      	str	r2, [r5, #92]	; 0x5c
    tmp_hal_status = HAL_ERROR;
 8001468:	4618      	mov	r0, r3
 800146a:	e6e8      	b.n	800123e <HAL_ADC_ConfigChannel+0xf6>
  __HAL_LOCK(hadc);
 800146c:	2002      	movs	r0, #2
 800146e:	e6e9      	b.n	8001244 <HAL_ADC_ConfigChannel+0xfc>
      LL_ADC_SetChannelSingleDiff(hadc->Instance, sConfig->Channel, sConfig->SingleDiff);
 8001470:	68e1      	ldr	r1, [r4, #12]
  MODIFY_REG(ADCx->DIFSEL,
 8001472:	4a2b      	ldr	r2, [pc, #172]	; (8001520 <HAL_ADC_ConfigChannel+0x3d8>)
 8001474:	f8d0 60b0 	ldr.w	r6, [r0, #176]	; 0xb0
 8001478:	6823      	ldr	r3, [r4, #0]
 800147a:	f001 0e20 	and.w	lr, r1, #32
 800147e:	fa02 f20e 	lsl.w	r2, r2, lr
 8001482:	f3c3 0712 	ubfx	r7, r3, #0, #19
 8001486:	4072      	eors	r2, r6
 8001488:	403a      	ands	r2, r7
 800148a:	4072      	eors	r2, r6
 800148c:	f8c0 20b0 	str.w	r2, [r0, #176]	; 0xb0
      if (sConfig->SingleDiff == ADC_DIFFERENTIAL_ENDED)
 8001490:	4a24      	ldr	r2, [pc, #144]	; (8001524 <HAL_ADC_ConfigChannel+0x3dc>)
 8001492:	4291      	cmp	r1, r2
 8001494:	f47f aec8 	bne.w	8001228 <HAL_ADC_ConfigChannel+0xe0>
        LL_ADC_SetChannelSamplingTime(hadc->Instance, __LL_ADC_DECIMAL_NB_TO_CHANNEL(__LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel) + 1), sConfig->SamplingTime);
 8001498:	2f00      	cmp	r7, #0
 800149a:	f47f af53 	bne.w	8001344 <HAL_ADC_ConfigChannel+0x1fc>
 800149e:	f3c3 6184 	ubfx	r1, r3, #26, #5
 80014a2:	f101 0e01 	add.w	lr, r1, #1
 80014a6:	f1be 0f09 	cmp.w	lr, #9
 80014aa:	f04f 0101 	mov.w	r1, #1
 80014ae:	ea4f 628e 	mov.w	r2, lr, lsl #26
 80014b2:	f63f af70 	bhi.w	8001396 <HAL_ADC_ConfigChannel+0x24e>
 80014b6:	fa01 f10e 	lsl.w	r1, r1, lr
 80014ba:	430a      	orrs	r2, r1
 80014bc:	2f00      	cmp	r7, #0
 80014be:	f47f af64 	bne.w	800138a <HAL_ADC_ConfigChannel+0x242>
 80014c2:	f3c3 6384 	ubfx	r3, r3, #26, #5
 80014c6:	1c59      	adds	r1, r3, #1
 80014c8:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 80014cc:	0509      	lsls	r1, r1, #20
 80014ce:	4311      	orrs	r1, r2
 80014d0:	68a2      	ldr	r2, [r4, #8]
 80014d2:	f7ff fcf1 	bl	8000eb8 <LL_ADC_SetChannelSamplingTime>
 80014d6:	e6a7      	b.n	8001228 <HAL_ADC_ConfigChannel+0xe0>
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80014d8:	f8de 1064 	ldr.w	r1, [lr, #100]	; 0x64
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_2)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80014dc:	f3c1 6084 	ubfx	r0, r1, #26, #5
 80014e0:	e6df      	b.n	80012a2 <HAL_ADC_ConfigChannel+0x15a>
 80014e2:	6891      	ldr	r1, [r2, #8]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_3)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80014e4:	6823      	ldr	r3, [r4, #0]
  register uint32_t *preg = __ADC_PTR_REG_OFFSET(ADCx->OFR1, Offsety);
 80014e6:	f102 0608 	add.w	r6, r2, #8
 80014ea:	f3c1 6084 	ubfx	r0, r1, #26, #5
 80014ee:	e6e9      	b.n	80012c4 <HAL_ADC_ConfigChannel+0x17c>
 80014f0:	f102 000c 	add.w	r0, r2, #12
  return (uint32_t) READ_BIT(*preg, ADC_OFR1_OFFSET1_CH);
 80014f4:	68d2      	ldr	r2, [r2, #12]
        if(__LL_ADC_CHANNEL_TO_DECIMAL_NB(LL_ADC_GetOffsetChannel(hadc->Instance, LL_ADC_OFFSET_4)) == __LL_ADC_CHANNEL_TO_DECIMAL_NB(sConfig->Channel))
 80014f6:	6823      	ldr	r3, [r4, #0]
 80014f8:	f3c2 6184 	ubfx	r1, r2, #26, #5
 80014fc:	e6f3      	b.n	80012e6 <HAL_ADC_ConfigChannel+0x19e>
 80014fe:	bf00      	nop
 8001500:	03fff000 	.word	0x03fff000
 8001504:	c7520000 	.word	0xc7520000
 8001508:	50040300 	.word	0x50040300
 800150c:	cb840000 	.word	0xcb840000
 8001510:	50040000 	.word	0x50040000
 8001514:	80000001 	.word	0x80000001
 8001518:	20000024 	.word	0x20000024
 800151c:	001e8480 	.word	0x001e8480
 8001520:	0007ffff 	.word	0x0007ffff
 8001524:	407f0000 	.word	0x407f0000

08001528 <HAL_ADC_GetState>:
{
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  
  /* Return ADC handle state */
  return hadc->State;
 8001528:	6dc0      	ldr	r0, [r0, #92]	; 0x5c
}
 800152a:	4770      	bx	lr

0800152c <ADC_ConversionStop>:
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_CONVERSION_GROUP(ConversionGroup));
    
  /* Verification if ADC is not already stopped (on regular and injected      */
  /* groups) to bypass this function if not needed.                           */
  if (ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(hadc))
 800152c:	6803      	ldr	r3, [r0, #0]
 800152e:	689a      	ldr	r2, [r3, #8]
 8001530:	f012 0f0c 	tst.w	r2, #12
{
 8001534:	b570      	push	{r4, r5, r6, lr}
 8001536:	4604      	mov	r4, r0
  if (ADC_IS_CONVERSION_ONGOING_REGULAR_INJECTED(hadc))
 8001538:	d101      	bne.n	800153e <ADC_ConversionStop+0x12>
    }
    
  }
  
  /* Return HAL status */
  return HAL_OK;
 800153a:	2000      	movs	r0, #0
 800153c:	bd70      	pop	{r4, r5, r6, pc}
    if ((HAL_IS_BIT_SET(hadc->Instance->CFGR, ADC_CFGR_JAUTO)) 
 800153e:	68da      	ldr	r2, [r3, #12]
 8001540:	0190      	lsls	r0, r2, #6
 8001542:	d52a      	bpl.n	800159a <ADC_ConversionStop+0x6e>
         && (hadc->Init.ContinuousConvMode==ENABLE) 
 8001544:	69e2      	ldr	r2, [r4, #28]
 8001546:	2a01      	cmp	r2, #1
 8001548:	d127      	bne.n	800159a <ADC_ConversionStop+0x6e>
         && (hadc->Init.LowPowerAutoWait==ENABLE))
 800154a:	69a2      	ldr	r2, [r4, #24]
 800154c:	2a01      	cmp	r2, #1
 800154e:	d124      	bne.n	800159a <ADC_ConversionStop+0x6e>
 8001550:	4a22      	ldr	r2, [pc, #136]	; (80015dc <ADC_ConversionStop+0xb0>)
      while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_JEOS) == RESET)
 8001552:	6819      	ldr	r1, [r3, #0]
 8001554:	0649      	lsls	r1, r1, #25
 8001556:	d514      	bpl.n	8001582 <ADC_ConversionStop+0x56>
      __HAL_ADC_CLEAR_FLAG(hadc, ADC_FLAG_JEOS);
 8001558:	2240      	movs	r2, #64	; 0x40
 800155a:	601a      	str	r2, [r3, #0]
      ConversionGroup = ADC_REGULAR_GROUP;
 800155c:	2101      	movs	r1, #1
      if (HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADSTART) && 
 800155e:	689a      	ldr	r2, [r3, #8]
 8001560:	0756      	lsls	r6, r2, #29
 8001562:	d50a      	bpl.n	800157a <ADC_ConversionStop+0x4e>
          HAL_IS_BIT_CLR(hadc->Instance->CR, ADC_CR_ADDIS)     )
 8001564:	689a      	ldr	r2, [r3, #8]
      if (HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADSTART) && 
 8001566:	0795      	lsls	r5, r2, #30
 8001568:	d407      	bmi.n	800157a <ADC_ConversionStop+0x4e>
  MODIFY_REG(ADCx->CR,
 800156a:	689a      	ldr	r2, [r3, #8]
 800156c:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
 8001570:	f022 023f 	bic.w	r2, r2, #63	; 0x3f
 8001574:	f042 0210 	orr.w	r2, r2, #16
 8001578:	609a      	str	r2, [r3, #8]
    if (ConversionGroup != ADC_REGULAR_GROUP)
 800157a:	2901      	cmp	r1, #1
 800157c:	d10f      	bne.n	800159e <ADC_ConversionStop+0x72>
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_ADSTART;
 800157e:	2504      	movs	r5, #4
        break;
 8001580:	e01e      	b.n	80015c0 <ADC_ConversionStop+0x94>
        if (Conversion_Timeout_CPU_cycles >= (ADC_CONVERSION_TIME_MAX_CPU_CYCLES *4))
 8001582:	3a01      	subs	r2, #1
 8001584:	d1e5      	bne.n	8001552 <ADC_ConversionStop+0x26>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001586:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8001588:	f043 0310 	orr.w	r3, r3, #16
 800158c:	65e3      	str	r3, [r4, #92]	; 0x5c
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 800158e:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001590:	f043 0301 	orr.w	r3, r3, #1
 8001594:	6623      	str	r3, [r4, #96]	; 0x60
        return HAL_ERROR;
 8001596:	2001      	movs	r0, #1
 8001598:	bd70      	pop	{r4, r5, r6, pc}
    if (ConversionGroup != ADC_INJECTED_GROUP)
 800159a:	2902      	cmp	r1, #2
 800159c:	d1df      	bne.n	800155e <ADC_ConversionStop+0x32>
      if (HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_JADSTART) && 
 800159e:	689a      	ldr	r2, [r3, #8]
 80015a0:	0710      	lsls	r0, r2, #28
 80015a2:	d506      	bpl.n	80015b2 <ADC_ConversionStop+0x86>
          HAL_IS_BIT_CLR(hadc->Instance->CR, ADC_CR_ADDIS)      )
 80015a4:	689a      	ldr	r2, [r3, #8]
      if (HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_JADSTART) && 
 80015a6:	0792      	lsls	r2, r2, #30
        SET_BIT(hadc->Instance->CR, ADC_CR_JADSTP);
 80015a8:	bf5e      	ittt	pl
 80015aa:	689a      	ldrpl	r2, [r3, #8]
 80015ac:	f042 0220 	orrpl.w	r2, r2, #32
 80015b0:	609a      	strpl	r2, [r3, #8]
    switch(ConversionGroup)
 80015b2:	2902      	cmp	r1, #2
 80015b4:	d003      	beq.n	80015be <ADC_ConversionStop+0x92>
 80015b6:	2903      	cmp	r1, #3
 80015b8:	d1e1      	bne.n	800157e <ADC_ConversionStop+0x52>
        tmp_ADC_CR_ADSTART_JADSTART = (ADC_CR_ADSTART | ADC_CR_JADSTART);
 80015ba:	250c      	movs	r5, #12
 80015bc:	e000      	b.n	80015c0 <ADC_ConversionStop+0x94>
        tmp_ADC_CR_ADSTART_JADSTART = ADC_CR_JADSTART;
 80015be:	2508      	movs	r5, #8
    tickstart = HAL_GetTick();
 80015c0:	f7ff fc66 	bl	8000e90 <HAL_GetTick>
 80015c4:	4606      	mov	r6, r0
    while((hadc->Instance->CR & tmp_ADC_CR_ADSTART_JADSTART) != RESET)
 80015c6:	6823      	ldr	r3, [r4, #0]
 80015c8:	689b      	ldr	r3, [r3, #8]
 80015ca:	421d      	tst	r5, r3
 80015cc:	d0b5      	beq.n	800153a <ADC_ConversionStop+0xe>
      if((HAL_GetTick()-tickstart) > ADC_STOP_CONVERSION_TIMEOUT)
 80015ce:	f7ff fc5f 	bl	8000e90 <HAL_GetTick>
 80015d2:	1b80      	subs	r0, r0, r6
 80015d4:	2805      	cmp	r0, #5
 80015d6:	d9f6      	bls.n	80015c6 <ADC_ConversionStop+0x9a>
 80015d8:	e7d5      	b.n	8001586 <ADC_ConversionStop+0x5a>
 80015da:	bf00      	nop
 80015dc:	a3400001 	.word	0xa3400001

080015e0 <ADC_Enable>:
  *         and voltage regulator must be enabled (done into HAL_ADC_Init()).
  * @param hadc ADC handle
  * @retval HAL status.
  */
HAL_StatusTypeDef ADC_Enable(ADC_HandleTypeDef* hadc)
{
 80015e0:	b573      	push	{r0, r1, r4, r5, r6, lr}
  uint32_t tickstart = 0;
  __IO uint32_t wait_loop_index = 0;
 80015e2:	2300      	movs	r3, #0
  
  /* ADC enable and wait for ADC ready (in case of ADC is disabled or         */
  /* enabling phase not yet completed: flag ADC ready not yet set).           */
  /* Timeout implemented to not be stuck if ADC cannot be enabled (possible   */
  /* causes: ADC clock not running, ...).                                     */
  if (ADC_IS_ENABLE(hadc) == RESET)
 80015e4:	6802      	ldr	r2, [r0, #0]
  __IO uint32_t wait_loop_index = 0;
 80015e6:	9301      	str	r3, [sp, #4]
  if (ADC_IS_ENABLE(hadc) == RESET)
 80015e8:	6893      	ldr	r3, [r2, #8]
 80015ea:	f003 0303 	and.w	r3, r3, #3
 80015ee:	2b01      	cmp	r3, #1
{
 80015f0:	4604      	mov	r4, r0
  if (ADC_IS_ENABLE(hadc) == RESET)
 80015f2:	d108      	bne.n	8001606 <ADC_Enable+0x26>
 80015f4:	6813      	ldr	r3, [r2, #0]
 80015f6:	07d8      	lsls	r0, r3, #31
 80015f8:	d505      	bpl.n	8001606 <ADC_Enable+0x26>
      }
    }
  }
   
  /* Return HAL status */
  return HAL_OK;
 80015fa:	2000      	movs	r0, #0
}
 80015fc:	b002      	add	sp, #8
 80015fe:	bd70      	pop	{r4, r5, r6, pc}
      wait_loop_index--;
 8001600:	9b01      	ldr	r3, [sp, #4]
 8001602:	3b01      	subs	r3, #1
 8001604:	e012      	b.n	800162c <ADC_Enable+0x4c>
    if (ADC_ENABLING_CONDITIONS(hadc) == RESET)
 8001606:	6891      	ldr	r1, [r2, #8]
 8001608:	4b1a      	ldr	r3, [pc, #104]	; (8001674 <ADC_Enable+0x94>)
 800160a:	4219      	tst	r1, r3
 800160c:	d127      	bne.n	800165e <ADC_Enable+0x7e>
  MODIFY_REG(ADCx->CR,
 800160e:	6893      	ldr	r3, [r2, #8]
 8001610:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8001614:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8001618:	f043 0301 	orr.w	r3, r3, #1
 800161c:	6093      	str	r3, [r2, #8]
    wait_loop_index = (LL_ADC_DELAY_INTERNAL_REGUL_STAB_US * (SystemCoreClock / (1000000 * 2)));
 800161e:	4b16      	ldr	r3, [pc, #88]	; (8001678 <ADC_Enable+0x98>)
 8001620:	4a16      	ldr	r2, [pc, #88]	; (800167c <ADC_Enable+0x9c>)
 8001622:	681b      	ldr	r3, [r3, #0]
 8001624:	fbb3 f2f2 	udiv	r2, r3, r2
 8001628:	230a      	movs	r3, #10
 800162a:	4353      	muls	r3, r2
      wait_loop_index--;
 800162c:	9301      	str	r3, [sp, #4]
    while(wait_loop_index != 0)
 800162e:	9b01      	ldr	r3, [sp, #4]
 8001630:	2b00      	cmp	r3, #0
 8001632:	d1e5      	bne.n	8001600 <ADC_Enable+0x20>
    tickstart = HAL_GetTick();
 8001634:	f7ff fc2c 	bl	8000e90 <HAL_GetTick>
 8001638:	4e11      	ldr	r6, [pc, #68]	; (8001680 <ADC_Enable+0xa0>)
 800163a:	4605      	mov	r5, r0
    while(__HAL_ADC_GET_FLAG(hadc, ADC_FLAG_RDY) == RESET)
 800163c:	6822      	ldr	r2, [r4, #0]
 800163e:	6813      	ldr	r3, [r2, #0]
 8001640:	07db      	lsls	r3, r3, #31
 8001642:	d4da      	bmi.n	80015fa <ADC_Enable+0x1a>
  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADEN) == (ADC_CR_ADEN));
 8001644:	6893      	ldr	r3, [r2, #8]
      if(LL_ADC_IsEnabled(hadc->Instance) == 0)
 8001646:	07d9      	lsls	r1, r3, #31
  MODIFY_REG(ADCx->CR,
 8001648:	bf5f      	itttt	pl
 800164a:	6893      	ldrpl	r3, [r2, #8]
 800164c:	4033      	andpl	r3, r6
 800164e:	f043 0301 	orrpl.w	r3, r3, #1
 8001652:	6093      	strpl	r3, [r2, #8]
      if((HAL_GetTick() - tickstart) > ADC_ENABLE_TIMEOUT)
 8001654:	f7ff fc1c 	bl	8000e90 <HAL_GetTick>
 8001658:	1b40      	subs	r0, r0, r5
 800165a:	2802      	cmp	r0, #2
 800165c:	d9ee      	bls.n	800163c <ADC_Enable+0x5c>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800165e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8001660:	f043 0310 	orr.w	r3, r3, #16
 8001664:	65e3      	str	r3, [r4, #92]	; 0x5c
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001666:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001668:	f043 0301 	orr.w	r3, r3, #1
 800166c:	6623      	str	r3, [r4, #96]	; 0x60
        return HAL_ERROR;
 800166e:	2001      	movs	r0, #1
 8001670:	e7c4      	b.n	80015fc <ADC_Enable+0x1c>
 8001672:	bf00      	nop
 8001674:	8000003f 	.word	0x8000003f
 8001678:	20000024 	.word	0x20000024
 800167c:	001e8480 	.word	0x001e8480
 8001680:	7fffffc0 	.word	0x7fffffc0

08001684 <HAL_ADC_Start>:
{
 8001684:	b538      	push	{r3, r4, r5, lr}
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8001686:	6803      	ldr	r3, [r0, #0]
  return (uint32_t)(READ_BIT(ADCx->CR, ADC_CR_ADSTART) == (ADC_CR_ADSTART));
 8001688:	689d      	ldr	r5, [r3, #8]
 800168a:	f015 0504 	ands.w	r5, r5, #4
{
 800168e:	4604      	mov	r4, r0
  if (ADC_IS_CONVERSION_ONGOING_REGULAR(hadc) == RESET)
 8001690:	d13a      	bne.n	8001708 <HAL_ADC_Start+0x84>
    __HAL_LOCK(hadc);
 8001692:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
 8001696:	2b01      	cmp	r3, #1
 8001698:	d036      	beq.n	8001708 <HAL_ADC_Start+0x84>
 800169a:	2301      	movs	r3, #1
 800169c:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
    tmp_hal_status = ADC_Enable(hadc);
 80016a0:	f7ff ff9e 	bl	80015e0 <ADC_Enable>
    if (tmp_hal_status == HAL_OK)
 80016a4:	2800      	cmp	r0, #0
 80016a6:	d12c      	bne.n	8001702 <HAL_ADC_Start+0x7e>
      ADC_STATE_CLR_SET(hadc->State,
 80016a8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80016aa:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
 80016ae:	f023 0301 	bic.w	r3, r3, #1
 80016b2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80016b6:	65e3      	str	r3, [r4, #92]	; 0x5c
        CLEAR_BIT(hadc->State, HAL_ADC_STATE_MULTIMODE_SLAVE);
 80016b8:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80016ba:	f423 1380 	bic.w	r3, r3, #1048576	; 0x100000
 80016be:	65e3      	str	r3, [r4, #92]	; 0x5c
      if (HAL_IS_BIT_SET(hadc->State, HAL_ADC_STATE_INJ_BUSY))
 80016c0:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 80016c2:	04da      	lsls	r2, r3, #19
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 80016c4:	bf48      	it	mi
 80016c6:	6e23      	ldrmi	r3, [r4, #96]	; 0x60
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 80016c8:	6822      	ldr	r2, [r4, #0]
        ADC_CLEAR_ERRORCODE(hadc); 
 80016ca:	bf52      	itee	pl
 80016cc:	6620      	strpl	r0, [r4, #96]	; 0x60
        CLEAR_BIT(hadc->ErrorCode, (HAL_ADC_ERROR_OVR | HAL_ADC_ERROR_DMA));         
 80016ce:	f023 0306 	bicmi.w	r3, r3, #6
 80016d2:	6623      	strmi	r3, [r4, #96]	; 0x60
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOC | ADC_FLAG_EOS | ADC_FLAG_OVR));
 80016d4:	231c      	movs	r3, #28
 80016d6:	6013      	str	r3, [r2, #0]
      __HAL_UNLOCK(hadc);
 80016d8:	2300      	movs	r3, #0
 80016da:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
        if (READ_BIT(hadc->Instance->CFGR, ADC_CFGR_JAUTO) != RESET)
 80016de:	68d3      	ldr	r3, [r2, #12]
 80016e0:	019b      	lsls	r3, r3, #6
          ADC_STATE_CLR_SET(hadc->State, HAL_ADC_STATE_INJ_EOC, HAL_ADC_STATE_INJ_BUSY);  
 80016e2:	bf41      	itttt	mi
 80016e4:	6de3      	ldrmi	r3, [r4, #92]	; 0x5c
 80016e6:	f423 5340 	bicmi.w	r3, r3, #12288	; 0x3000
 80016ea:	f443 5380 	orrmi.w	r3, r3, #4096	; 0x1000
 80016ee:	65e3      	strmi	r3, [r4, #92]	; 0x5c
  MODIFY_REG(ADCx->CR,
 80016f0:	6893      	ldr	r3, [r2, #8]
 80016f2:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 80016f6:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80016fa:	f043 0304 	orr.w	r3, r3, #4
 80016fe:	6093      	str	r3, [r2, #8]
 8001700:	bd38      	pop	{r3, r4, r5, pc}
      __HAL_UNLOCK(hadc);
 8001702:	f884 5058 	strb.w	r5, [r4, #88]	; 0x58
 8001706:	bd38      	pop	{r3, r4, r5, pc}
    tmp_hal_status = HAL_BUSY;
 8001708:	2002      	movs	r0, #2
}
 800170a:	bd38      	pop	{r3, r4, r5, pc}

0800170c <ADC_Disable>:
  uint32_t tickstart = 0;
  
  /* Verification if ADC is not already disabled:                             */
  /* Note: forbidden to disable ADC (set bit ADC_CR_ADDIS) if ADC is already  */
  /*       disabled.                                                          */
  if (ADC_IS_ENABLE(hadc) != RESET)
 800170c:	6802      	ldr	r2, [r0, #0]
{
 800170e:	b538      	push	{r3, r4, r5, lr}
 8001710:	4604      	mov	r4, r0
  if (ADC_IS_ENABLE(hadc) != RESET)
 8001712:	6890      	ldr	r0, [r2, #8]
 8001714:	f000 0003 	and.w	r0, r0, #3
 8001718:	2801      	cmp	r0, #1
 800171a:	d001      	beq.n	8001720 <ADC_Disable+0x14>
      }
    }
  }
  
  /* Return HAL status */
  return HAL_OK;
 800171c:	2000      	movs	r0, #0
 800171e:	bd38      	pop	{r3, r4, r5, pc}
  if (ADC_IS_ENABLE(hadc) != RESET)
 8001720:	6813      	ldr	r3, [r2, #0]
 8001722:	07d9      	lsls	r1, r3, #31
 8001724:	d5fa      	bpl.n	800171c <ADC_Disable+0x10>
    if (ADC_DISABLING_CONDITIONS(hadc) != RESET)
 8001726:	6893      	ldr	r3, [r2, #8]
 8001728:	f003 030d 	and.w	r3, r3, #13
 800172c:	2b01      	cmp	r3, #1
 800172e:	d11f      	bne.n	8001770 <ADC_Disable+0x64>
  MODIFY_REG(ADCx->CR,
 8001730:	6893      	ldr	r3, [r2, #8]
 8001732:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8001736:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 800173a:	f043 0302 	orr.w	r3, r3, #2
 800173e:	6093      	str	r3, [r2, #8]
      __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_EOSMP | ADC_FLAG_RDY));
 8001740:	2303      	movs	r3, #3
 8001742:	6013      	str	r3, [r2, #0]
    tickstart = HAL_GetTick();
 8001744:	f7ff fba4 	bl	8000e90 <HAL_GetTick>
 8001748:	4605      	mov	r5, r0
    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADEN))
 800174a:	6823      	ldr	r3, [r4, #0]
 800174c:	689b      	ldr	r3, [r3, #8]
 800174e:	07db      	lsls	r3, r3, #31
 8001750:	d5e4      	bpl.n	800171c <ADC_Disable+0x10>
      if((HAL_GetTick() - tickstart) > ADC_DISABLE_TIMEOUT)
 8001752:	f7ff fb9d 	bl	8000e90 <HAL_GetTick>
 8001756:	1b40      	subs	r0, r0, r5
 8001758:	2802      	cmp	r0, #2
 800175a:	d9f6      	bls.n	800174a <ADC_Disable+0x3e>
        SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 800175c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800175e:	f043 0310 	orr.w	r3, r3, #16
 8001762:	65e3      	str	r3, [r4, #92]	; 0x5c
        SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001764:	6e23      	ldr	r3, [r4, #96]	; 0x60
 8001766:	f043 0301 	orr.w	r3, r3, #1
 800176a:	6623      	str	r3, [r4, #96]	; 0x60
        return HAL_ERROR;
 800176c:	2001      	movs	r0, #1
 800176e:	bd38      	pop	{r3, r4, r5, pc}
      SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001770:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 8001772:	f043 0310 	orr.w	r3, r3, #16
 8001776:	65e3      	str	r3, [r4, #92]	; 0x5c
      SET_BIT(hadc->ErrorCode, HAL_ADC_ERROR_INTERNAL);
 8001778:	6e23      	ldr	r3, [r4, #96]	; 0x60
 800177a:	f043 0301 	orr.w	r3, r3, #1
 800177e:	6623      	str	r3, [r4, #96]	; 0x60
      return HAL_ERROR;
 8001780:	bd38      	pop	{r3, r4, r5, pc}
	...

08001784 <HAL_ADC_DeInit>:
{
 8001784:	b510      	push	{r4, lr}
  if(hadc == NULL)
 8001786:	4604      	mov	r4, r0
 8001788:	2800      	cmp	r0, #0
 800178a:	f000 8085 	beq.w	8001898 <HAL_ADC_DeInit+0x114>
  SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
 800178e:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 8001790:	f043 0302 	orr.w	r3, r3, #2
  ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
 8001794:	2103      	movs	r1, #3
  SET_BIT(hadc->State, HAL_ADC_STATE_BUSY_INTERNAL);
 8001796:	65c3      	str	r3, [r0, #92]	; 0x5c
  ADC_ConversionStop(hadc, ADC_REGULAR_INJECTED_GROUP);
 8001798:	f7ff fec8 	bl	800152c <ADC_ConversionStop>
  SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JQM);
 800179c:	6822      	ldr	r2, [r4, #0]
 800179e:	68d3      	ldr	r3, [r2, #12]
 80017a0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80017a4:	60d3      	str	r3, [r2, #12]
  ADC_Disable(hadc);
 80017a6:	4620      	mov	r0, r4
 80017a8:	f7ff ffb0 	bl	800170c <ADC_Disable>
  __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 | ADC_IT_AWD1 |
 80017ac:	6823      	ldr	r3, [r4, #0]
 80017ae:	483f      	ldr	r0, [pc, #252]	; (80018ac <HAL_ADC_DeInit+0x128>)
 80017b0:	6859      	ldr	r1, [r3, #4]
  __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 | ADC_FLAG_AWD1 |
 80017b2:	f240 72ff 	movw	r2, #2047	; 0x7ff
  __HAL_ADC_DISABLE_IT(hadc, (ADC_IT_AWD3  | ADC_IT_AWD2 | ADC_IT_AWD1 |
 80017b6:	4001      	ands	r1, r0
 80017b8:	6059      	str	r1, [r3, #4]
  __HAL_ADC_CLEAR_FLAG(hadc, (ADC_FLAG_AWD3  | ADC_FLAG_AWD2 | ADC_FLAG_AWD1 |
 80017ba:	601a      	str	r2, [r3, #0]
  CLEAR_BIT(hadc->Instance->CR, ADC_CR_ADVREGEN | ADC_CR_ADCALDIF);
 80017bc:	6899      	ldr	r1, [r3, #8]
 80017be:	f021 41a0 	bic.w	r1, r1, #1342177280	; 0x50000000
 80017c2:	6099      	str	r1, [r3, #8]
  SET_BIT(hadc->Instance->CR, ADC_CR_DEEPPWD);    
 80017c4:	6899      	ldr	r1, [r3, #8]
 80017c6:	f041 5100 	orr.w	r1, r1, #536870912	; 0x20000000
 80017ca:	6099      	str	r1, [r3, #8]
  CLEAR_BIT(hadc->Instance->CFGR, ADC_CFGR_FIELDS);
 80017cc:	68d9      	ldr	r1, [r3, #12]
 80017ce:	f001 2180 	and.w	r1, r1, #2147516416	; 0x80008000
 80017d2:	60d9      	str	r1, [r3, #12]
  SET_BIT(hadc->Instance->CFGR, ADC_CFGR_JQDIS);  
 80017d4:	68d9      	ldr	r1, [r3, #12]
 80017d6:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 80017da:	60d9      	str	r1, [r3, #12]
  CLEAR_BIT(hadc->Instance->CFGR2, ADC_CFGR2_ROVSM  | ADC_CFGR2_TROVS   | ADC_CFGR2_OVSS |   
 80017dc:	691a      	ldr	r2, [r3, #16]
 80017de:	4002      	ands	r2, r0
 80017e0:	611a      	str	r2, [r3, #16]
  CLEAR_BIT(hadc->Instance->SMPR1, ADC_SMPR1_FIELDS);                                 
 80017e2:	695a      	ldr	r2, [r3, #20]
  CLEAR_BIT(hadc->Instance->SQR2, ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7 | 
 80017e4:	4832      	ldr	r0, [pc, #200]	; (80018b0 <HAL_ADC_DeInit+0x12c>)
  CLEAR_BIT(hadc->Instance->SMPR1, ADC_SMPR1_FIELDS);                                 
 80017e6:	f002 4280 	and.w	r2, r2, #1073741824	; 0x40000000
 80017ea:	615a      	str	r2, [r3, #20]
  CLEAR_BIT(hadc->Instance->SMPR2, ADC_SMPR2_SMP18 | ADC_SMPR2_SMP17 | ADC_SMPR2_SMP16 | 
 80017ec:	699a      	ldr	r2, [r3, #24]
 80017ee:	f002 4278 	and.w	r2, r2, #4160749568	; 0xf8000000
 80017f2:	619a      	str	r2, [r3, #24]
  CLEAR_BIT(hadc->Instance->TR1, ADC_TR1_HT1 | ADC_TR1_LT1);
 80017f4:	6a1a      	ldr	r2, [r3, #32]
 80017f6:	f002 22f0 	and.w	r2, r2, #4026593280	; 0xf000f000
 80017fa:	621a      	str	r2, [r3, #32]
  CLEAR_BIT(hadc->Instance->TR2, ADC_TR2_HT2 | ADC_TR2_LT2);    
 80017fc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80017fe:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
 8001802:	625a      	str	r2, [r3, #36]	; 0x24
  CLEAR_BIT(hadc->Instance->TR3, ADC_TR3_HT3 | ADC_TR3_LT3);      
 8001804:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8001806:	f002 22ff 	and.w	r2, r2, #4278255360	; 0xff00ff00
 800180a:	629a      	str	r2, [r3, #40]	; 0x28
  CLEAR_BIT(hadc->Instance->SQR1, ADC_SQR1_SQ4 | ADC_SQR1_SQ3 | ADC_SQR1_SQ2 | 
 800180c:	6b19      	ldr	r1, [r3, #48]	; 0x30
 800180e:	4a29      	ldr	r2, [pc, #164]	; (80018b4 <HAL_ADC_DeInit+0x130>)
 8001810:	400a      	ands	r2, r1
 8001812:	631a      	str	r2, [r3, #48]	; 0x30
  CLEAR_BIT(hadc->Instance->SQR2, ADC_SQR2_SQ9 | ADC_SQR2_SQ8 | ADC_SQR2_SQ7 | 
 8001814:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8001816:	4001      	ands	r1, r0
 8001818:	6359      	str	r1, [r3, #52]	; 0x34
  CLEAR_BIT(hadc->Instance->SQR3, ADC_SQR3_SQ14 | ADC_SQR3_SQ13 | ADC_SQR3_SQ12 | 
 800181a:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800181c:	4002      	ands	r2, r0
 800181e:	639a      	str	r2, [r3, #56]	; 0x38
  CLEAR_BIT(hadc->Instance->SQR4, ADC_SQR4_SQ16 | ADC_SQR4_SQ15); 
 8001820:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8001822:	f422 62fb 	bic.w	r2, r2, #2008	; 0x7d8
 8001826:	f022 0207 	bic.w	r2, r2, #7
 800182a:	63da      	str	r2, [r3, #60]	; 0x3c
  CLEAR_BIT(hadc->Instance->OFR1, ADC_OFR1_OFFSET1_EN | ADC_OFR1_OFFSET1_CH | ADC_OFR1_OFFSET1); 
 800182c:	6e19      	ldr	r1, [r3, #96]	; 0x60
 800182e:	4a22      	ldr	r2, [pc, #136]	; (80018b8 <HAL_ADC_DeInit+0x134>)
 8001830:	4011      	ands	r1, r2
 8001832:	6619      	str	r1, [r3, #96]	; 0x60
  CLEAR_BIT(hadc->Instance->OFR2, ADC_OFR2_OFFSET2_EN | ADC_OFR2_OFFSET2_CH | ADC_OFR2_OFFSET2); 
 8001834:	6e59      	ldr	r1, [r3, #100]	; 0x64
 8001836:	4011      	ands	r1, r2
 8001838:	6659      	str	r1, [r3, #100]	; 0x64
  CLEAR_BIT(hadc->Instance->OFR3, ADC_OFR3_OFFSET3_EN | ADC_OFR3_OFFSET3_CH | ADC_OFR3_OFFSET3); 
 800183a:	6e99      	ldr	r1, [r3, #104]	; 0x68
 800183c:	4011      	ands	r1, r2
 800183e:	6699      	str	r1, [r3, #104]	; 0x68
  CLEAR_BIT(hadc->Instance->OFR4, ADC_OFR4_OFFSET4_EN | ADC_OFR4_OFFSET4_CH | ADC_OFR4_OFFSET4);
 8001840:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8001842:	400a      	ands	r2, r1
 8001844:	66da      	str	r2, [r3, #108]	; 0x6c
  CLEAR_BIT(hadc->Instance->AWD2CR, ADC_AWD2CR_AWD2CH);
 8001846:	f8d3 20a0 	ldr.w	r2, [r3, #160]	; 0xa0
 800184a:	491c      	ldr	r1, [pc, #112]	; (80018bc <HAL_ADC_DeInit+0x138>)
 800184c:	400a      	ands	r2, r1
 800184e:	f8c3 20a0 	str.w	r2, [r3, #160]	; 0xa0
  CLEAR_BIT(hadc->Instance->AWD3CR, ADC_AWD3CR_AWD3CH);
 8001852:	f8d3 20a4 	ldr.w	r2, [r3, #164]	; 0xa4
 8001856:	400a      	ands	r2, r1
 8001858:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
  CLEAR_BIT(hadc->Instance->DIFSEL, ADC_DIFSEL_DIFSEL);
 800185c:	f8d3 20b0 	ldr.w	r2, [r3, #176]	; 0xb0
 8001860:	400a      	ands	r2, r1
 8001862:	f8c3 20b0 	str.w	r2, [r3, #176]	; 0xb0
  CLEAR_BIT(hadc->Instance->CALFACT, ADC_CALFACT_CALFACT_D | ADC_CALFACT_CALFACT_S);
 8001866:	f8d3 20b4 	ldr.w	r2, [r3, #180]	; 0xb4
 800186a:	f022 127f 	bic.w	r2, r2, #8323199	; 0x7f007f
 800186e:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
  if ((ADC_IS_ENABLE(hadc) == RESET)   &&
 8001872:	689a      	ldr	r2, [r3, #8]
 8001874:	f002 0203 	and.w	r2, r2, #3
 8001878:	2a01      	cmp	r2, #1
 800187a:	d10f      	bne.n	800189c <HAL_ADC_DeInit+0x118>
 800187c:	681b      	ldr	r3, [r3, #0]
 800187e:	07db      	lsls	r3, r3, #31
 8001880:	d50c      	bpl.n	800189c <HAL_ADC_DeInit+0x118>
  HAL_ADC_MspDeInit(hadc);
 8001882:	4620      	mov	r0, r4
 8001884:	f008 f822 	bl	80098cc <HAL_ADC_MspDeInit>
  ADC_CLEAR_ERRORCODE(hadc);
 8001888:	2000      	movs	r0, #0
 800188a:	6620      	str	r0, [r4, #96]	; 0x60
  hadc->InjectionConfig.ContextQueue = 0;
 800188c:	6660      	str	r0, [r4, #100]	; 0x64
  hadc->InjectionConfig.ChannelCount = 0; 
 800188e:	66a0      	str	r0, [r4, #104]	; 0x68
  hadc->State = HAL_ADC_STATE_RESET;
 8001890:	65e0      	str	r0, [r4, #92]	; 0x5c
  __HAL_UNLOCK(hadc);
 8001892:	f884 0058 	strb.w	r0, [r4, #88]	; 0x58
  return HAL_OK;
 8001896:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8001898:	2001      	movs	r0, #1
 800189a:	bd10      	pop	{r4, pc}
    ADC_CLEAR_COMMON_CONTROL_REGISTER(hadc);
 800189c:	4a08      	ldr	r2, [pc, #32]	; (80018c0 <HAL_ADC_DeInit+0x13c>)
 800189e:	6893      	ldr	r3, [r2, #8]
 80018a0:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 80018a4:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80018a8:	6093      	str	r3, [r2, #8]
 80018aa:	e7ea      	b.n	8001882 <HAL_ADC_DeInit+0xfe>
 80018ac:	fffff800 	.word	0xfffff800
 80018b0:	e0820820 	.word	0xe0820820
 80018b4:	e0820830 	.word	0xe0820830
 80018b8:	03fff000 	.word	0x03fff000
 80018bc:	fff80000 	.word	0xfff80000
 80018c0:	50040300 	.word	0x50040300

080018c4 <HAL_ADCEx_Calibration_Start>:
  *           @arg @ref ADC_SINGLE_ENDED       Channel in mode input single ended
  *           @arg @ref ADC_DIFFERENTIAL_ENDED Channel in mode input differential ended
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_ADCEx_Calibration_Start(ADC_HandleTypeDef* hadc, uint32_t SingleDiff)
{
 80018c4:	b538      	push	{r3, r4, r5, lr}
  /* Check the parameters */
  assert_param(IS_ADC_ALL_INSTANCE(hadc->Instance));
  assert_param(IS_ADC_SINGLE_DIFFERENTIAL(SingleDiff));
  
  /* Process locked */
  __HAL_LOCK(hadc);
 80018c6:	f890 3058 	ldrb.w	r3, [r0, #88]	; 0x58
 80018ca:	2b01      	cmp	r3, #1
{
 80018cc:	4604      	mov	r4, r0
 80018ce:	460d      	mov	r5, r1
  __HAL_LOCK(hadc);
 80018d0:	d035      	beq.n	800193e <HAL_ADCEx_Calibration_Start+0x7a>
 80018d2:	2301      	movs	r3, #1
 80018d4:	f880 3058 	strb.w	r3, [r0, #88]	; 0x58
  
  /* Calibration prerequisite: ADC must be disabled. */
  
  /* Disable the ADC (if not already disabled) */
  tmp_hal_status = ADC_Disable(hadc);
 80018d8:	f7ff ff18 	bl	800170c <ADC_Disable>
  
  /* Check if ADC is effectively disabled */
  if (tmp_hal_status == HAL_OK)
  {
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State, 
 80018dc:	6de3      	ldr	r3, [r4, #92]	; 0x5c
  if (tmp_hal_status == HAL_OK)
 80018de:	bb58      	cbnz	r0, 8001938 <HAL_ADCEx_Calibration_Start+0x74>
    ADC_STATE_CLR_SET(hadc->State, 
 80018e0:	f423 5388 	bic.w	r3, r3, #4352	; 0x1100
 80018e4:	f023 0302 	bic.w	r3, r3, #2
 80018e8:	f043 0302 	orr.w	r3, r3, #2
 80018ec:	65e3      	str	r3, [r4, #92]	; 0x5c
                      HAL_ADC_STATE_BUSY_INTERNAL);

    

    /* Select calibration mode single ended or differential ended */
    MODIFY_REG(hadc->Instance->CR, ADC_CR_ADCALDIF, SingleDiff);
 80018ee:	6823      	ldr	r3, [r4, #0]
 80018f0:	689a      	ldr	r2, [r3, #8]
 80018f2:	f022 4280 	bic.w	r2, r2, #1073741824	; 0x40000000
 80018f6:	432a      	orrs	r2, r5
 80018f8:	609a      	str	r2, [r3, #8]
    
    /* Start ADC calibration */
    SET_BIT(hadc->Instance->CR, ADC_CR_ADCAL);
 80018fa:	689a      	ldr	r2, [r3, #8]
 80018fc:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 8001900:	609a      	str	r2, [r3, #8]
    
    /* Wait for calibration completion */
    while(HAL_IS_BIT_SET(hadc->Instance->CR, ADC_CR_ADCAL))
 8001902:	f44f 2291 	mov.w	r2, #296960	; 0x48800
 8001906:	6899      	ldr	r1, [r3, #8]
 8001908:	2900      	cmp	r1, #0
 800190a:	db09      	blt.n	8001920 <HAL_ADCEx_Calibration_Start+0x5c>
        return HAL_ERROR;
      }
    }
    
    /* Set ADC state */
    ADC_STATE_CLR_SET(hadc->State,
 800190c:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 800190e:	f023 0303 	bic.w	r3, r3, #3
 8001912:	f043 0301 	orr.w	r3, r3, #1
                      HAL_ADC_STATE_BUSY_INTERNAL,
                      HAL_ADC_STATE_READY);
  }
  else
  {
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001916:	65e3      	str	r3, [r4, #92]	; 0x5c
    /* Note: No need to update variable "tmp_hal_status" here: already set    */
    /*       to state "HAL_ERROR" by function disabling the ADC.              */
  }
  
  /* Process unlocked */
  __HAL_UNLOCK(hadc);
 8001918:	2300      	movs	r3, #0
 800191a:	f884 3058 	strb.w	r3, [r4, #88]	; 0x58
  
  /* Return function status */
  return tmp_hal_status;
 800191e:	bd38      	pop	{r3, r4, r5, pc}
      if (WaitLoopIndex >= ADC_CALIBRATION_TIMEOUT)
 8001920:	3a01      	subs	r2, #1
 8001922:	d1f0      	bne.n	8001906 <HAL_ADCEx_Calibration_Start+0x42>
        ADC_STATE_CLR_SET(hadc->State,
 8001924:	6de3      	ldr	r3, [r4, #92]	; 0x5c
        __HAL_UNLOCK(hadc);
 8001926:	f884 2058 	strb.w	r2, [r4, #88]	; 0x58
        ADC_STATE_CLR_SET(hadc->State,
 800192a:	f023 0312 	bic.w	r3, r3, #18
 800192e:	f043 0310 	orr.w	r3, r3, #16
 8001932:	65e3      	str	r3, [r4, #92]	; 0x5c
        return HAL_ERROR;
 8001934:	2001      	movs	r0, #1
 8001936:	bd38      	pop	{r3, r4, r5, pc}
    SET_BIT(hadc->State, HAL_ADC_STATE_ERROR_INTERNAL);
 8001938:	f043 0310 	orr.w	r3, r3, #16
 800193c:	e7eb      	b.n	8001916 <HAL_ADCEx_Calibration_Start+0x52>
  __HAL_LOCK(hadc);
 800193e:	2002      	movs	r0, #2
}
 8001940:	bd38      	pop	{r3, r4, r5, pc}
	...

08001944 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001944:	4a07      	ldr	r2, [pc, #28]	; (8001964 <HAL_NVIC_SetPriorityGrouping+0x20>)
 8001946:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8001948:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 800194c:	041b      	lsls	r3, r3, #16
 800194e:	0c1b      	lsrs	r3, r3, #16
 8001950:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
 8001954:	0200      	lsls	r0, r0, #8
 8001956:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800195a:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 800195e:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8001960:	60d3      	str	r3, [r2, #12]
 8001962:	4770      	bx	lr
 8001964:	e000ed00 	.word	0xe000ed00

08001968 <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8001968:	4b17      	ldr	r3, [pc, #92]	; (80019c8 <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800196a:	b530      	push	{r4, r5, lr}
 800196c:	68dc      	ldr	r4, [r3, #12]
 800196e:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001972:	f1c4 0307 	rsb	r3, r4, #7
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001976:	1d25      	adds	r5, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001978:	2b04      	cmp	r3, #4
 800197a:	bf28      	it	cs
 800197c:	2304      	movcs	r3, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800197e:	2d06      	cmp	r5, #6

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001980:	f04f 0501 	mov.w	r5, #1
 8001984:	fa05 f303 	lsl.w	r3, r5, r3
 8001988:	f103 33ff 	add.w	r3, r3, #4294967295
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800198c:	bf8c      	ite	hi
 800198e:	3c03      	subhi	r4, #3
 8001990:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001992:	4019      	ands	r1, r3
 8001994:	40a1      	lsls	r1, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8001996:	fa05 f404 	lsl.w	r4, r5, r4
 800199a:	3c01      	subs	r4, #1
 800199c:	4022      	ands	r2, r4
  if ((int32_t)(IRQn) < 0)
 800199e:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 80019a0:	ea42 0201 	orr.w	r2, r2, r1
 80019a4:	ea4f 1202 	mov.w	r2, r2, lsl #4
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80019a8:	bfaf      	iteee	ge
 80019aa:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80019ae:	f000 000f 	andlt.w	r0, r0, #15
 80019b2:	4b06      	ldrlt	r3, [pc, #24]	; (80019cc <HAL_NVIC_SetPriority+0x64>)
 80019b4:	b2d2      	uxtblt	r2, r2
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80019b6:	bfa5      	ittet	ge
 80019b8:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
 80019bc:	b2d2      	uxtbge	r2, r2
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80019be:	541a      	strblt	r2, [r3, r0]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80019c0:	f880 2300 	strbge.w	r2, [r0, #768]	; 0x300
 80019c4:	bd30      	pop	{r4, r5, pc}
 80019c6:	bf00      	nop
 80019c8:	e000ed00 	.word	0xe000ed00
 80019cc:	e000ed14 	.word	0xe000ed14

080019d0 <HAL_NVIC_EnableIRQ>:
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 80019d0:	0942      	lsrs	r2, r0, #5
 80019d2:	2301      	movs	r3, #1
 80019d4:	f000 001f 	and.w	r0, r0, #31
 80019d8:	fa03 f000 	lsl.w	r0, r3, r0
 80019dc:	4b01      	ldr	r3, [pc, #4]	; (80019e4 <HAL_NVIC_EnableIRQ+0x14>)
 80019de:	f843 0022 	str.w	r0, [r3, r2, lsl #2]
 80019e2:	4770      	bx	lr
 80019e4:	e000e100 	.word	0xe000e100

080019e8 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 80019e8:	3801      	subs	r0, #1
 80019ea:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 80019ee:	d20a      	bcs.n	8001a06 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80019f0:	4b06      	ldr	r3, [pc, #24]	; (8001a0c <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80019f2:	4a07      	ldr	r2, [pc, #28]	; (8001a10 <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80019f4:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80019f6:	21f0      	movs	r1, #240	; 0xf0
 80019f8:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80019fc:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80019fe:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8001a00:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8001a02:	601a      	str	r2, [r3, #0]
 8001a04:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 8001a06:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 8001a08:	4770      	bx	lr
 8001a0a:	bf00      	nop
 8001a0c:	e000e010 	.word	0xe000e010
 8001a10:	e000ed00 	.word	0xe000ed00

08001a14 <HAL_SYSTICK_CLKSourceConfig>:
  *             @arg SYSTICK_CLKSOURCE_HCLK_DIV8: AHB clock divided by 8 selected as SysTick clock source.
  *             @arg SYSTICK_CLKSOURCE_HCLK: AHB clock selected as SysTick clock source.
  * @retval None
  */
void HAL_SYSTICK_CLKSourceConfig(uint32_t CLKSource)
{
 8001a14:	4b04      	ldr	r3, [pc, #16]	; (8001a28 <HAL_SYSTICK_CLKSourceConfig+0x14>)
  /* Check the parameters */
  assert_param(IS_SYSTICK_CLK_SOURCE(CLKSource));
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
  {
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8001a16:	681a      	ldr	r2, [r3, #0]
  if (CLKSource == SYSTICK_CLKSOURCE_HCLK)
 8001a18:	2804      	cmp	r0, #4
    SysTick->CTRL |= SYSTICK_CLKSOURCE_HCLK;
 8001a1a:	bf0c      	ite	eq
 8001a1c:	f042 0204 	orreq.w	r2, r2, #4
  }
  else
  {
    SysTick->CTRL &= ~SYSTICK_CLKSOURCE_HCLK;
 8001a20:	f022 0204 	bicne.w	r2, r2, #4
 8001a24:	601a      	str	r2, [r3, #0]
 8001a26:	4770      	bx	lr
 8001a28:	e000e010 	.word	0xe000e010

08001a2c <HAL_SYSTICK_Callback>:
/**
  * @brief  SYSTICK callback.
  * @retval None
  */
__weak void HAL_SYSTICK_Callback(void)
{
 8001a2c:	4770      	bx	lr

08001a2e <HAL_SYSTICK_IRQHandler>:
{
 8001a2e:	b508      	push	{r3, lr}
  HAL_SYSTICK_Callback();
 8001a30:	f7ff fffc 	bl	8001a2c <HAL_SYSTICK_Callback>
 8001a34:	bd08      	pop	{r3, pc}

08001a36 <CRC_Handle_8>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_8(CRC_HandleTypeDef *hcrc, uint8_t pBuffer[], uint32_t BufferLength)
{
 8001a36:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint16_t *pReg;

  /* Processing time optimization: 4 bytes are entered in a row with a single word write,
   * last bytes must be carefully fed to the CRC calculator to ensure a correct type
   * handling by the IP */
  for (i = 0U; i < (BufferLength / 4U); i++)
 8001a38:	0896      	lsrs	r6, r2, #2
 8001a3a:	460b      	mov	r3, r1
 8001a3c:	eb01 0786 	add.w	r7, r1, r6, lsl #2
 8001a40:	42bb      	cmp	r3, r7
 8001a42:	6805      	ldr	r5, [r0, #0]
 8001a44:	d10a      	bne.n	8001a5c <CRC_Handle_8+0x26>
                         ((uint32_t)pBuffer[4U * i + 1U] << 16U) | \
                         ((uint32_t)pBuffer[4U * i + 2U] << 8U)  | \
                         (uint32_t)pBuffer[4U * i + 3U];
  }
  /* last bytes specific handling */
  if ((BufferLength % 4U) != 0U)
 8001a46:	f012 0203 	ands.w	r2, r2, #3
 8001a4a:	d004      	beq.n	8001a56 <CRC_Handle_8+0x20>
  {
    if (BufferLength % 4U == 1U)
 8001a4c:	2a01      	cmp	r2, #1
 8001a4e:	f811 1026 	ldrb.w	r1, [r1, r6, lsl #2]
 8001a52:	d114      	bne.n	8001a7e <CRC_Handle_8+0x48>
    {
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i];
 8001a54:	7029      	strb	r1, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i + 2U];
    }
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 8001a56:	6803      	ldr	r3, [r0, #0]
 8001a58:	6818      	ldr	r0, [r3, #0]
}
 8001a5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
                         ((uint32_t)pBuffer[4U * i + 1U] << 16U) | \
 8001a5c:	785c      	ldrb	r4, [r3, #1]
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 8001a5e:	f893 e000 	ldrb.w	lr, [r3]
                         ((uint32_t)pBuffer[4U * i + 1U] << 16U) | \
 8001a62:	0424      	lsls	r4, r4, #16
                         ((uint32_t)pBuffer[4U * i + 2U] << 8U)  | \
 8001a64:	ea44 640e 	orr.w	r4, r4, lr, lsl #24
                         (uint32_t)pBuffer[4U * i + 3U];
 8001a68:	f893 e003 	ldrb.w	lr, [r3, #3]
                         ((uint32_t)pBuffer[4U * i + 2U] << 8U)  | \
 8001a6c:	ea44 040e 	orr.w	r4, r4, lr
 8001a70:	f893 e002 	ldrb.w	lr, [r3, #2]
 8001a74:	ea44 240e 	orr.w	r4, r4, lr, lsl #8
    hcrc->Instance->DR = ((uint32_t)pBuffer[4U * i] << 24U) | \
 8001a78:	602c      	str	r4, [r5, #0]
 8001a7a:	3304      	adds	r3, #4
 8001a7c:	e7e0      	b.n	8001a40 <CRC_Handle_8+0xa>
    if (BufferLength % 4U == 2U)
 8001a7e:	2a02      	cmp	r2, #2
      data = (uint16_t)(pBuffer[4U * i] << 8U) | (uint16_t)pBuffer[4U * i + 1U];
 8001a80:	785a      	ldrb	r2, [r3, #1]
 8001a82:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
      *pReg = data;
 8001a86:	802a      	strh	r2, [r5, #0]
      *(__IO uint8_t *)(__IO void *)(&hcrc->Instance->DR) = pBuffer[4U * i + 2U];
 8001a88:	bf1c      	itt	ne
 8001a8a:	789b      	ldrbne	r3, [r3, #2]
 8001a8c:	702b      	strbne	r3, [r5, #0]
 8001a8e:	e7e2      	b.n	8001a56 <CRC_Handle_8+0x20>

08001a90 <CRC_Handle_16>:
  * @param  pBuffer pointer to the input data buffer
  * @param  BufferLength input data buffer length
  * @retval uint32_t CRC (returned value LSBs for CRC shorter than 32 bits)
  */
static uint32_t CRC_Handle_16(CRC_HandleTypeDef *hcrc, uint16_t pBuffer[], uint32_t BufferLength)
{
 8001a90:	b5f0      	push	{r4, r5, r6, r7, lr}
  __IO uint16_t *pReg;

  /* Processing time optimization: 2 HalfWords are entered in a row with a single word write,
   * in case of odd length, last HalfWord must be carefully fed to the CRC calculator to ensure
   * a correct type handling by the IP */
  for (i = 0U; i < (BufferLength / 2U); i++)
 8001a92:	2300      	movs	r3, #0
 8001a94:	0857      	lsrs	r7, r2, #1
 8001a96:	460c      	mov	r4, r1
 8001a98:	42bb      	cmp	r3, r7
 8001a9a:	f104 0404 	add.w	r4, r4, #4
 8001a9e:	6805      	ldr	r5, [r0, #0]
 8001aa0:	d106      	bne.n	8001ab0 <CRC_Handle_16+0x20>
  {
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[2U * i + 1U];
  }
  if ((BufferLength % 2U) != 0U)
 8001aa2:	07d2      	lsls	r2, r2, #31
  {
    pReg = (__IO uint16_t *)(__IO void *)(&hcrc->Instance->DR);
    *pReg = pBuffer[2U * i];
 8001aa4:	bf44      	itt	mi
 8001aa6:	f831 3023 	ldrhmi.w	r3, [r1, r3, lsl #2]
 8001aaa:	802b      	strhmi	r3, [r5, #0]
  }

  /* Return the CRC computed value */
  return hcrc->Instance->DR;
 8001aac:	6828      	ldr	r0, [r5, #0]
}
 8001aae:	bdf0      	pop	{r4, r5, r6, r7, pc}
    hcrc->Instance->DR = ((uint32_t)pBuffer[2U * i] << 16U) | (uint32_t)pBuffer[2U * i + 1U];
 8001ab0:	f834 ec04 	ldrh.w	lr, [r4, #-4]
 8001ab4:	f834 6c02 	ldrh.w	r6, [r4, #-2]
 8001ab8:	ea46 460e 	orr.w	r6, r6, lr, lsl #16
 8001abc:	602e      	str	r6, [r5, #0]
  for (i = 0U; i < (BufferLength / 2U); i++)
 8001abe:	3301      	adds	r3, #1
 8001ac0:	e7ea      	b.n	8001a98 <CRC_Handle_16+0x8>
	...

08001ac4 <HAL_CRC_Init>:
{
 8001ac4:	b510      	push	{r4, lr}
  if (hcrc == NULL)
 8001ac6:	4604      	mov	r4, r0
 8001ac8:	b908      	cbnz	r0, 8001ace <HAL_CRC_Init+0xa>
    return HAL_ERROR;
 8001aca:	2001      	movs	r0, #1
 8001acc:	bd10      	pop	{r4, pc}
  if (hcrc->State == HAL_CRC_STATE_RESET)
 8001ace:	7f43      	ldrb	r3, [r0, #29]
 8001ad0:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001ad4:	b913      	cbnz	r3, 8001adc <HAL_CRC_Init+0x18>
    hcrc->Lock = HAL_UNLOCKED;
 8001ad6:	7702      	strb	r2, [r0, #28]
    HAL_CRC_MspInit(hcrc);
 8001ad8:	f007 ff28 	bl	800992c <HAL_CRC_MspInit>
  hcrc->State = HAL_CRC_STATE_BUSY;
 8001adc:	2302      	movs	r3, #2
 8001ade:	7763      	strb	r3, [r4, #29]
  if (hcrc->Init.DefaultPolynomialUse == DEFAULT_POLYNOMIAL_ENABLE)
 8001ae0:	7923      	ldrb	r3, [r4, #4]
 8001ae2:	b9e3      	cbnz	r3, 8001b1e <HAL_CRC_Init+0x5a>
    WRITE_REG(hcrc->Instance->POL, DEFAULT_CRC32_POLY);
 8001ae4:	6823      	ldr	r3, [r4, #0]
 8001ae6:	4a13      	ldr	r2, [pc, #76]	; (8001b34 <HAL_CRC_Init+0x70>)
 8001ae8:	615a      	str	r2, [r3, #20]
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, CRC_POLYLENGTH_32B);
 8001aea:	689a      	ldr	r2, [r3, #8]
 8001aec:	f022 0218 	bic.w	r2, r2, #24
 8001af0:	609a      	str	r2, [r3, #8]
  if (hcrc->Init.DefaultInitValueUse == DEFAULT_INIT_VALUE_ENABLE)
 8001af2:	7962      	ldrb	r2, [r4, #5]
 8001af4:	6823      	ldr	r3, [r4, #0]
 8001af6:	b9d2      	cbnz	r2, 8001b2e <HAL_CRC_Init+0x6a>
    WRITE_REG(hcrc->Instance->INIT, DEFAULT_CRC_INITVALUE);
 8001af8:	f04f 32ff 	mov.w	r2, #4294967295
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 8001afc:	611a      	str	r2, [r3, #16]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_IN, hcrc->Init.InputDataInversionMode);
 8001afe:	689a      	ldr	r2, [r3, #8]
 8001b00:	6961      	ldr	r1, [r4, #20]
 8001b02:	f022 0260 	bic.w	r2, r2, #96	; 0x60
 8001b06:	430a      	orrs	r2, r1
 8001b08:	609a      	str	r2, [r3, #8]
  MODIFY_REG(hcrc->Instance->CR, CRC_CR_REV_OUT, hcrc->Init.OutputDataInversionMode);
 8001b0a:	689a      	ldr	r2, [r3, #8]
 8001b0c:	69a1      	ldr	r1, [r4, #24]
 8001b0e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8001b12:	430a      	orrs	r2, r1
 8001b14:	609a      	str	r2, [r3, #8]
  hcrc->State = HAL_CRC_STATE_READY;
 8001b16:	2301      	movs	r3, #1
 8001b18:	7763      	strb	r3, [r4, #29]
  return HAL_OK;
 8001b1a:	2000      	movs	r0, #0
}
 8001b1c:	bd10      	pop	{r4, pc}
    if (HAL_CRCEx_Polynomial_Set(hcrc, hcrc->Init.GeneratingPolynomial, hcrc->Init.CRCLength) != HAL_OK)
 8001b1e:	68e2      	ldr	r2, [r4, #12]
 8001b20:	68a1      	ldr	r1, [r4, #8]
 8001b22:	4620      	mov	r0, r4
 8001b24:	f000 f832 	bl	8001b8c <HAL_CRCEx_Polynomial_Set>
 8001b28:	2800      	cmp	r0, #0
 8001b2a:	d0e2      	beq.n	8001af2 <HAL_CRC_Init+0x2e>
 8001b2c:	e7cd      	b.n	8001aca <HAL_CRC_Init+0x6>
    WRITE_REG(hcrc->Instance->INIT, hcrc->Init.InitValue);
 8001b2e:	6922      	ldr	r2, [r4, #16]
 8001b30:	e7e4      	b.n	8001afc <HAL_CRC_Init+0x38>
 8001b32:	bf00      	nop
 8001b34:	04c11db7 	.word	0x04c11db7

08001b38 <HAL_CRC_Accumulate>:
{
 8001b38:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hcrc);
 8001b3a:	7f03      	ldrb	r3, [r0, #28]
 8001b3c:	2b01      	cmp	r3, #1
{
 8001b3e:	4604      	mov	r4, r0
 8001b40:	f04f 0302 	mov.w	r3, #2
  __HAL_LOCK(hcrc);
 8001b44:	d020      	beq.n	8001b88 <HAL_CRC_Accumulate+0x50>
  hcrc->State = HAL_CRC_STATE_BUSY;
 8001b46:	7743      	strb	r3, [r0, #29]
  switch (hcrc->InputDataFormat)
 8001b48:	6a03      	ldr	r3, [r0, #32]
  __HAL_LOCK(hcrc);
 8001b4a:	2701      	movs	r7, #1
  switch (hcrc->InputDataFormat)
 8001b4c:	2b02      	cmp	r3, #2
  __HAL_LOCK(hcrc);
 8001b4e:	7707      	strb	r7, [r0, #28]
  switch (hcrc->InputDataFormat)
 8001b50:	d015      	beq.n	8001b7e <HAL_CRC_Accumulate+0x46>
 8001b52:	2b03      	cmp	r3, #3
 8001b54:	d004      	beq.n	8001b60 <HAL_CRC_Accumulate+0x28>
 8001b56:	42bb      	cmp	r3, r7
 8001b58:	d114      	bne.n	8001b84 <HAL_CRC_Accumulate+0x4c>
      temp = CRC_Handle_8(hcrc, (uint8_t *)pBuffer, BufferLength);
 8001b5a:	f7ff ff6c 	bl	8001a36 <CRC_Handle_8>
      break;
 8001b5e:	e005      	b.n	8001b6c <HAL_CRC_Accumulate+0x34>
 8001b60:	eb01 0682 	add.w	r6, r1, r2, lsl #2
      for (index = 0U; index < BufferLength; index++)
 8001b64:	42b1      	cmp	r1, r6
 8001b66:	6823      	ldr	r3, [r4, #0]
 8001b68:	d105      	bne.n	8001b76 <HAL_CRC_Accumulate+0x3e>
      temp = hcrc->Instance->DR;
 8001b6a:	6818      	ldr	r0, [r3, #0]
  hcrc->State = HAL_CRC_STATE_READY;
 8001b6c:	2301      	movs	r3, #1
 8001b6e:	7763      	strb	r3, [r4, #29]
  __HAL_UNLOCK(hcrc);
 8001b70:	2300      	movs	r3, #0
 8001b72:	7723      	strb	r3, [r4, #28]
  return temp;
 8001b74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        hcrc->Instance->DR = pBuffer[index];
 8001b76:	f851 2b04 	ldr.w	r2, [r1], #4
 8001b7a:	601a      	str	r2, [r3, #0]
 8001b7c:	e7f2      	b.n	8001b64 <HAL_CRC_Accumulate+0x2c>
      temp = CRC_Handle_16(hcrc, (uint16_t *)pBuffer, BufferLength);
 8001b7e:	f7ff ff87 	bl	8001a90 <CRC_Handle_16>
      break;
 8001b82:	e7f3      	b.n	8001b6c <HAL_CRC_Accumulate+0x34>
  uint32_t temp = 0U;  /* CRC output (read from hcrc->Instance->DR register) */
 8001b84:	2000      	movs	r0, #0
 8001b86:	e7f1      	b.n	8001b6c <HAL_CRC_Accumulate+0x34>
  __HAL_LOCK(hcrc);
 8001b88:	4618      	mov	r0, r3
}
 8001b8a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08001b8c <HAL_CRCEx_Polynomial_Set>:
  *          @arg @ref CRC_POLYLENGTH_16B 16-bit long CRC (generating polynomial of degree 16)
  *          @arg @ref CRC_POLYLENGTH_32B 32-bit long CRC (generating polynomial of degree 32)
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CRCEx_Polynomial_Set(CRC_HandleTypeDef *hcrc, uint32_t Pol, uint32_t PolyLength)
{
 8001b8c:	b510      	push	{r4, lr}
  HAL_StatusTypeDef status = HAL_OK;
  uint32_t msb = 31U; /* polynomial degree is 32 at most, so msb is initialized to max value */
 8001b8e:	231f      	movs	r3, #31
   * definition. HAL_ERROR is reported if Pol degree is
   * larger than that indicated by PolyLength.
   * Look for MSB position: msb will contain the degree of
   *  the second to the largest polynomial member. E.g., for
   *  X^7 + X^6 + X^5 + X^2 + 1, msb = 6. */
  while ((msb-- > 0U) && ((Pol & ((uint32_t)(0x1U) << msb)) == 0U))
 8001b90:	f113 33ff 	adds.w	r3, r3, #4294967295
 8001b94:	d306      	bcc.n	8001ba4 <HAL_CRCEx_Polynomial_Set+0x18>
 8001b96:	fa21 f403 	lsr.w	r4, r1, r3
 8001b9a:	07e4      	lsls	r4, r4, #31
 8001b9c:	d5f8      	bpl.n	8001b90 <HAL_CRCEx_Polynomial_Set+0x4>
  {
  }

  switch (PolyLength)
 8001b9e:	2a08      	cmp	r2, #8
 8001ba0:	d014      	beq.n	8001bcc <HAL_CRCEx_Polynomial_Set+0x40>
 8001ba2:	d809      	bhi.n	8001bb8 <HAL_CRCEx_Polynomial_Set+0x2c>
 8001ba4:	b972      	cbnz	r2, 8001bc4 <HAL_CRCEx_Polynomial_Set+0x38>
      break;
  }
  if (status == HAL_OK)
  {
    /* set generating polynomial */
    WRITE_REG(hcrc->Instance->POL, Pol);
 8001ba6:	6800      	ldr	r0, [r0, #0]
 8001ba8:	6141      	str	r1, [r0, #20]

    /* set generating polynomial size */
    MODIFY_REG(hcrc->Instance->CR, CRC_CR_POLYSIZE, PolyLength);
 8001baa:	6883      	ldr	r3, [r0, #8]
 8001bac:	f023 0318 	bic.w	r3, r3, #24
 8001bb0:	431a      	orrs	r2, r3
 8001bb2:	6082      	str	r2, [r0, #8]
 8001bb4:	2000      	movs	r0, #0
  }
  /* Return function status */
  return status;
 8001bb6:	bd10      	pop	{r4, pc}
  switch (PolyLength)
 8001bb8:	2a10      	cmp	r2, #16
 8001bba:	d005      	beq.n	8001bc8 <HAL_CRCEx_Polynomial_Set+0x3c>
 8001bbc:	2a18      	cmp	r2, #24
 8001bbe:	d101      	bne.n	8001bc4 <HAL_CRCEx_Polynomial_Set+0x38>
      if (msb >= HAL_CRC_LENGTH_7B)
 8001bc0:	2b06      	cmp	r3, #6
      if (msb >= HAL_CRC_LENGTH_16B)
 8001bc2:	d9f0      	bls.n	8001ba6 <HAL_CRCEx_Polynomial_Set+0x1a>
  switch (PolyLength)
 8001bc4:	2001      	movs	r0, #1
 8001bc6:	bd10      	pop	{r4, pc}
      if (msb >= HAL_CRC_LENGTH_8B)
 8001bc8:	2b07      	cmp	r3, #7
 8001bca:	e7fa      	b.n	8001bc2 <HAL_CRCEx_Polynomial_Set+0x36>
      if (msb >= HAL_CRC_LENGTH_16B)
 8001bcc:	2b0f      	cmp	r3, #15
 8001bce:	e7f8      	b.n	8001bc2 <HAL_CRCEx_Polynomial_Set+0x36>

08001bd0 <HAL_FLASH_Unlock>:
  */
HAL_StatusTypeDef HAL_FLASH_Unlock(void)
{
  HAL_StatusTypeDef status = HAL_OK;

  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8001bd0:	4b06      	ldr	r3, [pc, #24]	; (8001bec <HAL_FLASH_Unlock+0x1c>)
 8001bd2:	695a      	ldr	r2, [r3, #20]
 8001bd4:	2a00      	cmp	r2, #0
  {
    /* Authorize the FLASH Registers access */
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 8001bd6:	bfbf      	itttt	lt
 8001bd8:	4a05      	ldrlt	r2, [pc, #20]	; (8001bf0 <HAL_FLASH_Unlock+0x20>)
 8001bda:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 8001bdc:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 8001be0:	609a      	strlt	r2, [r3, #8]

    /* Verify Flash is unlocked */
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 8001be2:	bfba      	itte	lt
 8001be4:	6958      	ldrlt	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_OK;
 8001be6:	0fc0      	lsrlt	r0, r0, #31
 8001be8:	2000      	movge	r0, #0
      status = HAL_ERROR;
    }
  }

  return status;
}
 8001bea:	4770      	bx	lr
 8001bec:	40022000 	.word	0x40022000
 8001bf0:	45670123 	.word	0x45670123

08001bf4 <HAL_FLASH_Lock>:
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_Lock(void)
{
  /* Set the LOCK Bit to lock the FLASH Registers access */
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8001bf4:	4a03      	ldr	r2, [pc, #12]	; (8001c04 <HAL_FLASH_Lock+0x10>)
 8001bf6:	6953      	ldr	r3, [r2, #20]
 8001bf8:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001bfc:	6153      	str	r3, [r2, #20]

  return HAL_OK;
}
 8001bfe:	2000      	movs	r0, #0
 8001c00:	4770      	bx	lr
 8001c02:	bf00      	nop
 8001c04:	40022000 	.word	0x40022000

08001c08 <HAL_FLASH_OB_Unlock>:
  * @brief  Unlock the FLASH Option Bytes Registers access.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_FLASH_OB_Unlock(void)
{
  if(READ_BIT(FLASH->CR, FLASH_CR_OPTLOCK) != 0U)
 8001c08:	4b06      	ldr	r3, [pc, #24]	; (8001c24 <HAL_FLASH_OB_Unlock+0x1c>)
 8001c0a:	695a      	ldr	r2, [r3, #20]
 8001c0c:	0052      	lsls	r2, r2, #1
  {
    /* Authorizes the Option Byte register programming */
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY1);
 8001c0e:	bf41      	itttt	mi
 8001c10:	4a05      	ldrmi	r2, [pc, #20]	; (8001c28 <HAL_FLASH_OB_Unlock+0x20>)
 8001c12:	60da      	strmi	r2, [r3, #12]
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
 8001c14:	f102 3244 	addmi.w	r2, r2, #1145324612	; 0x44444444
  else
  {
    return HAL_ERROR;
  }

  return HAL_OK;
 8001c18:	2000      	movmi	r0, #0
    WRITE_REG(FLASH->OPTKEYR, FLASH_OPTKEY2);
 8001c1a:	bf4c      	ite	mi
 8001c1c:	60da      	strmi	r2, [r3, #12]
    return HAL_ERROR;
 8001c1e:	2001      	movpl	r0, #1
}
 8001c20:	4770      	bx	lr
 8001c22:	bf00      	nop
 8001c24:	40022000 	.word	0x40022000
 8001c28:	08192a3b 	.word	0x08192a3b

08001c2c <FLASH_WaitForLastOperation>:
  * @brief  Wait for a FLASH operation to complete.
  * @param  Timeout: maximum flash operation timeout
  * @retval HAL_StatusTypeDef HAL Status
  */
HAL_StatusTypeDef FLASH_WaitForLastOperation(uint32_t Timeout)
{
 8001c2c:	b570      	push	{r4, r5, r6, lr}
 8001c2e:	4605      	mov	r5, r0
  /* Wait for the FLASH operation to complete by polling on BUSY flag to be reset.
     Even if the FLASH operation fails, the BUSY flag will be reset and an error
     flag will be set */

  uint32_t tickstart = HAL_GetTick();
 8001c30:	f7ff f92e 	bl	8000e90 <HAL_GetTick>
  uint32_t error;

  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8001c34:	4c1a      	ldr	r4, [pc, #104]	; (8001ca0 <FLASH_WaitForLastOperation+0x74>)
  uint32_t tickstart = HAL_GetTick();
 8001c36:	4606      	mov	r6, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8001c38:	6923      	ldr	r3, [r4, #16]
 8001c3a:	03db      	lsls	r3, r3, #15
 8001c3c:	d41e      	bmi.n	8001c7c <FLASH_WaitForLastOperation+0x50>
        return HAL_TIMEOUT;
      }
    }
  }

  error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
 8001c3e:	6923      	ldr	r3, [r4, #16]
  error |= (FLASH->ECCR & FLASH_FLAG_ECCD);
 8001c40:	69a0      	ldr	r0, [r4, #24]
  error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
 8001c42:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8001c46:	f423 037d 	bic.w	r3, r3, #16580608	; 0xfd0000
 8001c4a:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8001c4e:	f023 0305 	bic.w	r3, r3, #5
  error |= (FLASH->ECCR & FLASH_FLAG_ECCD);
 8001c52:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000

  if(error != 0u)
 8001c56:	4318      	orrs	r0, r3
 8001c58:	d019      	beq.n	8001c8e <FLASH_WaitForLastOperation+0x62>
  {
    /*Save the error code*/
    pFlash.ErrorCode |= error;
 8001c5a:	4a12      	ldr	r2, [pc, #72]	; (8001ca4 <FLASH_WaitForLastOperation+0x78>)
 8001c5c:	6853      	ldr	r3, [r2, #4]
 8001c5e:	4303      	orrs	r3, r0
 8001c60:	6053      	str	r3, [r2, #4]

    /* Clear error programming flags */
    __HAL_FLASH_CLEAR_FLAG(error);
 8001c62:	f010 4340 	ands.w	r3, r0, #3221225472	; 0xc0000000
 8001c66:	bf1e      	ittt	ne
 8001c68:	69a2      	ldrne	r2, [r4, #24]
 8001c6a:	4313      	orrne	r3, r2
 8001c6c:	61a3      	strne	r3, [r4, #24]
 8001c6e:	f030 4040 	bics.w	r0, r0, #3221225472	; 0xc0000000
 8001c72:	d001      	beq.n	8001c78 <FLASH_WaitForLastOperation+0x4c>
 8001c74:	4b0a      	ldr	r3, [pc, #40]	; (8001ca0 <FLASH_WaitForLastOperation+0x74>)
 8001c76:	6118      	str	r0, [r3, #16]

    return HAL_ERROR;
 8001c78:	2001      	movs	r0, #1
 8001c7a:	bd70      	pop	{r4, r5, r6, pc}
    if(Timeout != HAL_MAX_DELAY)
 8001c7c:	1c6a      	adds	r2, r5, #1
 8001c7e:	d0db      	beq.n	8001c38 <FLASH_WaitForLastOperation+0xc>
      if((HAL_GetTick() - tickstart) >= Timeout)
 8001c80:	f7ff f906 	bl	8000e90 <HAL_GetTick>
 8001c84:	1b80      	subs	r0, r0, r6
 8001c86:	4285      	cmp	r5, r0
 8001c88:	d8d6      	bhi.n	8001c38 <FLASH_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
 8001c8a:	2003      	movs	r0, #3
 8001c8c:	bd70      	pop	{r4, r5, r6, pc}
  }

  /* Check FLASH End of Operation flag  */
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8001c8e:	6923      	ldr	r3, [r4, #16]
 8001c90:	f013 0301 	ands.w	r3, r3, #1
 8001c94:	d002      	beq.n	8001c9c <FLASH_WaitForLastOperation+0x70>
  {
    /* Clear FLASH End of Operation pending bit */
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001c96:	2301      	movs	r3, #1
 8001c98:	6123      	str	r3, [r4, #16]
 8001c9a:	bd70      	pop	{r4, r5, r6, pc}
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 8001c9c:	4618      	mov	r0, r3
  }

  /* If there is an error flag set */
  return HAL_OK;
}
 8001c9e:	bd70      	pop	{r4, r5, r6, pc}
 8001ca0:	40022000 	.word	0x40022000
 8001ca4:	20000000 	.word	0x20000000

08001ca8 <HAL_FLASHEx_OBProgram>:
HAL_StatusTypeDef HAL_FLASHEx_OBProgram(FLASH_OBProgramInitTypeDef *pOBInit)
{
  HAL_StatusTypeDef status = HAL_OK;
  
  /* Process Locked */
  __HAL_LOCK(&pFlash);
 8001ca8:	4b8f      	ldr	r3, [pc, #572]	; (8001ee8 <HAL_FLASHEx_OBProgram+0x240>)
 8001caa:	781a      	ldrb	r2, [r3, #0]
 8001cac:	2a01      	cmp	r2, #1
{
 8001cae:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8001cb2:	4606      	mov	r6, r0
 8001cb4:	4698      	mov	r8, r3
  __HAL_LOCK(&pFlash);
 8001cb6:	f000 8114 	beq.w	8001ee2 <HAL_FLASHEx_OBProgram+0x23a>
 8001cba:	2701      	movs	r7, #1
 8001cbc:	701f      	strb	r7, [r3, #0]

  /* Check the parameters */
  assert_param(IS_OPTIONBYTE(pOBInit->OptionType));
  
  pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 8001cbe:	2300      	movs	r3, #0
 8001cc0:	f8c8 3004 	str.w	r3, [r8, #4]

  /* Write protection configuration */
  if((pOBInit->OptionType & OPTIONBYTE_WRP) != 0U)
 8001cc4:	6803      	ldr	r3, [r0, #0]
 8001cc6:	403b      	ands	r3, r7
 8001cc8:	f000 8109 	beq.w	8001ede <HAL_FLASHEx_OBProgram+0x236>
  {
    /* Configure of Write protection on the selected area */
    if(FLASH_OB_WRPConfig(pOBInit->WRPArea, pOBInit->WRPStartOffset, pOBInit->WRPEndOffset) != HAL_OK)
 8001ccc:	f8d0 a004 	ldr.w	sl, [r0, #4]
 8001cd0:	f8d0 9008 	ldr.w	r9, [r0, #8]
 8001cd4:	68c5      	ldr	r5, [r0, #12]
  assert_param(IS_OB_WRPAREA(WRPArea));
  assert_param(IS_FLASH_PAGE(WRPStartOffset));
  assert_param(IS_FLASH_PAGE(WRDPEndOffset));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001cd6:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001cda:	f7ff ffa7 	bl	8001c2c <FLASH_WaitForLastOperation>

  if(status == HAL_OK)
 8001cde:	b9d8      	cbnz	r0, 8001d18 <HAL_FLASHEx_OBProgram+0x70>
 8001ce0:	4c82      	ldr	r4, [pc, #520]	; (8001eec <HAL_FLASHEx_OBProgram+0x244>)
  {
    /* Configure the write protected area */
    if(WRPArea == OB_WRPAREA_BANK1_AREAA)
 8001ce2:	f1ba 0f00 	cmp.w	sl, #0
 8001ce6:	f040 80ed 	bne.w	8001ec4 <HAL_FLASHEx_OBProgram+0x21c>
    {
      MODIFY_REG(FLASH->WRP1AR, (FLASH_WRP1AR_WRP1A_STRT | FLASH_WRP1AR_WRP1A_END), 
 8001cea:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001cec:	f003 23ff 	and.w	r3, r3, #4278255360	; 0xff00ff00
 8001cf0:	ea43 0309 	orr.w	r3, r3, r9
 8001cf4:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
 8001cf8:	62e3      	str	r3, [r4, #44]	; 0x2c
    {
      /* Nothing to do */
    }
    
    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001cfa:	6963      	ldr	r3, [r4, #20]
 8001cfc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001d00:	6163      	str	r3, [r4, #20]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001d02:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001d06:	f7ff ff91 	bl	8001c2c <FLASH_WaitForLastOperation>

    /* If the option byte program operation is completed, disable the OPTSTRT Bit */
    CLEAR_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001d0a:	6963      	ldr	r3, [r4, #20]
  HAL_StatusTypeDef status = HAL_OK;
 8001d0c:	1c07      	adds	r7, r0, #0
    CLEAR_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001d0e:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8001d12:	6163      	str	r3, [r4, #20]
  HAL_StatusTypeDef status = HAL_OK;
 8001d14:	bf18      	it	ne
 8001d16:	2701      	movne	r7, #1
  if((pOBInit->OptionType & OPTIONBYTE_RDP) != 0U)
 8001d18:	6833      	ldr	r3, [r6, #0]
 8001d1a:	079d      	lsls	r5, r3, #30
 8001d1c:	d519      	bpl.n	8001d52 <HAL_FLASHEx_OBProgram+0xaa>

  /* Check the parameters */
  assert_param(IS_OB_RDP_LEVEL(RDPLevel));
    
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001d1e:	f24c 3050 	movw	r0, #50000	; 0xc350
    if(FLASH_OB_RDPConfig(pOBInit->RDPLevel) != HAL_OK)
 8001d22:	6935      	ldr	r5, [r6, #16]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001d24:	f7ff ff82 	bl	8001c2c <FLASH_WaitForLastOperation>

  if(status == HAL_OK)
 8001d28:	b990      	cbnz	r0, 8001d50 <HAL_FLASHEx_OBProgram+0xa8>
  { 
    /* Configure the RDP level in the option bytes register */
    MODIFY_REG(FLASH->OPTR, FLASH_OPTR_RDP, RDPLevel);
 8001d2a:	4c70      	ldr	r4, [pc, #448]	; (8001eec <HAL_FLASHEx_OBProgram+0x244>)
 8001d2c:	6a23      	ldr	r3, [r4, #32]
 8001d2e:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 8001d32:	432b      	orrs	r3, r5
 8001d34:	6223      	str	r3, [r4, #32]
    
    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001d36:	6963      	ldr	r3, [r4, #20]
 8001d38:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001d3c:	6163      	str	r3, [r4, #20]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001d3e:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001d42:	f7ff ff73 	bl	8001c2c <FLASH_WaitForLastOperation>

    /* If the option byte program operation is completed, disable the OPTSTRT Bit */
    CLEAR_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001d46:	6963      	ldr	r3, [r4, #20]
 8001d48:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8001d4c:	6163      	str	r3, [r4, #20]
    if(FLASH_OB_RDPConfig(pOBInit->RDPLevel) != HAL_OK)
 8001d4e:	b100      	cbz	r0, 8001d52 <HAL_FLASHEx_OBProgram+0xaa>
      status = HAL_ERROR;
 8001d50:	2701      	movs	r7, #1
  if((pOBInit->OptionType & OPTIONBYTE_USER) != 0U)
 8001d52:	6833      	ldr	r3, [r6, #0]
 8001d54:	075c      	lsls	r4, r3, #29
 8001d56:	d578      	bpl.n	8001e4a <HAL_FLASHEx_OBProgram+0x1a2>

  /* Check the parameters */
  assert_param(IS_OB_USER_TYPE(UserType));
  
  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001d58:	f24c 3050 	movw	r0, #50000	; 0xc350
    if(FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig) != HAL_OK)
 8001d5c:	6975      	ldr	r5, [r6, #20]
 8001d5e:	69b4      	ldr	r4, [r6, #24]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001d60:	f7ff ff64 	bl	8001c2c <FLASH_WaitForLastOperation>

  if(status == HAL_OK)
 8001d64:	2800      	cmp	r0, #0
 8001d66:	d16f      	bne.n	8001e48 <HAL_FLASHEx_OBProgram+0x1a0>
  { 
    if((UserType & OB_USER_BOR_LEV) != 0U)
 8001d68:	f015 0301 	ands.w	r3, r5, #1
  uint32_t optr_reg_val = 0;
 8001d6c:	bf0e      	itee	eq
 8001d6e:	461a      	moveq	r2, r3
    {
      /* BOR level option byte should be modified */
      assert_param(IS_OB_USER_BOR_LEVEL(UserConfig & FLASH_OPTR_BOR_LEV));
    
      /* Set value and mask for BOR level option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_BOR_LEV);
 8001d70:	f404 62e0 	andne.w	r2, r4, #1792	; 0x700
      optr_reg_mask |= FLASH_OPTR_BOR_LEV;
 8001d74:	f44f 63e0 	movne.w	r3, #1792	; 0x700
    }

    if((UserType & OB_USER_nRST_STOP) != 0U)
 8001d78:	07a8      	lsls	r0, r5, #30
    {
      /* nRST_STOP option byte should be modified */
      assert_param(IS_OB_USER_STOP(UserConfig & FLASH_OPTR_nRST_STOP));
    
      /* Set value and mask for nRST_STOP option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STOP);
 8001d7a:	bf42      	ittt	mi
 8001d7c:	f404 5180 	andmi.w	r1, r4, #4096	; 0x1000
 8001d80:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_nRST_STOP;
 8001d82:	f443 5380 	orrmi.w	r3, r3, #4096	; 0x1000
    }

    if((UserType & OB_USER_nRST_STDBY) != 0U)
 8001d86:	0769      	lsls	r1, r5, #29
    {
      /* nRST_STDBY option byte should be modified */
      assert_param(IS_OB_USER_STANDBY(UserConfig & FLASH_OPTR_nRST_STDBY));
    
      /* Set value and mask for nRST_STDBY option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_STDBY);
 8001d88:	bf42      	ittt	mi
 8001d8a:	f404 5100 	andmi.w	r1, r4, #8192	; 0x2000
 8001d8e:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_nRST_STDBY;
 8001d90:	f443 5300 	orrmi.w	r3, r3, #8192	; 0x2000
    }

    if((UserType & OB_USER_nRST_SHDW) != 0U)
 8001d94:	04e8      	lsls	r0, r5, #19
    {
      /* nRST_SHDW option byte should be modified */
      assert_param(IS_OB_USER_SHUTDOWN(UserConfig & FLASH_OPTR_nRST_SHDW));
    
      /* Set value and mask for nRST_SHDW option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nRST_SHDW);
 8001d96:	bf42      	ittt	mi
 8001d98:	f404 4180 	andmi.w	r1, r4, #16384	; 0x4000
 8001d9c:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_nRST_SHDW;
 8001d9e:	f443 4380 	orrmi.w	r3, r3, #16384	; 0x4000
    }

    if((UserType & OB_USER_IWDG_SW) != 0U)
 8001da2:	0729      	lsls	r1, r5, #28
    {
      /* IWDG_SW option byte should be modified */
      assert_param(IS_OB_USER_IWDG(UserConfig & FLASH_OPTR_IWDG_SW));
    
      /* Set value and mask for IWDG_SW option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_SW);
 8001da4:	bf42      	ittt	mi
 8001da6:	f404 3180 	andmi.w	r1, r4, #65536	; 0x10000
 8001daa:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_IWDG_SW;
 8001dac:	f443 3380 	orrmi.w	r3, r3, #65536	; 0x10000
    }

    if((UserType & OB_USER_IWDG_STOP) != 0U)
 8001db0:	06e8      	lsls	r0, r5, #27
    {
      /* IWDG_STOP option byte should be modified */
      assert_param(IS_OB_USER_IWDG_STOP(UserConfig & FLASH_OPTR_IWDG_STOP));
    
      /* Set value and mask for IWDG_STOP option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STOP);
 8001db2:	bf42      	ittt	mi
 8001db4:	f404 3100 	andmi.w	r1, r4, #131072	; 0x20000
 8001db8:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_IWDG_STOP;
 8001dba:	f443 3300 	orrmi.w	r3, r3, #131072	; 0x20000
    }

    if((UserType & OB_USER_IWDG_STDBY) != 0U)
 8001dbe:	06a9      	lsls	r1, r5, #26
    {
      /* IWDG_STDBY option byte should be modified */
      assert_param(IS_OB_USER_IWDG_STDBY(UserConfig & FLASH_OPTR_IWDG_STDBY));
    
      /* Set value and mask for IWDG_STDBY option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_IWDG_STDBY);
 8001dc0:	bf42      	ittt	mi
 8001dc2:	f404 2180 	andmi.w	r1, r4, #262144	; 0x40000
 8001dc6:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_IWDG_STDBY;
 8001dc8:	f443 2380 	orrmi.w	r3, r3, #262144	; 0x40000
    }

    if((UserType & OB_USER_WWDG_SW) != 0U)
 8001dcc:	0668      	lsls	r0, r5, #25
    {
      /* WWDG_SW option byte should be modified */
      assert_param(IS_OB_USER_WWDG(UserConfig & FLASH_OPTR_WWDG_SW));
    
      /* Set value and mask for WWDG_SW option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_WWDG_SW);
 8001dce:	bf42      	ittt	mi
 8001dd0:	f404 2100 	andmi.w	r1, r4, #524288	; 0x80000
 8001dd4:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_WWDG_SW;
 8001dd6:	f443 2300 	orrmi.w	r3, r3, #524288	; 0x80000
      optr_reg_mask |= FLASH_OPTR_DUALBANK;
#endif
    }
#endif
    
    if((UserType & OB_USER_nBOOT1) != 0U)
 8001dda:	05a9      	lsls	r1, r5, #22
    {
      /* nBOOT1 option byte should be modified */
      assert_param(IS_OB_USER_BOOT1(UserConfig & FLASH_OPTR_nBOOT1));
    
      /* Set value and mask for nBOOT1 option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nBOOT1);
 8001ddc:	bf42      	ittt	mi
 8001dde:	f404 0100 	andmi.w	r1, r4, #8388608	; 0x800000
 8001de2:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_nBOOT1;
 8001de4:	f443 0300 	orrmi.w	r3, r3, #8388608	; 0x800000
    }

    if((UserType & OB_USER_SRAM2_PE) != 0U)
 8001de8:	0568      	lsls	r0, r5, #21
    {
      /* SRAM2_PE option byte should be modified */
      assert_param(IS_OB_USER_SRAM2_PARITY(UserConfig & FLASH_OPTR_SRAM2_PE));
    
      /* Set value and mask for SRAM2_PE option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM2_PE);
 8001dea:	bf42      	ittt	mi
 8001dec:	f004 7180 	andmi.w	r1, r4, #16777216	; 0x1000000
 8001df0:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_SRAM2_PE;
 8001df2:	f043 7380 	orrmi.w	r3, r3, #16777216	; 0x1000000
    }

    if((UserType & OB_USER_SRAM2_RST) != 0U)
 8001df6:	0529      	lsls	r1, r5, #20
    {
      /* SRAM2_RST option byte should be modified */
      assert_param(IS_OB_USER_SRAM2_RST(UserConfig & FLASH_OPTR_SRAM2_RST));
    
      /* Set value and mask for SRAM2_RST option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_SRAM2_RST);
 8001df8:	bf42      	ittt	mi
 8001dfa:	f004 7100 	andmi.w	r1, r4, #33554432	; 0x2000000
 8001dfe:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_SRAM2_RST;
 8001e00:	f043 7300 	orrmi.w	r3, r3, #33554432	; 0x2000000

#if defined (STM32L431xx) || defined (STM32L432xx) || defined (STM32L433xx) || defined (STM32L442xx) || \
    defined (STM32L443xx) || defined (STM32L451xx) || defined (STM32L452xx) || defined (STM32L462xx) || \
    defined (STM32L496xx) || defined (STM32L4A6xx) || \
    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)
    if((UserType & OB_USER_nSWBOOT0) != 0U)
 8001e04:	04a8      	lsls	r0, r5, #18
    {
      /* nSWBOOT0 option byte should be modified */
      assert_param(IS_OB_USER_SWBOOT0(UserConfig & FLASH_OPTR_nSWBOOT0));
    
      /* Set value and mask for nSWBOOT0 option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nSWBOOT0);
 8001e06:	bf42      	ittt	mi
 8001e08:	f004 6180 	andmi.w	r1, r4, #67108864	; 0x4000000
 8001e0c:	430a      	orrmi	r2, r1
      optr_reg_mask |= FLASH_OPTR_nSWBOOT0;
 8001e0e:	f043 6380 	orrmi.w	r3, r3, #67108864	; 0x4000000
    }

    if((UserType & OB_USER_nBOOT0) != 0U)
 8001e12:	0469      	lsls	r1, r5, #17
    {
      /* nBOOT0 option byte should be modified */
      assert_param(IS_OB_USER_BOOT0(UserConfig & FLASH_OPTR_nBOOT0));
    
      /* Set value and mask for nBOOT0 option byte */
      optr_reg_val |= (UserConfig & FLASH_OPTR_nBOOT0);
 8001e14:	bf44      	itt	mi
 8001e16:	f004 6400 	andmi.w	r4, r4, #134217728	; 0x8000000
 8001e1a:	4322      	orrmi	r2, r4
      optr_reg_mask |= FLASH_OPTR_nBOOT0;
    }
#endif
    
    /* Configure the option bytes register */
    MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 8001e1c:	4c33      	ldr	r4, [pc, #204]	; (8001eec <HAL_FLASHEx_OBProgram+0x244>)
 8001e1e:	6a21      	ldr	r1, [r4, #32]
      optr_reg_mask |= FLASH_OPTR_nBOOT0;
 8001e20:	bf48      	it	mi
 8001e22:	f043 6300 	orrmi.w	r3, r3, #134217728	; 0x8000000
    MODIFY_REG(FLASH->OPTR, optr_reg_mask, optr_reg_val);
 8001e26:	ea21 0303 	bic.w	r3, r1, r3
 8001e2a:	431a      	orrs	r2, r3
 8001e2c:	6222      	str	r2, [r4, #32]
    
    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001e2e:	6963      	ldr	r3, [r4, #20]
 8001e30:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001e34:	6163      	str	r3, [r4, #20]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001e36:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001e3a:	f7ff fef7 	bl	8001c2c <FLASH_WaitForLastOperation>

    /* If the option byte program operation is completed, disable the OPTSTRT Bit */
    CLEAR_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001e3e:	6963      	ldr	r3, [r4, #20]
 8001e40:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8001e44:	6163      	str	r3, [r4, #20]
    if(FLASH_OB_UserConfig(pOBInit->USERType, pOBInit->USERConfig) != HAL_OK)
 8001e46:	b100      	cbz	r0, 8001e4a <HAL_FLASHEx_OBProgram+0x1a2>
      status = HAL_ERROR;
 8001e48:	2701      	movs	r7, #1
  if((pOBInit->OptionType & OPTIONBYTE_PCROP) != 0U)
 8001e4a:	6833      	ldr	r3, [r6, #0]
 8001e4c:	071a      	lsls	r2, r3, #28
 8001e4e:	d533      	bpl.n	8001eb8 <HAL_FLASHEx_OBProgram+0x210>
    if (pOBInit->PCROPStartAddr != pOBInit->PCROPEndAddr)
 8001e50:	f8d6 9020 	ldr.w	r9, [r6, #32]
 8001e54:	6a74      	ldr	r4, [r6, #36]	; 0x24
 8001e56:	45a1      	cmp	r9, r4
 8001e58:	d02e      	beq.n	8001eb8 <HAL_FLASHEx_OBProgram+0x210>
  assert_param(IS_OB_PCROP_RDP(PCROPConfig & FLASH_PCROP1ER_PCROP_RDP));
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROPStartAddr));
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(PCROPEndAddr));

  /* Wait for last operation to be completed */
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001e5a:	f24c 3050 	movw	r0, #50000	; 0xc350
      if(FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr) != HAL_OK)
 8001e5e:	69f5      	ldr	r5, [r6, #28]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001e60:	f7ff fee4 	bl	8001c2c <FLASH_WaitForLastOperation>

  if(status == HAL_OK)
 8001e64:	bb38      	cbnz	r0, 8001eb6 <HAL_FLASHEx_OBProgram+0x20e>
    }
    else
#endif
    {
      /* Configure the Proprietary code readout protection */
      if((PCROPConfig & FLASH_BANK_BOTH) == FLASH_BANK_1)
 8001e66:	07eb      	lsls	r3, r5, #31
 8001e68:	d510      	bpl.n	8001e8c <HAL_FLASHEx_OBProgram+0x1e4>
      {
        reg_value = ((PCROPStartAddr - bank1_addr) >> 3);
        MODIFY_REG(FLASH->PCROP1SR, FLASH_PCROP1SR_PCROP1_STRT, reg_value);
 8001e6a:	4b20      	ldr	r3, [pc, #128]	; (8001eec <HAL_FLASHEx_OBProgram+0x244>)
 8001e6c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8001e6e:	f5a0 4000 	sub.w	r0, r0, #32768	; 0x8000
        reg_value = ((PCROPStartAddr - bank1_addr) >> 3);
 8001e72:	f109 4978 	add.w	r9, r9, #4160749568	; 0xf8000000
        MODIFY_REG(FLASH->PCROP1SR, FLASH_PCROP1SR_PCROP1_STRT, reg_value);
 8001e76:	4001      	ands	r1, r0
 8001e78:	ea41 01d9 	orr.w	r1, r1, r9, lsr #3
 8001e7c:	6259      	str	r1, [r3, #36]	; 0x24
        
        reg_value = ((PCROPEndAddr - bank1_addr) >> 3);
        MODIFY_REG(FLASH->PCROP1ER, FLASH_PCROP1ER_PCROP1_END, reg_value);
 8001e7e:	6a9a      	ldr	r2, [r3, #40]	; 0x28
        reg_value = ((PCROPEndAddr - bank1_addr) >> 3);
 8001e80:	f104 4478 	add.w	r4, r4, #4160749568	; 0xf8000000
        MODIFY_REG(FLASH->PCROP1ER, FLASH_PCROP1ER_PCROP1_END, reg_value);
 8001e84:	4002      	ands	r2, r0
 8001e86:	ea42 02d4 	orr.w	r2, r2, r4, lsr #3
 8001e8a:	629a      	str	r2, [r3, #40]	; 0x28
      {
        /* Nothing to do */
      }
    }
    
    MODIFY_REG(FLASH->PCROP1ER, FLASH_PCROP1ER_PCROP_RDP, (PCROPConfig & FLASH_PCROP1ER_PCROP_RDP));
 8001e8c:	4c17      	ldr	r4, [pc, #92]	; (8001eec <HAL_FLASHEx_OBProgram+0x244>)
 8001e8e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001e90:	f005 4500 	and.w	r5, r5, #2147483648	; 0x80000000
 8001e94:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8001e98:	432b      	orrs	r3, r5
 8001e9a:	62a3      	str	r3, [r4, #40]	; 0x28
    
    /* Set OPTSTRT Bit */
    SET_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001e9c:	6963      	ldr	r3, [r4, #20]
 8001e9e:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8001ea2:	6163      	str	r3, [r4, #20]
    
    /* Wait for last operation to be completed */
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001ea4:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001ea8:	f7ff fec0 	bl	8001c2c <FLASH_WaitForLastOperation>

    /* If the option byte program operation is completed, disable the OPTSTRT Bit */
    CLEAR_BIT(FLASH->CR, FLASH_CR_OPTSTRT);
 8001eac:	6963      	ldr	r3, [r4, #20]
 8001eae:	f423 3300 	bic.w	r3, r3, #131072	; 0x20000
 8001eb2:	6163      	str	r3, [r4, #20]
      if(FLASH_OB_PCROPConfig(pOBInit->PCROPConfig, pOBInit->PCROPStartAddr, pOBInit->PCROPEndAddr) != HAL_OK)
 8001eb4:	b100      	cbz	r0, 8001eb8 <HAL_FLASHEx_OBProgram+0x210>
        status = HAL_ERROR;
 8001eb6:	2701      	movs	r7, #1
  __HAL_UNLOCK(&pFlash);
 8001eb8:	2300      	movs	r3, #0
 8001eba:	f888 3000 	strb.w	r3, [r8]
}
 8001ebe:	4638      	mov	r0, r7
 8001ec0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if(WRPArea == OB_WRPAREA_BANK1_AREAB)
 8001ec4:	f1ba 0f01 	cmp.w	sl, #1
 8001ec8:	f47f af17 	bne.w	8001cfa <HAL_FLASHEx_OBProgram+0x52>
      MODIFY_REG(FLASH->WRP1BR, (FLASH_WRP1BR_WRP1B_STRT | FLASH_WRP1BR_WRP1B_END), 
 8001ecc:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8001ece:	f003 23ff 	and.w	r3, r3, #4278255360	; 0xff00ff00
 8001ed2:	ea43 0309 	orr.w	r3, r3, r9
 8001ed6:	ea43 4305 	orr.w	r3, r3, r5, lsl #16
 8001eda:	6323      	str	r3, [r4, #48]	; 0x30
 8001edc:	e70d      	b.n	8001cfa <HAL_FLASHEx_OBProgram+0x52>
  HAL_StatusTypeDef status = HAL_OK;
 8001ede:	461f      	mov	r7, r3
 8001ee0:	e71a      	b.n	8001d18 <HAL_FLASHEx_OBProgram+0x70>
  __HAL_LOCK(&pFlash);
 8001ee2:	2702      	movs	r7, #2
 8001ee4:	e7eb      	b.n	8001ebe <HAL_FLASHEx_OBProgram+0x216>
 8001ee6:	bf00      	nop
 8001ee8:	20000000 	.word	0x20000000
 8001eec:	40022000 	.word	0x40022000

08001ef0 <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8001ef0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != RESET)
 8001ef4:	f8d1 8000 	ldr.w	r8, [r1]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001ef8:	f8df 9174 	ldr.w	r9, [pc, #372]	; 8002070 <HAL_GPIO_Init+0x180>
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
        SYSCFG->EXTICR[position >> 2] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8001efc:	4a5a      	ldr	r2, [pc, #360]	; (8002068 <HAL_GPIO_Init+0x178>)
  uint32_t position = 0x00;
 8001efe:	2300      	movs	r3, #0
  while (((GPIO_Init->Pin) >> position) != RESET)
 8001f00:	fa38 f403 	lsrs.w	r4, r8, r3
 8001f04:	d102      	bne.n	8001f0c <HAL_GPIO_Init+0x1c>
      }
    }
    
    position++;
  }
}
 8001f06:	b003      	add	sp, #12
 8001f08:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1U << position);
 8001f0c:	2401      	movs	r4, #1
 8001f0e:	fa04 fa03 	lsl.w	sl, r4, r3
    if(iocurrent)
 8001f12:	ea18 050a 	ands.w	r5, r8, sl
 8001f16:	f000 809c 	beq.w	8002052 <HAL_GPIO_Init+0x162>
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001f1a:	684c      	ldr	r4, [r1, #4]
 8001f1c:	f024 0b10 	bic.w	fp, r4, #16
 8001f20:	f1bb 0f02 	cmp.w	fp, #2
 8001f24:	d114      	bne.n	8001f50 <HAL_GPIO_Init+0x60>
        temp = GPIOx->AFR[position >> 3];
 8001f26:	ea4f 0ed3 	mov.w	lr, r3, lsr #3
 8001f2a:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001f2e:	f003 0c07 	and.w	ip, r3, #7
        temp = GPIOx->AFR[position >> 3];
 8001f32:	f8de 6020 	ldr.w	r6, [lr, #32]
        temp &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8001f36:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8001f3a:	270f      	movs	r7, #15
 8001f3c:	fa07 f70c 	lsl.w	r7, r7, ip
 8001f40:	ea26 0707 	bic.w	r7, r6, r7
        temp |= ((uint32_t)(GPIO_Init->Alternate) << (((uint32_t)position & (uint32_t)0x07) * 4));
 8001f44:	690e      	ldr	r6, [r1, #16]
 8001f46:	fa06 f60c 	lsl.w	r6, r6, ip
 8001f4a:	433e      	orrs	r6, r7
        GPIOx->AFR[position >> 3] = temp;
 8001f4c:	f8ce 6020 	str.w	r6, [lr, #32]
 8001f50:	ea4f 0c43 	mov.w	ip, r3, lsl #1
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8001f54:	2703      	movs	r7, #3
      temp = GPIOx->MODER;
 8001f56:	6806      	ldr	r6, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8001f58:	fa07 f70c 	lsl.w	r7, r7, ip
 8001f5c:	43ff      	mvns	r7, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001f5e:	f004 0e03 	and.w	lr, r4, #3
      temp &= ~(GPIO_MODER_MODE0 << (position * 2));
 8001f62:	403e      	ands	r6, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001f64:	fa0e fe0c 	lsl.w	lr, lr, ip
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001f68:	f10b 3bff 	add.w	fp, fp, #4294967295
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2));
 8001f6c:	ea4e 0606 	orr.w	r6, lr, r6
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001f70:	f1bb 0f01 	cmp.w	fp, #1
      GPIOx->MODER = temp;
 8001f74:	6006      	str	r6, [r0, #0]
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001f76:	d811      	bhi.n	8001f9c <HAL_GPIO_Init+0xac>
        temp = GPIOx->OSPEEDR;
 8001f78:	6886      	ldr	r6, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 8001f7a:	ea06 0b07 	and.w	fp, r6, r7
        temp |= (GPIO_Init->Speed << (position * 2));
 8001f7e:	68ce      	ldr	r6, [r1, #12]
 8001f80:	fa06 fe0c 	lsl.w	lr, r6, ip
 8001f84:	ea4e 060b 	orr.w	r6, lr, fp
        GPIOx->OSPEEDR = temp;
 8001f88:	6086      	str	r6, [r0, #8]
        temp = GPIOx->OTYPER;
 8001f8a:	6846      	ldr	r6, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8001f8c:	ea26 0a0a 	bic.w	sl, r6, sl
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4) << position);
 8001f90:	f3c4 1600 	ubfx	r6, r4, #4, #1
 8001f94:	409e      	lsls	r6, r3
 8001f96:	ea46 060a 	orr.w	r6, r6, sl
        GPIOx->OTYPER = temp;
 8001f9a:	6046      	str	r6, [r0, #4]
      temp = GPIOx->PUPDR;
 8001f9c:	68c6      	ldr	r6, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 8001f9e:	4037      	ands	r7, r6
      temp |= ((GPIO_Init->Pull) << (position * 2));
 8001fa0:	688e      	ldr	r6, [r1, #8]
 8001fa2:	fa06 f60c 	lsl.w	r6, r6, ip
 8001fa6:	4337      	orrs	r7, r6
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001fa8:	00e6      	lsls	r6, r4, #3
      GPIOx->PUPDR = temp;
 8001faa:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8001fac:	d551      	bpl.n	8002052 <HAL_GPIO_Init+0x162>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fae:	f8d9 6060 	ldr.w	r6, [r9, #96]	; 0x60
 8001fb2:	f046 0601 	orr.w	r6, r6, #1
 8001fb6:	f8c9 6060 	str.w	r6, [r9, #96]	; 0x60
 8001fba:	f8d9 6060 	ldr.w	r6, [r9, #96]	; 0x60
 8001fbe:	f023 0703 	bic.w	r7, r3, #3
 8001fc2:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 8001fc6:	f006 0601 	and.w	r6, r6, #1
 8001fca:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 8001fce:	9601      	str	r6, [sp, #4]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001fd0:	f003 0c03 	and.w	ip, r3, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 8001fd4:	9e01      	ldr	r6, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2];
 8001fd6:	68be      	ldr	r6, [r7, #8]
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001fd8:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8001fdc:	f04f 0e0f 	mov.w	lr, #15
 8001fe0:	fa0e fe0c 	lsl.w	lr, lr, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 8001fe4:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(((uint32_t)0x0F) << (4 * (position & 0x03)));
 8001fe8:	ea26 0e0e 	bic.w	lr, r6, lr
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 8001fec:	d033      	beq.n	8002056 <HAL_GPIO_Init+0x166>
 8001fee:	4e1f      	ldr	r6, [pc, #124]	; (800206c <HAL_GPIO_Init+0x17c>)
 8001ff0:	42b0      	cmp	r0, r6
 8001ff2:	d032      	beq.n	800205a <HAL_GPIO_Init+0x16a>
 8001ff4:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8001ff8:	42b0      	cmp	r0, r6
 8001ffa:	d030      	beq.n	800205e <HAL_GPIO_Init+0x16e>
 8001ffc:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8002000:	42b0      	cmp	r0, r6
 8002002:	d02e      	beq.n	8002062 <HAL_GPIO_Init+0x172>
 8002004:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8002008:	42b0      	cmp	r0, r6
 800200a:	bf14      	ite	ne
 800200c:	2607      	movne	r6, #7
 800200e:	2604      	moveq	r6, #4
 8002010:	fa06 f60c 	lsl.w	r6, r6, ip
 8002014:	ea46 060e 	orr.w	r6, r6, lr
        SYSCFG->EXTICR[position >> 2] = temp;
 8002018:	60be      	str	r6, [r7, #8]
        temp = EXTI->IMR1;
 800201a:	6816      	ldr	r6, [r2, #0]
        temp &= ~((uint32_t)iocurrent);
 800201c:	43ef      	mvns	r7, r5
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 800201e:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~((uint32_t)iocurrent);
 8002022:	bf0c      	ite	eq
 8002024:	403e      	andeq	r6, r7
          temp |= iocurrent;
 8002026:	432e      	orrne	r6, r5
        EXTI->IMR1 = temp;
 8002028:	6016      	str	r6, [r2, #0]
        temp = EXTI->EMR1;
 800202a:	6856      	ldr	r6, [r2, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 800202c:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~((uint32_t)iocurrent);
 8002030:	bf0c      	ite	eq
 8002032:	403e      	andeq	r6, r7
          temp |= iocurrent;
 8002034:	432e      	orrne	r6, r5
        EXTI->EMR1 = temp;
 8002036:	6056      	str	r6, [r2, #4]
        temp = EXTI->RTSR1;
 8002038:	6896      	ldr	r6, [r2, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 800203a:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~((uint32_t)iocurrent);
 800203e:	bf0c      	ite	eq
 8002040:	403e      	andeq	r6, r7
          temp |= iocurrent;
 8002042:	432e      	orrne	r6, r5
        EXTI->RTSR1 = temp;
 8002044:	6096      	str	r6, [r2, #8]
        temp = EXTI->FTSR1;
 8002046:	68d6      	ldr	r6, [r2, #12]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8002048:	02a4      	lsls	r4, r4, #10
        temp &= ~((uint32_t)iocurrent);
 800204a:	bf54      	ite	pl
 800204c:	403e      	andpl	r6, r7
          temp |= iocurrent;
 800204e:	432e      	orrmi	r6, r5
        EXTI->FTSR1 = temp;
 8002050:	60d6      	str	r6, [r2, #12]
    position++;
 8002052:	3301      	adds	r3, #1
 8002054:	e754      	b.n	8001f00 <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03)));
 8002056:	2600      	movs	r6, #0
 8002058:	e7da      	b.n	8002010 <HAL_GPIO_Init+0x120>
 800205a:	2601      	movs	r6, #1
 800205c:	e7d8      	b.n	8002010 <HAL_GPIO_Init+0x120>
 800205e:	2602      	movs	r6, #2
 8002060:	e7d6      	b.n	8002010 <HAL_GPIO_Init+0x120>
 8002062:	2603      	movs	r6, #3
 8002064:	e7d4      	b.n	8002010 <HAL_GPIO_Init+0x120>
 8002066:	bf00      	nop
 8002068:	40010400 	.word	0x40010400
 800206c:	48000400 	.word	0x48000400
 8002070:	40021000 	.word	0x40021000

08002074 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin: specifies the port bit to be written.
  *         This parameter can be one of GPIO_PIN_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 8002074:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      {
        tmp = ((uint32_t)0x0F) << (4 * (position & 0x03));
        SYSCFG->EXTICR[position >> 2] &= ~tmp;

        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 8002078:	4c37      	ldr	r4, [pc, #220]	; (8002158 <HAL_GPIO_DeInit+0xe4>)
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 800207a:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 8002160 <HAL_GPIO_DeInit+0xec>
  uint32_t position = 0x00;
 800207e:	2300      	movs	r3, #0
    iocurrent = (GPIO_Pin) & (1U << position);
 8002080:	f04f 0c01 	mov.w	ip, #1
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2));
 8002084:	f04f 0803 	mov.w	r8, #3
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 8002088:	f04f 0e0f 	mov.w	lr, #15
  while ((GPIO_Pin >> position) != RESET)
 800208c:	fa31 f203 	lsrs.w	r2, r1, r3
 8002090:	d101      	bne.n	8002096 <HAL_GPIO_DeInit+0x22>
      }
    }
    
    position++;
  }
}
 8002092:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1U << position);
 8002096:	fa0c fa03 	lsl.w	sl, ip, r3
    if (iocurrent)
 800209a:	ea11 050a 	ands.w	r5, r1, sl
 800209e:	d051      	beq.n	8002144 <HAL_GPIO_DeInit+0xd0>
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2));
 80020a0:	6806      	ldr	r6, [r0, #0]
 80020a2:	005a      	lsls	r2, r3, #1
 80020a4:	fa08 f202 	lsl.w	r2, r8, r2
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80020a8:	08df      	lsrs	r7, r3, #3
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2));
 80020aa:	4316      	orrs	r6, r2
 80020ac:	eb00 0787 	add.w	r7, r0, r7, lsl #2
 80020b0:	6006      	str	r6, [r0, #0]
      GPIOx->AFR[position >> 3] &= ~((uint32_t)0xF << ((uint32_t)(position & (uint32_t)0x07) * 4)) ;
 80020b2:	f003 0607 	and.w	r6, r3, #7
 80020b6:	f8d7 b020 	ldr.w	fp, [r7, #32]
 80020ba:	00b6      	lsls	r6, r6, #2
 80020bc:	fa0e f606 	lsl.w	r6, lr, r6
 80020c0:	ea2b 0606 	bic.w	r6, fp, r6
 80020c4:	623e      	str	r6, [r7, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2));
 80020c6:	6886      	ldr	r6, [r0, #8]
 80020c8:	43d2      	mvns	r2, r2
 80020ca:	4016      	ands	r6, r2
 80020cc:	6086      	str	r6, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 80020ce:	6846      	ldr	r6, [r0, #4]
 80020d0:	ea26 060a 	bic.w	r6, r6, sl
 80020d4:	6046      	str	r6, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2));
 80020d6:	68c6      	ldr	r6, [r0, #12]
 80020d8:	4032      	ands	r2, r6
 80020da:	60c2      	str	r2, [r0, #12]
 80020dc:	f023 0203 	bic.w	r2, r3, #3
 80020e0:	f102 4280 	add.w	r2, r2, #1073741824	; 0x40000000
 80020e4:	f502 3280 	add.w	r2, r2, #65536	; 0x10000
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 80020e8:	f003 0703 	and.w	r7, r3, #3
      tmp = SYSCFG->EXTICR[position >> 2];
 80020ec:	6896      	ldr	r6, [r2, #8]
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 80020ee:	00bf      	lsls	r7, r7, #2
 80020f0:	fa0e fb07 	lsl.w	fp, lr, r7
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 80020f4:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      tmp &= (((uint32_t)0x0F) << (4 * (position & 0x03)));
 80020f8:	ea06 0a0b 	and.w	sl, r6, fp
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 80020fc:	d024      	beq.n	8002148 <HAL_GPIO_DeInit+0xd4>
 80020fe:	4e17      	ldr	r6, [pc, #92]	; (800215c <HAL_GPIO_DeInit+0xe8>)
 8002100:	42b0      	cmp	r0, r6
 8002102:	d023      	beq.n	800214c <HAL_GPIO_DeInit+0xd8>
 8002104:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8002108:	42b0      	cmp	r0, r6
 800210a:	d021      	beq.n	8002150 <HAL_GPIO_DeInit+0xdc>
 800210c:	f506 6680 	add.w	r6, r6, #1024	; 0x400
 8002110:	42b0      	cmp	r0, r6
 8002112:	d01f      	beq.n	8002154 <HAL_GPIO_DeInit+0xe0>
 8002114:	4548      	cmp	r0, r9
 8002116:	bf0c      	ite	eq
 8002118:	2604      	moveq	r6, #4
 800211a:	2607      	movne	r6, #7
 800211c:	40be      	lsls	r6, r7
 800211e:	45b2      	cmp	sl, r6
 8002120:	d110      	bne.n	8002144 <HAL_GPIO_DeInit+0xd0>
        SYSCFG->EXTICR[position >> 2] &= ~tmp;
 8002122:	6896      	ldr	r6, [r2, #8]
 8002124:	ea26 060b 	bic.w	r6, r6, fp
 8002128:	6096      	str	r6, [r2, #8]
        EXTI->IMR1 &= ~((uint32_t)iocurrent);
 800212a:	6822      	ldr	r2, [r4, #0]
 800212c:	43ed      	mvns	r5, r5
 800212e:	402a      	ands	r2, r5
 8002130:	6022      	str	r2, [r4, #0]
        EXTI->EMR1 &= ~((uint32_t)iocurrent);
 8002132:	6862      	ldr	r2, [r4, #4]
 8002134:	402a      	ands	r2, r5
 8002136:	6062      	str	r2, [r4, #4]
        EXTI->RTSR1 &= ~((uint32_t)iocurrent);
 8002138:	68a2      	ldr	r2, [r4, #8]
 800213a:	402a      	ands	r2, r5
 800213c:	60a2      	str	r2, [r4, #8]
        EXTI->FTSR1 &= ~((uint32_t)iocurrent);
 800213e:	68e2      	ldr	r2, [r4, #12]
 8002140:	4015      	ands	r5, r2
 8002142:	60e5      	str	r5, [r4, #12]
    position++;
 8002144:	3301      	adds	r3, #1
 8002146:	e7a1      	b.n	800208c <HAL_GPIO_DeInit+0x18>
      if(tmp == (GPIO_GET_INDEX(GPIOx) << (4 * (position & 0x03))))
 8002148:	2600      	movs	r6, #0
 800214a:	e7e7      	b.n	800211c <HAL_GPIO_DeInit+0xa8>
 800214c:	2601      	movs	r6, #1
 800214e:	e7e5      	b.n	800211c <HAL_GPIO_DeInit+0xa8>
 8002150:	2602      	movs	r6, #2
 8002152:	e7e3      	b.n	800211c <HAL_GPIO_DeInit+0xa8>
 8002154:	2603      	movs	r6, #3
 8002156:	e7e1      	b.n	800211c <HAL_GPIO_DeInit+0xa8>
 8002158:	40010400 	.word	0x40010400
 800215c:	48000400 	.word	0x48000400
 8002160:	48001000 	.word	0x48001000

08002164 <HAL_GPIO_ReadPin>:
  GPIO_PinState bitstatus;

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  if((GPIOx->IDR & GPIO_Pin) != (uint32_t)GPIO_PIN_RESET)
 8002164:	6903      	ldr	r3, [r0, #16]
 8002166:	4219      	tst	r1, r3
  else
  {
    bitstatus = GPIO_PIN_RESET;
  }
  return bitstatus;
}
 8002168:	bf14      	ite	ne
 800216a:	2001      	movne	r0, #1
 800216c:	2000      	moveq	r0, #0
 800216e:	4770      	bx	lr

08002170 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 8002170:	b10a      	cbz	r2, 8002176 <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 8002172:	6181      	str	r1, [r0, #24]
 8002174:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 8002176:	6281      	str	r1, [r0, #40]	; 0x28
 8002178:	4770      	bx	lr

0800217a <HAL_GPIO_TogglePin>:
void HAL_GPIO_TogglePin(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  GPIOx->ODR ^= GPIO_Pin;
 800217a:	6943      	ldr	r3, [r0, #20]
 800217c:	4059      	eors	r1, r3
 800217e:	6141      	str	r1, [r0, #20]
 8002180:	4770      	bx	lr

08002182 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 8002182:	6803      	ldr	r3, [r0, #0]
 8002184:	699a      	ldr	r2, [r3, #24]
 8002186:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
 8002188:	bf44      	itt	mi
 800218a:	2200      	movmi	r2, #0
 800218c:	629a      	strmi	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 800218e:	699a      	ldr	r2, [r3, #24]
 8002190:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 8002192:	bf5e      	ittt	pl
 8002194:	699a      	ldrpl	r2, [r3, #24]
 8002196:	f042 0201 	orrpl.w	r2, r2, #1
 800219a:	619a      	strpl	r2, [r3, #24]
 800219c:	4770      	bx	lr

0800219e <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
 800219e:	b530      	push	{r4, r5, lr}
 80021a0:	9c03      	ldr	r4, [sp, #12]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 80021a2:	6805      	ldr	r5, [r0, #0]
 80021a4:	4323      	orrs	r3, r4
 80021a6:	0d64      	lsrs	r4, r4, #21
 80021a8:	f404 6480 	and.w	r4, r4, #1024	; 0x400
 80021ac:	f044 747f 	orr.w	r4, r4, #66846720	; 0x3fc0000
 80021b0:	f444 3458 	orr.w	r4, r4, #221184	; 0x36000
 80021b4:	6868      	ldr	r0, [r5, #4]
 80021b6:	f3c1 0109 	ubfx	r1, r1, #0, #10
 80021ba:	f444 747f 	orr.w	r4, r4, #1020	; 0x3fc
 80021be:	4319      	orrs	r1, r3
 80021c0:	f044 0403 	orr.w	r4, r4, #3
 80021c4:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 80021c8:	ea20 0404 	bic.w	r4, r0, r4
 80021cc:	4321      	orrs	r1, r4
 80021ce:	6069      	str	r1, [r5, #4]
 80021d0:	bd30      	pop	{r4, r5, pc}

080021d2 <I2C_WaitOnFlagUntilTimeout>:
{
 80021d2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80021d6:	9f06      	ldr	r7, [sp, #24]
 80021d8:	4604      	mov	r4, r0
 80021da:	4688      	mov	r8, r1
 80021dc:	4616      	mov	r6, r2
 80021de:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 80021e0:	6822      	ldr	r2, [r4, #0]
 80021e2:	6993      	ldr	r3, [r2, #24]
 80021e4:	ea38 0303 	bics.w	r3, r8, r3
 80021e8:	bf0c      	ite	eq
 80021ea:	2301      	moveq	r3, #1
 80021ec:	2300      	movne	r3, #0
 80021ee:	42b3      	cmp	r3, r6
 80021f0:	d002      	beq.n	80021f8 <I2C_WaitOnFlagUntilTimeout+0x26>
  return HAL_OK;
 80021f2:	2000      	movs	r0, #0
}
 80021f4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (Timeout != HAL_MAX_DELAY)
 80021f8:	1c6b      	adds	r3, r5, #1
 80021fa:	d0f2      	beq.n	80021e2 <I2C_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80021fc:	f7fe fe48 	bl	8000e90 <HAL_GetTick>
 8002200:	1bc0      	subs	r0, r0, r7
 8002202:	4285      	cmp	r5, r0
 8002204:	d301      	bcc.n	800220a <I2C_WaitOnFlagUntilTimeout+0x38>
 8002206:	2d00      	cmp	r5, #0
 8002208:	d1ea      	bne.n	80021e0 <I2C_WaitOnFlagUntilTimeout+0xe>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800220a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800220c:	f043 0320 	orr.w	r3, r3, #32
 8002210:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8002212:	2320      	movs	r3, #32
 8002214:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8002218:	2300      	movs	r3, #0
 800221a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 800221e:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8002222:	2001      	movs	r0, #1
 8002224:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08002228 <I2C_IsAcknowledgeFailed>:
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8002228:	6803      	ldr	r3, [r0, #0]
{
 800222a:	b570      	push	{r4, r5, r6, lr}
 800222c:	4604      	mov	r4, r0
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 800222e:	6998      	ldr	r0, [r3, #24]
 8002230:	f010 0010 	ands.w	r0, r0, #16
{
 8002234:	460d      	mov	r5, r1
 8002236:	4616      	mov	r6, r2
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8002238:	d116      	bne.n	8002268 <I2C_IsAcknowledgeFailed+0x40>
 800223a:	bd70      	pop	{r4, r5, r6, pc}
      if (Timeout != HAL_MAX_DELAY)
 800223c:	1c69      	adds	r1, r5, #1
 800223e:	d014      	beq.n	800226a <I2C_IsAcknowledgeFailed+0x42>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002240:	f7fe fe26 	bl	8000e90 <HAL_GetTick>
 8002244:	1b80      	subs	r0, r0, r6
 8002246:	4285      	cmp	r5, r0
 8002248:	d300      	bcc.n	800224c <I2C_IsAcknowledgeFailed+0x24>
 800224a:	b96d      	cbnz	r5, 8002268 <I2C_IsAcknowledgeFailed+0x40>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800224c:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800224e:	f043 0320 	orr.w	r3, r3, #32
 8002252:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8002254:	2320      	movs	r3, #32
 8002256:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 800225a:	2300      	movs	r3, #0
 800225c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    __HAL_UNLOCK(hi2c);
 8002260:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    return HAL_ERROR;
 8002264:	2001      	movs	r0, #1
}
 8002266:	bd70      	pop	{r4, r5, r6, pc}
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8002268:	6823      	ldr	r3, [r4, #0]
 800226a:	6999      	ldr	r1, [r3, #24]
 800226c:	068a      	lsls	r2, r1, #26
 800226e:	d5e5      	bpl.n	800223c <I2C_IsAcknowledgeFailed+0x14>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002270:	2210      	movs	r2, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002272:	2520      	movs	r5, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8002274:	61da      	str	r2, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 8002276:	4620      	mov	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002278:	61dd      	str	r5, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 800227a:	f7ff ff82 	bl	8002182 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 800227e:	6822      	ldr	r2, [r4, #0]
 8002280:	6853      	ldr	r3, [r2, #4]
 8002282:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 8002286:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
 800228a:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 800228e:	f023 0301 	bic.w	r3, r3, #1
 8002292:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8002294:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002296:	f043 0304 	orr.w	r3, r3, #4
 800229a:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 800229c:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
 80022a0:	e7db      	b.n	800225a <I2C_IsAcknowledgeFailed+0x32>

080022a2 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 80022a2:	b570      	push	{r4, r5, r6, lr}
 80022a4:	4604      	mov	r4, r0
 80022a6:	460d      	mov	r5, r1
 80022a8:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 80022aa:	6823      	ldr	r3, [r4, #0]
 80022ac:	699b      	ldr	r3, [r3, #24]
 80022ae:	079b      	lsls	r3, r3, #30
 80022b0:	d501      	bpl.n	80022b6 <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
 80022b2:	2000      	movs	r0, #0
 80022b4:	bd70      	pop	{r4, r5, r6, pc}
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 80022b6:	4632      	mov	r2, r6
 80022b8:	4629      	mov	r1, r5
 80022ba:	4620      	mov	r0, r4
 80022bc:	f7ff ffb4 	bl	8002228 <I2C_IsAcknowledgeFailed>
 80022c0:	b9a0      	cbnz	r0, 80022ec <I2C_WaitOnTXISFlagUntilTimeout+0x4a>
    if (Timeout != HAL_MAX_DELAY)
 80022c2:	1c6a      	adds	r2, r5, #1
 80022c4:	d0f1      	beq.n	80022aa <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80022c6:	f7fe fde3 	bl	8000e90 <HAL_GetTick>
 80022ca:	1b80      	subs	r0, r0, r6
 80022cc:	4285      	cmp	r5, r0
 80022ce:	d301      	bcc.n	80022d4 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
 80022d0:	2d00      	cmp	r5, #0
 80022d2:	d1ea      	bne.n	80022aa <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 80022d4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80022d6:	f043 0320 	orr.w	r3, r3, #32
 80022da:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 80022dc:	2320      	movs	r3, #32
 80022de:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 80022e2:	2300      	movs	r3, #0
 80022e4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 80022e8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 80022ec:	2001      	movs	r0, #1
}
 80022ee:	bd70      	pop	{r4, r5, r6, pc}

080022f0 <I2C_RequestMemoryRead>:
{
 80022f0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80022f2:	9e09      	ldr	r6, [sp, #36]	; 0x24
 80022f4:	461f      	mov	r7, r3
  I2C_TransferConfig(hi2c, DevAddress, MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 80022f6:	4b16      	ldr	r3, [pc, #88]	; (8002350 <I2C_RequestMemoryRead+0x60>)
 80022f8:	9300      	str	r3, [sp, #0]
{
 80022fa:	4605      	mov	r5, r0
 80022fc:	4614      	mov	r4, r2
  I2C_TransferConfig(hi2c, DevAddress, MemAddSize, I2C_SOFTEND_MODE, I2C_GENERATE_START_WRITE);
 80022fe:	2300      	movs	r3, #0
 8002300:	b2fa      	uxtb	r2, r7
 8002302:	f7ff ff4c 	bl	800219e <I2C_TransferConfig>
  if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 8002306:	4632      	mov	r2, r6
 8002308:	9908      	ldr	r1, [sp, #32]
 800230a:	4628      	mov	r0, r5
 800230c:	f7ff ffc9 	bl	80022a2 <I2C_WaitOnTXISFlagUntilTimeout>
 8002310:	b110      	cbz	r0, 8002318 <I2C_RequestMemoryRead+0x28>
    return HAL_ERROR;
 8002312:	2001      	movs	r0, #1
}
 8002314:	b003      	add	sp, #12
 8002316:	bdf0      	pop	{r4, r5, r6, r7, pc}
  if (MemAddSize == I2C_MEMADD_SIZE_8BIT)
 8002318:	2f01      	cmp	r7, #1
 800231a:	682b      	ldr	r3, [r5, #0]
 800231c:	d10c      	bne.n	8002338 <I2C_RequestMemoryRead+0x48>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800231e:	b2e4      	uxtb	r4, r4
 8002320:	629c      	str	r4, [r3, #40]	; 0x28
  if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TC, RESET, Timeout, Tickstart) != HAL_OK)
 8002322:	9b08      	ldr	r3, [sp, #32]
 8002324:	9600      	str	r6, [sp, #0]
 8002326:	2200      	movs	r2, #0
 8002328:	2140      	movs	r1, #64	; 0x40
 800232a:	4628      	mov	r0, r5
 800232c:	f7ff ff51 	bl	80021d2 <I2C_WaitOnFlagUntilTimeout>
    return HAL_ERROR;
 8002330:	3000      	adds	r0, #0
 8002332:	bf18      	it	ne
 8002334:	2001      	movne	r0, #1
 8002336:	e7ed      	b.n	8002314 <I2C_RequestMemoryRead+0x24>
    hi2c->Instance->TXDR = I2C_MEM_ADD_MSB(MemAddress);
 8002338:	0a22      	lsrs	r2, r4, #8
 800233a:	629a      	str	r2, [r3, #40]	; 0x28
    if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, Tickstart) != HAL_OK)
 800233c:	9908      	ldr	r1, [sp, #32]
 800233e:	4632      	mov	r2, r6
 8002340:	4628      	mov	r0, r5
 8002342:	f7ff ffae 	bl	80022a2 <I2C_WaitOnTXISFlagUntilTimeout>
 8002346:	2800      	cmp	r0, #0
 8002348:	d1e3      	bne.n	8002312 <I2C_RequestMemoryRead+0x22>
    hi2c->Instance->TXDR = I2C_MEM_ADD_LSB(MemAddress);
 800234a:	682b      	ldr	r3, [r5, #0]
 800234c:	e7e7      	b.n	800231e <I2C_RequestMemoryRead+0x2e>
 800234e:	bf00      	nop
 8002350:	80002000 	.word	0x80002000

08002354 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8002354:	b570      	push	{r4, r5, r6, lr}
 8002356:	4604      	mov	r4, r0
 8002358:	460d      	mov	r5, r1
 800235a:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 800235c:	6823      	ldr	r3, [r4, #0]
 800235e:	699b      	ldr	r3, [r3, #24]
 8002360:	069b      	lsls	r3, r3, #26
 8002362:	d501      	bpl.n	8002368 <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
 8002364:	2000      	movs	r0, #0
 8002366:	bd70      	pop	{r4, r5, r6, pc}
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8002368:	4632      	mov	r2, r6
 800236a:	4629      	mov	r1, r5
 800236c:	4620      	mov	r0, r4
 800236e:	f7ff ff5b 	bl	8002228 <I2C_IsAcknowledgeFailed>
 8002372:	b990      	cbnz	r0, 800239a <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8002374:	f7fe fd8c 	bl	8000e90 <HAL_GetTick>
 8002378:	1b80      	subs	r0, r0, r6
 800237a:	4285      	cmp	r5, r0
 800237c:	d301      	bcc.n	8002382 <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
 800237e:	2d00      	cmp	r5, #0
 8002380:	d1ec      	bne.n	800235c <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8002382:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8002384:	f043 0320 	orr.w	r3, r3, #32
 8002388:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 800238a:	2320      	movs	r3, #32
 800238c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      hi2c->Mode = HAL_I2C_MODE_NONE;
 8002390:	2300      	movs	r3, #0
 8002392:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 8002396:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 800239a:	2001      	movs	r0, #1
}
 800239c:	bd70      	pop	{r4, r5, r6, pc}

0800239e <I2C_WaitOnRXNEFlagUntilTimeout>:
{
 800239e:	b570      	push	{r4, r5, r6, lr}
 80023a0:	4604      	mov	r4, r0
 80023a2:	460d      	mov	r5, r1
 80023a4:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 80023a6:	6823      	ldr	r3, [r4, #0]
 80023a8:	699b      	ldr	r3, [r3, #24]
 80023aa:	075b      	lsls	r3, r3, #29
 80023ac:	d40e      	bmi.n	80023cc <I2C_WaitOnRXNEFlagUntilTimeout+0x2e>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 80023ae:	4632      	mov	r2, r6
 80023b0:	4629      	mov	r1, r5
 80023b2:	4620      	mov	r0, r4
 80023b4:	f7ff ff38 	bl	8002228 <I2C_IsAcknowledgeFailed>
 80023b8:	b9f0      	cbnz	r0, 80023f8 <I2C_WaitOnRXNEFlagUntilTimeout+0x5a>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 80023ba:	6823      	ldr	r3, [r4, #0]
 80023bc:	699a      	ldr	r2, [r3, #24]
 80023be:	0691      	lsls	r1, r2, #26
 80023c0:	d51c      	bpl.n	80023fc <I2C_WaitOnRXNEFlagUntilTimeout+0x5e>
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
 80023c2:	699a      	ldr	r2, [r3, #24]
 80023c4:	0752      	lsls	r2, r2, #29
 80023c6:	d503      	bpl.n	80023d0 <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
 80023c8:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 80023ca:	b10a      	cbz	r2, 80023d0 <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
        return HAL_OK;
 80023cc:	2000      	movs	r0, #0
 80023ce:	bd70      	pop	{r4, r5, r6, pc}
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80023d0:	2120      	movs	r1, #32
 80023d2:	61d9      	str	r1, [r3, #28]
        I2C_RESET_CR2(hi2c);
 80023d4:	685a      	ldr	r2, [r3, #4]
 80023d6:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 80023da:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 80023de:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 80023e2:	f022 0201 	bic.w	r2, r2, #1
 80023e6:	605a      	str	r2, [r3, #4]
        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80023e8:	2300      	movs	r3, #0
 80023ea:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 80023ec:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 80023f0:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 80023f4:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 80023f8:	2001      	movs	r0, #1
}
 80023fa:	bd70      	pop	{r4, r5, r6, pc}
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80023fc:	f7fe fd48 	bl	8000e90 <HAL_GetTick>
 8002400:	1b80      	subs	r0, r0, r6
 8002402:	4285      	cmp	r5, r0
 8002404:	d301      	bcc.n	800240a <I2C_WaitOnRXNEFlagUntilTimeout+0x6c>
 8002406:	2d00      	cmp	r5, #0
 8002408:	d1cd      	bne.n	80023a6 <I2C_WaitOnRXNEFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 800240a:	6c63      	ldr	r3, [r4, #68]	; 0x44
 800240c:	f043 0320 	orr.w	r3, r3, #32
 8002410:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8002412:	2320      	movs	r3, #32
 8002414:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      __HAL_UNLOCK(hi2c);
 8002418:	2300      	movs	r3, #0
 800241a:	e7eb      	b.n	80023f4 <I2C_WaitOnRXNEFlagUntilTimeout+0x56>

0800241c <HAL_I2C_Init>:
{
 800241c:	b510      	push	{r4, lr}
  if (hi2c == NULL)
 800241e:	4604      	mov	r4, r0
 8002420:	b908      	cbnz	r0, 8002426 <HAL_I2C_Init+0xa>
    hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 8002422:	6460      	str	r0, [r4, #68]	; 0x44
 8002424:	deff      	udf	#255	; 0xff
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8002426:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 800242a:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 800242e:	b91b      	cbnz	r3, 8002438 <HAL_I2C_Init+0x1c>
    hi2c->Lock = HAL_UNLOCKED;
 8002430:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 8002434:	f007 fd7e 	bl	8009f34 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8002438:	2324      	movs	r3, #36	; 0x24
 800243a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 800243e:	6823      	ldr	r3, [r4, #0]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8002440:	68e1      	ldr	r1, [r4, #12]
  __HAL_I2C_DISABLE(hi2c);
 8002442:	681a      	ldr	r2, [r3, #0]
 8002444:	f022 0201 	bic.w	r2, r2, #1
 8002448:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 800244a:	6862      	ldr	r2, [r4, #4]
 800244c:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8002450:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8002452:	689a      	ldr	r2, [r3, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8002454:	2901      	cmp	r1, #1
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8002456:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800245a:	609a      	str	r2, [r3, #8]
 800245c:	68a2      	ldr	r2, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 800245e:	d124      	bne.n	80024aa <HAL_I2C_Init+0x8e>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8002460:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002464:	609a      	str	r2, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8002466:	685a      	ldr	r2, [r3, #4]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8002468:	6961      	ldr	r1, [r4, #20]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 800246a:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 800246e:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8002472:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8002474:	68da      	ldr	r2, [r3, #12]
 8002476:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800247a:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 800247c:	6922      	ldr	r2, [r4, #16]
 800247e:	430a      	orrs	r2, r1
 8002480:	69a1      	ldr	r1, [r4, #24]
 8002482:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8002486:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8002488:	6a21      	ldr	r1, [r4, #32]
 800248a:	69e2      	ldr	r2, [r4, #28]
 800248c:	430a      	orrs	r2, r1
 800248e:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8002490:	681a      	ldr	r2, [r3, #0]
 8002492:	f042 0201 	orr.w	r2, r2, #1
 8002496:	601a      	str	r2, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002498:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 800249a:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 800249c:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 800249e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 80024a2:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80024a4:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
}
 80024a8:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 80024aa:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 80024ae:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 80024b0:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 80024b2:	bf04      	itt	eq
 80024b4:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 80024b8:	605a      	streq	r2, [r3, #4]
 80024ba:	e7d4      	b.n	8002466 <HAL_I2C_Init+0x4a>

080024bc <HAL_I2C_DeInit>:
{
 80024bc:	b510      	push	{r4, lr}
  if (hi2c == NULL)
 80024be:	4604      	mov	r4, r0
 80024c0:	b908      	cbnz	r0, 80024c6 <HAL_I2C_DeInit+0xa>
    hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 80024c2:	6460      	str	r0, [r4, #68]	; 0x44
 80024c4:	deff      	udf	#255	; 0xff
  __HAL_I2C_DISABLE(hi2c);
 80024c6:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 80024c8:	2324      	movs	r3, #36	; 0x24
 80024ca:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 80024ce:	6813      	ldr	r3, [r2, #0]
 80024d0:	f023 0301 	bic.w	r3, r3, #1
 80024d4:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 80024d6:	f007 fd75 	bl	8009fc4 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80024da:	2000      	movs	r0, #0
 80024dc:	6460      	str	r0, [r4, #68]	; 0x44
  __HAL_UNLOCK(hi2c);
 80024de:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
 80024e2:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 80024e6:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 80024e8:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
}
 80024ec:	bd10      	pop	{r4, pc}
	...

080024f0 <HAL_I2C_Master_Transmit>:
{
 80024f0:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 80024f4:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 80024f6:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 80024fa:	2b20      	cmp	r3, #32
{
 80024fc:	4604      	mov	r4, r0
 80024fe:	460e      	mov	r6, r1
 8002500:	4691      	mov	r9, r2
  if (hi2c->State == HAL_I2C_STATE_READY)
 8002502:	f040 8084 	bne.w	800260e <HAL_I2C_Master_Transmit+0x11e>
    __HAL_LOCK(hi2c);
 8002506:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 800250a:	2b01      	cmp	r3, #1
 800250c:	d07f      	beq.n	800260e <HAL_I2C_Master_Transmit+0x11e>
 800250e:	2701      	movs	r7, #1
 8002510:	f880 7040 	strb.w	r7, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 8002514:	f7fe fcbc 	bl	8000e90 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8002518:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
 800251a:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800251c:	9000      	str	r0, [sp, #0]
 800251e:	463a      	mov	r2, r7
 8002520:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8002524:	4620      	mov	r0, r4
 8002526:	f7ff fe54 	bl	80021d2 <I2C_WaitOnFlagUntilTimeout>
 800252a:	b118      	cbz	r0, 8002534 <HAL_I2C_Master_Transmit+0x44>
      return HAL_ERROR;
 800252c:	2001      	movs	r0, #1
}
 800252e:	b003      	add	sp, #12
 8002530:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8002534:	2321      	movs	r3, #33	; 0x21
 8002536:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 800253a:	2310      	movs	r3, #16
 800253c:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002540:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 8002542:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8002546:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr  = pData;
 8002548:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800254c:	b29b      	uxth	r3, r3
 800254e:	2bff      	cmp	r3, #255	; 0xff
    hi2c->XferISR   = NULL;
 8002550:	6360      	str	r0, [r4, #52]	; 0x34
 8002552:	4b30      	ldr	r3, [pc, #192]	; (8002614 <HAL_I2C_Master_Transmit+0x124>)
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8002554:	d926      	bls.n	80025a4 <HAL_I2C_Master_Transmit+0xb4>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8002556:	22ff      	movs	r2, #255	; 0xff
 8002558:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 800255a:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 800255c:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8002560:	4631      	mov	r1, r6
 8002562:	4620      	mov	r0, r4
 8002564:	f7ff fe1b 	bl	800219e <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 8002568:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800256a:	990a      	ldr	r1, [sp, #40]	; 0x28
    while (hi2c->XferCount > 0U)
 800256c:	b29b      	uxth	r3, r3
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800256e:	462a      	mov	r2, r5
 8002570:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 8002572:	b9fb      	cbnz	r3, 80025b4 <HAL_I2C_Master_Transmit+0xc4>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8002574:	f7ff feee 	bl	8002354 <I2C_WaitOnSTOPFlagUntilTimeout>
 8002578:	2800      	cmp	r0, #0
 800257a:	d1d7      	bne.n	800252c <HAL_I2C_Master_Transmit+0x3c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 800257c:	6823      	ldr	r3, [r4, #0]
 800257e:	2120      	movs	r1, #32
 8002580:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8002582:	685a      	ldr	r2, [r3, #4]
 8002584:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 8002588:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 800258c:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 8002590:	f022 0201 	bic.w	r2, r2, #1
 8002594:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8002596:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 800259a:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800259e:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 80025a2:	e7c4      	b.n	800252e <HAL_I2C_Master_Transmit+0x3e>
      hi2c->XferSize = hi2c->XferCount;
 80025a4:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
 80025a6:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = hi2c->XferCount;
 80025a8:	b292      	uxth	r2, r2
 80025aa:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80025ac:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80025b0:	b2d2      	uxtb	r2, r2
 80025b2:	e7d5      	b.n	8002560 <HAL_I2C_Master_Transmit+0x70>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80025b4:	f7ff fe75 	bl	80022a2 <I2C_WaitOnTXISFlagUntilTimeout>
 80025b8:	2800      	cmp	r0, #0
 80025ba:	d1b7      	bne.n	800252c <HAL_I2C_Master_Transmit+0x3c>
      hi2c->Instance->TXDR = (*hi2c->pBuffPtr++);
 80025bc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80025be:	6822      	ldr	r2, [r4, #0]
 80025c0:	1c59      	adds	r1, r3, #1
 80025c2:	6261      	str	r1, [r4, #36]	; 0x24
 80025c4:	781b      	ldrb	r3, [r3, #0]
 80025c6:	6293      	str	r3, [r2, #40]	; 0x28
      hi2c->XferCount--;
 80025c8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80025ca:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 80025cc:	3b01      	subs	r3, #1
 80025ce:	b29b      	uxth	r3, r3
 80025d0:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80025d2:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80025d4:	3a01      	subs	r2, #1
 80025d6:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80025d8:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 80025da:	8522      	strh	r2, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80025dc:	2b00      	cmp	r3, #0
 80025de:	d0c3      	beq.n	8002568 <HAL_I2C_Master_Transmit+0x78>
 80025e0:	2a00      	cmp	r2, #0
 80025e2:	d1c1      	bne.n	8002568 <HAL_I2C_Master_Transmit+0x78>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 80025e4:	9500      	str	r5, [sp, #0]
 80025e6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80025e8:	2180      	movs	r1, #128	; 0x80
 80025ea:	4620      	mov	r0, r4
 80025ec:	f7ff fdf1 	bl	80021d2 <I2C_WaitOnFlagUntilTimeout>
 80025f0:	2800      	cmp	r0, #0
 80025f2:	d19b      	bne.n	800252c <HAL_I2C_Master_Transmit+0x3c>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80025f4:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80025f6:	b29b      	uxth	r3, r3
 80025f8:	2bff      	cmp	r3, #255	; 0xff
 80025fa:	d903      	bls.n	8002604 <HAL_I2C_Master_Transmit+0x114>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 80025fc:	22ff      	movs	r2, #255	; 0xff
 80025fe:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8002600:	9000      	str	r0, [sp, #0]
 8002602:	e7ab      	b.n	800255c <HAL_I2C_Master_Transmit+0x6c>
          hi2c->XferSize = hi2c->XferCount;
 8002604:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8002606:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = hi2c->XferCount;
 8002608:	b292      	uxth	r2, r2
 800260a:	8522      	strh	r2, [r4, #40]	; 0x28
 800260c:	e7ce      	b.n	80025ac <HAL_I2C_Master_Transmit+0xbc>
    return HAL_BUSY;
 800260e:	2002      	movs	r0, #2
 8002610:	e78d      	b.n	800252e <HAL_I2C_Master_Transmit+0x3e>
 8002612:	bf00      	nop
 8002614:	80002000 	.word	0x80002000

08002618 <HAL_I2C_Master_Receive>:
{
 8002618:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 800261c:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 800261e:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8002622:	2b20      	cmp	r3, #32
{
 8002624:	4604      	mov	r4, r0
 8002626:	460e      	mov	r6, r1
 8002628:	4691      	mov	r9, r2
  if (hi2c->State == HAL_I2C_STATE_READY)
 800262a:	f040 8084 	bne.w	8002736 <HAL_I2C_Master_Receive+0x11e>
    __HAL_LOCK(hi2c);
 800262e:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8002632:	2b01      	cmp	r3, #1
 8002634:	d07f      	beq.n	8002736 <HAL_I2C_Master_Receive+0x11e>
 8002636:	2701      	movs	r7, #1
 8002638:	f880 7040 	strb.w	r7, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 800263c:	f7fe fc28 	bl	8000e90 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8002640:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
 8002642:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8002644:	9000      	str	r0, [sp, #0]
 8002646:	463a      	mov	r2, r7
 8002648:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800264c:	4620      	mov	r0, r4
 800264e:	f7ff fdc0 	bl	80021d2 <I2C_WaitOnFlagUntilTimeout>
 8002652:	b118      	cbz	r0, 800265c <HAL_I2C_Master_Receive+0x44>
      return HAL_ERROR;
 8002654:	2001      	movs	r0, #1
}
 8002656:	b003      	add	sp, #12
 8002658:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 800265c:	2322      	movs	r3, #34	; 0x22
 800265e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8002662:	2310      	movs	r3, #16
 8002664:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8002668:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 800266a:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800266e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr  = pData;
 8002670:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8002674:	b29b      	uxth	r3, r3
 8002676:	2bff      	cmp	r3, #255	; 0xff
    hi2c->XferISR   = NULL;
 8002678:	6360      	str	r0, [r4, #52]	; 0x34
 800267a:	4b30      	ldr	r3, [pc, #192]	; (800273c <HAL_I2C_Master_Receive+0x124>)
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800267c:	d926      	bls.n	80026cc <HAL_I2C_Master_Receive+0xb4>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 800267e:	22ff      	movs	r2, #255	; 0xff
 8002680:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 8002682:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8002684:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8002688:	4631      	mov	r1, r6
 800268a:	4620      	mov	r0, r4
 800268c:	f7ff fd87 	bl	800219e <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 8002690:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8002692:	990a      	ldr	r1, [sp, #40]	; 0x28
    while (hi2c->XferCount > 0U)
 8002694:	b29b      	uxth	r3, r3
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8002696:	462a      	mov	r2, r5
 8002698:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 800269a:	b9fb      	cbnz	r3, 80026dc <HAL_I2C_Master_Receive+0xc4>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800269c:	f7ff fe5a 	bl	8002354 <I2C_WaitOnSTOPFlagUntilTimeout>
 80026a0:	2800      	cmp	r0, #0
 80026a2:	d1d7      	bne.n	8002654 <HAL_I2C_Master_Receive+0x3c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 80026a4:	6823      	ldr	r3, [r4, #0]
 80026a6:	2120      	movs	r1, #32
 80026a8:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 80026aa:	685a      	ldr	r2, [r3, #4]
 80026ac:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 80026b0:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 80026b4:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 80026b8:	f022 0201 	bic.w	r2, r2, #1
 80026bc:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 80026be:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 80026c2:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 80026c6:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 80026ca:	e7c4      	b.n	8002656 <HAL_I2C_Master_Receive+0x3e>
      hi2c->XferSize = hi2c->XferCount;
 80026cc:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 80026ce:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = hi2c->XferCount;
 80026d0:	b292      	uxth	r2, r2
 80026d2:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80026d4:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80026d8:	b2d2      	uxtb	r2, r2
 80026da:	e7d5      	b.n	8002688 <HAL_I2C_Master_Receive+0x70>
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 80026dc:	f7ff fe5f 	bl	800239e <I2C_WaitOnRXNEFlagUntilTimeout>
 80026e0:	2800      	cmp	r0, #0
 80026e2:	d1b7      	bne.n	8002654 <HAL_I2C_Master_Receive+0x3c>
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 80026e4:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80026e6:	1c5a      	adds	r2, r3, #1
 80026e8:	6262      	str	r2, [r4, #36]	; 0x24
 80026ea:	6822      	ldr	r2, [r4, #0]
 80026ec:	6a52      	ldr	r2, [r2, #36]	; 0x24
 80026ee:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
 80026f0:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80026f2:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 80026f4:	3b01      	subs	r3, #1
 80026f6:	b29b      	uxth	r3, r3
 80026f8:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 80026fa:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 80026fc:	3a01      	subs	r2, #1
 80026fe:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8002700:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8002702:	8522      	strh	r2, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8002704:	2b00      	cmp	r3, #0
 8002706:	d0c3      	beq.n	8002690 <HAL_I2C_Master_Receive+0x78>
 8002708:	2a00      	cmp	r2, #0
 800270a:	d1c1      	bne.n	8002690 <HAL_I2C_Master_Receive+0x78>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 800270c:	9500      	str	r5, [sp, #0]
 800270e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8002710:	2180      	movs	r1, #128	; 0x80
 8002712:	4620      	mov	r0, r4
 8002714:	f7ff fd5d 	bl	80021d2 <I2C_WaitOnFlagUntilTimeout>
 8002718:	2800      	cmp	r0, #0
 800271a:	d19b      	bne.n	8002654 <HAL_I2C_Master_Receive+0x3c>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 800271c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800271e:	b29b      	uxth	r3, r3
 8002720:	2bff      	cmp	r3, #255	; 0xff
 8002722:	d903      	bls.n	800272c <HAL_I2C_Master_Receive+0x114>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8002724:	22ff      	movs	r2, #255	; 0xff
 8002726:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8002728:	9000      	str	r0, [sp, #0]
 800272a:	e7ab      	b.n	8002684 <HAL_I2C_Master_Receive+0x6c>
          hi2c->XferSize = hi2c->XferCount;
 800272c:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800272e:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = hi2c->XferCount;
 8002730:	b292      	uxth	r2, r2
 8002732:	8522      	strh	r2, [r4, #40]	; 0x28
 8002734:	e7ce      	b.n	80026d4 <HAL_I2C_Master_Receive+0xbc>
    return HAL_BUSY;
 8002736:	2002      	movs	r0, #2
 8002738:	e78d      	b.n	8002656 <HAL_I2C_Master_Receive+0x3e>
 800273a:	bf00      	nop
 800273c:	80002400 	.word	0x80002400

08002740 <HAL_I2C_Mem_Read>:
{
 8002740:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8002744:	469b      	mov	fp, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 8002746:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
{
 800274a:	b085      	sub	sp, #20
  if (hi2c->State == HAL_I2C_STATE_READY)
 800274c:	2b20      	cmp	r3, #32
{
 800274e:	4604      	mov	r4, r0
 8002750:	460f      	mov	r7, r1
 8002752:	9203      	str	r2, [sp, #12]
 8002754:	f8bd a03c 	ldrh.w	sl, [sp, #60]	; 0x3c
 8002758:	f8dd 8040 	ldr.w	r8, [sp, #64]	; 0x40
  if (hi2c->State == HAL_I2C_STATE_READY)
 800275c:	f040 80a8 	bne.w	80028b0 <HAL_I2C_Mem_Read+0x170>
    if ((pData == NULL) || (Size == 0U))
 8002760:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8002762:	b113      	cbz	r3, 800276a <HAL_I2C_Mem_Read+0x2a>
 8002764:	f1ba 0f00 	cmp.w	sl, #0
 8002768:	d106      	bne.n	8002778 <HAL_I2C_Mem_Read+0x38>
      hi2c->ErrorCode = HAL_I2C_ERROR_INVALID_PARAM;
 800276a:	f44f 7300 	mov.w	r3, #512	; 0x200
 800276e:	6463      	str	r3, [r4, #68]	; 0x44
      return HAL_ERROR;
 8002770:	2001      	movs	r0, #1
}
 8002772:	b005      	add	sp, #20
 8002774:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    __HAL_LOCK(hi2c);
 8002778:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 800277c:	2b01      	cmp	r3, #1
 800277e:	f000 8097 	beq.w	80028b0 <HAL_I2C_Mem_Read+0x170>
 8002782:	2501      	movs	r5, #1
 8002784:	f880 5040 	strb.w	r5, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 8002788:	f7fe fb82 	bl	8000e90 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 800278c:	2319      	movs	r3, #25
 800278e:	9000      	str	r0, [sp, #0]
    tickstart = HAL_GetTick();
 8002790:	4606      	mov	r6, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8002792:	462a      	mov	r2, r5
 8002794:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8002798:	4620      	mov	r0, r4
 800279a:	f7ff fd1a 	bl	80021d2 <I2C_WaitOnFlagUntilTimeout>
 800279e:	4681      	mov	r9, r0
 80027a0:	2800      	cmp	r0, #0
 80027a2:	d1e5      	bne.n	8002770 <HAL_I2C_Mem_Read+0x30>
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 80027a4:	2322      	movs	r3, #34	; 0x22
 80027a6:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MEM;
 80027aa:	2340      	movs	r3, #64	; 0x40
 80027ac:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->pBuffPtr  = pData;
 80027b0:	9b0e      	ldr	r3, [sp, #56]	; 0x38
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 80027b2:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->pBuffPtr  = pData;
 80027b4:	6263      	str	r3, [r4, #36]	; 0x24
    hi2c->XferISR   = NULL;
 80027b6:	6360      	str	r0, [r4, #52]	; 0x34
    hi2c->XferCount = Size;
 80027b8:	f8a4 a02a 	strh.w	sl, [r4, #42]	; 0x2a
    if (I2C_RequestMemoryRead(hi2c, DevAddress, MemAddress, MemAddSize, Timeout, tickstart) != HAL_OK)
 80027bc:	9601      	str	r6, [sp, #4]
 80027be:	f8cd 8000 	str.w	r8, [sp]
 80027c2:	465b      	mov	r3, fp
 80027c4:	9a03      	ldr	r2, [sp, #12]
 80027c6:	4639      	mov	r1, r7
 80027c8:	4620      	mov	r0, r4
 80027ca:	f7ff fd91 	bl	80022f0 <I2C_RequestMemoryRead>
 80027ce:	b110      	cbz	r0, 80027d6 <HAL_I2C_Mem_Read+0x96>
      __HAL_UNLOCK(hi2c);
 80027d0:	f884 9040 	strb.w	r9, [r4, #64]	; 0x40
 80027d4:	e7cc      	b.n	8002770 <HAL_I2C_Mem_Read+0x30>
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 80027d6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 80027d8:	b29b      	uxth	r3, r3
 80027da:	2bff      	cmp	r3, #255	; 0xff
 80027dc:	4b35      	ldr	r3, [pc, #212]	; (80028b4 <HAL_I2C_Mem_Read+0x174>)
 80027de:	d957      	bls.n	8002890 <HAL_I2C_Mem_Read+0x150>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80027e0:	22ff      	movs	r2, #255	; 0xff
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80027e2:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = MAX_NBYTE_SIZE;
 80027e4:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 80027e6:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 80027ea:	4639      	mov	r1, r7
 80027ec:	4620      	mov	r0, r4
 80027ee:	f7ff fcd6 	bl	800219e <I2C_TransferConfig>
      if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_RXNE, RESET, Timeout, tickstart) != HAL_OK)
 80027f2:	9600      	str	r6, [sp, #0]
 80027f4:	4643      	mov	r3, r8
 80027f6:	2200      	movs	r2, #0
 80027f8:	2104      	movs	r1, #4
 80027fa:	4620      	mov	r0, r4
 80027fc:	f7ff fce9 	bl	80021d2 <I2C_WaitOnFlagUntilTimeout>
 8002800:	2800      	cmp	r0, #0
 8002802:	d1b5      	bne.n	8002770 <HAL_I2C_Mem_Read+0x30>
      (*hi2c->pBuffPtr++) = hi2c->Instance->RXDR;
 8002804:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002806:	1c5a      	adds	r2, r3, #1
 8002808:	6262      	str	r2, [r4, #36]	; 0x24
 800280a:	6822      	ldr	r2, [r4, #0]
 800280c:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800280e:	701a      	strb	r2, [r3, #0]
      hi2c->XferCount--;
 8002810:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8002812:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8002814:	3b01      	subs	r3, #1
 8002816:	b29b      	uxth	r3, r3
 8002818:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 800281a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 800281c:	3a01      	subs	r2, #1
 800281e:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8002820:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8002822:	8522      	strh	r2, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8002824:	b1ab      	cbz	r3, 8002852 <HAL_I2C_Mem_Read+0x112>
 8002826:	b9a2      	cbnz	r2, 8002852 <HAL_I2C_Mem_Read+0x112>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8002828:	9600      	str	r6, [sp, #0]
 800282a:	4643      	mov	r3, r8
 800282c:	2180      	movs	r1, #128	; 0x80
 800282e:	4620      	mov	r0, r4
 8002830:	f7ff fccf 	bl	80021d2 <I2C_WaitOnFlagUntilTimeout>
 8002834:	2800      	cmp	r0, #0
 8002836:	d19b      	bne.n	8002770 <HAL_I2C_Mem_Read+0x30>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8002838:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 800283a:	b29b      	uxth	r3, r3
 800283c:	2bff      	cmp	r3, #255	; 0xff
 800283e:	d92f      	bls.n	80028a0 <HAL_I2C_Mem_Read+0x160>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8002840:	22ff      	movs	r2, #255	; 0xff
 8002842:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8002844:	9000      	str	r0, [sp, #0]
 8002846:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 800284a:	4639      	mov	r1, r7
 800284c:	4620      	mov	r0, r4
 800284e:	f7ff fca6 	bl	800219e <I2C_TransferConfig>
    while (hi2c->XferCount > 0U);
 8002852:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8002854:	b29b      	uxth	r3, r3
 8002856:	2b00      	cmp	r3, #0
 8002858:	d1cb      	bne.n	80027f2 <HAL_I2C_Mem_Read+0xb2>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 800285a:	4632      	mov	r2, r6
 800285c:	4641      	mov	r1, r8
 800285e:	4620      	mov	r0, r4
 8002860:	f7ff fd78 	bl	8002354 <I2C_WaitOnSTOPFlagUntilTimeout>
 8002864:	2800      	cmp	r0, #0
 8002866:	d183      	bne.n	8002770 <HAL_I2C_Mem_Read+0x30>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8002868:	6823      	ldr	r3, [r4, #0]
 800286a:	2120      	movs	r1, #32
 800286c:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 800286e:	685a      	ldr	r2, [r3, #4]
 8002870:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 8002874:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 8002878:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 800287c:	f022 0201 	bic.w	r2, r2, #1
 8002880:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8002882:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8002886:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 800288a:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 800288e:	e770      	b.n	8002772 <HAL_I2C_Mem_Read+0x32>
      hi2c->XferSize = hi2c->XferCount;
 8002890:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8002892:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = hi2c->XferCount;
 8002894:	b292      	uxth	r2, r2
 8002896:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8002898:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 800289c:	b2d2      	uxtb	r2, r2
 800289e:	e7a4      	b.n	80027ea <HAL_I2C_Mem_Read+0xaa>
          hi2c->XferSize = hi2c->XferCount;
 80028a0:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80028a2:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = hi2c->XferCount;
 80028a4:	b292      	uxth	r2, r2
 80028a6:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 80028a8:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 80028ac:	b2d2      	uxtb	r2, r2
 80028ae:	e7cc      	b.n	800284a <HAL_I2C_Mem_Read+0x10a>
    return HAL_BUSY;
 80028b0:	2002      	movs	r0, #2
 80028b2:	e75e      	b.n	8002772 <HAL_I2C_Mem_Read+0x32>
 80028b4:	80002400 	.word	0x80002400

080028b8 <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 80028b8:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 80028bc:	b2d2      	uxtb	r2, r2
 80028be:	2a20      	cmp	r2, #32
{
 80028c0:	b510      	push	{r4, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 80028c2:	d11d      	bne.n	8002900 <HAL_I2CEx_ConfigAnalogFilter+0x48>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 80028c4:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 80028c8:	2b01      	cmp	r3, #1
 80028ca:	d019      	beq.n	8002900 <HAL_I2CEx_ConfigAnalogFilter+0x48>

    hi2c->State = HAL_I2C_STATE_BUSY;
 80028cc:	2324      	movs	r3, #36	; 0x24
 80028ce:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 80028d2:	6803      	ldr	r3, [r0, #0]
 80028d4:	681c      	ldr	r4, [r3, #0]
 80028d6:	f024 0401 	bic.w	r4, r4, #1
 80028da:	601c      	str	r4, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 80028dc:	681c      	ldr	r4, [r3, #0]
 80028de:	f424 5480 	bic.w	r4, r4, #4096	; 0x1000
 80028e2:	601c      	str	r4, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 80028e4:	681c      	ldr	r4, [r3, #0]
 80028e6:	4321      	orrs	r1, r4
 80028e8:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 80028ea:	6819      	ldr	r1, [r3, #0]
 80028ec:	f041 0101 	orr.w	r1, r1, #1
 80028f0:	6019      	str	r1, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 80028f2:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 80028f4:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 80028f8:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 80028fc:	4618      	mov	r0, r3
 80028fe:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
 8002900:	2002      	movs	r0, #2
  }
}
 8002902:	bd10      	pop	{r4, pc}

08002904 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 8002904:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8002906:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
 800290a:	b2e4      	uxtb	r4, r4
 800290c:	2c20      	cmp	r4, #32
 800290e:	d11c      	bne.n	800294a <HAL_I2CEx_ConfigDigitalFilter+0x46>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8002910:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8002914:	2b01      	cmp	r3, #1
 8002916:	d018      	beq.n	800294a <HAL_I2CEx_ConfigDigitalFilter+0x46>

    hi2c->State = HAL_I2C_STATE_BUSY;
 8002918:	2324      	movs	r3, #36	; 0x24
 800291a:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 800291e:	6803      	ldr	r3, [r0, #0]
 8002920:	681a      	ldr	r2, [r3, #0]
 8002922:	f022 0201 	bic.w	r2, r2, #1
 8002926:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8002928:	681a      	ldr	r2, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 800292a:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 800292e:	ea42 2101 	orr.w	r1, r2, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 8002932:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8002934:	681a      	ldr	r2, [r3, #0]
 8002936:	f042 0201 	orr.w	r2, r2, #1
 800293a:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 800293c:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 800293e:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8002942:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 8002946:	4618      	mov	r0, r3
 8002948:	bd10      	pop	{r4, pc}
  }
  else
  {
    return HAL_BUSY;
 800294a:	2002      	movs	r0, #2
  }
}
 800294c:	bd10      	pop	{r4, pc}

0800294e <HAL_IWDG_Init>:
  * @param  hiwdg  pointer to a IWDG_HandleTypeDef structure that contains
  *                the configuration information for the specified IWDG module.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_IWDG_Init(IWDG_HandleTypeDef *hiwdg)
{
 800294e:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart;

  /* Check the IWDG handle allocation */
  if(hiwdg == NULL)
 8002950:	4604      	mov	r4, r0
 8002952:	b300      	cbz	r0, 8002996 <HAL_IWDG_Init+0x48>
  assert_param(IS_IWDG_PRESCALER(hiwdg->Init.Prescaler));
  assert_param(IS_IWDG_RELOAD(hiwdg->Init.Reload));
  assert_param(IS_IWDG_WINDOW(hiwdg->Init.Window));

  /* Enable IWDG. LSI is turned on automaticaly */
  __HAL_IWDG_START(hiwdg);
 8002954:	6803      	ldr	r3, [r0, #0]
 8002956:	f64c 42cc 	movw	r2, #52428	; 0xcccc
 800295a:	601a      	str	r2, [r3, #0]

  /* Enable write access to IWDG_PR, IWDG_RLR and IWDG_WINR registers by writing
  0x5555 in KR */
  IWDG_ENABLE_WRITE_ACCESS(hiwdg);
 800295c:	f245 5255 	movw	r2, #21845	; 0x5555
 8002960:	601a      	str	r2, [r3, #0]

  /* Write to IWDG registers the Prescaler & Reload values to work with */
  hiwdg->Instance->PR = hiwdg->Init.Prescaler;
 8002962:	6842      	ldr	r2, [r0, #4]
 8002964:	605a      	str	r2, [r3, #4]
  hiwdg->Instance->RLR = hiwdg->Init.Reload;
 8002966:	6882      	ldr	r2, [r0, #8]
 8002968:	609a      	str	r2, [r3, #8]

  /* Check pending flag, if previous update not done, return timeout */
  tickstart = HAL_GetTick();
 800296a:	f7fe fa91 	bl	8000e90 <HAL_GetTick>
 800296e:	4605      	mov	r5, r0

  /* Wait for register to be updated */
  while (hiwdg->Instance->SR != 0x00u)
 8002970:	6823      	ldr	r3, [r4, #0]
 8002972:	68d8      	ldr	r0, [r3, #12]
 8002974:	b940      	cbnz	r0, 8002988 <HAL_IWDG_Init+0x3a>
    }
  }

  /* If window parameter is different than current value, modify window 
  register */
  if(hiwdg->Instance->WINR != hiwdg->Init.Window)
 8002976:	68e2      	ldr	r2, [r4, #12]
 8002978:	6919      	ldr	r1, [r3, #16]
 800297a:	4291      	cmp	r1, r2
    hiwdg->Instance->WINR = hiwdg->Init.Window;
  }
  else
  {
    /* Reload IWDG counter with value defined in the reload register */
    __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 800297c:	bf0a      	itet	eq
 800297e:	f64a 22aa 	movweq	r2, #43690	; 0xaaaa
    hiwdg->Instance->WINR = hiwdg->Init.Window;
 8002982:	611a      	strne	r2, [r3, #16]
    __HAL_IWDG_RELOAD_COUNTER(hiwdg);
 8002984:	601a      	streq	r2, [r3, #0]
 8002986:	bd38      	pop	{r3, r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > HAL_IWDG_DEFAULT_TIMEOUT)
 8002988:	f7fe fa82 	bl	8000e90 <HAL_GetTick>
 800298c:	1b40      	subs	r0, r0, r5
 800298e:	2830      	cmp	r0, #48	; 0x30
 8002990:	d9ee      	bls.n	8002970 <HAL_IWDG_Init+0x22>
      return HAL_TIMEOUT;
 8002992:	2003      	movs	r0, #3
  }

  /* Return function status */
  return HAL_OK;
}
 8002994:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8002996:	2001      	movs	r0, #1
 8002998:	bd38      	pop	{r3, r4, r5, pc}
	...

0800299c <HAL_LPTIM_Init>:
  *         LPTIM_InitTypeDef and initialize the associated handle.
  * @param  hlptim: LPTIM handle
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_LPTIM_Init(LPTIM_HandleTypeDef *hlptim)
{
 800299c:	b570      	push	{r4, r5, r6, lr}
  uint32_t tmpcfgr = 0;

  /* Check the LPTIM handle allocation */
  if(hlptim == NULL)
 800299e:	4604      	mov	r4, r0
 80029a0:	2800      	cmp	r0, #0
 80029a2:	d047      	beq.n	8002a34 <HAL_LPTIM_Init+0x98>
  }
  assert_param(IS_LPTIM_OUTPUT_POLARITY(hlptim->Init.OutputPolarity));
  assert_param(IS_LPTIM_UPDATE_MODE(hlptim->Init.UpdateMode));
  assert_param(IS_LPTIM_COUNTER_SOURCE(hlptim->Init.CounterSource));

  if(hlptim->State == HAL_LPTIM_STATE_RESET)
 80029a4:	f890 3036 	ldrb.w	r3, [r0, #54]	; 0x36
 80029a8:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80029ac:	b91b      	cbnz	r3, 80029b6 <HAL_LPTIM_Init+0x1a>
  {
    /* Allocate lock resource and initialize it */
    hlptim->Lock = HAL_UNLOCKED;
 80029ae:	f880 2035 	strb.w	r2, [r0, #53]	; 0x35

    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    hlptim->MspInitCallback(hlptim);
#else
    /* Init the low level hardware : GPIO, CLOCK, NVIC */
    HAL_LPTIM_MspInit(hlptim);
 80029b2:	f007 fbaf 	bl	800a114 <HAL_LPTIM_MspInit>
#endif /* USE_HAL_LPTIM_REGISTER_CALLBACKS */
  }

  /* Change the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_BUSY;
 80029b6:	2302      	movs	r3, #2

  /* Get the LPTIMx CFGR value */
  tmpcfgr = hlptim->Instance->CFGR;
 80029b8:	6820      	ldr	r0, [r4, #0]

  if ((hlptim->Init.Clock.Source) ==  LPTIM_CLOCKSOURCE_ULPTIM)
 80029ba:	6865      	ldr	r5, [r4, #4]
  hlptim->State = HAL_LPTIM_STATE_BUSY;
 80029bc:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36
  tmpcfgr = hlptim->Instance->CFGR;
 80029c0:	68c2      	ldr	r2, [r0, #12]
  {
    tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKPOL | LPTIM_CFGR_CKFLT));
  }
  if ((hlptim->Init.Trigger.Source) !=  LPTIM_TRIGSOURCE_SOFTWARE)
 80029c2:	6961      	ldr	r1, [r4, #20]
  {
    tmpcfgr &= (uint32_t)(~ (LPTIM_CFGR_TRGFLT | LPTIM_CFGR_TRIGSEL));
  }

  /* Clear CKSEL, PRESC, TRIGEN, TRGFLT, WAVPOL, PRELOAD & COUNTMODE bits */
  tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKSEL | LPTIM_CFGR_TRIGEN | LPTIM_CFGR_PRELOAD |
 80029c4:	4e1c      	ldr	r6, [pc, #112]	; (8002a38 <HAL_LPTIM_Init+0x9c>)
  if ((hlptim->Init.Clock.Source) ==  LPTIM_CLOCKSOURCE_ULPTIM)
 80029c6:	2d01      	cmp	r5, #1
  if ((hlptim->Init.Trigger.Source) !=  LPTIM_TRIGSOURCE_SOFTWARE)
 80029c8:	f64f 73ff 	movw	r3, #65535	; 0xffff
    tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKPOL | LPTIM_CFGR_CKFLT));
 80029cc:	bf08      	it	eq
 80029ce:	f022 021e 	biceq.w	r2, r2, #30
  if ((hlptim->Init.Trigger.Source) !=  LPTIM_TRIGSOURCE_SOFTWARE)
 80029d2:	4299      	cmp	r1, r3
    tmpcfgr &= (uint32_t)(~ (LPTIM_CFGR_TRGFLT | LPTIM_CFGR_TRIGSEL));
 80029d4:	bf1c      	itt	ne
 80029d6:	f422 4260 	bicne.w	r2, r2, #57344	; 0xe000
 80029da:	f022 02c0 	bicne.w	r2, r2, #192	; 0xc0
  tmpcfgr &= (uint32_t)(~(LPTIM_CFGR_CKSEL | LPTIM_CFGR_TRIGEN | LPTIM_CFGR_PRELOAD |
 80029de:	4016      	ands	r6, r2
                          LPTIM_CFGR_WAVPOL | LPTIM_CFGR_PRESC | LPTIM_CFGR_COUNTMODE ));

  /* Set initialization parameters */
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 80029e0:	68a2      	ldr	r2, [r4, #8]
 80029e2:	ea45 0302 	orr.w	r3, r5, r2
              hlptim->Init.Clock.Prescaler |
 80029e6:	6a22      	ldr	r2, [r4, #32]
 80029e8:	4313      	orrs	r3, r2
              hlptim->Init.OutputPolarity  |
 80029ea:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80029ec:	4313      	orrs	r3, r2
              hlptim->Init.UpdateMode      |
 80029ee:	6aa2      	ldr	r2, [r4, #40]	; 0x28
              hlptim->Init.CounterSource);

  if ((hlptim->Init.Clock.Source) ==  LPTIM_CLOCKSOURCE_ULPTIM)
 80029f0:	2d01      	cmp	r5, #1
              hlptim->Init.UpdateMode      |
 80029f2:	ea43 0302 	orr.w	r3, r3, r2
  {
    tmpcfgr |=  (hlptim->Init.UltraLowPowerClock.Polarity |
 80029f6:	bf04      	itt	eq
 80029f8:	6925      	ldreq	r5, [r4, #16]
 80029fa:	68e2      	ldreq	r2, [r4, #12]
  tmpcfgr |= (hlptim->Init.Clock.Source    |
 80029fc:	ea43 0306 	orr.w	r3, r3, r6
    tmpcfgr |=  (hlptim->Init.UltraLowPowerClock.Polarity |
 8002a00:	bf04      	itt	eq
 8002a02:	432a      	orreq	r2, r5
 8002a04:	4313      	orreq	r3, r2
                hlptim->Init.UltraLowPowerClock.SampleTime);
  }

  if ((hlptim->Init.Trigger.Source) !=  LPTIM_TRIGSOURCE_SOFTWARE)
 8002a06:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8002a0a:	4291      	cmp	r1, r2
 8002a0c:	d004      	beq.n	8002a18 <HAL_LPTIM_Init+0x7c>
  {
    /* Enable External trigger and set the trigger source */
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 8002a0e:	69a2      	ldr	r2, [r4, #24]
 8002a10:	4311      	orrs	r1, r2
                hlptim->Init.Trigger.ActiveEdge |
 8002a12:	69e2      	ldr	r2, [r4, #28]
 8002a14:	4311      	orrs	r1, r2
    tmpcfgr |= (hlptim->Init.Trigger.Source     |
 8002a16:	430b      	orrs	r3, r1
                hlptim->Init.Trigger.SampleTime);
  }

  /* Write to LPTIMx CFGR */
  hlptim->Instance->CFGR = tmpcfgr;
 8002a18:	60c3      	str	r3, [r0, #12]

  /* Configure LPTIM input sources */
  if(hlptim->Instance == LPTIM1)
 8002a1a:	4b08      	ldr	r3, [pc, #32]	; (8002a3c <HAL_LPTIM_Init+0xa0>)
 8002a1c:	4298      	cmp	r0, r3
    /* Check LPTIM1 Input1 and Input2 sources */
    assert_param(IS_LPTIM_INPUT1_SOURCE(hlptim->Instance,hlptim->Init.Input1Source));
    assert_param(IS_LPTIM_INPUT2_SOURCE(hlptim->Instance,hlptim->Init.Input2Source));

    /* Configure LPTIM1 Input1 and Input2 sources */
    hlptim->Instance->OR = (hlptim->Init.Input1Source | hlptim->Init.Input2Source);
 8002a1e:	bf08      	it	eq
 8002a20:	6b22      	ldreq	r2, [r4, #48]	; 0x30
 8002a22:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8002a24:	bf08      	it	eq
 8002a26:	4313      	orreq	r3, r2
  {
    /* Check LPTIM2 Input1 source */
    assert_param(IS_LPTIM_INPUT1_SOURCE(hlptim->Instance,hlptim->Init.Input1Source));

    /* Configure LPTIM2 Input1 source */
    hlptim->Instance->OR = hlptim->Init.Input1Source;
 8002a28:	6203      	str	r3, [r0, #32]
  }

  /* Change the LPTIM state */
  hlptim->State = HAL_LPTIM_STATE_READY;
 8002a2a:	2301      	movs	r3, #1
 8002a2c:	f884 3036 	strb.w	r3, [r4, #54]	; 0x36

  /* Return function status */
  return HAL_OK;
 8002a30:	2000      	movs	r0, #0
 8002a32:	bd70      	pop	{r4, r5, r6, pc}
    return HAL_ERROR;
 8002a34:	2001      	movs	r0, #1
}
 8002a36:	bd70      	pop	{r4, r5, r6, pc}
 8002a38:	ff19f1fe 	.word	0xff19f1fe
 8002a3c:	40007c00 	.word	0x40007c00

08002a40 <HAL_LPTIM_TimeOut_Start_IT>:
  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));
  assert_param(IS_LPTIM_PERIOD(Period));
  assert_param(IS_LPTIM_PULSE(Timeout));

  /* Set the LPTIM state */
  hlptim->State= HAL_LPTIM_STATE_BUSY;
 8002a40:	2302      	movs	r3, #2
{
 8002a42:	b510      	push	{r4, lr}
  hlptim->State= HAL_LPTIM_STATE_BUSY;
 8002a44:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36

  /* Set TIMOUT bit to enable the timeout function */
  hlptim->Instance->CFGR |= LPTIM_CFGR_TIMOUT;
 8002a48:	6803      	ldr	r3, [r0, #0]
 8002a4a:	68dc      	ldr	r4, [r3, #12]
 8002a4c:	f444 2400 	orr.w	r4, r4, #524288	; 0x80000
 8002a50:	60dc      	str	r4, [r3, #12]

  /* Enable Compare match interrupt */
  __HAL_LPTIM_ENABLE_IT(hlptim, LPTIM_IT_CMPM);
 8002a52:	689c      	ldr	r4, [r3, #8]
 8002a54:	f044 0401 	orr.w	r4, r4, #1
 8002a58:	609c      	str	r4, [r3, #8]

  /* Enable the Peripheral */
  __HAL_LPTIM_ENABLE(hlptim);
 8002a5a:	691c      	ldr	r4, [r3, #16]
 8002a5c:	f044 0401 	orr.w	r4, r4, #1
 8002a60:	611c      	str	r4, [r3, #16]

  /* Load the period value in the autoreload register */
  __HAL_LPTIM_AUTORELOAD_SET(hlptim, Period);
 8002a62:	6199      	str	r1, [r3, #24]

  /* Load the Timeout value in the compare register */
  __HAL_LPTIM_COMPARE_SET(hlptim, Timeout);
 8002a64:	615a      	str	r2, [r3, #20]

  /* Start timer in continuous mode */
  __HAL_LPTIM_START_CONTINUOUS(hlptim);
 8002a66:	691a      	ldr	r2, [r3, #16]
 8002a68:	f042 0204 	orr.w	r2, r2, #4
 8002a6c:	611a      	str	r2, [r3, #16]

  /* Change the TIM state*/
  hlptim->State= HAL_LPTIM_STATE_READY;
 8002a6e:	2301      	movs	r3, #1
 8002a70:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36

  /* Return function status */
  return HAL_OK;
}
 8002a74:	2000      	movs	r0, #0
 8002a76:	bd10      	pop	{r4, pc}

08002a78 <HAL_LPTIM_TimeOut_Stop_IT>:
{
  /* Check the parameters */
  assert_param(IS_LPTIM_INSTANCE(hlptim->Instance));

  /* Set the LPTIM state */
  hlptim->State= HAL_LPTIM_STATE_BUSY;
 8002a78:	2302      	movs	r3, #2
 8002a7a:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36

  /* Disable the Peripheral */
  __HAL_LPTIM_DISABLE(hlptim);
 8002a7e:	6803      	ldr	r3, [r0, #0]
 8002a80:	691a      	ldr	r2, [r3, #16]
 8002a82:	f022 0201 	bic.w	r2, r2, #1
 8002a86:	611a      	str	r2, [r3, #16]

  /* Reset TIMOUT bit to enable the timeout function */
  hlptim->Instance->CFGR &= ~LPTIM_CFGR_TIMOUT;
 8002a88:	68da      	ldr	r2, [r3, #12]
 8002a8a:	f422 2200 	bic.w	r2, r2, #524288	; 0x80000
 8002a8e:	60da      	str	r2, [r3, #12]

  /* Disable Compare match interrupt */
  __HAL_LPTIM_DISABLE_IT(hlptim, LPTIM_IT_CMPM);
 8002a90:	689a      	ldr	r2, [r3, #8]
 8002a92:	f022 0201 	bic.w	r2, r2, #1
 8002a96:	609a      	str	r2, [r3, #8]

  /* Change the TIM state*/
  hlptim->State= HAL_LPTIM_STATE_READY;
 8002a98:	2301      	movs	r3, #1
 8002a9a:	f880 3036 	strb.w	r3, [r0, #54]	; 0x36

  /* Return function status */
  return HAL_OK;
}
 8002a9e:	2000      	movs	r0, #0
 8002aa0:	4770      	bx	lr

08002aa2 <HAL_LPTIM_CompareMatchCallback>:
 8002aa2:	4770      	bx	lr

08002aa4 <HAL_LPTIM_AutoReloadMatchCallback>:
 8002aa4:	4770      	bx	lr

08002aa6 <HAL_LPTIM_TriggerCallback>:
 8002aa6:	4770      	bx	lr

08002aa8 <HAL_LPTIM_CompareWriteCallback>:
 8002aa8:	4770      	bx	lr

08002aaa <HAL_LPTIM_AutoReloadWriteCallback>:
 8002aaa:	4770      	bx	lr

08002aac <HAL_LPTIM_DirectionUpCallback>:
 8002aac:	4770      	bx	lr

08002aae <HAL_LPTIM_DirectionDownCallback>:
  * @brief  Direction counter changed from Up to Down callback in non-blocking mode.
  * @param  hlptim : LPTIM handle
  * @retval None
  */
__weak void HAL_LPTIM_DirectionDownCallback(LPTIM_HandleTypeDef *hlptim)
{
 8002aae:	4770      	bx	lr

08002ab0 <HAL_LPTIM_IRQHandler>:
  if(__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPM) != RESET)
 8002ab0:	6803      	ldr	r3, [r0, #0]
 8002ab2:	681a      	ldr	r2, [r3, #0]
 8002ab4:	07d1      	lsls	r1, r2, #31
{
 8002ab6:	b510      	push	{r4, lr}
 8002ab8:	4604      	mov	r4, r0
  if(__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPM) != RESET)
 8002aba:	d506      	bpl.n	8002aca <HAL_LPTIM_IRQHandler+0x1a>
    if(__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_CMPM) != RESET)
 8002abc:	689a      	ldr	r2, [r3, #8]
 8002abe:	07d2      	lsls	r2, r2, #31
 8002ac0:	d503      	bpl.n	8002aca <HAL_LPTIM_IRQHandler+0x1a>
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPM);
 8002ac2:	2201      	movs	r2, #1
 8002ac4:	605a      	str	r2, [r3, #4]
      HAL_LPTIM_CompareMatchCallback(hlptim);
 8002ac6:	f7ff ffec 	bl	8002aa2 <HAL_LPTIM_CompareMatchCallback>
  if(__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_ARRM) != RESET)
 8002aca:	6823      	ldr	r3, [r4, #0]
 8002acc:	681a      	ldr	r2, [r3, #0]
 8002ace:	0790      	lsls	r0, r2, #30
 8002ad0:	d507      	bpl.n	8002ae2 <HAL_LPTIM_IRQHandler+0x32>
    if(__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_ARRM) != RESET)
 8002ad2:	689a      	ldr	r2, [r3, #8]
 8002ad4:	0791      	lsls	r1, r2, #30
 8002ad6:	d504      	bpl.n	8002ae2 <HAL_LPTIM_IRQHandler+0x32>
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARRM);
 8002ad8:	2202      	movs	r2, #2
 8002ada:	605a      	str	r2, [r3, #4]
      HAL_LPTIM_AutoReloadMatchCallback(hlptim);
 8002adc:	4620      	mov	r0, r4
 8002ade:	f7ff ffe1 	bl	8002aa4 <HAL_LPTIM_AutoReloadMatchCallback>
  if(__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_EXTTRIG) != RESET)
 8002ae2:	6823      	ldr	r3, [r4, #0]
 8002ae4:	681a      	ldr	r2, [r3, #0]
 8002ae6:	0752      	lsls	r2, r2, #29
 8002ae8:	d507      	bpl.n	8002afa <HAL_LPTIM_IRQHandler+0x4a>
    if(__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_EXTTRIG) != RESET)
 8002aea:	689a      	ldr	r2, [r3, #8]
 8002aec:	0750      	lsls	r0, r2, #29
 8002aee:	d504      	bpl.n	8002afa <HAL_LPTIM_IRQHandler+0x4a>
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_EXTTRIG);
 8002af0:	2204      	movs	r2, #4
 8002af2:	605a      	str	r2, [r3, #4]
      HAL_LPTIM_TriggerCallback(hlptim);
 8002af4:	4620      	mov	r0, r4
 8002af6:	f7ff ffd6 	bl	8002aa6 <HAL_LPTIM_TriggerCallback>
  if(__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_CMPOK) != RESET)
 8002afa:	6823      	ldr	r3, [r4, #0]
 8002afc:	681a      	ldr	r2, [r3, #0]
 8002afe:	0711      	lsls	r1, r2, #28
 8002b00:	d507      	bpl.n	8002b12 <HAL_LPTIM_IRQHandler+0x62>
    if(__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_CMPOK) != RESET)
 8002b02:	689a      	ldr	r2, [r3, #8]
 8002b04:	0712      	lsls	r2, r2, #28
 8002b06:	d504      	bpl.n	8002b12 <HAL_LPTIM_IRQHandler+0x62>
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_CMPOK);
 8002b08:	2208      	movs	r2, #8
 8002b0a:	605a      	str	r2, [r3, #4]
      HAL_LPTIM_CompareWriteCallback(hlptim);
 8002b0c:	4620      	mov	r0, r4
 8002b0e:	f7ff ffcb 	bl	8002aa8 <HAL_LPTIM_CompareWriteCallback>
  if(__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_ARROK) != RESET)
 8002b12:	6823      	ldr	r3, [r4, #0]
 8002b14:	681a      	ldr	r2, [r3, #0]
 8002b16:	06d0      	lsls	r0, r2, #27
 8002b18:	d507      	bpl.n	8002b2a <HAL_LPTIM_IRQHandler+0x7a>
    if(__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_ARROK) != RESET)
 8002b1a:	689a      	ldr	r2, [r3, #8]
 8002b1c:	06d1      	lsls	r1, r2, #27
 8002b1e:	d504      	bpl.n	8002b2a <HAL_LPTIM_IRQHandler+0x7a>
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_ARROK);
 8002b20:	2210      	movs	r2, #16
 8002b22:	605a      	str	r2, [r3, #4]
      HAL_LPTIM_AutoReloadWriteCallback(hlptim);
 8002b24:	4620      	mov	r0, r4
 8002b26:	f7ff ffc0 	bl	8002aaa <HAL_LPTIM_AutoReloadWriteCallback>
  if(__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_UP) != RESET)
 8002b2a:	6823      	ldr	r3, [r4, #0]
 8002b2c:	681a      	ldr	r2, [r3, #0]
 8002b2e:	0692      	lsls	r2, r2, #26
 8002b30:	d507      	bpl.n	8002b42 <HAL_LPTIM_IRQHandler+0x92>
    if(__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_UP) != RESET)
 8002b32:	689a      	ldr	r2, [r3, #8]
 8002b34:	0690      	lsls	r0, r2, #26
 8002b36:	d504      	bpl.n	8002b42 <HAL_LPTIM_IRQHandler+0x92>
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_UP);
 8002b38:	2220      	movs	r2, #32
 8002b3a:	605a      	str	r2, [r3, #4]
      HAL_LPTIM_DirectionUpCallback(hlptim);
 8002b3c:	4620      	mov	r0, r4
 8002b3e:	f7ff ffb5 	bl	8002aac <HAL_LPTIM_DirectionUpCallback>
  if(__HAL_LPTIM_GET_FLAG(hlptim, LPTIM_FLAG_DOWN) != RESET)
 8002b42:	6823      	ldr	r3, [r4, #0]
 8002b44:	681a      	ldr	r2, [r3, #0]
 8002b46:	0651      	lsls	r1, r2, #25
 8002b48:	d507      	bpl.n	8002b5a <HAL_LPTIM_IRQHandler+0xaa>
    if(__HAL_LPTIM_GET_IT_SOURCE(hlptim, LPTIM_IT_DOWN) != RESET)
 8002b4a:	689a      	ldr	r2, [r3, #8]
 8002b4c:	0652      	lsls	r2, r2, #25
 8002b4e:	d504      	bpl.n	8002b5a <HAL_LPTIM_IRQHandler+0xaa>
      __HAL_LPTIM_CLEAR_FLAG(hlptim, LPTIM_FLAG_DOWN);
 8002b50:	2240      	movs	r2, #64	; 0x40
 8002b52:	605a      	str	r2, [r3, #4]
      HAL_LPTIM_DirectionDownCallback(hlptim);
 8002b54:	4620      	mov	r0, r4
 8002b56:	f7ff ffaa 	bl	8002aae <HAL_LPTIM_DirectionDownCallback>
 8002b5a:	bd10      	pop	{r4, pc}

08002b5c <HAL_PWR_EnableBkUpAccess>:
  *        back-up domain.                
  * @retval None
  */
void HAL_PWR_EnableBkUpAccess(void)
{
  SET_BIT(PWR->CR1, PWR_CR1_DBP);    
 8002b5c:	4a02      	ldr	r2, [pc, #8]	; (8002b68 <HAL_PWR_EnableBkUpAccess+0xc>)
 8002b5e:	6813      	ldr	r3, [r2, #0]
 8002b60:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002b64:	6013      	str	r3, [r2, #0]
 8002b66:	4770      	bx	lr
 8002b68:	40007000 	.word	0x40007000

08002b6c <HAL_PWREx_GetVoltageRange>:
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
 8002b6c:	4b02      	ldr	r3, [pc, #8]	; (8002b78 <HAL_PWREx_GetVoltageRange+0xc>)
 8002b6e:	6818      	ldr	r0, [r3, #0]
#endif  
}
 8002b70:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8002b74:	4770      	bx	lr
 8002b76:	bf00      	nop
 8002b78:	40007000 	.word	0x40007000

08002b7c <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.                    
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8002b7c:	4b16      	ldr	r3, [pc, #88]	; (8002bd8 <HAL_PWREx_ControlVoltageScaling+0x5c>)
#else

  /* If Set Range 1 */
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
  {
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8002b7e:	681a      	ldr	r2, [r3, #0]
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8002b80:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8002b84:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8002b88:	d11a      	bne.n	8002bc0 <HAL_PWREx_ControlVoltageScaling+0x44>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE1)
 8002b8a:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 8002b8e:	d013      	beq.n	8002bb8 <HAL_PWREx_ControlVoltageScaling+0x3c>
    {
      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8002b90:	681a      	ldr	r2, [r3, #0]
      
      /* Wait until VOSF is cleared */      
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 8002b92:	4912      	ldr	r1, [pc, #72]	; (8002bdc <HAL_PWREx_ControlVoltageScaling+0x60>)
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 8002b94:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8002b98:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002b9c:	601a      	str	r2, [r3, #0]
      wait_loop_index = (PWR_FLAG_SETTING_DELAY_US * (SystemCoreClock / 1000000));
 8002b9e:	4a10      	ldr	r2, [pc, #64]	; (8002be0 <HAL_PWREx_ControlVoltageScaling+0x64>)
 8002ba0:	6812      	ldr	r2, [r2, #0]
 8002ba2:	fbb2 f1f1 	udiv	r1, r2, r1
 8002ba6:	2232      	movs	r2, #50	; 0x32
 8002ba8:	434a      	muls	r2, r1
      while ((wait_loop_index != 0) && (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)))
 8002baa:	b112      	cbz	r2, 8002bb2 <HAL_PWREx_ControlVoltageScaling+0x36>
 8002bac:	6959      	ldr	r1, [r3, #20]
 8002bae:	0549      	lsls	r1, r1, #21
 8002bb0:	d404      	bmi.n	8002bbc <HAL_PWREx_ControlVoltageScaling+0x40>
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8002bb2:	695b      	ldr	r3, [r3, #20]
 8002bb4:	055b      	lsls	r3, r3, #21
 8002bb6:	d40d      	bmi.n	8002bd4 <HAL_PWREx_ControlVoltageScaling+0x58>
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif  
  
  return HAL_OK;
 8002bb8:	2000      	movs	r0, #0
 8002bba:	4770      	bx	lr
        wait_loop_index--;
 8002bbc:	3a01      	subs	r2, #1
 8002bbe:	e7f4      	b.n	8002baa <HAL_PWREx_ControlVoltageScaling+0x2e>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) != PWR_REGULATOR_VOLTAGE_SCALE2)
 8002bc0:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 8002bc4:	bf1f      	itttt	ne
 8002bc6:	681a      	ldrne	r2, [r3, #0]
 8002bc8:	f422 62c0 	bicne.w	r2, r2, #1536	; 0x600
 8002bcc:	f442 6280 	orrne.w	r2, r2, #1024	; 0x400
 8002bd0:	601a      	strne	r2, [r3, #0]
 8002bd2:	e7f1      	b.n	8002bb8 <HAL_PWREx_ControlVoltageScaling+0x3c>
        return HAL_TIMEOUT;
 8002bd4:	2003      	movs	r0, #3
}  
 8002bd6:	4770      	bx	lr
 8002bd8:	40007000 	.word	0x40007000
 8002bdc:	000f4240 	.word	0x000f4240
 8002be0:	20000024 	.word	0x20000024

08002be4 <HAL_PWREx_EnterSTOP2Mode>:
{
  /* Check the parameter */
  assert_param(IS_PWR_STOP_ENTRY(STOPEntry));

  /* Set Stop mode 2 */
  MODIFY_REG(PWR->CR1, PWR_CR1_LPMS, PWR_CR1_LPMS_STOP2);
 8002be4:	4a0b      	ldr	r2, [pc, #44]	; (8002c14 <HAL_PWREx_EnterSTOP2Mode+0x30>)
 8002be6:	6813      	ldr	r3, [r2, #0]
 8002be8:	f023 0307 	bic.w	r3, r3, #7
 8002bec:	f043 0302 	orr.w	r3, r3, #2
 8002bf0:	6013      	str	r3, [r2, #0]

  /* Set SLEEPDEEP bit of Cortex System Control Register */
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8002bf2:	4b09      	ldr	r3, [pc, #36]	; (8002c18 <HAL_PWREx_EnterSTOP2Mode+0x34>)
 8002bf4:	691a      	ldr	r2, [r3, #16]

  /* Select Stop mode entry --------------------------------------------------*/
  if(STOPEntry == PWR_STOPENTRY_WFI)
 8002bf6:	2801      	cmp	r0, #1
  SET_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8002bf8:	f042 0204 	orr.w	r2, r2, #4
 8002bfc:	611a      	str	r2, [r3, #16]
  if(STOPEntry == PWR_STOPENTRY_WFI)
 8002bfe:	d105      	bne.n	8002c0c <HAL_PWREx_EnterSTOP2Mode+0x28>
  __ASM volatile ("wfi");
 8002c00:	bf30      	wfi
    __WFE();
    __WFE();
  }

  /* Reset SLEEPDEEP bit of Cortex System Control Register */
  CLEAR_BIT(SCB->SCR, ((uint32_t)SCB_SCR_SLEEPDEEP_Msk));
 8002c02:	691a      	ldr	r2, [r3, #16]
 8002c04:	f022 0204 	bic.w	r2, r2, #4
 8002c08:	611a      	str	r2, [r3, #16]
 8002c0a:	4770      	bx	lr
  __ASM volatile ("sev");
 8002c0c:	bf40      	sev
  __ASM volatile ("wfe");
 8002c0e:	bf20      	wfe
 8002c10:	bf20      	wfe
 8002c12:	e7f6      	b.n	8002c02 <HAL_PWREx_EnterSTOP2Mode+0x1e>
 8002c14:	40007000 	.word	0x40007000
 8002c18:	e000ed00 	.word	0xe000ed00

08002c1c <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 8002c1c:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos = 0;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8002c1e:	4d1e      	ldr	r5, [pc, #120]	; (8002c98 <RCC_SetFlashLatencyFromMSIRange+0x7c>)
 8002c20:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8002c22:	00da      	lsls	r2, r3, #3
{
 8002c24:	4604      	mov	r4, r0
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 8002c26:	d518      	bpl.n	8002c5a <RCC_SetFlashLatencyFromMSIRange+0x3e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 8002c28:	f7ff ffa0 	bl	8002b6c <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 8002c2c:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8002c30:	d123      	bne.n	8002c7a <RCC_SetFlashLatencyFromMSIRange+0x5e>
  {
    if(msirange > RCC_MSIRANGE_8)
 8002c32:	2c80      	cmp	r4, #128	; 0x80
 8002c34:	d929      	bls.n	8002c8a <RCC_SetFlashLatencyFromMSIRange+0x6e>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 8002c36:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 8002c38:	bf8c      	ite	hi
 8002c3a:	2002      	movhi	r0, #2
 8002c3c:	2001      	movls	r0, #1
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 8002c3e:	4a17      	ldr	r2, [pc, #92]	; (8002c9c <RCC_SetFlashLatencyFromMSIRange+0x80>)
 8002c40:	6813      	ldr	r3, [r2, #0]
 8002c42:	f023 0307 	bic.w	r3, r3, #7
 8002c46:	4303      	orrs	r3, r0
 8002c48:	6013      	str	r3, [r2, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 8002c4a:	6813      	ldr	r3, [r2, #0]
 8002c4c:	f003 0307 	and.w	r3, r3, #7
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 8002c50:	1a18      	subs	r0, r3, r0
 8002c52:	bf18      	it	ne
 8002c54:	2001      	movne	r0, #1
 8002c56:	b003      	add	sp, #12
 8002c58:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 8002c5a:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8002c5c:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002c60:	65ab      	str	r3, [r5, #88]	; 0x58
 8002c62:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8002c64:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002c68:	9301      	str	r3, [sp, #4]
 8002c6a:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 8002c6c:	f7ff ff7e 	bl	8002b6c <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 8002c70:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8002c72:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002c76:	65ab      	str	r3, [r5, #88]	; 0x58
 8002c78:	e7d8      	b.n	8002c2c <RCC_SetFlashLatencyFromMSIRange+0x10>
    if(msirange > RCC_MSIRANGE_8)
 8002c7a:	2c80      	cmp	r4, #128	; 0x80
 8002c7c:	d807      	bhi.n	8002c8e <RCC_SetFlashLatencyFromMSIRange+0x72>
      if(msirange == RCC_MSIRANGE_8)
 8002c7e:	d008      	beq.n	8002c92 <RCC_SetFlashLatencyFromMSIRange+0x76>
      else if(msirange == RCC_MSIRANGE_7)
 8002c80:	f1a4 0370 	sub.w	r3, r4, #112	; 0x70
 8002c84:	4258      	negs	r0, r3
 8002c86:	4158      	adcs	r0, r3
 8002c88:	e7d9      	b.n	8002c3e <RCC_SetFlashLatencyFromMSIRange+0x22>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8002c8a:	2000      	movs	r0, #0
 8002c8c:	e7d7      	b.n	8002c3e <RCC_SetFlashLatencyFromMSIRange+0x22>
      latency = FLASH_LATENCY_3; /* 3WS */
 8002c8e:	2003      	movs	r0, #3
 8002c90:	e7d5      	b.n	8002c3e <RCC_SetFlashLatencyFromMSIRange+0x22>
        latency = FLASH_LATENCY_2; /* 2WS */
 8002c92:	2002      	movs	r0, #2
 8002c94:	e7d3      	b.n	8002c3e <RCC_SetFlashLatencyFromMSIRange+0x22>
 8002c96:	bf00      	nop
 8002c98:	40021000 	.word	0x40021000
 8002c9c:	40022000 	.word	0x40022000

08002ca0 <HAL_RCC_GetSysClockFreq>:
  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8002ca0:	4b2f      	ldr	r3, [pc, #188]	; (8002d60 <HAL_RCC_GetSysClockFreq+0xc0>)
 8002ca2:	689a      	ldr	r2, [r3, #8]
 8002ca4:	f012 0f0c 	tst.w	r2, #12
{
 8002ca8:	b510      	push	{r4, lr}
  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8002caa:	d009      	beq.n	8002cc0 <HAL_RCC_GetSysClockFreq+0x20>
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8002cac:	689a      	ldr	r2, [r3, #8]
 8002cae:	f002 020c 	and.w	r2, r2, #12
  if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) ||
 8002cb2:	2a0c      	cmp	r2, #12
 8002cb4:	d12d      	bne.n	8002d12 <HAL_RCC_GetSysClockFreq+0x72>
     ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)))
 8002cb6:	68da      	ldr	r2, [r3, #12]
 8002cb8:	f002 0203 	and.w	r2, r2, #3
 8002cbc:	2a01      	cmp	r2, #1
 8002cbe:	d128      	bne.n	8002d12 <HAL_RCC_GetSysClockFreq+0x72>
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 8002cc0:	681a      	ldr	r2, [r3, #0]
    msirange = MSIRangeTable[msirange];
 8002cc2:	4928      	ldr	r1, [pc, #160]	; (8002d64 <HAL_RCC_GetSysClockFreq+0xc4>)
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == RESET)
 8002cc4:	0712      	lsls	r2, r2, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8002cc6:	bf55      	itete	pl
 8002cc8:	f8d3 2094 	ldrpl.w	r2, [r3, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8002ccc:	681a      	ldrmi	r2, [r3, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8002cce:	f3c2 2203 	ubfxpl	r2, r2, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8002cd2:	f3c2 1203 	ubfxmi	r2, r2, #4, #4
    msirange = MSIRangeTable[msirange];
 8002cd6:	f851 2022 	ldr.w	r2, [r1, r2, lsl #2]
    if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI)
 8002cda:	6899      	ldr	r1, [r3, #8]
      sysclockfreq = msirange;
 8002cdc:	f011 0f0c 	tst.w	r1, #12
 8002ce0:	bf0c      	ite	eq
 8002ce2:	4610      	moveq	r0, r2
 8002ce4:	2000      	movne	r0, #0
  if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL)
 8002ce6:	6899      	ldr	r1, [r3, #8]
 8002ce8:	f001 010c 	and.w	r1, r1, #12
 8002cec:	290c      	cmp	r1, #12
 8002cee:	d130      	bne.n	8002d52 <HAL_RCC_GetSysClockFreq+0xb2>
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8002cf0:	68dc      	ldr	r4, [r3, #12]
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8002cf2:	68d8      	ldr	r0, [r3, #12]
 8002cf4:	f3c0 1002 	ubfx	r0, r0, #4, #3
 8002cf8:	1c41      	adds	r1, r0, #1
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 8002cfa:	f004 0003 	and.w	r0, r4, #3
    switch (pllsource)
 8002cfe:	2802      	cmp	r0, #2
 8002d00:	d019      	beq.n	8002d36 <HAL_RCC_GetSysClockFreq+0x96>
 8002d02:	2803      	cmp	r0, #3
 8002d04:	d026      	beq.n	8002d54 <HAL_RCC_GetSysClockFreq+0xb4>
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8002d06:	fbb2 f2f1 	udiv	r2, r2, r1
 8002d0a:	68d8      	ldr	r0, [r3, #12]
 8002d0c:	f3c0 2006 	ubfx	r0, r0, #8, #7
 8002d10:	e017      	b.n	8002d42 <HAL_RCC_GetSysClockFreq+0xa2>
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI)
 8002d12:	689a      	ldr	r2, [r3, #8]
 8002d14:	f002 020c 	and.w	r2, r2, #12
 8002d18:	2a04      	cmp	r2, #4
 8002d1a:	d007      	beq.n	8002d2c <HAL_RCC_GetSysClockFreq+0x8c>
  else if(__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE)
 8002d1c:	689a      	ldr	r2, [r3, #8]
 8002d1e:	f002 020c 	and.w	r2, r2, #12
 8002d22:	2a08      	cmp	r2, #8
 8002d24:	d104      	bne.n	8002d30 <HAL_RCC_GetSysClockFreq+0x90>
    sysclockfreq = HSE_VALUE;
 8002d26:	4810      	ldr	r0, [pc, #64]	; (8002d68 <HAL_RCC_GetSysClockFreq+0xc8>)
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 8002d28:	2200      	movs	r2, #0
 8002d2a:	e7dc      	b.n	8002ce6 <HAL_RCC_GetSysClockFreq+0x46>
    sysclockfreq = HSI_VALUE;
 8002d2c:	480f      	ldr	r0, [pc, #60]	; (8002d6c <HAL_RCC_GetSysClockFreq+0xcc>)
 8002d2e:	e7fb      	b.n	8002d28 <HAL_RCC_GetSysClockFreq+0x88>
  uint32_t sysclockfreq = 0U;
 8002d30:	2000      	movs	r0, #0
  uint32_t msirange = 0U, pllvco = 0U, pllsource = 0U, pllr = 2U, pllm = 2U;
 8002d32:	4602      	mov	r2, r0
 8002d34:	e7d7      	b.n	8002ce6 <HAL_RCC_GetSysClockFreq+0x46>
      pllvco = (HSI_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8002d36:	68da      	ldr	r2, [r3, #12]
 8002d38:	480c      	ldr	r0, [pc, #48]	; (8002d6c <HAL_RCC_GetSysClockFreq+0xcc>)
 8002d3a:	f3c2 2206 	ubfx	r2, r2, #8, #7
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8002d3e:	fbb0 f0f1 	udiv	r0, r0, r1
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8002d42:	68db      	ldr	r3, [r3, #12]
 8002d44:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8002d48:	3301      	adds	r3, #1
      pllvco = (msirange / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8002d4a:	4350      	muls	r0, r2
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8002d4c:	005b      	lsls	r3, r3, #1
    sysclockfreq = pllvco/pllr;
 8002d4e:	fbb0 f0f3 	udiv	r0, r0, r3
}
 8002d52:	bd10      	pop	{r4, pc}
      pllvco = (HSE_VALUE / pllm) * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos);
 8002d54:	68da      	ldr	r2, [r3, #12]
 8002d56:	4804      	ldr	r0, [pc, #16]	; (8002d68 <HAL_RCC_GetSysClockFreq+0xc8>)
 8002d58:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8002d5c:	e7ef      	b.n	8002d3e <HAL_RCC_GetSysClockFreq+0x9e>
 8002d5e:	bf00      	nop
 8002d60:	40021000 	.word	0x40021000
 8002d64:	0800fa38 	.word	0x0800fa38
 8002d68:	007a1200 	.word	0x007a1200
 8002d6c:	00f42400 	.word	0x00f42400

08002d70 <HAL_RCC_OscConfig>:
{
 8002d70:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  if(RCC_OscInitStruct == NULL)
 8002d74:	4605      	mov	r5, r0
 8002d76:	b908      	cbnz	r0, 8002d7c <HAL_RCC_OscConfig+0xc>
      return HAL_ERROR;
 8002d78:	2001      	movs	r0, #1
 8002d7a:	e08d      	b.n	8002e98 <HAL_RCC_OscConfig+0x128>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 8002d7c:	6803      	ldr	r3, [r0, #0]
 8002d7e:	06d8      	lsls	r0, r3, #27
 8002d80:	d538      	bpl.n	8002df4 <HAL_RCC_OscConfig+0x84>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_MSI) )
 8002d82:	4cab      	ldr	r4, [pc, #684]	; (8003030 <HAL_RCC_OscConfig+0x2c0>)
 8002d84:	68a3      	ldr	r3, [r4, #8]
 8002d86:	f013 0f0c 	tst.w	r3, #12
 8002d8a:	d161      	bne.n	8002e50 <HAL_RCC_OscConfig+0xe0>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 8002d8c:	6823      	ldr	r3, [r4, #0]
 8002d8e:	0799      	lsls	r1, r3, #30
 8002d90:	d502      	bpl.n	8002d98 <HAL_RCC_OscConfig+0x28>
 8002d92:	69ab      	ldr	r3, [r5, #24]
 8002d94:	2b00      	cmp	r3, #0
 8002d96:	d0ef      	beq.n	8002d78 <HAL_RCC_OscConfig+0x8>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 8002d98:	6823      	ldr	r3, [r4, #0]
 8002d9a:	6a28      	ldr	r0, [r5, #32]
 8002d9c:	071a      	lsls	r2, r3, #28
 8002d9e:	bf56      	itet	pl
 8002da0:	f8d4 3094 	ldrpl.w	r3, [r4, #148]	; 0x94
 8002da4:	6823      	ldrmi	r3, [r4, #0]
 8002da6:	091b      	lsrpl	r3, r3, #4
 8002da8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8002dac:	4283      	cmp	r3, r0
 8002dae:	d23a      	bcs.n	8002e26 <HAL_RCC_OscConfig+0xb6>
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8002db0:	f7ff ff34 	bl	8002c1c <RCC_SetFlashLatencyFromMSIRange>
 8002db4:	2800      	cmp	r0, #0
 8002db6:	d1df      	bne.n	8002d78 <HAL_RCC_OscConfig+0x8>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8002db8:	6823      	ldr	r3, [r4, #0]
 8002dba:	f043 0308 	orr.w	r3, r3, #8
 8002dbe:	6023      	str	r3, [r4, #0]
 8002dc0:	6823      	ldr	r3, [r4, #0]
 8002dc2:	6a2a      	ldr	r2, [r5, #32]
 8002dc4:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002dc8:	4313      	orrs	r3, r2
 8002dca:	6023      	str	r3, [r4, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002dcc:	6863      	ldr	r3, [r4, #4]
 8002dce:	69ea      	ldr	r2, [r5, #28]
 8002dd0:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8002dd4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002dd8:	6063      	str	r3, [r4, #4]
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 8002dda:	f7ff ff61 	bl	8002ca0 <HAL_RCC_GetSysClockFreq>
 8002dde:	68a3      	ldr	r3, [r4, #8]
 8002de0:	4a94      	ldr	r2, [pc, #592]	; (8003034 <HAL_RCC_OscConfig+0x2c4>)
 8002de2:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8002de6:	5cd3      	ldrb	r3, [r2, r3]
 8002de8:	40d8      	lsrs	r0, r3
 8002dea:	4b93      	ldr	r3, [pc, #588]	; (8003038 <HAL_RCC_OscConfig+0x2c8>)
 8002dec:	6018      	str	r0, [r3, #0]
        HAL_InitTick (TICK_INT_PRIORITY);
 8002dee:	2000      	movs	r0, #0
 8002df0:	f7fe f820 	bl	8000e34 <HAL_InitTick>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 8002df4:	682b      	ldr	r3, [r5, #0]
 8002df6:	07d8      	lsls	r0, r3, #31
 8002df8:	d461      	bmi.n	8002ebe <HAL_RCC_OscConfig+0x14e>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 8002dfa:	682b      	ldr	r3, [r5, #0]
 8002dfc:	0799      	lsls	r1, r3, #30
 8002dfe:	f100 80a9 	bmi.w	8002f54 <HAL_RCC_OscConfig+0x1e4>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 8002e02:	682b      	ldr	r3, [r5, #0]
 8002e04:	071a      	lsls	r2, r3, #28
 8002e06:	f100 80e7 	bmi.w	8002fd8 <HAL_RCC_OscConfig+0x268>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 8002e0a:	682b      	ldr	r3, [r5, #0]
 8002e0c:	075b      	lsls	r3, r3, #29
 8002e0e:	f100 8115 	bmi.w	800303c <HAL_RCC_OscConfig+0x2cc>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 8002e12:	682b      	ldr	r3, [r5, #0]
 8002e14:	069a      	lsls	r2, r3, #26
 8002e16:	f100 817c 	bmi.w	8003112 <HAL_RCC_OscConfig+0x3a2>
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 8002e1a:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8002e1c:	2a00      	cmp	r2, #0
 8002e1e:	f040 81a3 	bne.w	8003168 <HAL_RCC_OscConfig+0x3f8>
  return HAL_OK;
 8002e22:	2000      	movs	r0, #0
 8002e24:	e038      	b.n	8002e98 <HAL_RCC_OscConfig+0x128>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8002e26:	6823      	ldr	r3, [r4, #0]
 8002e28:	f043 0308 	orr.w	r3, r3, #8
 8002e2c:	6023      	str	r3, [r4, #0]
 8002e2e:	6823      	ldr	r3, [r4, #0]
 8002e30:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002e34:	4303      	orrs	r3, r0
 8002e36:	6023      	str	r3, [r4, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002e38:	6863      	ldr	r3, [r4, #4]
 8002e3a:	69ea      	ldr	r2, [r5, #28]
 8002e3c:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8002e40:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002e44:	6063      	str	r3, [r4, #4]
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8002e46:	f7ff fee9 	bl	8002c1c <RCC_SetFlashLatencyFromMSIRange>
 8002e4a:	2800      	cmp	r0, #0
 8002e4c:	d0c5      	beq.n	8002dda <HAL_RCC_OscConfig+0x6a>
 8002e4e:	e793      	b.n	8002d78 <HAL_RCC_OscConfig+0x8>
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 8002e50:	69ab      	ldr	r3, [r5, #24]
 8002e52:	b323      	cbz	r3, 8002e9e <HAL_RCC_OscConfig+0x12e>
        __HAL_RCC_MSI_ENABLE();
 8002e54:	6823      	ldr	r3, [r4, #0]
 8002e56:	f043 0301 	orr.w	r3, r3, #1
 8002e5a:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8002e5c:	f7fe f818 	bl	8000e90 <HAL_GetTick>
 8002e60:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 8002e62:	6823      	ldr	r3, [r4, #0]
 8002e64:	079b      	lsls	r3, r3, #30
 8002e66:	d511      	bpl.n	8002e8c <HAL_RCC_OscConfig+0x11c>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8002e68:	6823      	ldr	r3, [r4, #0]
 8002e6a:	f043 0308 	orr.w	r3, r3, #8
 8002e6e:	6023      	str	r3, [r4, #0]
 8002e70:	6823      	ldr	r3, [r4, #0]
 8002e72:	6a2a      	ldr	r2, [r5, #32]
 8002e74:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002e78:	4313      	orrs	r3, r2
 8002e7a:	6023      	str	r3, [r4, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002e7c:	6863      	ldr	r3, [r4, #4]
 8002e7e:	69ea      	ldr	r2, [r5, #28]
 8002e80:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8002e84:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002e88:	6063      	str	r3, [r4, #4]
 8002e8a:	e7b3      	b.n	8002df4 <HAL_RCC_OscConfig+0x84>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8002e8c:	f7fe f800 	bl	8000e90 <HAL_GetTick>
 8002e90:	1b80      	subs	r0, r0, r6
 8002e92:	2802      	cmp	r0, #2
 8002e94:	d9e5      	bls.n	8002e62 <HAL_RCC_OscConfig+0xf2>
            return HAL_TIMEOUT;
 8002e96:	2003      	movs	r0, #3
}
 8002e98:	b002      	add	sp, #8
 8002e9a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        __HAL_RCC_MSI_DISABLE();
 8002e9e:	6823      	ldr	r3, [r4, #0]
 8002ea0:	f023 0301 	bic.w	r3, r3, #1
 8002ea4:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8002ea6:	f7fd fff3 	bl	8000e90 <HAL_GetTick>
 8002eaa:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != RESET)
 8002eac:	6823      	ldr	r3, [r4, #0]
 8002eae:	079f      	lsls	r7, r3, #30
 8002eb0:	d5a0      	bpl.n	8002df4 <HAL_RCC_OscConfig+0x84>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 8002eb2:	f7fd ffed 	bl	8000e90 <HAL_GetTick>
 8002eb6:	1b80      	subs	r0, r0, r6
 8002eb8:	2802      	cmp	r0, #2
 8002eba:	d9f7      	bls.n	8002eac <HAL_RCC_OscConfig+0x13c>
 8002ebc:	e7eb      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||
 8002ebe:	4c5c      	ldr	r4, [pc, #368]	; (8003030 <HAL_RCC_OscConfig+0x2c0>)
 8002ec0:	68a3      	ldr	r3, [r4, #8]
 8002ec2:	f003 030c 	and.w	r3, r3, #12
 8002ec6:	2b08      	cmp	r3, #8
 8002ec8:	d009      	beq.n	8002ede <HAL_RCC_OscConfig+0x16e>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8002eca:	68a3      	ldr	r3, [r4, #8]
 8002ecc:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSE) ||
 8002ed0:	2b0c      	cmp	r3, #12
 8002ed2:	d10b      	bne.n	8002eec <HAL_RCC_OscConfig+0x17c>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSE)))
 8002ed4:	68e3      	ldr	r3, [r4, #12]
 8002ed6:	f003 0303 	and.w	r3, r3, #3
 8002eda:	2b03      	cmp	r3, #3
 8002edc:	d106      	bne.n	8002eec <HAL_RCC_OscConfig+0x17c>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002ede:	6823      	ldr	r3, [r4, #0]
 8002ee0:	039a      	lsls	r2, r3, #14
 8002ee2:	d58a      	bpl.n	8002dfa <HAL_RCC_OscConfig+0x8a>
 8002ee4:	686b      	ldr	r3, [r5, #4]
 8002ee6:	2b00      	cmp	r3, #0
 8002ee8:	d187      	bne.n	8002dfa <HAL_RCC_OscConfig+0x8a>
 8002eea:	e745      	b.n	8002d78 <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002eec:	686b      	ldr	r3, [r5, #4]
 8002eee:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 8002ef2:	d110      	bne.n	8002f16 <HAL_RCC_OscConfig+0x1a6>
 8002ef4:	6823      	ldr	r3, [r4, #0]
 8002ef6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002efa:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8002efc:	f7fd ffc8 	bl	8000e90 <HAL_GetTick>
 8002f00:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 8002f02:	6823      	ldr	r3, [r4, #0]
 8002f04:	039b      	lsls	r3, r3, #14
 8002f06:	f53f af78 	bmi.w	8002dfa <HAL_RCC_OscConfig+0x8a>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002f0a:	f7fd ffc1 	bl	8000e90 <HAL_GetTick>
 8002f0e:	1b80      	subs	r0, r0, r6
 8002f10:	2864      	cmp	r0, #100	; 0x64
 8002f12:	d9f6      	bls.n	8002f02 <HAL_RCC_OscConfig+0x192>
 8002f14:	e7bf      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002f16:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8002f1a:	d104      	bne.n	8002f26 <HAL_RCC_OscConfig+0x1b6>
 8002f1c:	6823      	ldr	r3, [r4, #0]
 8002f1e:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 8002f22:	6023      	str	r3, [r4, #0]
 8002f24:	e7e6      	b.n	8002ef4 <HAL_RCC_OscConfig+0x184>
 8002f26:	6822      	ldr	r2, [r4, #0]
 8002f28:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002f2c:	6022      	str	r2, [r4, #0]
 8002f2e:	6822      	ldr	r2, [r4, #0]
 8002f30:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8002f34:	6022      	str	r2, [r4, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 8002f36:	2b00      	cmp	r3, #0
 8002f38:	d1e0      	bne.n	8002efc <HAL_RCC_OscConfig+0x18c>
        tickstart = HAL_GetTick();
 8002f3a:	f7fd ffa9 	bl	8000e90 <HAL_GetTick>
 8002f3e:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != RESET)
 8002f40:	6823      	ldr	r3, [r4, #0]
 8002f42:	039f      	lsls	r7, r3, #14
 8002f44:	f57f af59 	bpl.w	8002dfa <HAL_RCC_OscConfig+0x8a>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002f48:	f7fd ffa2 	bl	8000e90 <HAL_GetTick>
 8002f4c:	1b80      	subs	r0, r0, r6
 8002f4e:	2864      	cmp	r0, #100	; 0x64
 8002f50:	d9f6      	bls.n	8002f40 <HAL_RCC_OscConfig+0x1d0>
 8002f52:	e7a0      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 8002f54:	4c36      	ldr	r4, [pc, #216]	; (8003030 <HAL_RCC_OscConfig+0x2c0>)
 8002f56:	68a3      	ldr	r3, [r4, #8]
 8002f58:	f003 030c 	and.w	r3, r3, #12
 8002f5c:	2b04      	cmp	r3, #4
 8002f5e:	d009      	beq.n	8002f74 <HAL_RCC_OscConfig+0x204>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8002f60:	68a3      	ldr	r3, [r4, #8]
 8002f62:	f003 030c 	and.w	r3, r3, #12
    if((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_HSI) ||
 8002f66:	2b0c      	cmp	r3, #12
 8002f68:	d113      	bne.n	8002f92 <HAL_RCC_OscConfig+0x222>
       ((__HAL_RCC_GET_SYSCLK_SOURCE() == RCC_CFGR_SWS_PLL) && (__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_HSI)))
 8002f6a:	68e3      	ldr	r3, [r4, #12]
 8002f6c:	f003 0303 	and.w	r3, r3, #3
 8002f70:	2b02      	cmp	r3, #2
 8002f72:	d10e      	bne.n	8002f92 <HAL_RCC_OscConfig+0x222>
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 8002f74:	6823      	ldr	r3, [r4, #0]
 8002f76:	055e      	lsls	r6, r3, #21
 8002f78:	d503      	bpl.n	8002f82 <HAL_RCC_OscConfig+0x212>
 8002f7a:	68eb      	ldr	r3, [r5, #12]
 8002f7c:	2b00      	cmp	r3, #0
 8002f7e:	f43f aefb 	beq.w	8002d78 <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 8002f82:	6863      	ldr	r3, [r4, #4]
 8002f84:	692a      	ldr	r2, [r5, #16]
 8002f86:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 8002f8a:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 8002f8e:	6063      	str	r3, [r4, #4]
 8002f90:	e737      	b.n	8002e02 <HAL_RCC_OscConfig+0x92>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 8002f92:	68eb      	ldr	r3, [r5, #12]
 8002f94:	b17b      	cbz	r3, 8002fb6 <HAL_RCC_OscConfig+0x246>
        __HAL_RCC_HSI_ENABLE();
 8002f96:	6823      	ldr	r3, [r4, #0]
 8002f98:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002f9c:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8002f9e:	f7fd ff77 	bl	8000e90 <HAL_GetTick>
 8002fa2:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 8002fa4:	6823      	ldr	r3, [r4, #0]
 8002fa6:	0558      	lsls	r0, r3, #21
 8002fa8:	d4eb      	bmi.n	8002f82 <HAL_RCC_OscConfig+0x212>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002faa:	f7fd ff71 	bl	8000e90 <HAL_GetTick>
 8002fae:	1b80      	subs	r0, r0, r6
 8002fb0:	2802      	cmp	r0, #2
 8002fb2:	d9f7      	bls.n	8002fa4 <HAL_RCC_OscConfig+0x234>
 8002fb4:	e76f      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
        __HAL_RCC_HSI_DISABLE();
 8002fb6:	6823      	ldr	r3, [r4, #0]
 8002fb8:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002fbc:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8002fbe:	f7fd ff67 	bl	8000e90 <HAL_GetTick>
 8002fc2:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != RESET)
 8002fc4:	6823      	ldr	r3, [r4, #0]
 8002fc6:	0559      	lsls	r1, r3, #21
 8002fc8:	f57f af1b 	bpl.w	8002e02 <HAL_RCC_OscConfig+0x92>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002fcc:	f7fd ff60 	bl	8000e90 <HAL_GetTick>
 8002fd0:	1b80      	subs	r0, r0, r6
 8002fd2:	2802      	cmp	r0, #2
 8002fd4:	d9f6      	bls.n	8002fc4 <HAL_RCC_OscConfig+0x254>
 8002fd6:	e75e      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 8002fd8:	696b      	ldr	r3, [r5, #20]
 8002fda:	4c15      	ldr	r4, [pc, #84]	; (8003030 <HAL_RCC_OscConfig+0x2c0>)
 8002fdc:	b19b      	cbz	r3, 8003006 <HAL_RCC_OscConfig+0x296>
      __HAL_RCC_LSI_ENABLE();
 8002fde:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8002fe2:	f043 0301 	orr.w	r3, r3, #1
 8002fe6:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      tickstart = HAL_GetTick();
 8002fea:	f7fd ff51 	bl	8000e90 <HAL_GetTick>
 8002fee:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == RESET)
 8002ff0:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8002ff4:	079f      	lsls	r7, r3, #30
 8002ff6:	f53f af08 	bmi.w	8002e0a <HAL_RCC_OscConfig+0x9a>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8002ffa:	f7fd ff49 	bl	8000e90 <HAL_GetTick>
 8002ffe:	1b80      	subs	r0, r0, r6
 8003000:	2802      	cmp	r0, #2
 8003002:	d9f5      	bls.n	8002ff0 <HAL_RCC_OscConfig+0x280>
 8003004:	e747      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
      __HAL_RCC_LSI_DISABLE();
 8003006:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800300a:	f023 0301 	bic.w	r3, r3, #1
 800300e:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      tickstart = HAL_GetTick();
 8003012:	f7fd ff3d 	bl	8000e90 <HAL_GetTick>
 8003016:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != RESET)
 8003018:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800301c:	0798      	lsls	r0, r3, #30
 800301e:	f57f aef4 	bpl.w	8002e0a <HAL_RCC_OscConfig+0x9a>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8003022:	f7fd ff35 	bl	8000e90 <HAL_GetTick>
 8003026:	1b80      	subs	r0, r0, r6
 8003028:	2802      	cmp	r0, #2
 800302a:	d9f5      	bls.n	8003018 <HAL_RCC_OscConfig+0x2a8>
 800302c:	e733      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
 800302e:	bf00      	nop
 8003030:	40021000 	.word	0x40021000
 8003034:	0800fa1f 	.word	0x0800fa1f
 8003038:	20000024 	.word	0x20000024
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 800303c:	4c79      	ldr	r4, [pc, #484]	; (8003224 <HAL_RCC_OscConfig+0x4b4>)
 800303e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003040:	00d9      	lsls	r1, r3, #3
 8003042:	d427      	bmi.n	8003094 <HAL_RCC_OscConfig+0x324>
      __HAL_RCC_PWR_CLK_ENABLE();
 8003044:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8003046:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800304a:	65a3      	str	r3, [r4, #88]	; 0x58
 800304c:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800304e:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8003052:	9301      	str	r3, [sp, #4]
 8003054:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8003056:	2701      	movs	r7, #1
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 8003058:	4e73      	ldr	r6, [pc, #460]	; (8003228 <HAL_RCC_OscConfig+0x4b8>)
 800305a:	6833      	ldr	r3, [r6, #0]
 800305c:	05da      	lsls	r2, r3, #23
 800305e:	d51b      	bpl.n	8003098 <HAL_RCC_OscConfig+0x328>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8003060:	68ab      	ldr	r3, [r5, #8]
 8003062:	2b01      	cmp	r3, #1
 8003064:	d129      	bne.n	80030ba <HAL_RCC_OscConfig+0x34a>
 8003066:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800306a:	f043 0301 	orr.w	r3, r3, #1
 800306e:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
      tickstart = HAL_GetTick();
 8003072:	f7fd ff0d 	bl	8000e90 <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003076:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 800307a:	4606      	mov	r6, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 800307c:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 8003080:	0798      	lsls	r0, r3, #30
 8003082:	d540      	bpl.n	8003106 <HAL_RCC_OscConfig+0x396>
    if(pwrclkchanged == SET)
 8003084:	2f00      	cmp	r7, #0
 8003086:	f43f aec4 	beq.w	8002e12 <HAL_RCC_OscConfig+0xa2>
      __HAL_RCC_PWR_CLK_DISABLE();
 800308a:	6da3      	ldr	r3, [r4, #88]	; 0x58
 800308c:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8003090:	65a3      	str	r3, [r4, #88]	; 0x58
 8003092:	e6be      	b.n	8002e12 <HAL_RCC_OscConfig+0xa2>
    FlagStatus       pwrclkchanged = RESET;
 8003094:	2700      	movs	r7, #0
 8003096:	e7df      	b.n	8003058 <HAL_RCC_OscConfig+0x2e8>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8003098:	6833      	ldr	r3, [r6, #0]
 800309a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800309e:	6033      	str	r3, [r6, #0]
      tickstart = HAL_GetTick();
 80030a0:	f7fd fef6 	bl	8000e90 <HAL_GetTick>
 80030a4:	4680      	mov	r8, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80030a6:	6833      	ldr	r3, [r6, #0]
 80030a8:	05db      	lsls	r3, r3, #23
 80030aa:	d4d9      	bmi.n	8003060 <HAL_RCC_OscConfig+0x2f0>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80030ac:	f7fd fef0 	bl	8000e90 <HAL_GetTick>
 80030b0:	eba0 0008 	sub.w	r0, r0, r8
 80030b4:	2802      	cmp	r0, #2
 80030b6:	d9f6      	bls.n	80030a6 <HAL_RCC_OscConfig+0x336>
 80030b8:	e6ed      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80030ba:	2b05      	cmp	r3, #5
 80030bc:	d106      	bne.n	80030cc <HAL_RCC_OscConfig+0x35c>
 80030be:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80030c2:	f043 0304 	orr.w	r3, r3, #4
 80030c6:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 80030ca:	e7cc      	b.n	8003066 <HAL_RCC_OscConfig+0x2f6>
 80030cc:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 80030d0:	f022 0201 	bic.w	r2, r2, #1
 80030d4:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
 80030d8:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 80030dc:	f022 0204 	bic.w	r2, r2, #4
 80030e0:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 80030e4:	2b00      	cmp	r3, #0
 80030e6:	d1c4      	bne.n	8003072 <HAL_RCC_OscConfig+0x302>
      tickstart = HAL_GetTick();
 80030e8:	f7fd fed2 	bl	8000e90 <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80030ec:	f241 3888 	movw	r8, #5000	; 0x1388
      tickstart = HAL_GetTick();
 80030f0:	4606      	mov	r6, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != RESET)
 80030f2:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80030f6:	0799      	lsls	r1, r3, #30
 80030f8:	d5c4      	bpl.n	8003084 <HAL_RCC_OscConfig+0x314>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80030fa:	f7fd fec9 	bl	8000e90 <HAL_GetTick>
 80030fe:	1b80      	subs	r0, r0, r6
 8003100:	4540      	cmp	r0, r8
 8003102:	d9f6      	bls.n	80030f2 <HAL_RCC_OscConfig+0x382>
 8003104:	e6c7      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003106:	f7fd fec3 	bl	8000e90 <HAL_GetTick>
 800310a:	1b80      	subs	r0, r0, r6
 800310c:	4540      	cmp	r0, r8
 800310e:	d9b5      	bls.n	800307c <HAL_RCC_OscConfig+0x30c>
 8003110:	e6c1      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 8003112:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 8003114:	4c43      	ldr	r4, [pc, #268]	; (8003224 <HAL_RCC_OscConfig+0x4b4>)
 8003116:	b19b      	cbz	r3, 8003140 <HAL_RCC_OscConfig+0x3d0>
      __HAL_RCC_HSI48_ENABLE();
 8003118:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800311c:	f043 0301 	orr.w	r3, r3, #1
 8003120:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
      tickstart = HAL_GetTick();
 8003124:	f7fd feb4 	bl	8000e90 <HAL_GetTick>
 8003128:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == RESET)
 800312a:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800312e:	079b      	lsls	r3, r3, #30
 8003130:	f53f ae73 	bmi.w	8002e1a <HAL_RCC_OscConfig+0xaa>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 8003134:	f7fd feac 	bl	8000e90 <HAL_GetTick>
 8003138:	1b80      	subs	r0, r0, r6
 800313a:	2802      	cmp	r0, #2
 800313c:	d9f5      	bls.n	800312a <HAL_RCC_OscConfig+0x3ba>
 800313e:	e6aa      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
      __HAL_RCC_HSI48_DISABLE();
 8003140:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8003144:	f023 0301 	bic.w	r3, r3, #1
 8003148:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
      tickstart = HAL_GetTick();
 800314c:	f7fd fea0 	bl	8000e90 <HAL_GetTick>
 8003150:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != RESET)
 8003152:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8003156:	079f      	lsls	r7, r3, #30
 8003158:	f57f ae5f 	bpl.w	8002e1a <HAL_RCC_OscConfig+0xaa>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800315c:	f7fd fe98 	bl	8000e90 <HAL_GetTick>
 8003160:	1b80      	subs	r0, r0, r6
 8003162:	2802      	cmp	r0, #2
 8003164:	d9f5      	bls.n	8003152 <HAL_RCC_OscConfig+0x3e2>
 8003166:	e696      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
    if(__HAL_RCC_GET_SYSCLK_SOURCE() != RCC_CFGR_SWS_PLL)
 8003168:	4c2e      	ldr	r4, [pc, #184]	; (8003224 <HAL_RCC_OscConfig+0x4b4>)
 800316a:	68a3      	ldr	r3, [r4, #8]
 800316c:	f003 030c 	and.w	r3, r3, #12
 8003170:	2b0c      	cmp	r3, #12
 8003172:	f43f ae01 	beq.w	8002d78 <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_PLL_DISABLE();
 8003176:	6823      	ldr	r3, [r4, #0]
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8003178:	2a02      	cmp	r2, #2
        __HAL_RCC_PLL_DISABLE();
 800317a:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 800317e:	6023      	str	r3, [r4, #0]
      if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 8003180:	d136      	bne.n	80031f0 <HAL_RCC_OscConfig+0x480>
        tickstart = HAL_GetTick();
 8003182:	f7fd fe85 	bl	8000e90 <HAL_GetTick>
 8003186:	4606      	mov	r6, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8003188:	6823      	ldr	r3, [r4, #0]
 800318a:	0198      	lsls	r0, r3, #6
 800318c:	d42a      	bmi.n	80031e4 <HAL_RCC_OscConfig+0x474>
        __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 800318e:	6bab      	ldr	r3, [r5, #56]	; 0x38
 8003190:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 8003192:	06db      	lsls	r3, r3, #27
 8003194:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8003198:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 800319a:	4313      	orrs	r3, r2
 800319c:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 800319e:	3a01      	subs	r2, #1
 80031a0:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 80031a4:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 80031a6:	0852      	lsrs	r2, r2, #1
 80031a8:	3a01      	subs	r2, #1
 80031aa:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 80031ae:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 80031b0:	0852      	lsrs	r2, r2, #1
 80031b2:	3a01      	subs	r2, #1
 80031b4:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 80031b8:	60e3      	str	r3, [r4, #12]
        __HAL_RCC_PLL_ENABLE();
 80031ba:	6823      	ldr	r3, [r4, #0]
 80031bc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80031c0:	6023      	str	r3, [r4, #0]
         __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 80031c2:	68e3      	ldr	r3, [r4, #12]
 80031c4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80031c8:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 80031ca:	f7fd fe61 	bl	8000e90 <HAL_GetTick>
 80031ce:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 80031d0:	6823      	ldr	r3, [r4, #0]
 80031d2:	0199      	lsls	r1, r3, #6
 80031d4:	f53f ae25 	bmi.w	8002e22 <HAL_RCC_OscConfig+0xb2>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80031d8:	f7fd fe5a 	bl	8000e90 <HAL_GetTick>
 80031dc:	1b40      	subs	r0, r0, r5
 80031de:	2802      	cmp	r0, #2
 80031e0:	d9f6      	bls.n	80031d0 <HAL_RCC_OscConfig+0x460>
 80031e2:	e658      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80031e4:	f7fd fe54 	bl	8000e90 <HAL_GetTick>
 80031e8:	1b80      	subs	r0, r0, r6
 80031ea:	2802      	cmp	r0, #2
 80031ec:	d9cc      	bls.n	8003188 <HAL_RCC_OscConfig+0x418>
 80031ee:	e652      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
        if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == RESET)
 80031f0:	6823      	ldr	r3, [r4, #0]
 80031f2:	011a      	lsls	r2, r3, #4
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 80031f4:	bf5e      	ittt	pl
 80031f6:	68e3      	ldrpl	r3, [r4, #12]
 80031f8:	f023 0303 	bicpl.w	r3, r3, #3
 80031fc:	60e3      	strpl	r3, [r4, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI2CLK);
 80031fe:	68e3      	ldr	r3, [r4, #12]
 8003200:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 8003204:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 8003208:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 800320a:	f7fd fe41 	bl	8000e90 <HAL_GetTick>
 800320e:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != RESET)
 8003210:	6823      	ldr	r3, [r4, #0]
 8003212:	019b      	lsls	r3, r3, #6
 8003214:	f57f ae05 	bpl.w	8002e22 <HAL_RCC_OscConfig+0xb2>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8003218:	f7fd fe3a 	bl	8000e90 <HAL_GetTick>
 800321c:	1b40      	subs	r0, r0, r5
 800321e:	2802      	cmp	r0, #2
 8003220:	d9f6      	bls.n	8003210 <HAL_RCC_OscConfig+0x4a0>
 8003222:	e638      	b.n	8002e96 <HAL_RCC_OscConfig+0x126>
 8003224:	40021000 	.word	0x40021000
 8003228:	40007000 	.word	0x40007000

0800322c <HAL_RCC_ClockConfig>:
{
 800322c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003230:	460e      	mov	r6, r1
  if(RCC_ClkInitStruct == NULL)
 8003232:	4604      	mov	r4, r0
 8003234:	b910      	cbnz	r0, 800323c <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 8003236:	2001      	movs	r0, #1
 8003238:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 800323c:	4a40      	ldr	r2, [pc, #256]	; (8003340 <HAL_RCC_ClockConfig+0x114>)
 800323e:	6813      	ldr	r3, [r2, #0]
 8003240:	f003 0307 	and.w	r3, r3, #7
 8003244:	428b      	cmp	r3, r1
 8003246:	d328      	bcc.n	800329a <HAL_RCC_ClockConfig+0x6e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8003248:	6823      	ldr	r3, [r4, #0]
 800324a:	07d9      	lsls	r1, r3, #31
 800324c:	d430      	bmi.n	80032b0 <HAL_RCC_ClockConfig+0x84>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800324e:	6821      	ldr	r1, [r4, #0]
 8003250:	078a      	lsls	r2, r1, #30
 8003252:	d45a      	bmi.n	800330a <HAL_RCC_ClockConfig+0xde>
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8003254:	4a3a      	ldr	r2, [pc, #232]	; (8003340 <HAL_RCC_ClockConfig+0x114>)
 8003256:	6813      	ldr	r3, [r2, #0]
 8003258:	f003 0307 	and.w	r3, r3, #7
 800325c:	429e      	cmp	r6, r3
 800325e:	d35c      	bcc.n	800331a <HAL_RCC_ClockConfig+0xee>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8003260:	f011 0f04 	tst.w	r1, #4
 8003264:	4d37      	ldr	r5, [pc, #220]	; (8003344 <HAL_RCC_ClockConfig+0x118>)
 8003266:	d163      	bne.n	8003330 <HAL_RCC_ClockConfig+0x104>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 8003268:	070b      	lsls	r3, r1, #28
 800326a:	d506      	bpl.n	800327a <HAL_RCC_ClockConfig+0x4e>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800326c:	68ab      	ldr	r3, [r5, #8]
 800326e:	6922      	ldr	r2, [r4, #16]
 8003270:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8003274:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 8003278:	60ab      	str	r3, [r5, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos];
 800327a:	f7ff fd11 	bl	8002ca0 <HAL_RCC_GetSysClockFreq>
 800327e:	68ab      	ldr	r3, [r5, #8]
 8003280:	4a31      	ldr	r2, [pc, #196]	; (8003348 <HAL_RCC_ClockConfig+0x11c>)
 8003282:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8003286:	5cd3      	ldrb	r3, [r2, r3]
 8003288:	40d8      	lsrs	r0, r3
 800328a:	4b30      	ldr	r3, [pc, #192]	; (800334c <HAL_RCC_ClockConfig+0x120>)
 800328c:	6018      	str	r0, [r3, #0]
  HAL_InitTick (TICK_INT_PRIORITY);
 800328e:	2000      	movs	r0, #0
 8003290:	f7fd fdd0 	bl	8000e34 <HAL_InitTick>
  return HAL_OK;
 8003294:	2000      	movs	r0, #0
 8003296:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    __HAL_FLASH_SET_LATENCY(FLatency);
 800329a:	6813      	ldr	r3, [r2, #0]
 800329c:	f023 0307 	bic.w	r3, r3, #7
 80032a0:	430b      	orrs	r3, r1
 80032a2:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80032a4:	6813      	ldr	r3, [r2, #0]
 80032a6:	f003 0307 	and.w	r3, r3, #7
 80032aa:	4299      	cmp	r1, r3
 80032ac:	d1c3      	bne.n	8003236 <HAL_RCC_ClockConfig+0xa>
 80032ae:	e7cb      	b.n	8003248 <HAL_RCC_ClockConfig+0x1c>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80032b0:	6862      	ldr	r2, [r4, #4]
 80032b2:	4d24      	ldr	r5, [pc, #144]	; (8003344 <HAL_RCC_ClockConfig+0x118>)
 80032b4:	2a03      	cmp	r2, #3
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 80032b6:	682b      	ldr	r3, [r5, #0]
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80032b8:	d11b      	bne.n	80032f2 <HAL_RCC_ClockConfig+0xc6>
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == RESET)
 80032ba:	f013 7f00 	tst.w	r3, #33554432	; 0x2000000
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 80032be:	d0ba      	beq.n	8003236 <HAL_RCC_ClockConfig+0xa>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 80032c0:	68ab      	ldr	r3, [r5, #8]
 80032c2:	f023 0303 	bic.w	r3, r3, #3
 80032c6:	4313      	orrs	r3, r2
 80032c8:	60ab      	str	r3, [r5, #8]
    tickstart = HAL_GetTick();
 80032ca:	f7fd fde1 	bl	8000e90 <HAL_GetTick>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80032ce:	f241 3888 	movw	r8, #5000	; 0x1388
    tickstart = HAL_GetTick();
 80032d2:	4607      	mov	r7, r0
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 80032d4:	68ab      	ldr	r3, [r5, #8]
 80032d6:	6862      	ldr	r2, [r4, #4]
 80032d8:	f003 030c 	and.w	r3, r3, #12
 80032dc:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 80032e0:	d0b5      	beq.n	800324e <HAL_RCC_ClockConfig+0x22>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 80032e2:	f7fd fdd5 	bl	8000e90 <HAL_GetTick>
 80032e6:	1bc0      	subs	r0, r0, r7
 80032e8:	4540      	cmp	r0, r8
 80032ea:	d9f3      	bls.n	80032d4 <HAL_RCC_ClockConfig+0xa8>
        return HAL_TIMEOUT;
 80032ec:	2003      	movs	r0, #3
}
 80032ee:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 80032f2:	2a02      	cmp	r2, #2
 80032f4:	d102      	bne.n	80032fc <HAL_RCC_ClockConfig+0xd0>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == RESET)
 80032f6:	f413 3f00 	tst.w	r3, #131072	; 0x20000
 80032fa:	e7e0      	b.n	80032be <HAL_RCC_ClockConfig+0x92>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 80032fc:	b912      	cbnz	r2, 8003304 <HAL_RCC_ClockConfig+0xd8>
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == RESET)
 80032fe:	f013 0f02 	tst.w	r3, #2
 8003302:	e7dc      	b.n	80032be <HAL_RCC_ClockConfig+0x92>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == RESET)
 8003304:	f413 6f80 	tst.w	r3, #1024	; 0x400
 8003308:	e7d9      	b.n	80032be <HAL_RCC_ClockConfig+0x92>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 800330a:	4a0e      	ldr	r2, [pc, #56]	; (8003344 <HAL_RCC_ClockConfig+0x118>)
 800330c:	68a0      	ldr	r0, [r4, #8]
 800330e:	6893      	ldr	r3, [r2, #8]
 8003310:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8003314:	4303      	orrs	r3, r0
 8003316:	6093      	str	r3, [r2, #8]
 8003318:	e79c      	b.n	8003254 <HAL_RCC_ClockConfig+0x28>
    __HAL_FLASH_SET_LATENCY(FLatency);
 800331a:	6813      	ldr	r3, [r2, #0]
 800331c:	f023 0307 	bic.w	r3, r3, #7
 8003320:	4333      	orrs	r3, r6
 8003322:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 8003324:	6813      	ldr	r3, [r2, #0]
 8003326:	f003 0307 	and.w	r3, r3, #7
 800332a:	429e      	cmp	r6, r3
 800332c:	d183      	bne.n	8003236 <HAL_RCC_ClockConfig+0xa>
 800332e:	e797      	b.n	8003260 <HAL_RCC_ClockConfig+0x34>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 8003330:	68ab      	ldr	r3, [r5, #8]
 8003332:	68e2      	ldr	r2, [r4, #12]
 8003334:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8003338:	4313      	orrs	r3, r2
 800333a:	60ab      	str	r3, [r5, #8]
 800333c:	e794      	b.n	8003268 <HAL_RCC_ClockConfig+0x3c>
 800333e:	bf00      	nop
 8003340:	40022000 	.word	0x40022000
 8003344:	40021000 	.word	0x40021000
 8003348:	0800fa1f 	.word	0x0800fa1f
 800334c:	20000024 	.word	0x20000024

08003350 <HAL_RCC_GetHCLKFreq>:
}
 8003350:	4b01      	ldr	r3, [pc, #4]	; (8003358 <HAL_RCC_GetHCLKFreq+0x8>)
 8003352:	6818      	ldr	r0, [r3, #0]
 8003354:	4770      	bx	lr
 8003356:	bf00      	nop
 8003358:	20000024 	.word	0x20000024

0800335c <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos]);
 800335c:	4b04      	ldr	r3, [pc, #16]	; (8003370 <HAL_RCC_GetPCLK1Freq+0x14>)
 800335e:	4a05      	ldr	r2, [pc, #20]	; (8003374 <HAL_RCC_GetPCLK1Freq+0x18>)
 8003360:	689b      	ldr	r3, [r3, #8]
 8003362:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8003366:	5cd3      	ldrb	r3, [r2, r3]
 8003368:	4a03      	ldr	r2, [pc, #12]	; (8003378 <HAL_RCC_GetPCLK1Freq+0x1c>)
 800336a:	6810      	ldr	r0, [r2, #0]
}
 800336c:	40d8      	lsrs	r0, r3
 800336e:	4770      	bx	lr
 8003370:	40021000 	.word	0x40021000
 8003374:	0800fa2f 	.word	0x0800fa2f
 8003378:	20000024 	.word	0x20000024

0800337c <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos]);
 800337c:	4b04      	ldr	r3, [pc, #16]	; (8003390 <HAL_RCC_GetPCLK2Freq+0x14>)
 800337e:	4a05      	ldr	r2, [pc, #20]	; (8003394 <HAL_RCC_GetPCLK2Freq+0x18>)
 8003380:	689b      	ldr	r3, [r3, #8]
 8003382:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8003386:	5cd3      	ldrb	r3, [r2, r3]
 8003388:	4a03      	ldr	r2, [pc, #12]	; (8003398 <HAL_RCC_GetPCLK2Freq+0x1c>)
 800338a:	6810      	ldr	r0, [r2, #0]
}
 800338c:	40d8      	lsrs	r0, r3
 800338e:	4770      	bx	lr
 8003390:	40021000 	.word	0x40021000
 8003394:	0800fa2f 	.word	0x0800fa2f
 8003398:	20000024 	.word	0x20000024

0800339c <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 800339c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 800339e:	4b44      	ldr	r3, [pc, #272]	; (80034b0 <RCCEx_PLLSAI1_Config+0x114>)
 80033a0:	68da      	ldr	r2, [r3, #12]
 80033a2:	f012 0f03 	tst.w	r2, #3
{
 80033a6:	4605      	mov	r5, r0
 80033a8:	460e      	mov	r6, r1
 80033aa:	461c      	mov	r4, r3
 80033ac:	6800      	ldr	r0, [r0, #0]
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 80033ae:	d039      	beq.n	8003424 <RCCEx_PLLSAI1_Config+0x88>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 80033b0:	68da      	ldr	r2, [r3, #12]
 80033b2:	f002 0203 	and.w	r2, r2, #3
 80033b6:	4282      	cmp	r2, r0
 80033b8:	d14b      	bne.n	8003452 <RCCEx_PLLSAI1_Config+0xb6>
       ||
 80033ba:	2a00      	cmp	r2, #0
 80033bc:	d049      	beq.n	8003452 <RCCEx_PLLSAI1_Config+0xb6>
       (PllSai1->PLLSAI1Source == RCC_PLLSOURCE_NONE)
#if !defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
       ||
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 80033be:	68db      	ldr	r3, [r3, #12]
       ||
 80033c0:	686a      	ldr	r2, [r5, #4]
       (((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U) != PllSai1->PLLSAI1M)
 80033c2:	f3c3 1302 	ubfx	r3, r3, #4, #3
 80033c6:	3301      	adds	r3, #1
       ||
 80033c8:	4293      	cmp	r3, r2
 80033ca:	d142      	bne.n	8003452 <RCCEx_PLLSAI1_Config+0xb6>
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 80033cc:	6823      	ldr	r3, [r4, #0]
 80033ce:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 80033d2:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 80033d4:	f7fd fd5c 	bl	8000e90 <HAL_GetTick>
 80033d8:	4607      	mov	r7, r0

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != RESET)
 80033da:	6823      	ldr	r3, [r4, #0]
 80033dc:	011a      	lsls	r2, r3, #4
 80033de:	d441      	bmi.n	8003464 <RCCEx_PLLSAI1_Config+0xc8>
 80033e0:	68af      	ldr	r7, [r5, #8]
      }
    }

    if(status == HAL_OK)
    {
      if(Divider == DIVIDER_P_UPDATE)
 80033e2:	2e00      	cmp	r6, #0
 80033e4:	d045      	beq.n	8003472 <RCCEx_PLLSAI1_Config+0xd6>
                   ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 80033e6:	2e01      	cmp	r6, #1
 80033e8:	d14f      	bne.n	800348a <RCCEx_PLLSAI1_Config+0xee>
                   (PllSai1->PLLSAI1N << RCC_PLLSAI1CFGR_PLLSAI1N_Pos) |
                   (((PllSai1->PLLSAI1Q >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1Q_Pos) |
                   ((PllSai1->PLLSAI1M - 1U) << RCC_PLLSAI1CFGR_PLLSAI1M_Pos));
#else
        /* Configure the PLLSAI1 Division factor Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80033ea:	6922      	ldr	r2, [r4, #16]
 80033ec:	6928      	ldr	r0, [r5, #16]
 80033ee:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 80033f2:	0840      	lsrs	r0, r0, #1
 80033f4:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 80033f8:	3801      	subs	r0, #1
 80033fa:	ea42 2207 	orr.w	r2, r2, r7, lsl #8
 80033fe:	ea42 5240 	orr.w	r2, r2, r0, lsl #21
 8003402:	6122      	str	r2, [r4, #16]
                   (((PllSai1->PLLSAI1R >> 1U) - 1U) << RCC_PLLSAI1CFGR_PLLSAI1R_Pos));
#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI1 again by setting PLLSAI1ON to 1*/
      __HAL_RCC_PLLSAI1_ENABLE();
 8003404:	6823      	ldr	r3, [r4, #0]
 8003406:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 800340a:	6023      	str	r3, [r4, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 800340c:	f7fd fd40 	bl	8000e90 <HAL_GetTick>
 8003410:	4606      	mov	r6, r0

      /* Wait till PLLSAI1 is ready */
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == RESET)
 8003412:	6823      	ldr	r3, [r4, #0]
 8003414:	011b      	lsls	r3, r3, #4
 8003416:	d545      	bpl.n	80034a4 <RCCEx_PLLSAI1_Config+0x108>
      }

      if(status == HAL_OK)
      {
        /* Configure the PLLSAI1 Clock output(s) */
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8003418:	6923      	ldr	r3, [r4, #16]
 800341a:	69aa      	ldr	r2, [r5, #24]
 800341c:	4313      	orrs	r3, r2
 800341e:	6123      	str	r3, [r4, #16]
 8003420:	2000      	movs	r0, #0
      }
    }
  }

  return status;
}
 8003422:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    switch(PllSai1->PLLSAI1Source)
 8003424:	2802      	cmp	r0, #2
 8003426:	d010      	beq.n	800344a <RCCEx_PLLSAI1_Config+0xae>
 8003428:	2803      	cmp	r0, #3
 800342a:	d014      	beq.n	8003456 <RCCEx_PLLSAI1_Config+0xba>
 800342c:	2801      	cmp	r0, #1
 800342e:	d110      	bne.n	8003452 <RCCEx_PLLSAI1_Config+0xb6>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8003430:	681b      	ldr	r3, [r3, #0]
 8003432:	079f      	lsls	r7, r3, #30
 8003434:	d5f5      	bpl.n	8003422 <RCCEx_PLLSAI1_Config+0x86>
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC | RCC_PLLCFGR_PLLM, PllSai1->PLLSAI1Source | (PllSai1->PLLSAI1M - 1U) << RCC_PLLCFGR_PLLM_Pos);
 8003436:	68e3      	ldr	r3, [r4, #12]
 8003438:	686a      	ldr	r2, [r5, #4]
 800343a:	f023 0373 	bic.w	r3, r3, #115	; 0x73
 800343e:	3a01      	subs	r2, #1
 8003440:	4318      	orrs	r0, r3
 8003442:	ea40 1002 	orr.w	r0, r0, r2, lsl #4
 8003446:	60e0      	str	r0, [r4, #12]
 8003448:	e7c0      	b.n	80033cc <RCCEx_PLLSAI1_Config+0x30>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 800344a:	681b      	ldr	r3, [r3, #0]
 800344c:	f413 6f80 	tst.w	r3, #1024	; 0x400
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY) && HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8003450:	d1f1      	bne.n	8003436 <RCCEx_PLLSAI1_Config+0x9a>
 8003452:	2001      	movs	r0, #1
 8003454:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003456:	681a      	ldr	r2, [r3, #0]
 8003458:	0391      	lsls	r1, r2, #14
 800345a:	d4ec      	bmi.n	8003436 <RCCEx_PLLSAI1_Config+0x9a>
 800345c:	681b      	ldr	r3, [r3, #0]
 800345e:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8003462:	e7f5      	b.n	8003450 <RCCEx_PLLSAI1_Config+0xb4>
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8003464:	f7fd fd14 	bl	8000e90 <HAL_GetTick>
 8003468:	1bc0      	subs	r0, r0, r7
 800346a:	2802      	cmp	r0, #2
 800346c:	d9b5      	bls.n	80033da <RCCEx_PLLSAI1_Config+0x3e>
        status = HAL_TIMEOUT;
 800346e:	2003      	movs	r0, #3
 8003470:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8003472:	6922      	ldr	r2, [r4, #16]
 8003474:	68e9      	ldr	r1, [r5, #12]
 8003476:	f022 4278 	bic.w	r2, r2, #4160749568	; 0xf8000000
 800347a:	06c9      	lsls	r1, r1, #27
 800347c:	ea41 2307 	orr.w	r3, r1, r7, lsl #8
 8003480:	f422 42fe 	bic.w	r2, r2, #32512	; 0x7f00
 8003484:	4313      	orrs	r3, r2
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8003486:	6123      	str	r3, [r4, #16]
 8003488:	e7bc      	b.n	8003404 <RCCEx_PLLSAI1_Config+0x68>
 800348a:	6923      	ldr	r3, [r4, #16]
 800348c:	6968      	ldr	r0, [r5, #20]
 800348e:	f023 63c0 	bic.w	r3, r3, #100663296	; 0x6000000
 8003492:	0840      	lsrs	r0, r0, #1
 8003494:	f423 43fe 	bic.w	r3, r3, #32512	; 0x7f00
 8003498:	3801      	subs	r0, #1
 800349a:	ea43 2307 	orr.w	r3, r3, r7, lsl #8
 800349e:	ea43 6340 	orr.w	r3, r3, r0, lsl #25
 80034a2:	e7f0      	b.n	8003486 <RCCEx_PLLSAI1_Config+0xea>
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80034a4:	f7fd fcf4 	bl	8000e90 <HAL_GetTick>
 80034a8:	1b80      	subs	r0, r0, r6
 80034aa:	2802      	cmp	r0, #2
 80034ac:	d9b1      	bls.n	8003412 <RCCEx_PLLSAI1_Config+0x76>
 80034ae:	e7de      	b.n	800346e <RCCEx_PLLSAI1_Config+0xd2>
 80034b0:	40021000 	.word	0x40021000

080034b4 <HAL_RCCEx_PeriphCLKConfig>:
{
 80034b4:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 80034b8:	6805      	ldr	r5, [r0, #0]
 80034ba:	f415 6500 	ands.w	r5, r5, #2048	; 0x800
{
 80034be:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 80034c0:	d00e      	beq.n	80034e0 <HAL_RCCEx_PeriphCLKConfig+0x2c>
    switch(PeriphClkInit->Sai1ClockSelection)
 80034c2:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 80034c4:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80034c8:	d05b      	beq.n	8003582 <HAL_RCCEx_PeriphCLKConfig+0xce>
 80034ca:	f5b1 0f40 	cmp.w	r1, #12582912	; 0xc00000
 80034ce:	d05d      	beq.n	800358c <HAL_RCCEx_PeriphCLKConfig+0xd8>
 80034d0:	2900      	cmp	r1, #0
 80034d2:	d166      	bne.n	80035a2 <HAL_RCCEx_PeriphCLKConfig+0xee>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 80034d4:	3004      	adds	r0, #4
 80034d6:	f7ff ff61 	bl	800339c <RCCEx_PLLSAI1_Config>
    if(ret == HAL_OK)
 80034da:	4605      	mov	r5, r0
 80034dc:	2800      	cmp	r0, #0
 80034de:	d055      	beq.n	800358c <HAL_RCCEx_PeriphCLKConfig+0xd8>
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 80034e0:	6823      	ldr	r3, [r4, #0]
 80034e2:	039e      	lsls	r6, r3, #14
 80034e4:	d56d      	bpl.n	80035c2 <HAL_RCCEx_PeriphCLKConfig+0x10e>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED())
 80034e6:	4eb7      	ldr	r6, [pc, #732]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 80034e8:	6db3      	ldr	r3, [r6, #88]	; 0x58
 80034ea:	00d8      	lsls	r0, r3, #3
 80034ec:	d45b      	bmi.n	80035a6 <HAL_RCCEx_PeriphCLKConfig+0xf2>
      __HAL_RCC_PWR_CLK_ENABLE();
 80034ee:	6db3      	ldr	r3, [r6, #88]	; 0x58
 80034f0:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80034f4:	65b3      	str	r3, [r6, #88]	; 0x58
 80034f6:	6db3      	ldr	r3, [r6, #88]	; 0x58
 80034f8:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80034fc:	9301      	str	r3, [sp, #4]
 80034fe:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8003500:	2701      	movs	r7, #1
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8003502:	f8df 82c4 	ldr.w	r8, [pc, #708]	; 80037c8 <HAL_RCCEx_PeriphCLKConfig+0x314>
 8003506:	f8d8 3000 	ldr.w	r3, [r8]
 800350a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800350e:	f8c8 3000 	str.w	r3, [r8]
    tickstart = HAL_GetTick();
 8003512:	f7fd fcbd 	bl	8000e90 <HAL_GetTick>
 8003516:	4681      	mov	r9, r0
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == RESET)
 8003518:	f8d8 3000 	ldr.w	r3, [r8]
 800351c:	05d9      	lsls	r1, r3, #23
 800351e:	d544      	bpl.n	80035aa <HAL_RCCEx_PeriphCLKConfig+0xf6>
    if(ret == HAL_OK)
 8003520:	2d00      	cmp	r5, #0
 8003522:	d149      	bne.n	80035b8 <HAL_RCCEx_PeriphCLKConfig+0x104>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8003524:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8003528:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 800352c:	d014      	beq.n	8003558 <HAL_RCCEx_PeriphCLKConfig+0xa4>
 800352e:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8003530:	4293      	cmp	r3, r2
 8003532:	d011      	beq.n	8003558 <HAL_RCCEx_PeriphCLKConfig+0xa4>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8003534:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_FORCE();
 8003538:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
 800353c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8003540:	f8c6 2090 	str.w	r2, [r6, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8003544:	f8d6 2090 	ldr.w	r2, [r6, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8003548:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        __HAL_RCC_BACKUPRESET_RELEASE();
 800354c:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8003550:	f8c6 2090 	str.w	r2, [r6, #144]	; 0x90
        RCC->BDCR = tmpregister;
 8003554:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8003558:	07da      	lsls	r2, r3, #31
 800355a:	d509      	bpl.n	8003570 <HAL_RCCEx_PeriphCLKConfig+0xbc>
        tickstart = HAL_GetTick();
 800355c:	f7fd fc98 	bl	8000e90 <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003560:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8003564:	4680      	mov	r8, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == RESET)
 8003566:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 800356a:	079b      	lsls	r3, r3, #30
 800356c:	f140 8101 	bpl.w	8003772 <HAL_RCCEx_PeriphCLKConfig+0x2be>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8003570:	f8d6 3090 	ldr.w	r3, [r6, #144]	; 0x90
 8003574:	6e62      	ldr	r2, [r4, #100]	; 0x64
 8003576:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 800357a:	4313      	orrs	r3, r2
 800357c:	f8c6 3090 	str.w	r3, [r6, #144]	; 0x90
 8003580:	e01a      	b.n	80035b8 <HAL_RCCEx_PeriphCLKConfig+0x104>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI2CLK);
 8003582:	4a90      	ldr	r2, [pc, #576]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 8003584:	68d3      	ldr	r3, [r2, #12]
 8003586:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 800358a:	60d3      	str	r3, [r2, #12]
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 800358c:	4a8d      	ldr	r2, [pc, #564]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 800358e:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
 8003590:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8003594:	f423 0340 	bic.w	r3, r3, #12582912	; 0xc00000
 8003598:	430b      	orrs	r3, r1
 800359a:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 800359e:	2500      	movs	r5, #0
 80035a0:	e79e      	b.n	80034e0 <HAL_RCCEx_PeriphCLKConfig+0x2c>
      ret = HAL_ERROR;
 80035a2:	2501      	movs	r5, #1
 80035a4:	e79c      	b.n	80034e0 <HAL_RCCEx_PeriphCLKConfig+0x2c>
    FlagStatus       pwrclkchanged = RESET;
 80035a6:	2700      	movs	r7, #0
 80035a8:	e7ab      	b.n	8003502 <HAL_RCCEx_PeriphCLKConfig+0x4e>
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80035aa:	f7fd fc71 	bl	8000e90 <HAL_GetTick>
 80035ae:	eba0 0009 	sub.w	r0, r0, r9
 80035b2:	2802      	cmp	r0, #2
 80035b4:	d9b0      	bls.n	8003518 <HAL_RCCEx_PeriphCLKConfig+0x64>
        ret = HAL_TIMEOUT;
 80035b6:	2503      	movs	r5, #3
    if(pwrclkchanged == SET)
 80035b8:	b11f      	cbz	r7, 80035c2 <HAL_RCCEx_PeriphCLKConfig+0x10e>
      __HAL_RCC_PWR_CLK_DISABLE();
 80035ba:	6db3      	ldr	r3, [r6, #88]	; 0x58
 80035bc:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80035c0:	65b3      	str	r3, [r6, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 80035c2:	6823      	ldr	r3, [r4, #0]
 80035c4:	07df      	lsls	r7, r3, #31
 80035c6:	d508      	bpl.n	80035da <HAL_RCCEx_PeriphCLKConfig+0x126>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 80035c8:	497e      	ldr	r1, [pc, #504]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 80035ca:	6a20      	ldr	r0, [r4, #32]
 80035cc:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80035d0:	f022 0203 	bic.w	r2, r2, #3
 80035d4:	4302      	orrs	r2, r0
 80035d6:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 80035da:	079e      	lsls	r6, r3, #30
 80035dc:	d508      	bpl.n	80035f0 <HAL_RCCEx_PeriphCLKConfig+0x13c>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 80035de:	4979      	ldr	r1, [pc, #484]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 80035e0:	6a60      	ldr	r0, [r4, #36]	; 0x24
 80035e2:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80035e6:	f022 020c 	bic.w	r2, r2, #12
 80035ea:	4302      	orrs	r2, r0
 80035ec:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 80035f0:	0758      	lsls	r0, r3, #29
 80035f2:	d508      	bpl.n	8003606 <HAL_RCCEx_PeriphCLKConfig+0x152>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 80035f4:	4973      	ldr	r1, [pc, #460]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 80035f6:	6aa0      	ldr	r0, [r4, #40]	; 0x28
 80035f8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 80035fc:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8003600:	4302      	orrs	r2, r0
 8003602:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8003606:	0719      	lsls	r1, r3, #28
 8003608:	d508      	bpl.n	800361c <HAL_RCCEx_PeriphCLKConfig+0x168>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 800360a:	496e      	ldr	r1, [pc, #440]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 800360c:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
 800360e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003612:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8003616:	4302      	orrs	r2, r0
 8003618:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 800361c:	069a      	lsls	r2, r3, #26
 800361e:	d508      	bpl.n	8003632 <HAL_RCCEx_PeriphCLKConfig+0x17e>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8003620:	4968      	ldr	r1, [pc, #416]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 8003622:	6b20      	ldr	r0, [r4, #48]	; 0x30
 8003624:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003628:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 800362c:	4302      	orrs	r2, r0
 800362e:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8003632:	059f      	lsls	r7, r3, #22
 8003634:	d508      	bpl.n	8003648 <HAL_RCCEx_PeriphCLKConfig+0x194>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8003636:	4963      	ldr	r1, [pc, #396]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 8003638:	6c60      	ldr	r0, [r4, #68]	; 0x44
 800363a:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800363e:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8003642:	4302      	orrs	r2, r0
 8003644:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8003648:	055e      	lsls	r6, r3, #21
 800364a:	d508      	bpl.n	800365e <HAL_RCCEx_PeriphCLKConfig+0x1aa>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 800364c:	495d      	ldr	r1, [pc, #372]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 800364e:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8003650:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003654:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8003658:	4302      	orrs	r2, r0
 800365a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 800365e:	0658      	lsls	r0, r3, #25
 8003660:	d508      	bpl.n	8003674 <HAL_RCCEx_PeriphCLKConfig+0x1c0>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8003662:	4958      	ldr	r1, [pc, #352]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 8003664:	6b60      	ldr	r0, [r4, #52]	; 0x34
 8003666:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 800366a:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 800366e:	4302      	orrs	r2, r0
 8003670:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8003674:	0619      	lsls	r1, r3, #24
 8003676:	d508      	bpl.n	800368a <HAL_RCCEx_PeriphCLKConfig+0x1d6>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8003678:	4952      	ldr	r1, [pc, #328]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 800367a:	6ba0      	ldr	r0, [r4, #56]	; 0x38
 800367c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003680:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8003684:	4302      	orrs	r2, r0
 8003686:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 800368a:	05da      	lsls	r2, r3, #23
 800368c:	d508      	bpl.n	80036a0 <HAL_RCCEx_PeriphCLKConfig+0x1ec>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 800368e:	494d      	ldr	r1, [pc, #308]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 8003690:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8003692:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8003696:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 800369a:	4302      	orrs	r2, r0
 800369c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 80036a0:	02df      	lsls	r7, r3, #11
 80036a2:	d508      	bpl.n	80036b6 <HAL_RCCEx_PeriphCLKConfig+0x202>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 80036a4:	4947      	ldr	r1, [pc, #284]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 80036a6:	6c20      	ldr	r0, [r4, #64]	; 0x40
 80036a8:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 80036ac:	f022 0203 	bic.w	r2, r2, #3
 80036b0:	4302      	orrs	r2, r0
 80036b2:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 80036b6:	049e      	lsls	r6, r3, #18
 80036b8:	d50f      	bpl.n	80036da <HAL_RCCEx_PeriphCLKConfig+0x226>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 80036ba:	4a42      	ldr	r2, [pc, #264]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 80036bc:	6d21      	ldr	r1, [r4, #80]	; 0x50
 80036be:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80036c2:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 80036c6:	430b      	orrs	r3, r1
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 80036c8:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 80036cc:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 80036d0:	d157      	bne.n	8003782 <HAL_RCCEx_PeriphCLKConfig+0x2ce>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80036d2:	68d3      	ldr	r3, [r2, #12]
 80036d4:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80036d8:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 80036da:	6823      	ldr	r3, [r4, #0]
 80036dc:	0318      	lsls	r0, r3, #12
 80036de:	d50f      	bpl.n	8003700 <HAL_RCCEx_PeriphCLKConfig+0x24c>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80036e0:	4a38      	ldr	r2, [pc, #224]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 80036e2:	6d61      	ldr	r1, [r4, #84]	; 0x54
 80036e4:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 80036e8:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 80036ec:	430b      	orrs	r3, r1
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80036ee:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 80036f2:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 80036f6:	d14f      	bne.n	8003798 <HAL_RCCEx_PeriphCLKConfig+0x2e4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 80036f8:	68d3      	ldr	r3, [r2, #12]
 80036fa:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80036fe:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8003700:	6823      	ldr	r3, [r4, #0]
 8003702:	0359      	lsls	r1, r3, #13
 8003704:	d50f      	bpl.n	8003726 <HAL_RCCEx_PeriphCLKConfig+0x272>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8003706:	4a2f      	ldr	r2, [pc, #188]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 8003708:	6da1      	ldr	r1, [r4, #88]	; 0x58
 800370a:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 800370e:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8003712:	430b      	orrs	r3, r1
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8003714:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8003718:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 800371c:	d147      	bne.n	80037ae <HAL_RCCEx_PeriphCLKConfig+0x2fa>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 800371e:	68d3      	ldr	r3, [r2, #12]
 8003720:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8003724:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8003726:	6823      	ldr	r3, [r4, #0]
 8003728:	045a      	lsls	r2, r3, #17
 800372a:	d512      	bpl.n	8003752 <HAL_RCCEx_PeriphCLKConfig+0x29e>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800372c:	4925      	ldr	r1, [pc, #148]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 800372e:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8003730:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8003734:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8003738:	4313      	orrs	r3, r2
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 800373a:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 800373e:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8003742:	d106      	bne.n	8003752 <HAL_RCCEx_PeriphCLKConfig+0x29e>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8003744:	2102      	movs	r1, #2
 8003746:	1d20      	adds	r0, r4, #4
 8003748:	f7ff fe28 	bl	800339c <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 800374c:	2800      	cmp	r0, #0
 800374e:	bf18      	it	ne
 8003750:	4605      	movne	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8003752:	6823      	ldr	r3, [r4, #0]
 8003754:	03db      	lsls	r3, r3, #15
 8003756:	d508      	bpl.n	800376a <HAL_RCCEx_PeriphCLKConfig+0x2b6>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8003758:	4a1a      	ldr	r2, [pc, #104]	; (80037c4 <HAL_RCCEx_PeriphCLKConfig+0x310>)
 800375a:	6e21      	ldr	r1, [r4, #96]	; 0x60
 800375c:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8003760:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 8003764:	430b      	orrs	r3, r1
 8003766:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
}
 800376a:	4628      	mov	r0, r5
 800376c:	b003      	add	sp, #12
 800376e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8003772:	f7fd fb8d 	bl	8000e90 <HAL_GetTick>
 8003776:	eba0 0008 	sub.w	r0, r0, r8
 800377a:	4548      	cmp	r0, r9
 800377c:	f67f aef3 	bls.w	8003566 <HAL_RCCEx_PeriphCLKConfig+0xb2>
 8003780:	e719      	b.n	80035b6 <HAL_RCCEx_PeriphCLKConfig+0x102>
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8003782:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8003786:	d1a8      	bne.n	80036da <HAL_RCCEx_PeriphCLKConfig+0x226>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8003788:	2101      	movs	r1, #1
 800378a:	1d20      	adds	r0, r4, #4
 800378c:	f7ff fe06 	bl	800339c <RCCEx_PLLSAI1_Config>
        if(ret != HAL_OK)
 8003790:	2800      	cmp	r0, #0
 8003792:	bf18      	it	ne
 8003794:	4605      	movne	r5, r0
 8003796:	e7a0      	b.n	80036da <HAL_RCCEx_PeriphCLKConfig+0x226>
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 8003798:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 800379c:	d1b0      	bne.n	8003700 <HAL_RCCEx_PeriphCLKConfig+0x24c>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 800379e:	2101      	movs	r1, #1
 80037a0:	1d20      	adds	r0, r4, #4
 80037a2:	f7ff fdfb 	bl	800339c <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 80037a6:	2800      	cmp	r0, #0
 80037a8:	bf18      	it	ne
 80037aa:	4605      	movne	r5, r0
 80037ac:	e7a8      	b.n	8003700 <HAL_RCCEx_PeriphCLKConfig+0x24c>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 80037ae:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 80037b2:	d1b8      	bne.n	8003726 <HAL_RCCEx_PeriphCLKConfig+0x272>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 80037b4:	2101      	movs	r1, #1
 80037b6:	1d20      	adds	r0, r4, #4
 80037b8:	f7ff fdf0 	bl	800339c <RCCEx_PLLSAI1_Config>
      if(ret != HAL_OK)
 80037bc:	2800      	cmp	r0, #0
 80037be:	bf18      	it	ne
 80037c0:	4605      	movne	r5, r0
 80037c2:	e7b0      	b.n	8003726 <HAL_RCCEx_PeriphCLKConfig+0x272>
 80037c4:	40021000 	.word	0x40021000
 80037c8:	40007000 	.word	0x40007000

080037cc <HAL_RTC_AlarmIRQHandler>:
  * @retval None
  */
void HAL_RTC_AlarmIRQHandler(RTC_HandleTypeDef* hrtc)
{
  /* Clear the EXTI's line Flag for RTC Alarm */
  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
 80037cc:	4b1a      	ldr	r3, [pc, #104]	; (8003838 <HAL_RTC_AlarmIRQHandler+0x6c>)
 80037ce:	f44f 2280 	mov.w	r2, #262144	; 0x40000
{
 80037d2:	b510      	push	{r4, lr}
 80037d4:	4604      	mov	r4, r0
  __HAL_RTC_ALARM_EXTI_CLEAR_FLAG();
 80037d6:	615a      	str	r2, [r3, #20]

  /* As alarms are sharing the same EXTI line, exit when no more pending Alarm event */
  while(((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != RESET)) ||
 80037d8:	6823      	ldr	r3, [r4, #0]
 80037da:	689a      	ldr	r2, [r3, #8]
 80037dc:	04d2      	lsls	r2, r2, #19
 80037de:	d502      	bpl.n	80037e6 <HAL_RTC_AlarmIRQHandler+0x1a>
 80037e0:	68da      	ldr	r2, [r3, #12]
 80037e2:	05d0      	lsls	r0, r2, #23
 80037e4:	d409      	bmi.n	80037fa <HAL_RTC_AlarmIRQHandler+0x2e>
        ((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != RESET)))
 80037e6:	689a      	ldr	r2, [r3, #8]
  while(((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != RESET)) ||
 80037e8:	0491      	lsls	r1, r2, #18
 80037ea:	d502      	bpl.n	80037f2 <HAL_RTC_AlarmIRQHandler+0x26>
        ((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != RESET)))
 80037ec:	68da      	ldr	r2, [r3, #12]
 80037ee:	0592      	lsls	r2, r2, #22
 80037f0:	d403      	bmi.n	80037fa <HAL_RTC_AlarmIRQHandler+0x2e>
#endif /* USE_HAL_RTC_REGISTER_CALLBACKS */
    }
  }

  /* Change RTC state */
  hrtc->State = HAL_RTC_STATE_READY;
 80037f2:	2301      	movs	r3, #1
 80037f4:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
 80037f8:	bd10      	pop	{r4, pc}
    if((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRA) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAF) != RESET))
 80037fa:	689a      	ldr	r2, [r3, #8]
 80037fc:	04d1      	lsls	r1, r2, #19
 80037fe:	d50a      	bpl.n	8003816 <HAL_RTC_AlarmIRQHandler+0x4a>
 8003800:	68da      	ldr	r2, [r3, #12]
 8003802:	05d2      	lsls	r2, r2, #23
 8003804:	d507      	bpl.n	8003816 <HAL_RTC_AlarmIRQHandler+0x4a>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 8003806:	68da      	ldr	r2, [r3, #12]
 8003808:	b2d2      	uxtb	r2, r2
 800380a:	f462 72c0 	orn	r2, r2, #384	; 0x180
 800380e:	60da      	str	r2, [r3, #12]
      HAL_RTC_AlarmAEventCallback(hrtc);
 8003810:	4620      	mov	r0, r4
 8003812:	f006 fe55 	bl	800a4c0 <HAL_RTC_AlarmAEventCallback>
    if((__HAL_RTC_ALARM_GET_IT_SOURCE(hrtc, RTC_IT_ALRB) != RESET) && (__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBF) != RESET))
 8003816:	6822      	ldr	r2, [r4, #0]
 8003818:	6893      	ldr	r3, [r2, #8]
 800381a:	0498      	lsls	r0, r3, #18
 800381c:	d5dc      	bpl.n	80037d8 <HAL_RTC_AlarmIRQHandler+0xc>
 800381e:	68d3      	ldr	r3, [r2, #12]
 8003820:	0599      	lsls	r1, r3, #22
 8003822:	d5d9      	bpl.n	80037d8 <HAL_RTC_AlarmIRQHandler+0xc>
      __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 8003824:	68d3      	ldr	r3, [r2, #12]
 8003826:	b2db      	uxtb	r3, r3
 8003828:	f463 7320 	orn	r3, r3, #640	; 0x280
 800382c:	60d3      	str	r3, [r2, #12]
      HAL_RTCEx_AlarmBEventCallback(hrtc);
 800382e:	4620      	mov	r0, r4
 8003830:	f006 fe52 	bl	800a4d8 <HAL_RTCEx_AlarmBEventCallback>
 8003834:	e7d0      	b.n	80037d8 <HAL_RTC_AlarmIRQHandler+0xc>
 8003836:	bf00      	nop
 8003838:	40010400 	.word	0x40010400

0800383c <HAL_RTC_WaitForSynchro>:
HAL_StatusTypeDef HAL_RTC_WaitForSynchro(RTC_HandleTypeDef* hrtc)
{
  uint32_t tickstart = 0;

  /* Clear RSF flag */
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 800383c:	6802      	ldr	r2, [r0, #0]
{
 800383e:	b538      	push	{r3, r4, r5, lr}
  hrtc->Instance->ISR &= (uint32_t)RTC_RSF_MASK;
 8003840:	68d3      	ldr	r3, [r2, #12]
 8003842:	f023 03a0 	bic.w	r3, r3, #160	; 0xa0
 8003846:	60d3      	str	r3, [r2, #12]
{
 8003848:	4604      	mov	r4, r0

  tickstart = HAL_GetTick();
 800384a:	f7fd fb21 	bl	8000e90 <HAL_GetTick>
 800384e:	4605      	mov	r5, r0

  /* Wait the registers to be synchronised */
  while((hrtc->Instance->ISR & RTC_ISR_RSF) == (uint32_t)RESET)
 8003850:	6823      	ldr	r3, [r4, #0]
 8003852:	68db      	ldr	r3, [r3, #12]
 8003854:	069b      	lsls	r3, r3, #26
 8003856:	d501      	bpl.n	800385c <HAL_RTC_WaitForSynchro+0x20>
    {
      return HAL_TIMEOUT;
    }
  }

  return HAL_OK;
 8003858:	2000      	movs	r0, #0
 800385a:	bd38      	pop	{r3, r4, r5, pc}
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 800385c:	f7fd fb18 	bl	8000e90 <HAL_GetTick>
 8003860:	1b40      	subs	r0, r0, r5
 8003862:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003866:	d9f3      	bls.n	8003850 <HAL_RTC_WaitForSynchro+0x14>
      return HAL_TIMEOUT;
 8003868:	2003      	movs	r0, #3
}
 800386a:	bd38      	pop	{r3, r4, r5, pc}

0800386c <RTC_EnterInitMode>:
  *         __HAL_RTC_WRITEPROTECTION_DISABLE() before calling this function.
  * @param  hrtc: RTC handle
  * @retval HAL status
  */
HAL_StatusTypeDef RTC_EnterInitMode(RTC_HandleTypeDef* hrtc)
{
 800386c:	b538      	push	{r3, r4, r5, lr}
  uint32_t tickstart = 0;

  /* Check if the Initialization mode is set */
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 800386e:	6803      	ldr	r3, [r0, #0]
 8003870:	68da      	ldr	r2, [r3, #12]
 8003872:	0652      	lsls	r2, r2, #25
{
 8003874:	4604      	mov	r4, r0
  if((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8003876:	d501      	bpl.n	800387c <RTC_EnterInitMode+0x10>
        return HAL_TIMEOUT;
      }
    }
  }

  return HAL_OK;
 8003878:	2000      	movs	r0, #0
 800387a:	bd38      	pop	{r3, r4, r5, pc}
    hrtc->Instance->ISR = (uint32_t)RTC_INIT_MASK;
 800387c:	f04f 32ff 	mov.w	r2, #4294967295
 8003880:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 8003882:	f7fd fb05 	bl	8000e90 <HAL_GetTick>
 8003886:	4605      	mov	r5, r0
    while((hrtc->Instance->ISR & RTC_ISR_INITF) == (uint32_t)RESET)
 8003888:	6823      	ldr	r3, [r4, #0]
 800388a:	68db      	ldr	r3, [r3, #12]
 800388c:	065b      	lsls	r3, r3, #25
 800388e:	d4f3      	bmi.n	8003878 <RTC_EnterInitMode+0xc>
      if((HAL_GetTick()  - tickstart ) > RTC_TIMEOUT_VALUE)
 8003890:	f7fd fafe 	bl	8000e90 <HAL_GetTick>
 8003894:	1b40      	subs	r0, r0, r5
 8003896:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 800389a:	d9f5      	bls.n	8003888 <RTC_EnterInitMode+0x1c>
        return HAL_TIMEOUT;
 800389c:	2003      	movs	r0, #3
}
 800389e:	bd38      	pop	{r3, r4, r5, pc}

080038a0 <HAL_RTC_Init>:
{
 80038a0:	b538      	push	{r3, r4, r5, lr}
  if(hrtc == NULL)
 80038a2:	4604      	mov	r4, r0
 80038a4:	b1d8      	cbz	r0, 80038de <HAL_RTC_Init+0x3e>
  if(hrtc->State == HAL_RTC_STATE_RESET)
 80038a6:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 80038aa:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80038ae:	b91b      	cbnz	r3, 80038b8 <HAL_RTC_Init+0x18>
    hrtc->Lock = HAL_UNLOCKED;
 80038b0:	f880 2020 	strb.w	r2, [r0, #32]
    HAL_RTC_MspInit(hrtc);
 80038b4:	f006 fcce 	bl	800a254 <HAL_RTC_MspInit>
  hrtc->State = HAL_RTC_STATE_BUSY;
 80038b8:	2302      	movs	r3, #2
 80038ba:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80038be:	6823      	ldr	r3, [r4, #0]
 80038c0:	22ca      	movs	r2, #202	; 0xca
 80038c2:	625a      	str	r2, [r3, #36]	; 0x24
 80038c4:	2253      	movs	r2, #83	; 0x53
 80038c6:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80038c8:	4620      	mov	r0, r4
 80038ca:	f7ff ffcf 	bl	800386c <RTC_EnterInitMode>
 80038ce:	6823      	ldr	r3, [r4, #0]
 80038d0:	4605      	mov	r5, r0
 80038d2:	b130      	cbz	r0, 80038e2 <HAL_RTC_Init+0x42>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80038d4:	22ff      	movs	r2, #255	; 0xff
 80038d6:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 80038d8:	2304      	movs	r3, #4
 80038da:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
     return HAL_ERROR;
 80038de:	2501      	movs	r5, #1
 80038e0:	e031      	b.n	8003946 <HAL_RTC_Init+0xa6>
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 80038e2:	689a      	ldr	r2, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 80038e4:	6920      	ldr	r0, [r4, #16]
    hrtc->Instance->CR &= ((uint32_t)~(RTC_CR_FMT | RTC_CR_OSEL | RTC_CR_POL));
 80038e6:	f422 02e0 	bic.w	r2, r2, #7340032	; 0x700000
 80038ea:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 80038ee:	609a      	str	r2, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(hrtc->Init.HourFormat | hrtc->Init.OutPut | hrtc->Init.OutPutPolarity);
 80038f0:	6862      	ldr	r2, [r4, #4]
 80038f2:	6899      	ldr	r1, [r3, #8]
 80038f4:	4302      	orrs	r2, r0
 80038f6:	69a0      	ldr	r0, [r4, #24]
 80038f8:	4302      	orrs	r2, r0
 80038fa:	430a      	orrs	r2, r1
 80038fc:	609a      	str	r2, [r3, #8]
    hrtc->Instance->PRER = (uint32_t)(hrtc->Init.SynchPrediv);
 80038fe:	68e2      	ldr	r2, [r4, #12]
 8003900:	611a      	str	r2, [r3, #16]
    hrtc->Instance->PRER |= (uint32_t)(hrtc->Init.AsynchPrediv << 16);
 8003902:	691a      	ldr	r2, [r3, #16]
 8003904:	68a1      	ldr	r1, [r4, #8]
 8003906:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 800390a:	611a      	str	r2, [r3, #16]
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 800390c:	68da      	ldr	r2, [r3, #12]
 800390e:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003912:	60da      	str	r2, [r3, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8003914:	689b      	ldr	r3, [r3, #8]
 8003916:	069b      	lsls	r3, r3, #26
 8003918:	d405      	bmi.n	8003926 <HAL_RTC_Init+0x86>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 800391a:	4620      	mov	r0, r4
 800391c:	f7ff ff8e 	bl	800383c <HAL_RTC_WaitForSynchro>
 8003920:	b108      	cbz	r0, 8003926 <HAL_RTC_Init+0x86>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003922:	6823      	ldr	r3, [r4, #0]
 8003924:	e7d6      	b.n	80038d4 <HAL_RTC_Init+0x34>
    hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 8003926:	6823      	ldr	r3, [r4, #0]
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8003928:	6960      	ldr	r0, [r4, #20]
    hrtc->Instance->OR &= (uint32_t)~(RTC_OR_ALARMOUTTYPE | RTC_OR_OUT_RMP);
 800392a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800392c:	f022 0203 	bic.w	r2, r2, #3
 8003930:	64da      	str	r2, [r3, #76]	; 0x4c
    hrtc->Instance->OR |= (uint32_t)(hrtc->Init.OutPutType | hrtc->Init.OutPutRemap);
 8003932:	69e2      	ldr	r2, [r4, #28]
 8003934:	6cd9      	ldr	r1, [r3, #76]	; 0x4c
 8003936:	4302      	orrs	r2, r0
 8003938:	430a      	orrs	r2, r1
 800393a:	64da      	str	r2, [r3, #76]	; 0x4c
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 800393c:	22ff      	movs	r2, #255	; 0xff
 800393e:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY;
 8003940:	2301      	movs	r3, #1
 8003942:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
}
 8003946:	4628      	mov	r0, r5
 8003948:	bd38      	pop	{r3, r4, r5, pc}

0800394a <RTC_ByteToBcd2>:
  * @param  Value: Byte to be converted
  * @retval Converted byte
  */
uint8_t RTC_ByteToBcd2(uint8_t Value)
{
  uint32_t bcdhigh = 0;
 800394a:	2300      	movs	r3, #0

  while(Value >= 10)
 800394c:	2809      	cmp	r0, #9
 800394e:	d803      	bhi.n	8003958 <RTC_ByteToBcd2+0xe>
  {
    bcdhigh++;
    Value -= 10;
  }

  return  ((uint8_t)(bcdhigh << 4) | Value);
 8003950:	ea40 1003 	orr.w	r0, r0, r3, lsl #4
}
 8003954:	b2c0      	uxtb	r0, r0
 8003956:	4770      	bx	lr
    Value -= 10;
 8003958:	380a      	subs	r0, #10
    bcdhigh++;
 800395a:	3301      	adds	r3, #1
    Value -= 10;
 800395c:	b2c0      	uxtb	r0, r0
 800395e:	e7f5      	b.n	800394c <RTC_ByteToBcd2+0x2>

08003960 <HAL_RTC_SetTime>:
{
 8003960:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  __HAL_LOCK(hrtc);
 8003962:	f890 3020 	ldrb.w	r3, [r0, #32]
 8003966:	2b01      	cmp	r3, #1
{
 8003968:	4606      	mov	r6, r0
 800396a:	460f      	mov	r7, r1
 800396c:	f04f 0502 	mov.w	r5, #2
  __HAL_LOCK(hrtc);
 8003970:	d033      	beq.n	80039da <HAL_RTC_SetTime+0x7a>
 8003972:	2301      	movs	r3, #1
 8003974:	f880 3020 	strb.w	r3, [r0, #32]
 8003978:	6803      	ldr	r3, [r0, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;
 800397a:	f880 5021 	strb.w	r5, [r0, #33]	; 0x21
 800397e:	7808      	ldrb	r0, [r1, #0]
 8003980:	784d      	ldrb	r5, [r1, #1]
 8003982:	788c      	ldrb	r4, [r1, #2]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003984:	689b      	ldr	r3, [r3, #8]
  if(Format == RTC_FORMAT_BIN)
 8003986:	bb52      	cbnz	r2, 80039de <HAL_RTC_SetTime+0x7e>
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003988:	f013 0340 	ands.w	r3, r3, #64	; 0x40
      sTime->TimeFormat = 0x00;
 800398c:	bf08      	it	eq
 800398e:	70cb      	strbeq	r3, [r1, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 8003990:	f7ff ffdb 	bl	800394a <RTC_ByteToBcd2>
 8003994:	4601      	mov	r1, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Minutes) << 8) | \
 8003996:	4628      	mov	r0, r5
 8003998:	f7ff ffd7 	bl	800394a <RTC_ByteToBcd2>
 800399c:	4602      	mov	r2, r0
                        ((uint32_t)RTC_ByteToBcd2(sTime->Seconds)) | \
 800399e:	4620      	mov	r0, r4
 80039a0:	f7ff ffd3 	bl	800394a <RTC_ByteToBcd2>
                        (((uint32_t)sTime->TimeFormat) << 16));
 80039a4:	78fb      	ldrb	r3, [r7, #3]
    tmpreg = (uint32_t)(((uint32_t)RTC_ByteToBcd2(sTime->Hours) << 16) | \
 80039a6:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
 80039aa:	ea40 4001 	orr.w	r0, r0, r1, lsl #16
 80039ae:	ea40 2402 	orr.w	r4, r0, r2, lsl #8
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 80039b2:	6833      	ldr	r3, [r6, #0]
 80039b4:	22ca      	movs	r2, #202	; 0xca
 80039b6:	625a      	str	r2, [r3, #36]	; 0x24
 80039b8:	2253      	movs	r2, #83	; 0x53
 80039ba:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 80039bc:	4630      	mov	r0, r6
 80039be:	f7ff ff55 	bl	800386c <RTC_EnterInitMode>
 80039c2:	6833      	ldr	r3, [r6, #0]
 80039c4:	4605      	mov	r5, r0
 80039c6:	b1b8      	cbz	r0, 80039f8 <HAL_RTC_SetTime+0x98>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 80039c8:	22ff      	movs	r2, #255	; 0xff
 80039ca:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 80039cc:	2304      	movs	r3, #4
 80039ce:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
    __HAL_UNLOCK(hrtc);
 80039d2:	2300      	movs	r3, #0
 80039d4:	f886 3020 	strb.w	r3, [r6, #32]
        return HAL_ERROR;
 80039d8:	2501      	movs	r5, #1
}
 80039da:	4628      	mov	r0, r5
 80039dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 80039de:	f013 0340 	ands.w	r3, r3, #64	; 0x40
              ((uint32_t)(sTime->Minutes) << 8) | \
 80039e2:	ea4f 2505 	mov.w	r5, r5, lsl #8
      sTime->TimeFormat = 0x00;
 80039e6:	bf08      	it	eq
 80039e8:	70cb      	strbeq	r3, [r1, #3]
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 80039ea:	ea45 4000 	orr.w	r0, r5, r0, lsl #16
              ((uint32_t)(sTime->Minutes) << 8) | \
 80039ee:	4320      	orrs	r0, r4
              ((uint32_t)(sTime->TimeFormat) << 16));
 80039f0:	78cc      	ldrb	r4, [r1, #3]
    tmpreg = (((uint32_t)(sTime->Hours) << 16) | \
 80039f2:	ea40 4404 	orr.w	r4, r0, r4, lsl #16
 80039f6:	e7dc      	b.n	80039b2 <HAL_RTC_SetTime+0x52>
    hrtc->Instance->TR = (uint32_t)(tmpreg & RTC_TR_RESERVED_MASK);
 80039f8:	f004 347f 	and.w	r4, r4, #2139062143	; 0x7f7f7f7f
 80039fc:	f024 44fe 	bic.w	r4, r4, #2130706432	; 0x7f000000
 8003a00:	601c      	str	r4, [r3, #0]
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BCK);
 8003a02:	689a      	ldr	r2, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8003a04:	6938      	ldr	r0, [r7, #16]
    hrtc->Instance->CR &= ((uint32_t)~RTC_CR_BCK);
 8003a06:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8003a0a:	609a      	str	r2, [r3, #8]
    hrtc->Instance->CR |= (uint32_t)(sTime->DayLightSaving | sTime->StoreOperation);
 8003a0c:	68fa      	ldr	r2, [r7, #12]
 8003a0e:	6899      	ldr	r1, [r3, #8]
 8003a10:	4302      	orrs	r2, r0
 8003a12:	430a      	orrs	r2, r1
 8003a14:	609a      	str	r2, [r3, #8]
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8003a16:	68da      	ldr	r2, [r3, #12]
 8003a18:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003a1c:	60da      	str	r2, [r3, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8003a1e:	689b      	ldr	r3, [r3, #8]
 8003a20:	069b      	lsls	r3, r3, #26
 8003a22:	d40c      	bmi.n	8003a3e <HAL_RTC_SetTime+0xde>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8003a24:	4630      	mov	r0, r6
 8003a26:	f7ff ff09 	bl	800383c <HAL_RTC_WaitForSynchro>
 8003a2a:	b140      	cbz	r0, 8003a3e <HAL_RTC_SetTime+0xde>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003a2c:	6833      	ldr	r3, [r6, #0]
 8003a2e:	22ff      	movs	r2, #255	; 0xff
 8003a30:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8003a32:	2304      	movs	r3, #4
 8003a34:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
        __HAL_UNLOCK(hrtc);
 8003a38:	f886 5020 	strb.w	r5, [r6, #32]
 8003a3c:	e7cc      	b.n	80039d8 <HAL_RTC_SetTime+0x78>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003a3e:	6833      	ldr	r3, [r6, #0]
 8003a40:	22ff      	movs	r2, #255	; 0xff
 8003a42:	625a      	str	r2, [r3, #36]	; 0x24
   hrtc->State = HAL_RTC_STATE_READY;
 8003a44:	2301      	movs	r3, #1
 8003a46:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
   __HAL_UNLOCK(hrtc); 
 8003a4a:	2300      	movs	r3, #0
 8003a4c:	f886 3020 	strb.w	r3, [r6, #32]
   return HAL_OK;
 8003a50:	e7c3      	b.n	80039da <HAL_RTC_SetTime+0x7a>

08003a52 <HAL_RTC_SetDate>:
{
 8003a52:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 __HAL_LOCK(hrtc);
 8003a54:	f890 3020 	ldrb.w	r3, [r0, #32]
 8003a58:	2b01      	cmp	r3, #1
{
 8003a5a:	4605      	mov	r5, r0
 8003a5c:	f04f 0602 	mov.w	r6, #2
 __HAL_LOCK(hrtc);
 8003a60:	d034      	beq.n	8003acc <HAL_RTC_SetDate+0x7a>
 8003a62:	2301      	movs	r3, #1
 8003a64:	f880 3020 	strb.w	r3, [r0, #32]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8003a68:	f880 6021 	strb.w	r6, [r0, #33]	; 0x21
 8003a6c:	784b      	ldrb	r3, [r1, #1]
 8003a6e:	78c8      	ldrb	r0, [r1, #3]
 8003a70:	788e      	ldrb	r6, [r1, #2]
 8003a72:	780c      	ldrb	r4, [r1, #0]
  if((Format == RTC_FORMAT_BIN) && ((sDate->Month & 0x10U) == 0x10U))
 8003a74:	2a00      	cmp	r2, #0
 8003a76:	d14e      	bne.n	8003b16 <HAL_RTC_SetDate+0xc4>
 8003a78:	06da      	lsls	r2, r3, #27
 8003a7a:	d503      	bpl.n	8003a84 <HAL_RTC_SetDate+0x32>
    sDate->Month = (uint8_t)((sDate->Month & (uint8_t)~(0x10U)) + (uint8_t)0x0AU);
 8003a7c:	f023 0310 	bic.w	r3, r3, #16
 8003a80:	330a      	adds	r3, #10
 8003a82:	704b      	strb	r3, [r1, #1]
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8003a84:	f7ff ff61 	bl	800394a <RTC_ByteToBcd2>
 8003a88:	4607      	mov	r7, r0
                 ((uint32_t)RTC_ByteToBcd2(sDate->Month) << 8) | \
 8003a8a:	7848      	ldrb	r0, [r1, #1]
 8003a8c:	f7ff ff5d 	bl	800394a <RTC_ByteToBcd2>
 8003a90:	4602      	mov	r2, r0
                 ((uint32_t)RTC_ByteToBcd2(sDate->Date)) | \
 8003a92:	4630      	mov	r0, r6
 8003a94:	f7ff ff59 	bl	800394a <RTC_ByteToBcd2>
   datetmpreg = (((uint32_t)RTC_ByteToBcd2(sDate->Year) << 16) | \
 8003a98:	ea40 3044 	orr.w	r0, r0, r4, lsl #13
 8003a9c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8003aa0:	ea40 2402 	orr.w	r4, r0, r2, lsl #8
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8003aa4:	682b      	ldr	r3, [r5, #0]
 8003aa6:	22ca      	movs	r2, #202	; 0xca
 8003aa8:	625a      	str	r2, [r3, #36]	; 0x24
 8003aaa:	2253      	movs	r2, #83	; 0x53
 8003aac:	625a      	str	r2, [r3, #36]	; 0x24
  if(RTC_EnterInitMode(hrtc) != HAL_OK)
 8003aae:	4628      	mov	r0, r5
 8003ab0:	f7ff fedc 	bl	800386c <RTC_EnterInitMode>
 8003ab4:	682b      	ldr	r3, [r5, #0]
 8003ab6:	4606      	mov	r6, r0
 8003ab8:	b150      	cbz	r0, 8003ad0 <HAL_RTC_SetDate+0x7e>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003aba:	22ff      	movs	r2, #255	; 0xff
 8003abc:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_ERROR;
 8003abe:	2304      	movs	r3, #4
 8003ac0:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
    __HAL_UNLOCK(hrtc);
 8003ac4:	2300      	movs	r3, #0
 8003ac6:	f885 3020 	strb.w	r3, [r5, #32]
        return HAL_ERROR;
 8003aca:	2601      	movs	r6, #1
}
 8003acc:	4630      	mov	r0, r6
 8003ace:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    hrtc->Instance->DR = (uint32_t)(datetmpreg & RTC_DR_RESERVED_MASK);
 8003ad0:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
 8003ad4:	f024 04c0 	bic.w	r4, r4, #192	; 0xc0
 8003ad8:	605c      	str	r4, [r3, #4]
    hrtc->Instance->ISR &= ((uint32_t)~RTC_ISR_INIT);
 8003ada:	68da      	ldr	r2, [r3, #12]
 8003adc:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8003ae0:	60da      	str	r2, [r3, #12]
    if((hrtc->Instance->CR & RTC_CR_BYPSHAD) == RESET)
 8003ae2:	689b      	ldr	r3, [r3, #8]
 8003ae4:	069b      	lsls	r3, r3, #26
 8003ae6:	d40c      	bmi.n	8003b02 <HAL_RTC_SetDate+0xb0>
      if(HAL_RTC_WaitForSynchro(hrtc) != HAL_OK)
 8003ae8:	4628      	mov	r0, r5
 8003aea:	f7ff fea7 	bl	800383c <HAL_RTC_WaitForSynchro>
 8003aee:	b140      	cbz	r0, 8003b02 <HAL_RTC_SetDate+0xb0>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);  
 8003af0:	682b      	ldr	r3, [r5, #0]
 8003af2:	22ff      	movs	r2, #255	; 0xff
 8003af4:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_ERROR;
 8003af6:	2304      	movs	r3, #4
 8003af8:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
        __HAL_UNLOCK(hrtc);
 8003afc:	f885 6020 	strb.w	r6, [r5, #32]
 8003b00:	e7e3      	b.n	8003aca <HAL_RTC_SetDate+0x78>
    __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003b02:	682b      	ldr	r3, [r5, #0]
 8003b04:	22ff      	movs	r2, #255	; 0xff
 8003b06:	625a      	str	r2, [r3, #36]	; 0x24
    hrtc->State = HAL_RTC_STATE_READY ;
 8003b08:	2301      	movs	r3, #1
 8003b0a:	f885 3021 	strb.w	r3, [r5, #33]	; 0x21
    __HAL_UNLOCK(hrtc);
 8003b0e:	2300      	movs	r3, #0
 8003b10:	f885 3020 	strb.w	r3, [r5, #32]
    return HAL_OK;
 8003b14:	e7da      	b.n	8003acc <HAL_RTC_SetDate+0x7a>
                  (((uint32_t)sDate->Month) << 8) | \
 8003b16:	021b      	lsls	r3, r3, #8
    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 8003b18:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
                  (((uint32_t)sDate->Month) << 8) | \
 8003b1c:	4330      	orrs	r0, r6
    datetmpreg = ((((uint32_t)sDate->Year) << 16) | \
 8003b1e:	ea40 3444 	orr.w	r4, r0, r4, lsl #13
 8003b22:	e7bf      	b.n	8003aa4 <HAL_RTC_SetDate+0x52>

08003b24 <HAL_RTC_SetAlarm_IT>:
  __HAL_LOCK(hrtc);
 8003b24:	f890 3020 	ldrb.w	r3, [r0, #32]
 8003b28:	2b01      	cmp	r3, #1
{
 8003b2a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8003b2e:	4604      	mov	r4, r0
 8003b30:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 8003b34:	d067      	beq.n	8003c06 <HAL_RTC_SetAlarm_IT+0xe2>
 8003b36:	2301      	movs	r3, #1
 8003b38:	f884 3020 	strb.w	r3, [r4, #32]
 8003b3c:	6823      	ldr	r3, [r4, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8003b3e:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
 8003b42:	7808      	ldrb	r0, [r1, #0]
 8003b44:	f891 9001 	ldrb.w	r9, [r1, #1]
 8003b48:	788d      	ldrb	r5, [r1, #2]
 8003b4a:	f891 8020 	ldrb.w	r8, [r1, #32]
 8003b4e:	69ce      	ldr	r6, [r1, #28]
 8003b50:	694f      	ldr	r7, [r1, #20]
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003b52:	689b      	ldr	r3, [r3, #8]
  if(Format == RTC_FORMAT_BIN)
 8003b54:	2a00      	cmp	r2, #0
 8003b56:	d158      	bne.n	8003c0a <HAL_RTC_SetAlarm_IT+0xe6>
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003b58:	f013 0340 	ands.w	r3, r3, #64	; 0x40
      sAlarm->AlarmTime.TimeFormat = 0x00;
 8003b5c:	bf08      	it	eq
 8003b5e:	70cb      	strbeq	r3, [r1, #3]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8003b60:	f7ff fef3 	bl	800394a <RTC_ByteToBcd2>
 8003b64:	4682      	mov	sl, r0
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Minutes) << 8) | \
 8003b66:	4648      	mov	r0, r9
 8003b68:	f7ff feef 	bl	800394a <RTC_ByteToBcd2>
 8003b6c:	4602      	mov	r2, r0
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Seconds)) | \
 8003b6e:	4628      	mov	r0, r5
 8003b70:	f7ff feeb 	bl	800394a <RTC_ByteToBcd2>
 8003b74:	4681      	mov	r9, r0
              ((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmDateWeekDay) << 24) | \
 8003b76:	4640      	mov	r0, r8
 8003b78:	f7ff fee7 	bl	800394a <RTC_ByteToBcd2>
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
 8003b7c:	78cd      	ldrb	r5, [r1, #3]
    tmpreg = (((uint32_t)RTC_ByteToBcd2(sAlarm->AlarmTime.Hours) << 16) | \
 8003b7e:	433e      	orrs	r6, r7
 8003b80:	ea46 4505 	orr.w	r5, r6, r5, lsl #16
 8003b84:	ea45 0509 	orr.w	r5, r5, r9
 8003b88:	ea45 450a 	orr.w	r5, r5, sl, lsl #16
 8003b8c:	ea45 2502 	orr.w	r5, r5, r2, lsl #8
 8003b90:	ea45 6500 	orr.w	r5, r5, r0, lsl #24
  subsecondtmpreg = (uint32_t)((uint32_t)(sAlarm->AlarmTime.SubSeconds) | (uint32_t)(sAlarm->AlarmSubSecondMask));
 8003b94:	698b      	ldr	r3, [r1, #24]
 8003b96:	684e      	ldr	r6, [r1, #4]
 8003b98:	431e      	orrs	r6, r3
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8003b9a:	6823      	ldr	r3, [r4, #0]
 8003b9c:	22ca      	movs	r2, #202	; 0xca
 8003b9e:	625a      	str	r2, [r3, #36]	; 0x24
 8003ba0:	2253      	movs	r2, #83	; 0x53
 8003ba2:	625a      	str	r2, [r3, #36]	; 0x24
  if(sAlarm->Alarm == RTC_ALARM_A)
 8003ba4:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8003ba6:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8003baa:	689a      	ldr	r2, [r3, #8]
  if(sAlarm->Alarm == RTC_ALARM_A)
 8003bac:	d14f      	bne.n	8003c4e <HAL_RTC_SetAlarm_IT+0x12a>
    __HAL_RTC_ALARMA_DISABLE(hrtc);
 8003bae:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8003bb2:	609a      	str	r2, [r3, #8]
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRAF);
 8003bb4:	68da      	ldr	r2, [r3, #12]
 8003bb6:	b2d2      	uxtb	r2, r2
 8003bb8:	f462 72c0 	orn	r2, r2, #384	; 0x180
 8003bbc:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 8003bbe:	f7fd f967 	bl	8000e90 <HAL_GetTick>
 8003bc2:	4680      	mov	r8, r0
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRAWF) == RESET)
 8003bc4:	6823      	ldr	r3, [r4, #0]
 8003bc6:	68df      	ldr	r7, [r3, #12]
 8003bc8:	f017 0701 	ands.w	r7, r7, #1
 8003bcc:	d02e      	beq.n	8003c2c <HAL_RTC_SetAlarm_IT+0x108>
    hrtc->Instance->ALRMAR = (uint32_t)tmpreg;
 8003bce:	61dd      	str	r5, [r3, #28]
    hrtc->Instance->ALRMASSR = subsecondtmpreg;
 8003bd0:	645e      	str	r6, [r3, #68]	; 0x44
    __HAL_RTC_ALARMA_ENABLE(hrtc);
 8003bd2:	689a      	ldr	r2, [r3, #8]
 8003bd4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8003bd8:	609a      	str	r2, [r3, #8]
    __HAL_RTC_ALARM_ENABLE_IT(hrtc,RTC_IT_ALRA);
 8003bda:	689a      	ldr	r2, [r3, #8]
 8003bdc:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
 8003be0:	609a      	str	r2, [r3, #8]
  __HAL_RTC_ALARM_EXTI_ENABLE_IT();
 8003be2:	4b2c      	ldr	r3, [pc, #176]	; (8003c94 <HAL_RTC_SetAlarm_IT+0x170>)
 8003be4:	681a      	ldr	r2, [r3, #0]
 8003be6:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8003bea:	601a      	str	r2, [r3, #0]
  __HAL_RTC_ALARM_EXTI_ENABLE_RISING_EDGE();
 8003bec:	689a      	ldr	r2, [r3, #8]
 8003bee:	f442 2280 	orr.w	r2, r2, #262144	; 0x40000
 8003bf2:	609a      	str	r2, [r3, #8]
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003bf4:	6823      	ldr	r3, [r4, #0]
 8003bf6:	22ff      	movs	r2, #255	; 0xff
 8003bf8:	625a      	str	r2, [r3, #36]	; 0x24
  __HAL_UNLOCK(hrtc);
 8003bfa:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY; 
 8003bfc:	2301      	movs	r3, #1
 8003bfe:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  __HAL_UNLOCK(hrtc);
 8003c02:	f884 0020 	strb.w	r0, [r4, #32]
}
 8003c06:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    if((hrtc->Instance->CR & RTC_CR_FMT) != (uint32_t)RESET)
 8003c0a:	f013 0340 	ands.w	r3, r3, #64	; 0x40
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
 8003c0e:	ea46 0607 	orr.w	r6, r6, r7
      sAlarm->AlarmTime.TimeFormat = 0x00;
 8003c12:	bf08      	it	eq
 8003c14:	70cb      	strbeq	r3, [r1, #3]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
 8003c16:	4335      	orrs	r5, r6
 8003c18:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
              ((uint32_t)(sAlarm->AlarmTime.TimeFormat) << 16) | \
 8003c1c:	78c8      	ldrb	r0, [r1, #3]
    tmpreg = (((uint32_t)(sAlarm->AlarmTime.Hours) << 16) | \
 8003c1e:	ea45 2509 	orr.w	r5, r5, r9, lsl #8
 8003c22:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
 8003c26:	ea45 6508 	orr.w	r5, r5, r8, lsl #24
 8003c2a:	e7b3      	b.n	8003b94 <HAL_RTC_SetAlarm_IT+0x70>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8003c2c:	f7fd f930 	bl	8000e90 <HAL_GetTick>
 8003c30:	eba0 0008 	sub.w	r0, r0, r8
 8003c34:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003c38:	d9c4      	bls.n	8003bc4 <HAL_RTC_SetAlarm_IT+0xa0>
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003c3a:	6823      	ldr	r3, [r4, #0]
 8003c3c:	22ff      	movs	r2, #255	; 0xff
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8003c3e:	2003      	movs	r0, #3
        __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003c40:	625a      	str	r2, [r3, #36]	; 0x24
        hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8003c42:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
        __HAL_UNLOCK(hrtc);
 8003c46:	f884 7020 	strb.w	r7, [r4, #32]
        return HAL_TIMEOUT;
 8003c4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    __HAL_RTC_ALARMB_DISABLE(hrtc);
 8003c4e:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8003c52:	609a      	str	r2, [r3, #8]
    __HAL_RTC_ALARM_CLEAR_FLAG(hrtc, RTC_FLAG_ALRBF);
 8003c54:	68da      	ldr	r2, [r3, #12]
 8003c56:	b2d2      	uxtb	r2, r2
 8003c58:	f462 7220 	orn	r2, r2, #640	; 0x280
 8003c5c:	60da      	str	r2, [r3, #12]
    tickstart = HAL_GetTick();
 8003c5e:	f7fd f917 	bl	8000e90 <HAL_GetTick>
 8003c62:	4680      	mov	r8, r0
    while(__HAL_RTC_ALARM_GET_FLAG(hrtc, RTC_FLAG_ALRBWF) == RESET)
 8003c64:	6823      	ldr	r3, [r4, #0]
 8003c66:	68df      	ldr	r7, [r3, #12]
 8003c68:	f017 0702 	ands.w	r7, r7, #2
 8003c6c:	d009      	beq.n	8003c82 <HAL_RTC_SetAlarm_IT+0x15e>
    hrtc->Instance->ALRMBR = (uint32_t)tmpreg;
 8003c6e:	621d      	str	r5, [r3, #32]
    hrtc->Instance->ALRMBSSR = subsecondtmpreg;
 8003c70:	649e      	str	r6, [r3, #72]	; 0x48
    __HAL_RTC_ALARMB_ENABLE(hrtc);
 8003c72:	689a      	ldr	r2, [r3, #8]
 8003c74:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8003c78:	609a      	str	r2, [r3, #8]
    __HAL_RTC_ALARM_ENABLE_IT(hrtc, RTC_IT_ALRB);
 8003c7a:	689a      	ldr	r2, [r3, #8]
 8003c7c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 8003c80:	e7ae      	b.n	8003be0 <HAL_RTC_SetAlarm_IT+0xbc>
      if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8003c82:	f7fd f905 	bl	8000e90 <HAL_GetTick>
 8003c86:	eba0 0008 	sub.w	r0, r0, r8
 8003c8a:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003c8e:	d9e9      	bls.n	8003c64 <HAL_RTC_SetAlarm_IT+0x140>
 8003c90:	e7d3      	b.n	8003c3a <HAL_RTC_SetAlarm_IT+0x116>
 8003c92:	bf00      	nop
 8003c94:	40010400 	.word	0x40010400

08003c98 <RTC_Bcd2ToByte>:
  * @retval Converted word
  */
uint8_t RTC_Bcd2ToByte(uint8_t Value)
{
  uint32_t tmp = 0;
  tmp = ((uint8_t)(Value & (uint8_t)0xF0) >> (uint8_t)0x4) * 10;
 8003c98:	0903      	lsrs	r3, r0, #4
 8003c9a:	eb03 0383 	add.w	r3, r3, r3, lsl #2
  return (tmp + (Value & (uint8_t)0x0F));
 8003c9e:	f000 000f 	and.w	r0, r0, #15
 8003ca2:	eb00 0043 	add.w	r0, r0, r3, lsl #1
}
 8003ca6:	b2c0      	uxtb	r0, r0
 8003ca8:	4770      	bx	lr

08003caa <HAL_RTC_GetTime>:
  sTime->SubSeconds = (uint32_t)(hrtc->Instance->SSR);
 8003caa:	6803      	ldr	r3, [r0, #0]
 8003cac:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8003cae:	6048      	str	r0, [r1, #4]
{
 8003cb0:	b570      	push	{r4, r5, r6, lr}
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8003cb2:	6918      	ldr	r0, [r3, #16]
  tmpreg = (uint32_t)(hrtc->Instance->TR & RTC_TR_RESERVED_MASK);
 8003cb4:	681d      	ldr	r5, [r3, #0]
 8003cb6:	f005 337f 	and.w	r3, r5, #2139062143	; 0x7f7f7f7f
 8003cba:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8003cbe:	f3c0 000e 	ubfx	r0, r0, #0, #15
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8003cc2:	0c1e      	lsrs	r6, r3, #16
  sTime->SecondFraction = (uint32_t)(hrtc->Instance->PRER & RTC_PRER_PREDIV_S);
 8003cc4:	6088      	str	r0, [r1, #8]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8003cc6:	f3c3 2406 	ubfx	r4, r3, #8, #7
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8003cca:	f006 003f 	and.w	r0, r6, #63	; 0x3f
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8003cce:	f005 057f 	and.w	r5, r5, #127	; 0x7f
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);
 8003cd2:	f006 0640 	and.w	r6, r6, #64	; 0x40
  sTime->Hours = (uint8_t)((tmpreg & (RTC_TR_HT | RTC_TR_HU)) >> 16);
 8003cd6:	7008      	strb	r0, [r1, #0]
  sTime->Minutes = (uint8_t)((tmpreg & (RTC_TR_MNT | RTC_TR_MNU)) >>8);
 8003cd8:	704c      	strb	r4, [r1, #1]
  sTime->Seconds = (uint8_t)(tmpreg & (RTC_TR_ST | RTC_TR_SU));
 8003cda:	708d      	strb	r5, [r1, #2]
  sTime->TimeFormat = (uint8_t)((tmpreg & (RTC_TR_PM)) >> 16);
 8003cdc:	70ce      	strb	r6, [r1, #3]
  if(Format == RTC_FORMAT_BIN)
 8003cde:	b952      	cbnz	r2, 8003cf6 <HAL_RTC_GetTime+0x4c>
    sTime->Hours = (uint8_t)RTC_Bcd2ToByte(sTime->Hours);
 8003ce0:	f7ff ffda 	bl	8003c98 <RTC_Bcd2ToByte>
 8003ce4:	7008      	strb	r0, [r1, #0]
    sTime->Minutes = (uint8_t)RTC_Bcd2ToByte(sTime->Minutes);
 8003ce6:	4620      	mov	r0, r4
 8003ce8:	f7ff ffd6 	bl	8003c98 <RTC_Bcd2ToByte>
 8003cec:	7048      	strb	r0, [r1, #1]
    sTime->Seconds = (uint8_t)RTC_Bcd2ToByte(sTime->Seconds);
 8003cee:	4628      	mov	r0, r5
 8003cf0:	f7ff ffd2 	bl	8003c98 <RTC_Bcd2ToByte>
 8003cf4:	7088      	strb	r0, [r1, #2]
}
 8003cf6:	2000      	movs	r0, #0
 8003cf8:	bd70      	pop	{r4, r5, r6, pc}

08003cfa <HAL_RTC_GetDate>:
{
 8003cfa:	b538      	push	{r3, r4, r5, lr}
  datetmpreg = (uint32_t)(hrtc->Instance->DR & RTC_DR_RESERVED_MASK);
 8003cfc:	6803      	ldr	r3, [r0, #0]
 8003cfe:	685c      	ldr	r4, [r3, #4]
 8003d00:	f024 437f 	bic.w	r3, r4, #4278190080	; 0xff000000
 8003d04:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8003d08:	0c18      	lsrs	r0, r3, #16
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8003d0a:	f3c3 2504 	ubfx	r5, r3, #8, #5
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8003d0e:	f004 043f 	and.w	r4, r4, #63	; 0x3f
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13); 
 8003d12:	f3c3 3342 	ubfx	r3, r3, #13, #3
  sDate->Year = (uint8_t)((datetmpreg & (RTC_DR_YT | RTC_DR_YU)) >> 16);
 8003d16:	70c8      	strb	r0, [r1, #3]
  sDate->Month = (uint8_t)((datetmpreg & (RTC_DR_MT | RTC_DR_MU)) >> 8);
 8003d18:	704d      	strb	r5, [r1, #1]
  sDate->Date = (uint8_t)(datetmpreg & (RTC_DR_DT | RTC_DR_DU));
 8003d1a:	708c      	strb	r4, [r1, #2]
  sDate->WeekDay = (uint8_t)((datetmpreg & (RTC_DR_WDU)) >> 13); 
 8003d1c:	700b      	strb	r3, [r1, #0]
  if(Format == RTC_FORMAT_BIN)
 8003d1e:	b952      	cbnz	r2, 8003d36 <HAL_RTC_GetDate+0x3c>
    sDate->Year = (uint8_t)RTC_Bcd2ToByte(sDate->Year);
 8003d20:	f7ff ffba 	bl	8003c98 <RTC_Bcd2ToByte>
 8003d24:	70c8      	strb	r0, [r1, #3]
    sDate->Month = (uint8_t)RTC_Bcd2ToByte(sDate->Month);
 8003d26:	4628      	mov	r0, r5
 8003d28:	f7ff ffb6 	bl	8003c98 <RTC_Bcd2ToByte>
 8003d2c:	7048      	strb	r0, [r1, #1]
    sDate->Date = (uint8_t)RTC_Bcd2ToByte(sDate->Date);
 8003d2e:	4620      	mov	r0, r4
 8003d30:	f7ff ffb2 	bl	8003c98 <RTC_Bcd2ToByte>
 8003d34:	7088      	strb	r0, [r1, #2]
}
 8003d36:	2000      	movs	r0, #0
 8003d38:	bd38      	pop	{r3, r4, r5, pc}

08003d3a <HAL_RTCEx_DeactivateWakeUpTimer>:
uint32_t HAL_RTCEx_DeactivateWakeUpTimer(RTC_HandleTypeDef *hrtc)
{
  uint32_t tickstart = 0;

  /* Process Locked */ 
  __HAL_LOCK(hrtc);
 8003d3a:	f890 3020 	ldrb.w	r3, [r0, #32]
 8003d3e:	2b01      	cmp	r3, #1
{
 8003d40:	b570      	push	{r4, r5, r6, lr}
 8003d42:	4604      	mov	r4, r0
 8003d44:	f04f 0002 	mov.w	r0, #2
  __HAL_LOCK(hrtc);
 8003d48:	d021      	beq.n	8003d8e <HAL_RTCEx_DeactivateWakeUpTimer+0x54>
 8003d4a:	2301      	movs	r3, #1
 8003d4c:	f884 3020 	strb.w	r3, [r4, #32]

  hrtc->State = HAL_RTC_STATE_BUSY;

  /* Disable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8003d50:	6823      	ldr	r3, [r4, #0]
  hrtc->State = HAL_RTC_STATE_BUSY;
 8003d52:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
  __HAL_RTC_WRITEPROTECTION_DISABLE(hrtc);
 8003d56:	22ca      	movs	r2, #202	; 0xca
 8003d58:	625a      	str	r2, [r3, #36]	; 0x24
 8003d5a:	2253      	movs	r2, #83	; 0x53
 8003d5c:	625a      	str	r2, [r3, #36]	; 0x24

  /* Disable the Wakeup Timer */
  __HAL_RTC_WAKEUPTIMER_DISABLE(hrtc);
 8003d5e:	689a      	ldr	r2, [r3, #8]
 8003d60:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8003d64:	609a      	str	r2, [r3, #8]

  /* In case of interrupt mode is used, the interrupt source must disabled */
  __HAL_RTC_WAKEUPTIMER_DISABLE_IT(hrtc,RTC_IT_WUT);
 8003d66:	689a      	ldr	r2, [r3, #8]
 8003d68:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8003d6c:	609a      	str	r2, [r3, #8]

  tickstart = HAL_GetTick();
 8003d6e:	f7fd f88f 	bl	8000e90 <HAL_GetTick>
 8003d72:	4606      	mov	r6, r0
  /* Wait till RTC WUTWF flag is set and if Time out is reached exit */
  while(__HAL_RTC_WAKEUPTIMER_GET_FLAG(hrtc, RTC_FLAG_WUTWF) == RESET)
 8003d74:	6822      	ldr	r2, [r4, #0]
 8003d76:	68d5      	ldr	r5, [r2, #12]
 8003d78:	f015 0504 	ands.w	r5, r5, #4
 8003d7c:	d008      	beq.n	8003d90 <HAL_RTCEx_DeactivateWakeUpTimer+0x56>
      return HAL_TIMEOUT;
    }
  }

  /* Enable the write protection for RTC registers */
  __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003d7e:	23ff      	movs	r3, #255	; 0xff
 8003d80:	6253      	str	r3, [r2, #36]	; 0x24

  hrtc->State = HAL_RTC_STATE_READY;

  /* Process Unlocked */
  __HAL_UNLOCK(hrtc);
 8003d82:	2000      	movs	r0, #0
  hrtc->State = HAL_RTC_STATE_READY;
 8003d84:	2301      	movs	r3, #1
 8003d86:	f884 3021 	strb.w	r3, [r4, #33]	; 0x21
  __HAL_UNLOCK(hrtc);
 8003d8a:	f884 0020 	strb.w	r0, [r4, #32]

  return HAL_OK;
}
 8003d8e:	bd70      	pop	{r4, r5, r6, pc}
    if((HAL_GetTick() - tickstart ) > RTC_TIMEOUT_VALUE)
 8003d90:	f7fd f87e 	bl	8000e90 <HAL_GetTick>
 8003d94:	1b80      	subs	r0, r0, r6
 8003d96:	f5b0 7f7a 	cmp.w	r0, #1000	; 0x3e8
 8003d9a:	d9eb      	bls.n	8003d74 <HAL_RTCEx_DeactivateWakeUpTimer+0x3a>
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003d9c:	6823      	ldr	r3, [r4, #0]
 8003d9e:	22ff      	movs	r2, #255	; 0xff
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8003da0:	2003      	movs	r0, #3
      __HAL_RTC_WRITEPROTECTION_ENABLE(hrtc);
 8003da2:	625a      	str	r2, [r3, #36]	; 0x24
      hrtc->State = HAL_RTC_STATE_TIMEOUT;
 8003da4:	f884 0021 	strb.w	r0, [r4, #33]	; 0x21
      __HAL_UNLOCK(hrtc);
 8003da8:	f884 5020 	strb.w	r5, [r4, #32]
      return HAL_TIMEOUT;
 8003dac:	bd70      	pop	{r4, r5, r6, pc}
	...

08003db0 <HAL_SD_ReadBlocks>:
  * @param  NumberOfBlocks: Number of SD blocks to read   
  * @param  Timeout: Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_ReadBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks, uint32_t Timeout)
{
 8003db0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003db4:	b087      	sub	sp, #28
 8003db6:	4604      	mov	r4, r0
 8003db8:	460d      	mov	r5, r1
 8003dba:	4690      	mov	r8, r2
 8003dbc:	4699      	mov	r9, r3
 8003dbe:	9f10      	ldr	r7, [sp, #64]	; 0x40
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 8003dc0:	f7fd f866 	bl	8000e90 <HAL_GetTick>
 8003dc4:	4606      	mov	r6, r0
  uint32_t count, data;
  uint32_t add = BlockAdd;
  uint8_t *tempbuff = pData;
  
  if(NULL == pData)
 8003dc6:	b92d      	cbnz	r5, 8003dd4 <HAL_SD_ReadBlocks+0x24>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8003dc8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003dca:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    
    return HAL_OK;
  }
  else
  {
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 8003dce:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 8003dd0:	2001      	movs	r0, #1
 8003dd2:	e010      	b.n	8003df6 <HAL_SD_ReadBlocks+0x46>
  if(hsd->State == HAL_SD_STATE_READY)
 8003dd4:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 8003dd8:	b2c0      	uxtb	r0, r0
 8003dda:	2801      	cmp	r0, #1
 8003ddc:	f040 80e9 	bne.w	8003fb2 <HAL_SD_ReadBlocks+0x202>
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8003de0:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8003de2:	eb08 0309 	add.w	r3, r8, r9
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8003de6:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8003de8:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8003dea:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8003dec:	d906      	bls.n	8003dfc <HAL_SD_ReadBlocks+0x4c>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8003dee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003df0:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8003df4:	63a3      	str	r3, [r4, #56]	; 0x38
  }
}
 8003df6:	b007      	add	sp, #28
 8003df8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    hsd->State = HAL_SD_STATE_BUSY;
 8003dfc:	2303      	movs	r3, #3
 8003dfe:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    hsd->Instance->DCTRL = 0U;
 8003e02:	6820      	ldr	r0, [r4, #0]
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8003e04:	6c63      	ldr	r3, [r4, #68]	; 0x44
    hsd->Instance->DCTRL = 0U;
 8003e06:	62c1      	str	r1, [r0, #44]	; 0x2c
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8003e08:	2b01      	cmp	r3, #1
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8003e0a:	f44f 7100 	mov.w	r1, #512	; 0x200
      add *= 512U;
 8003e0e:	bf18      	it	ne
 8003e10:	ea4f 2848 	movne.w	r8, r8, lsl #9
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8003e14:	f001 f997 	bl	8005146 <SDMMC_CmdBlockLength>
    if(errorstate != HAL_SD_ERROR_NONE)
 8003e18:	b148      	cbz	r0, 8003e2e <HAL_SD_ReadBlocks+0x7e>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8003e1a:	6823      	ldr	r3, [r4, #0]
 8003e1c:	4a67      	ldr	r2, [pc, #412]	; (8003fbc <HAL_SD_ReadBlocks+0x20c>)
 8003e1e:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 8003e20:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003e22:	4318      	orrs	r0, r3
 8003e24:	63a0      	str	r0, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8003e26:	2001      	movs	r0, #1
 8003e28:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      return HAL_ERROR;
 8003e2c:	e7e3      	b.n	8003df6 <HAL_SD_ReadBlocks+0x46>
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 8003e2e:	f04f 33ff 	mov.w	r3, #4294967295
 8003e32:	9300      	str	r3, [sp, #0]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 8003e34:	ea4f 2349 	mov.w	r3, r9, lsl #9
 8003e38:	9301      	str	r3, [sp, #4]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 8003e3a:	9004      	str	r0, [sp, #16]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8003e3c:	2390      	movs	r3, #144	; 0x90
    config.DPSM          = SDMMC_DPSM_ENABLE;
 8003e3e:	f04f 0a01 	mov.w	sl, #1
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8003e42:	f04f 0b02 	mov.w	fp, #2
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 8003e46:	4669      	mov	r1, sp
 8003e48:	6820      	ldr	r0, [r4, #0]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8003e4a:	9302      	str	r3, [sp, #8]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_SDMMC;
 8003e4c:	f8cd b00c 	str.w	fp, [sp, #12]
    config.DPSM          = SDMMC_DPSM_ENABLE;
 8003e50:	f8cd a014 	str.w	sl, [sp, #20]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 8003e54:	f001 f965 	bl	8005122 <SDMMC_ConfigData>
    if(NumberOfBlocks > 1U)
 8003e58:	45d1      	cmp	r9, sl
 8003e5a:	d913      	bls.n	8003e84 <HAL_SD_ReadBlocks+0xd4>
      hsd->Context = SD_CONTEXT_READ_MULTIPLE_BLOCK;
 8003e5c:	f8c4 b030 	str.w	fp, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadMultiBlock(hsd->Instance, add);
 8003e60:	4641      	mov	r1, r8
 8003e62:	6820      	ldr	r0, [r4, #0]
 8003e64:	f001 f99f 	bl	80051a6 <SDMMC_CmdReadMultiBlock>
    if(errorstate != HAL_SD_ERROR_NONE)
 8003e68:	2800      	cmp	r0, #0
 8003e6a:	d03e      	beq.n	8003eea <HAL_SD_ReadBlocks+0x13a>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8003e6c:	6823      	ldr	r3, [r4, #0]
 8003e6e:	4a53      	ldr	r2, [pc, #332]	; (8003fbc <HAL_SD_ReadBlocks+0x20c>)
 8003e70:	639a      	str	r2, [r3, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
 8003e72:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003e74:	4318      	orrs	r0, r3
 8003e76:	63a0      	str	r0, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 8003e78:	2001      	movs	r0, #1
        hsd->Context = SD_CONTEXT_NONE;
 8003e7a:	2300      	movs	r3, #0
        hsd->State= HAL_SD_STATE_READY;
 8003e7c:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 8003e80:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_ERROR;
 8003e82:	e7b8      	b.n	8003df6 <HAL_SD_ReadBlocks+0x46>
      hsd->Context = SD_CONTEXT_READ_SINGLE_BLOCK;
 8003e84:	f8c4 a030 	str.w	sl, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdReadSingleBlock(hsd->Instance, add);
 8003e88:	4641      	mov	r1, r8
 8003e8a:	6820      	ldr	r0, [r4, #0]
 8003e8c:	f001 f973 	bl	8005176 <SDMMC_CmdReadSingleBlock>
 8003e90:	e7ea      	b.n	8003e68 <HAL_SD_ReadBlocks+0xb8>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 8003e92:	041a      	lsls	r2, r3, #16
 8003e94:	d516      	bpl.n	8003ec4 <HAL_SD_ReadBlocks+0x114>
 8003e96:	f105 0804 	add.w	r8, r5, #4
 8003e9a:	f105 0a24 	add.w	sl, r5, #36	; 0x24
          data = SDMMC_ReadFIFO(hsd->Instance);
 8003e9e:	6820      	ldr	r0, [r4, #0]
 8003ea0:	f001 f91a 	bl	80050d8 <SDMMC_ReadFIFO>
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 8003ea4:	0a03      	lsrs	r3, r0, #8
          *tempbuff = (uint8_t)(data & 0xFFU);
 8003ea6:	f808 0c04 	strb.w	r0, [r8, #-4]
          *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 8003eaa:	f808 3c03 	strb.w	r3, [r8, #-3]
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 8003eae:	0c03      	lsrs	r3, r0, #16
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 8003eb0:	0e00      	lsrs	r0, r0, #24
          *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 8003eb2:	f808 3c02 	strb.w	r3, [r8, #-2]
          *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 8003eb6:	f808 0c01 	strb.w	r0, [r8, #-1]
 8003eba:	f108 0804 	add.w	r8, r8, #4
        for(count = 0U; count < 8U; count++)
 8003ebe:	45d0      	cmp	r8, sl
 8003ec0:	d1ed      	bne.n	8003e9e <HAL_SD_ReadBlocks+0xee>
 8003ec2:	3520      	adds	r5, #32
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 8003ec4:	f7fc ffe4 	bl	8000e90 <HAL_GetTick>
 8003ec8:	1b80      	subs	r0, r0, r6
 8003eca:	42b8      	cmp	r0, r7
 8003ecc:	d30d      	bcc.n	8003eea <HAL_SD_ReadBlocks+0x13a>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8003ece:	6823      	ldr	r3, [r4, #0]
 8003ed0:	4a3a      	ldr	r2, [pc, #232]	; (8003fbc <HAL_SD_ReadBlocks+0x20c>)
 8003ed2:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 8003ed4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003ed6:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003eda:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State= HAL_SD_STATE_READY;
 8003edc:	2301      	movs	r3, #1
 8003ede:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 8003ee2:	2300      	movs	r3, #0
 8003ee4:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
 8003ee6:	2003      	movs	r0, #3
 8003ee8:	e785      	b.n	8003df6 <HAL_SD_ReadBlocks+0x46>
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 8003eea:	6820      	ldr	r0, [r4, #0]
 8003eec:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003eee:	f413 7f95 	tst.w	r3, #298	; 0x12a
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXFIFOHF))
 8003ef2:	6b43      	ldr	r3, [r0, #52]	; 0x34
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 8003ef4:	d0cd      	beq.n	8003e92 <HAL_SD_ReadBlocks+0xe2>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 8003ef6:	05db      	lsls	r3, r3, #23
 8003ef8:	d509      	bpl.n	8003f0e <HAL_SD_ReadBlocks+0x15e>
 8003efa:	f1b9 0f01 	cmp.w	r9, #1
 8003efe:	d906      	bls.n	8003f0e <HAL_SD_ReadBlocks+0x15e>
      if(hsd->SdCard.CardType != CARD_SECURED)
 8003f00:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8003f02:	2b03      	cmp	r3, #3
 8003f04:	d003      	beq.n	8003f0e <HAL_SD_ReadBlocks+0x15e>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 8003f06:	f001 f997 	bl	8005238 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 8003f0a:	2800      	cmp	r0, #0
 8003f0c:	d1ae      	bne.n	8003e6c <HAL_SD_ReadBlocks+0xbc>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 8003f0e:	6823      	ldr	r3, [r4, #0]
 8003f10:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8003f12:	f011 0108 	ands.w	r1, r1, #8
 8003f16:	d006      	beq.n	8003f26 <HAL_SD_ReadBlocks+0x176>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8003f18:	4a28      	ldr	r2, [pc, #160]	; (8003fbc <HAL_SD_ReadBlocks+0x20c>)
 8003f1a:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 8003f1c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003f1e:	f043 0308 	orr.w	r3, r3, #8
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 8003f22:	63a3      	str	r3, [r4, #56]	; 0x38
 8003f24:	e7a8      	b.n	8003e78 <HAL_SD_ReadBlocks+0xc8>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 8003f26:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8003f28:	f012 0202 	ands.w	r2, r2, #2
 8003f2c:	d00a      	beq.n	8003f44 <HAL_SD_ReadBlocks+0x194>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8003f2e:	4a23      	ldr	r2, [pc, #140]	; (8003fbc <HAL_SD_ReadBlocks+0x20c>)
 8003f30:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 8003f32:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8003f34:	2001      	movs	r0, #1
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 8003f36:	f043 0302 	orr.w	r3, r3, #2
 8003f3a:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8003f3c:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8003f40:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 8003f42:	e758      	b.n	8003df6 <HAL_SD_ReadBlocks+0x46>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXOVERR))
 8003f44:	6b59      	ldr	r1, [r3, #52]	; 0x34
 8003f46:	0689      	lsls	r1, r1, #26
 8003f48:	d525      	bpl.n	8003f96 <HAL_SD_ReadBlocks+0x1e6>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8003f4a:	491c      	ldr	r1, [pc, #112]	; (8003fbc <HAL_SD_ReadBlocks+0x20c>)
 8003f4c:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 8003f4e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8003f50:	2001      	movs	r0, #1
      hsd->ErrorCode |= HAL_SD_ERROR_RX_OVERRUN;
 8003f52:	f043 0320 	orr.w	r3, r3, #32
 8003f56:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8003f58:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8003f5c:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
 8003f5e:	e74a      	b.n	8003df6 <HAL_SD_ReadBlocks+0x46>
      data = SDMMC_ReadFIFO(hsd->Instance);
 8003f60:	f001 f8ba 	bl	80050d8 <SDMMC_ReadFIFO>
      *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 8003f64:	0a03      	lsrs	r3, r0, #8
      *tempbuff = (uint8_t)(data & 0xFFU);
 8003f66:	f805 0c04 	strb.w	r0, [r5, #-4]
      *tempbuff = (uint8_t)((data >> 8U) & 0xFFU);
 8003f6a:	f805 3c03 	strb.w	r3, [r5, #-3]
      *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 8003f6e:	0c03      	lsrs	r3, r0, #16
      *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 8003f70:	0e00      	lsrs	r0, r0, #24
      *tempbuff = (uint8_t)((data >> 16U) & 0xFFU);
 8003f72:	f805 3c02 	strb.w	r3, [r5, #-2]
      *tempbuff = (uint8_t)((data >> 24U) & 0xFFU);
 8003f76:	f805 0c01 	strb.w	r0, [r5, #-1]
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 8003f7a:	f7fc ff89 	bl	8000e90 <HAL_GetTick>
 8003f7e:	1b80      	subs	r0, r0, r6
 8003f80:	4287      	cmp	r7, r0
 8003f82:	f105 0504 	add.w	r5, r5, #4
 8003f86:	d807      	bhi.n	8003f98 <HAL_SD_ReadBlocks+0x1e8>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);        
 8003f88:	6823      	ldr	r3, [r4, #0]
 8003f8a:	4a0c      	ldr	r2, [pc, #48]	; (8003fbc <HAL_SD_ReadBlocks+0x20c>)
 8003f8c:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= HAL_SD_ERROR_TIMEOUT;
 8003f8e:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003f90:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8003f94:	e7c5      	b.n	8003f22 <HAL_SD_ReadBlocks+0x172>
 8003f96:	3504      	adds	r5, #4
    while ((__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_RXDAVL)))
 8003f98:	6820      	ldr	r0, [r4, #0]
 8003f9a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8003f9c:	f413 1300 	ands.w	r3, r3, #2097152	; 0x200000
 8003fa0:	d1de      	bne.n	8003f60 <HAL_SD_ReadBlocks+0x1b0>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 8003fa2:	f240 523a 	movw	r2, #1338	; 0x53a
 8003fa6:	6382      	str	r2, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8003fa8:	2201      	movs	r2, #1
 8003faa:	f884 2034 	strb.w	r2, [r4, #52]	; 0x34
    return HAL_OK;
 8003fae:	4618      	mov	r0, r3
 8003fb0:	e721      	b.n	8003df6 <HAL_SD_ReadBlocks+0x46>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 8003fb2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003fb4:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8003fb8:	e709      	b.n	8003dce <HAL_SD_ReadBlocks+0x1e>
 8003fba:	bf00      	nop
 8003fbc:	004005ff 	.word	0x004005ff

08003fc0 <HAL_SD_WriteBlocks>:
  * @param  NumberOfBlocks: Number of SD blocks to write 
  * @param  Timeout: Specify timeout value
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_WriteBlocks(SD_HandleTypeDef *hsd, uint8_t *pData, uint32_t BlockAdd, uint32_t NumberOfBlocks, uint32_t Timeout)
{
 8003fc0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8003fc4:	b089      	sub	sp, #36	; 0x24
 8003fc6:	4604      	mov	r4, r0
 8003fc8:	460e      	mov	r6, r1
 8003fca:	4691      	mov	r9, r2
 8003fcc:	461f      	mov	r7, r3
 8003fce:	9d10      	ldr	r5, [sp, #64]	; 0x40
  SDMMC_DataInitTypeDef config;
  uint32_t errorstate;
  uint32_t tickstart = HAL_GetTick();
 8003fd0:	f7fc ff5e 	bl	8000e90 <HAL_GetTick>
 8003fd4:	4680      	mov	r8, r0
  uint32_t count, data;
  uint32_t add = BlockAdd;
  uint8_t *tempbuff = pData;
  
  if(NULL == pData)
 8003fd6:	b92e      	cbnz	r6, 8003fe4 <HAL_SD_WriteBlocks+0x24>
  {
    hsd->ErrorCode |= HAL_SD_ERROR_PARAM;
 8003fd8:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8003fda:	f043 6300 	orr.w	r3, r3, #134217728	; 0x8000000
    
    return HAL_OK;
  }
  else
  {
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 8003fde:	63a3      	str	r3, [r4, #56]	; 0x38
    return HAL_ERROR;
 8003fe0:	2001      	movs	r0, #1
 8003fe2:	e010      	b.n	8004006 <HAL_SD_WriteBlocks+0x46>
  if(hsd->State == HAL_SD_STATE_READY)
 8003fe4:	f894 0034 	ldrb.w	r0, [r4, #52]	; 0x34
 8003fe8:	b2c0      	uxtb	r0, r0
 8003fea:	2801      	cmp	r0, #1
 8003fec:	f040 80b4 	bne.w	8004158 <HAL_SD_WriteBlocks+0x198>
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8003ff0:	6de2      	ldr	r2, [r4, #92]	; 0x5c
 8003ff2:	eb09 0307 	add.w	r3, r9, r7
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8003ff6:	2100      	movs	r1, #0
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8003ff8:	4293      	cmp	r3, r2
    hsd->ErrorCode = HAL_SD_ERROR_NONE;
 8003ffa:	63a1      	str	r1, [r4, #56]	; 0x38
    if((add + NumberOfBlocks) > (hsd->SdCard.LogBlockNbr))
 8003ffc:	d906      	bls.n	800400c <HAL_SD_WriteBlocks+0x4c>
      hsd->ErrorCode |= HAL_SD_ERROR_ADDR_OUT_OF_RANGE;
 8003ffe:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004000:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8004004:	63a3      	str	r3, [r4, #56]	; 0x38
  }
}
 8004006:	b009      	add	sp, #36	; 0x24
 8004008:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hsd->State = HAL_SD_STATE_BUSY;
 800400c:	2303      	movs	r3, #3
 800400e:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    hsd->Instance->DCTRL = 0U;
 8004012:	6820      	ldr	r0, [r4, #0]
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8004014:	6c63      	ldr	r3, [r4, #68]	; 0x44
    hsd->Instance->DCTRL = 0U;
 8004016:	62c1      	str	r1, [r0, #44]	; 0x2c
    if(hsd->SdCard.CardType != CARD_SDHC_SDXC)
 8004018:	2b01      	cmp	r3, #1
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 800401a:	f44f 7100 	mov.w	r1, #512	; 0x200
      add *= 512U;
 800401e:	bf18      	it	ne
 8004020:	ea4f 2949 	movne.w	r9, r9, lsl #9
    errorstate = SDMMC_CmdBlockLength(hsd->Instance, BLOCKSIZE);
 8004024:	f001 f88f 	bl	8005146 <SDMMC_CmdBlockLength>
    if(errorstate != HAL_SD_ERROR_NONE)
 8004028:	b148      	cbz	r0, 800403e <HAL_SD_WriteBlocks+0x7e>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 800402a:	6823      	ldr	r3, [r4, #0]
 800402c:	4a4c      	ldr	r2, [pc, #304]	; (8004160 <HAL_SD_WriteBlocks+0x1a0>)
 800402e:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= errorstate;
 8004030:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004032:	4318      	orrs	r0, r3
 8004034:	63a0      	str	r0, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8004036:	2001      	movs	r0, #1
 8004038:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      return HAL_ERROR;
 800403c:	e7e3      	b.n	8004006 <HAL_SD_WriteBlocks+0x46>
    config.DataTimeOut   = SDMMC_DATATIMEOUT;
 800403e:	f04f 33ff 	mov.w	r3, #4294967295
 8004042:	9302      	str	r3, [sp, #8]
    config.DataLength    = NumberOfBlocks * BLOCKSIZE;
 8004044:	027b      	lsls	r3, r7, #9
 8004046:	9303      	str	r3, [sp, #12]
    config.DataBlockSize = SDMMC_DATABLOCK_SIZE_512B;
 8004048:	2390      	movs	r3, #144	; 0x90
 800404a:	9304      	str	r3, [sp, #16]
    config.TransferDir   = SDMMC_TRANSFER_DIR_TO_CARD;
 800404c:	9005      	str	r0, [sp, #20]
    config.TransferMode  = SDMMC_TRANSFER_MODE_BLOCK;
 800404e:	9006      	str	r0, [sp, #24]
    config.DPSM          = SDMMC_DPSM_ENABLE;
 8004050:	2301      	movs	r3, #1
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 8004052:	a902      	add	r1, sp, #8
 8004054:	6820      	ldr	r0, [r4, #0]
    config.DPSM          = SDMMC_DPSM_ENABLE;
 8004056:	9307      	str	r3, [sp, #28]
    (void)SDMMC_ConfigData(hsd->Instance, &config);
 8004058:	f001 f863 	bl	8005122 <SDMMC_ConfigData>
    if(NumberOfBlocks > 1U)
 800405c:	2f01      	cmp	r7, #1
 800405e:	d913      	bls.n	8004088 <HAL_SD_WriteBlocks+0xc8>
      hsd->Context = SD_CONTEXT_WRITE_MULTIPLE_BLOCK;
 8004060:	2320      	movs	r3, #32
 8004062:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteMultiBlock(hsd->Instance, add);
 8004064:	4649      	mov	r1, r9
 8004066:	6820      	ldr	r0, [r4, #0]
 8004068:	f001 f8cd 	bl	8005206 <SDMMC_CmdWriteMultiBlock>
    if(errorstate != HAL_SD_ERROR_NONE)
 800406c:	2800      	cmp	r0, #0
 800406e:	d031      	beq.n	80040d4 <HAL_SD_WriteBlocks+0x114>
          __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 8004070:	6823      	ldr	r3, [r4, #0]
 8004072:	4a3b      	ldr	r2, [pc, #236]	; (8004160 <HAL_SD_WriteBlocks+0x1a0>)
 8004074:	639a      	str	r2, [r3, #56]	; 0x38
          hsd->ErrorCode |= errorstate;
 8004076:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004078:	4318      	orrs	r0, r3
 800407a:	63a0      	str	r0, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800407c:	2001      	movs	r0, #1
      hsd->Context = SD_CONTEXT_NONE;
 800407e:	2300      	movs	r3, #0
      hsd->State = HAL_SD_STATE_READY;
 8004080:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8004084:	6323      	str	r3, [r4, #48]	; 0x30
      return HAL_ERROR;
 8004086:	e7be      	b.n	8004006 <HAL_SD_WriteBlocks+0x46>
      hsd->Context = SD_CONTEXT_WRITE_SINGLE_BLOCK;
 8004088:	2310      	movs	r3, #16
 800408a:	6323      	str	r3, [r4, #48]	; 0x30
      errorstate = SDMMC_CmdWriteSingleBlock(hsd->Instance, add);
 800408c:	4649      	mov	r1, r9
 800408e:	6820      	ldr	r0, [r4, #0]
 8004090:	f001 f8a1 	bl	80051d6 <SDMMC_CmdWriteSingleBlock>
 8004094:	e7ea      	b.n	800406c <HAL_SD_WriteBlocks+0xac>
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE))
 8004096:	045a      	lsls	r2, r3, #17
 8004098:	d50a      	bpl.n	80040b0 <HAL_SD_WriteBlocks+0xf0>
 800409a:	f106 0920 	add.w	r9, r6, #32
          data |= ((uint32_t)(*tempbuff) << 24U);
 800409e:	f856 3b04 	ldr.w	r3, [r6], #4
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 80040a2:	6820      	ldr	r0, [r4, #0]
          data |= ((uint32_t)(*tempbuff) << 24U);
 80040a4:	9301      	str	r3, [sp, #4]
          (void)SDMMC_WriteFIFO(hsd->Instance, &data);
 80040a6:	a901      	add	r1, sp, #4
 80040a8:	f001 f819 	bl	80050de <SDMMC_WriteFIFO>
        for(count = 0U; count < 8U; count++)
 80040ac:	45b1      	cmp	r9, r6
 80040ae:	d1f6      	bne.n	800409e <HAL_SD_WriteBlocks+0xde>
      if(((HAL_GetTick()-tickstart) >=  Timeout) || (Timeout == 0U))
 80040b0:	f7fc feee 	bl	8000e90 <HAL_GetTick>
 80040b4:	eba0 0008 	sub.w	r0, r0, r8
 80040b8:	42a8      	cmp	r0, r5
 80040ba:	d30b      	bcc.n	80040d4 <HAL_SD_WriteBlocks+0x114>
        __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);  
 80040bc:	6823      	ldr	r3, [r4, #0]
 80040be:	4a28      	ldr	r2, [pc, #160]	; (8004160 <HAL_SD_WriteBlocks+0x1a0>)
 80040c0:	639a      	str	r2, [r3, #56]	; 0x38
        hsd->ErrorCode |= errorstate;
 80040c2:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80040c4:	63a3      	str	r3, [r4, #56]	; 0x38
        hsd->State = HAL_SD_STATE_READY;
 80040c6:	2301      	movs	r3, #1
 80040c8:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
        hsd->Context = SD_CONTEXT_NONE;
 80040cc:	2300      	movs	r3, #0
 80040ce:	6323      	str	r3, [r4, #48]	; 0x30
        return HAL_TIMEOUT;
 80040d0:	2003      	movs	r0, #3
 80040d2:	e798      	b.n	8004006 <HAL_SD_WriteBlocks+0x46>
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 80040d4:	6820      	ldr	r0, [r4, #0]
 80040d6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 80040d8:	f413 7f8d 	tst.w	r3, #282	; 0x11a
      if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXFIFOHE))
 80040dc:	6b43      	ldr	r3, [r0, #52]	; 0x34
    while(!__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR | SDMMC_FLAG_DCRCFAIL | SDMMC_FLAG_DTIMEOUT | SDMMC_FLAG_DATAEND))
 80040de:	d0da      	beq.n	8004096 <HAL_SD_WriteBlocks+0xd6>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DATAEND) && (NumberOfBlocks > 1U))
 80040e0:	05db      	lsls	r3, r3, #23
 80040e2:	d508      	bpl.n	80040f6 <HAL_SD_WriteBlocks+0x136>
 80040e4:	2f01      	cmp	r7, #1
 80040e6:	d906      	bls.n	80040f6 <HAL_SD_WriteBlocks+0x136>
      if(hsd->SdCard.CardType != CARD_SECURED)
 80040e8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80040ea:	2b03      	cmp	r3, #3
 80040ec:	d003      	beq.n	80040f6 <HAL_SD_WriteBlocks+0x136>
        errorstate = SDMMC_CmdStopTransfer(hsd->Instance);
 80040ee:	f001 f8a3 	bl	8005238 <SDMMC_CmdStopTransfer>
        if(errorstate != HAL_SD_ERROR_NONE)
 80040f2:	2800      	cmp	r0, #0
 80040f4:	d1bc      	bne.n	8004070 <HAL_SD_WriteBlocks+0xb0>
    if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DTIMEOUT))
 80040f6:	6823      	ldr	r3, [r4, #0]
 80040f8:	6b59      	ldr	r1, [r3, #52]	; 0x34
 80040fa:	f011 0108 	ands.w	r1, r1, #8
 80040fe:	d006      	beq.n	800410e <HAL_SD_WriteBlocks+0x14e>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8004100:	4a17      	ldr	r2, [pc, #92]	; (8004160 <HAL_SD_WriteBlocks+0x1a0>)
 8004102:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_TIMEOUT;
 8004104:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004106:	f043 0308 	orr.w	r3, r3, #8
 800410a:	63a3      	str	r3, [r4, #56]	; 0x38
 800410c:	e7b6      	b.n	800407c <HAL_SD_WriteBlocks+0xbc>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_DCRCFAIL))
 800410e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8004110:	f012 0202 	ands.w	r2, r2, #2
 8004114:	d00a      	beq.n	800412c <HAL_SD_WriteBlocks+0x16c>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8004116:	4a12      	ldr	r2, [pc, #72]	; (8004160 <HAL_SD_WriteBlocks+0x1a0>)
 8004118:	639a      	str	r2, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800411a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800411c:	2001      	movs	r0, #1
      hsd->ErrorCode |= HAL_SD_ERROR_DATA_CRC_FAIL;
 800411e:	f043 0302 	orr.w	r3, r3, #2
 8004122:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8004124:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8004128:	6321      	str	r1, [r4, #48]	; 0x30
      return HAL_ERROR;
 800412a:	e76c      	b.n	8004006 <HAL_SD_WriteBlocks+0x46>
    else if(__HAL_SD_GET_FLAG(hsd, SDMMC_FLAG_TXUNDERR))
 800412c:	6b58      	ldr	r0, [r3, #52]	; 0x34
 800412e:	f010 0010 	ands.w	r0, r0, #16
 8004132:	d00a      	beq.n	800414a <HAL_SD_WriteBlocks+0x18a>
      __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);
 8004134:	490a      	ldr	r1, [pc, #40]	; (8004160 <HAL_SD_WriteBlocks+0x1a0>)
 8004136:	6399      	str	r1, [r3, #56]	; 0x38
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 8004138:	6ba3      	ldr	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 800413a:	2001      	movs	r0, #1
      hsd->ErrorCode |= HAL_SD_ERROR_TX_UNDERRUN;
 800413c:	f043 0310 	orr.w	r3, r3, #16
 8004140:	63a3      	str	r3, [r4, #56]	; 0x38
      hsd->State = HAL_SD_STATE_READY;
 8004142:	f884 0034 	strb.w	r0, [r4, #52]	; 0x34
      hsd->Context = SD_CONTEXT_NONE;
 8004146:	6322      	str	r2, [r4, #48]	; 0x30
      return HAL_ERROR;
 8004148:	e75d      	b.n	8004006 <HAL_SD_WriteBlocks+0x46>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_DATA_FLAGS);
 800414a:	f240 523a 	movw	r2, #1338	; 0x53a
 800414e:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 8004150:	2301      	movs	r3, #1
 8004152:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
    return HAL_OK;
 8004156:	e756      	b.n	8004006 <HAL_SD_WriteBlocks+0x46>
    hsd->ErrorCode |= HAL_SD_ERROR_BUSY;
 8004158:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800415a:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800415e:	e73e      	b.n	8003fde <HAL_SD_WriteBlocks+0x1e>
 8004160:	004005ff 	.word	0x004005ff

08004164 <HAL_SD_GetCardCSD>:
  *         contains all CSD register parameters  
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_SD_GetCardCSD(SD_HandleTypeDef *hsd, HAL_SD_CardCSDTypedef *pCSD)
{
  pCSD->CSDStruct = (uint8_t)((hsd->CSD[0] & 0xC0000000U) >> 30U);
 8004164:	6e43      	ldr	r3, [r0, #100]	; 0x64
 8004166:	0f9a      	lsrs	r2, r3, #30
 8004168:	700a      	strb	r2, [r1, #0]

  pCSD->SysSpecVersion = (uint8_t)((hsd->CSD[0] & 0x3C000000U) >> 26U);
 800416a:	f3c3 6283 	ubfx	r2, r3, #26, #4
 800416e:	704a      	strb	r2, [r1, #1]

  pCSD->Reserved1 = (uint8_t)((hsd->CSD[0] & 0x03000000U) >> 24U);
 8004170:	f3c3 6201 	ubfx	r2, r3, #24, #2
 8004174:	708a      	strb	r2, [r1, #2]
  
  pCSD->TAAC = (uint8_t)((hsd->CSD[0] & 0x00FF0000U) >> 16U);
 8004176:	f3c3 4207 	ubfx	r2, r3, #16, #8
 800417a:	70ca      	strb	r2, [r1, #3]
  
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 800417c:	f3c3 2207 	ubfx	r2, r3, #8, #8
  
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 8004180:	b2db      	uxtb	r3, r3
  pCSD->NSAC = (uint8_t)((hsd->CSD[0] & 0x0000FF00U) >> 8U);
 8004182:	710a      	strb	r2, [r1, #4]
  pCSD->MaxBusClkFrec = (uint8_t)(hsd->CSD[0] & 0x000000FFU);
 8004184:	714b      	strb	r3, [r1, #5]
  
  pCSD->CardComdClasses = (uint16_t)((hsd->CSD[1] & 0xFFF00000U) >> 20U);
 8004186:	6e83      	ldr	r3, [r0, #104]	; 0x68
 8004188:	0d1a      	lsrs	r2, r3, #20
 800418a:	80ca      	strh	r2, [r1, #6]
  
  pCSD->RdBlockLen = (uint8_t)((hsd->CSD[1] & 0x000F0000U) >> 16U);
 800418c:	f3c3 4203 	ubfx	r2, r3, #16, #4
 8004190:	720a      	strb	r2, [r1, #8]
  
  pCSD->PartBlockRead   = (uint8_t)((hsd->CSD[1] & 0x00008000U) >> 15U);
 8004192:	f3c3 32c0 	ubfx	r2, r3, #15, #1
 8004196:	724a      	strb	r2, [r1, #9]

  pCSD->WrBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00004000U) >> 14U);
 8004198:	f3c3 3280 	ubfx	r2, r3, #14, #1
 800419c:	728a      	strb	r2, [r1, #10]

  pCSD->RdBlockMisalign = (uint8_t)((hsd->CSD[1] & 0x00002000U) >> 13U);
 800419e:	f3c3 3240 	ubfx	r2, r3, #13, #1
 80041a2:	72ca      	strb	r2, [r1, #11]

  pCSD->DSRImpl = (uint8_t)((hsd->CSD[1] & 0x00001000U) >> 12U);
 80041a4:	f3c3 3200 	ubfx	r2, r3, #12, #1
 80041a8:	730a      	strb	r2, [r1, #12]

  pCSD->Reserved2 = 0U; /*!< Reserved */
 80041aa:	2200      	movs	r2, #0
 80041ac:	734a      	strb	r2, [r1, #13]
  
  if(hsd->SdCard.CardType == CARD_SDSC)
 80041ae:	6c42      	ldr	r2, [r0, #68]	; 0x44
{
 80041b0:	b510      	push	{r4, lr}
  if(hsd->SdCard.CardType == CARD_SDSC)
 80041b2:	2a00      	cmp	r2, #0
 80041b4:	d16b      	bne.n	800428e <HAL_SD_GetCardCSD+0x12a>
  {
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x000003FFU) << 2U) | ((hsd->CSD[2] & 0xC0000000U) >> 30U));
 80041b6:	6ec2      	ldr	r2, [r0, #108]	; 0x6c
 80041b8:	f640 74fc 	movw	r4, #4092	; 0xffc
 80041bc:	ea04 0383 	and.w	r3, r4, r3, lsl #2
 80041c0:	ea43 7392 	orr.w	r3, r3, r2, lsr #30
 80041c4:	610b      	str	r3, [r1, #16]
    
    pCSD->MaxRdCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x38000000U) >> 27U);
 80041c6:	f3c2 63c2 	ubfx	r3, r2, #27, #3
 80041ca:	750b      	strb	r3, [r1, #20]

    pCSD->MaxRdCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x07000000U) >> 24U);
 80041cc:	f3c2 6302 	ubfx	r3, r2, #24, #3
 80041d0:	754b      	strb	r3, [r1, #21]
    
    pCSD->MaxWrCurrentVDDMin = (uint8_t)((hsd->CSD[2] & 0x00E00000U) >> 21U);
 80041d2:	f3c2 5342 	ubfx	r3, r2, #21, #3
 80041d6:	758b      	strb	r3, [r1, #22]

    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 80041d8:	f3c2 4382 	ubfx	r3, r2, #18, #3

    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 80041dc:	f3c2 32c2 	ubfx	r2, r2, #15, #3
    pCSD->MaxWrCurrentVDDMax = (uint8_t)((hsd->CSD[2] & 0x001C0000U) >> 18U);
 80041e0:	75cb      	strb	r3, [r1, #23]
    pCSD->DeviceSizeMul = (uint8_t)((hsd->CSD[2] & 0x00038000U) >> 15U);
 80041e2:	760a      	strb	r2, [r1, #24]
    
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 80041e4:	690b      	ldr	r3, [r1, #16]
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 80041e6:	7e0a      	ldrb	r2, [r1, #24]
 80041e8:	f002 0207 	and.w	r2, r2, #7
 80041ec:	3202      	adds	r2, #2
    hsd->SdCard.BlockNbr  = (pCSD->DeviceSize + 1U) ;
 80041ee:	3301      	adds	r3, #1
    hsd->SdCard.BlockNbr *= (1UL << ((pCSD->DeviceSizeMul & 0x07U) + 2U));
 80041f0:	4093      	lsls	r3, r2
 80041f2:	6543      	str	r3, [r0, #84]	; 0x54
    hsd->SdCard.BlockSize = (1UL << (pCSD->RdBlockLen & 0x0FU));
 80041f4:	7a0a      	ldrb	r2, [r1, #8]
 80041f6:	f002 040f 	and.w	r4, r2, #15
 80041fa:	2201      	movs	r2, #1
 80041fc:	40a2      	lsls	r2, r4
 80041fe:	6582      	str	r2, [r0, #88]	; 0x58

    hsd->SdCard.LogBlockNbr =  (hsd->SdCard.BlockNbr) * ((hsd->SdCard.BlockSize) / 512U); 
 8004200:	0a52      	lsrs	r2, r2, #9
 8004202:	4353      	muls	r3, r2
 8004204:	65c3      	str	r3, [r0, #92]	; 0x5c
    hsd->SdCard.LogBlockSize = 512U;
 8004206:	f44f 7300 	mov.w	r3, #512	; 0x200
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));

    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
    hsd->SdCard.BlockSize = 512U;
    hsd->SdCard.LogBlockSize = hsd->SdCard.BlockSize;
 800420a:	6603      	str	r3, [r0, #96]	; 0x60
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
    hsd->State = HAL_SD_STATE_READY;
    return HAL_ERROR;
  }
  
  pCSD->EraseGrSize = (uint8_t)((hsd->CSD[2] & 0x00004000U) >> 14U);
 800420c:	6ec3      	ldr	r3, [r0, #108]	; 0x6c
 800420e:	f3c3 3280 	ubfx	r2, r3, #14, #1
 8004212:	764a      	strb	r2, [r1, #25]

  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 8004214:	f3c3 12c6 	ubfx	r2, r3, #7, #7
  
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 8004218:	f003 037f 	and.w	r3, r3, #127	; 0x7f
  pCSD->EraseGrMul = (uint8_t)((hsd->CSD[2] & 0x00003F80U) >> 7U);
 800421c:	768a      	strb	r2, [r1, #26]
  pCSD->WrProtectGrSize = (uint8_t)(hsd->CSD[2] & 0x0000007FU);
 800421e:	76cb      	strb	r3, [r1, #27]
  
  pCSD->WrProtectGrEnable = (uint8_t)((hsd->CSD[3] & 0x80000000U) >> 31U);
 8004220:	6f03      	ldr	r3, [r0, #112]	; 0x70
 8004222:	0fda      	lsrs	r2, r3, #31
 8004224:	770a      	strb	r2, [r1, #28]

  pCSD->ManDeflECC = (uint8_t)((hsd->CSD[3] & 0x60000000U) >> 29U);
 8004226:	f3c3 7241 	ubfx	r2, r3, #29, #2
 800422a:	774a      	strb	r2, [r1, #29]

  pCSD->WrSpeedFact = (uint8_t)((hsd->CSD[3] & 0x1C000000U) >> 26U);
 800422c:	f3c3 6282 	ubfx	r2, r3, #26, #3
 8004230:	778a      	strb	r2, [r1, #30]

  pCSD->MaxWrBlockLen= (uint8_t)((hsd->CSD[3] & 0x03C00000U) >> 22U);
 8004232:	f3c3 5283 	ubfx	r2, r3, #22, #4
 8004236:	77ca      	strb	r2, [r1, #31]
  
  pCSD->WriteBlockPaPartial = (uint8_t)((hsd->CSD[3] & 0x00200000U) >> 21U);
 8004238:	f3c3 5240 	ubfx	r2, r3, #21, #1
 800423c:	f881 2020 	strb.w	r2, [r1, #32]

  pCSD->Reserved3 = 0;
 8004240:	2000      	movs	r0, #0

  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 8004242:	f3c3 4200 	ubfx	r2, r3, #16, #1
  pCSD->Reserved3 = 0;
 8004246:	f881 0021 	strb.w	r0, [r1, #33]	; 0x21
  pCSD->ContentProtectAppli = (uint8_t)((hsd->CSD[3] & 0x00010000U) >> 16U);
 800424a:	f881 2022 	strb.w	r2, [r1, #34]	; 0x22
  
  pCSD->FileFormatGroup = (uint8_t)((hsd->CSD[3] & 0x00008000U) >> 15U);
 800424e:	f3c3 32c0 	ubfx	r2, r3, #15, #1
 8004252:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23

  pCSD->CopyFlag = (uint8_t)((hsd->CSD[3] & 0x00004000U) >> 14U);
 8004256:	f3c3 3280 	ubfx	r2, r3, #14, #1
 800425a:	f881 2024 	strb.w	r2, [r1, #36]	; 0x24

  pCSD->PermWrProtect = (uint8_t)((hsd->CSD[3] & 0x00002000U) >> 13U);
 800425e:	f3c3 3240 	ubfx	r2, r3, #13, #1
 8004262:	f881 2025 	strb.w	r2, [r1, #37]	; 0x25

  pCSD->TempWrProtect = (uint8_t)((hsd->CSD[3] & 0x00001000U) >> 12U);
 8004266:	f3c3 3200 	ubfx	r2, r3, #12, #1
 800426a:	f881 2026 	strb.w	r2, [r1, #38]	; 0x26

  pCSD->FileFormat = (uint8_t)((hsd->CSD[3] & 0x00000C00U) >> 10U);
 800426e:	f3c3 2281 	ubfx	r2, r3, #10, #2
 8004272:	f881 2027 	strb.w	r2, [r1, #39]	; 0x27

  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 8004276:	f3c3 2201 	ubfx	r2, r3, #8, #2
  
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 800427a:	f3c3 0346 	ubfx	r3, r3, #1, #7
  pCSD->ECC= (uint8_t)((hsd->CSD[3] & 0x00000300U) >> 8U);
 800427e:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
  pCSD->CSD_CRC = (uint8_t)((hsd->CSD[3] & 0x000000FEU) >> 1U);
 8004282:	f881 3029 	strb.w	r3, [r1, #41]	; 0x29

  pCSD->Reserved4 = 1;
 8004286:	2301      	movs	r3, #1
 8004288:	f881 302a 	strb.w	r3, [r1, #42]	; 0x2a
  
  return HAL_OK;
}
 800428c:	bd10      	pop	{r4, pc}
  else if(hsd->SdCard.CardType == CARD_SDHC_SDXC)
 800428e:	2a01      	cmp	r2, #1
 8004290:	d10f      	bne.n	80042b2 <HAL_SD_GetCardCSD+0x14e>
    pCSD->DeviceSize = (((hsd->CSD[1] & 0x0000003FU) << 16U) | ((hsd->CSD[2] & 0xFFFF0000U) >> 16U));
 8004292:	f8b0 206e 	ldrh.w	r2, [r0, #110]	; 0x6e
 8004296:	041b      	lsls	r3, r3, #16
 8004298:	f403 137c 	and.w	r3, r3, #4128768	; 0x3f0000
 800429c:	4313      	orrs	r3, r2
 800429e:	610b      	str	r3, [r1, #16]
    hsd->SdCard.BlockNbr = ((pCSD->DeviceSize + 1U) * 1024U);
 80042a0:	690b      	ldr	r3, [r1, #16]
 80042a2:	3301      	adds	r3, #1
 80042a4:	029b      	lsls	r3, r3, #10
 80042a6:	6543      	str	r3, [r0, #84]	; 0x54
    hsd->SdCard.LogBlockNbr = hsd->SdCard.BlockNbr;
 80042a8:	65c3      	str	r3, [r0, #92]	; 0x5c
    hsd->SdCard.BlockSize = 512U;
 80042aa:	f44f 7300 	mov.w	r3, #512	; 0x200
 80042ae:	6583      	str	r3, [r0, #88]	; 0x58
 80042b0:	e7ab      	b.n	800420a <HAL_SD_GetCardCSD+0xa6>
    __HAL_SD_CLEAR_FLAG(hsd, SDMMC_STATIC_FLAGS);   
 80042b2:	6803      	ldr	r3, [r0, #0]
 80042b4:	4a05      	ldr	r2, [pc, #20]	; (80042cc <HAL_SD_GetCardCSD+0x168>)
 80042b6:	639a      	str	r2, [r3, #56]	; 0x38
    hsd->ErrorCode |= HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80042b8:	6b83      	ldr	r3, [r0, #56]	; 0x38
 80042ba:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80042be:	6383      	str	r3, [r0, #56]	; 0x38
    hsd->State = HAL_SD_STATE_READY;
 80042c0:	2301      	movs	r3, #1
 80042c2:	f880 3034 	strb.w	r3, [r0, #52]	; 0x34
    return HAL_ERROR;
 80042c6:	4618      	mov	r0, r3
 80042c8:	bd10      	pop	{r4, pc}
 80042ca:	bf00      	nop
 80042cc:	004005ff 	.word	0x004005ff

080042d0 <HAL_SD_InitCard>:
{
 80042d0:	b570      	push	{r4, r5, r6, lr}
 80042d2:	b098      	sub	sp, #96	; 0x60
  Init.ClockEdge           = SDMMC_CLOCK_EDGE_RISING;
 80042d4:	2300      	movs	r3, #0
 80042d6:	9307      	str	r3, [sp, #28]
  Init.ClockBypass         = SDMMC_CLOCK_BYPASS_DISABLE;
 80042d8:	9308      	str	r3, [sp, #32]
  Init.ClockPowerSave      = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 80042da:	9309      	str	r3, [sp, #36]	; 0x24
  Init.BusWide             = SDMMC_BUS_WIDE_1B;
 80042dc:	930a      	str	r3, [sp, #40]	; 0x28
  Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 80042de:	930b      	str	r3, [sp, #44]	; 0x2c
  Init.ClockDiv            = SDMMC_INIT_CLK_DIV;
 80042e0:	2376      	movs	r3, #118	; 0x76
 80042e2:	930c      	str	r3, [sp, #48]	; 0x30
  status = SDMMC_Init(hsd->Instance, Init);
 80042e4:	ab0a      	add	r3, sp, #40	; 0x28
{
 80042e6:	4604      	mov	r4, r0
  status = SDMMC_Init(hsd->Instance, Init);
 80042e8:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 80042ec:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 80042f0:	ab07      	add	r3, sp, #28
 80042f2:	cb0e      	ldmia	r3, {r1, r2, r3}
 80042f4:	6820      	ldr	r0, [r4, #0]
 80042f6:	f000 fed3 	bl	80050a0 <SDMMC_Init>
  if(status != HAL_OK)
 80042fa:	b118      	cbz	r0, 8004304 <HAL_SD_InitCard+0x34>
    return HAL_ERROR;
 80042fc:	2501      	movs	r5, #1
}
 80042fe:	4628      	mov	r0, r5
 8004300:	b018      	add	sp, #96	; 0x60
 8004302:	bd70      	pop	{r4, r5, r6, pc}
  __HAL_SD_DISABLE(hsd); 
 8004304:	6820      	ldr	r0, [r4, #0]
 8004306:	6843      	ldr	r3, [r0, #4]
 8004308:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 800430c:	6043      	str	r3, [r0, #4]
  status = SDMMC_PowerState_ON(hsd->Instance);
 800430e:	f000 feeb 	bl	80050e8 <SDMMC_PowerState_ON>
  if(status != HAL_OK)
 8004312:	4605      	mov	r5, r0
 8004314:	2800      	cmp	r0, #0
 8004316:	d1f1      	bne.n	80042fc <HAL_SD_InitCard+0x2c>
  __HAL_SD_ENABLE(hsd);
 8004318:	6822      	ldr	r2, [r4, #0]
 800431a:	6853      	ldr	r3, [r2, #4]
 800431c:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8004320:	6053      	str	r3, [r2, #4]
  HAL_Delay(2U);
 8004322:	2002      	movs	r0, #2
 8004324:	f7fc fdba 	bl	8000e9c <HAL_Delay>
#if defined(STM32L4R5xx) || defined(STM32L4R7xx) || defined(STM32L4R9xx) || defined(STM32L4S5xx) || defined(STM32L4S7xx) || defined(STM32L4S9xx)
  uint32_t tickstart = HAL_GetTick();
#endif /* STM32L4R5xx || STM32L4R7xx || STM32L4R9xx || STM32L4S5xx || STM32L4S7xx || STM32L4S9xx */
  
  /* CMD0: GO_IDLE_STATE */
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 8004328:	6820      	ldr	r0, [r4, #0]
  __IO uint32_t count = 0;
 800432a:	9506      	str	r5, [sp, #24]
  errorstate = SDMMC_CmdGoIdleState(hsd->Instance);
 800432c:	f000 ffb6 	bl	800529c <SDMMC_CmdGoIdleState>
  if(errorstate != HAL_SD_ERROR_NONE)
 8004330:	4606      	mov	r6, r0
 8004332:	b970      	cbnz	r0, 8004352 <HAL_SD_InitCard+0x82>
  {
    return errorstate;
  }
  
  /* CMD8: SEND_IF_COND: Command available only on V2.0 cards */
  errorstate = SDMMC_CmdOperCond(hsd->Instance);
 8004334:	6820      	ldr	r0, [r4, #0]
 8004336:	f000 ffd9 	bl	80052ec <SDMMC_CmdOperCond>
  if(errorstate != HAL_SD_ERROR_NONE)
 800433a:	2800      	cmp	r0, #0
 800433c:	d073      	beq.n	8004426 <HAL_SD_InitCard+0x156>
  {
    hsd->SdCard.CardVersion = CARD_V1_X;
 800433e:	64a6      	str	r6, [r4, #72]	; 0x48
      
#if !defined(STM32L4R5xx) && !defined(STM32L4R7xx) && !defined(STM32L4R9xx) && !defined(STM32L4S5xx) && !defined(STM32L4S7xx) && !defined(STM32L4S9xx)
    /* Send ACMD41 SD_APP_OP_COND with Argument 0x80100000 */
    while(validvoltage == 0U)
    {
      if(count++ == SDMMC_MAX_VOLT_TRIAL)
 8004340:	f64f 75ff 	movw	r5, #65535	; 0xffff
 8004344:	9b06      	ldr	r3, [sp, #24]
 8004346:	1c5a      	adds	r2, r3, #1
 8004348:	42ab      	cmp	r3, r5
 800434a:	9206      	str	r2, [sp, #24]
 800434c:	d108      	bne.n	8004360 <HAL_SD_InitCard+0x90>
      {
        return HAL_SD_ERROR_INVALID_VOLTRANGE;
 800434e:	f04f 7680 	mov.w	r6, #16777216	; 0x1000000
    hsd->State = HAL_SD_STATE_READY;
 8004352:	2501      	movs	r5, #1
 8004354:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 8004358:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 800435a:	430e      	orrs	r6, r1
 800435c:	63a6      	str	r6, [r4, #56]	; 0x38
 800435e:	e7ce      	b.n	80042fe <HAL_SD_InitCard+0x2e>
      }
      
      /* SEND CMD55 APP_CMD with RCA as 0 */
      errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8004360:	2100      	movs	r1, #0
 8004362:	6820      	ldr	r0, [r4, #0]
 8004364:	f000 fffe 	bl	8005364 <SDMMC_CmdAppCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 8004368:	4601      	mov	r1, r0
 800436a:	b110      	cbz	r0, 8004372 <HAL_SD_InitCard+0xa2>
      {
        return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 800436c:	f04f 5680 	mov.w	r6, #268435456	; 0x10000000
 8004370:	e7ef      	b.n	8004352 <HAL_SD_InitCard+0x82>
      }
      
      /* Send CMD41 */
      errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_STD_CAPACITY);
 8004372:	6820      	ldr	r0, [r4, #0]
 8004374:	f001 f80e 	bl	8005394 <SDMMC_CmdAppOperCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 8004378:	4601      	mov	r1, r0
 800437a:	2800      	cmp	r0, #0
 800437c:	d1f6      	bne.n	800436c <HAL_SD_InitCard+0x9c>
      {
        return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
      }
      
      /* Get command response */
      response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800437e:	6820      	ldr	r0, [r4, #0]
 8004380:	f000 fecc 	bl	800511c <SDMMC_GetResponse>
    while(validvoltage == 0U)
 8004384:	2800      	cmp	r0, #0
 8004386:	dadd      	bge.n	8004344 <HAL_SD_InitCard+0x74>
      
      /* Get operating voltage*/
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
    }
    /* Card type is SDSC */
    hsd->SdCard.CardType = CARD_SDSC;
 8004388:	2300      	movs	r3, #0
      validvoltage = (((response >> 31U) == 1U) ? 1U : 0U);
    }
    
    if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
    {
      hsd->SdCard.CardType = CARD_SDHC_SDXC;
 800438a:	6463      	str	r3, [r4, #68]	; 0x44
  if(SDMMC_GetPowerState(hsd->Instance) == 0U) 
 800438c:	6820      	ldr	r0, [r4, #0]
  uint16_t sd_rca = 1;
 800438e:	2301      	movs	r3, #1
 8004390:	f8ad 3016 	strh.w	r3, [sp, #22]
  if(SDMMC_GetPowerState(hsd->Instance) == 0U) 
 8004394:	f000 feac 	bl	80050f0 <SDMMC_GetPowerState>
 8004398:	2800      	cmp	r0, #0
 800439a:	f000 8095 	beq.w	80044c8 <HAL_SD_InitCard+0x1f8>
  if(hsd->SdCard.CardType != CARD_SECURED) 
 800439e:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80043a0:	2b03      	cmp	r3, #3
 80043a2:	d019      	beq.n	80043d8 <HAL_SD_InitCard+0x108>
    errorstate = SDMMC_CmdSendCID(hsd->Instance);
 80043a4:	6820      	ldr	r0, [r4, #0]
 80043a6:	f001 f80e 	bl	80053c6 <SDMMC_CmdSendCID>
    if(errorstate != HAL_SD_ERROR_NONE)
 80043aa:	2800      	cmp	r0, #0
 80043ac:	d164      	bne.n	8004478 <HAL_SD_InitCard+0x1a8>
      hsd->CID[0] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80043ae:	4601      	mov	r1, r0
 80043b0:	6820      	ldr	r0, [r4, #0]
 80043b2:	f000 feb3 	bl	800511c <SDMMC_GetResponse>
      hsd->CID[1] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80043b6:	2104      	movs	r1, #4
      hsd->CID[0] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80043b8:	6760      	str	r0, [r4, #116]	; 0x74
      hsd->CID[1] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80043ba:	6820      	ldr	r0, [r4, #0]
 80043bc:	f000 feae 	bl	800511c <SDMMC_GetResponse>
      hsd->CID[2] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80043c0:	2108      	movs	r1, #8
      hsd->CID[1] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80043c2:	67a0      	str	r0, [r4, #120]	; 0x78
      hsd->CID[2] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80043c4:	6820      	ldr	r0, [r4, #0]
 80043c6:	f000 fea9 	bl	800511c <SDMMC_GetResponse>
      hsd->CID[3] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80043ca:	210c      	movs	r1, #12
      hsd->CID[2] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80043cc:	67e0      	str	r0, [r4, #124]	; 0x7c
      hsd->CID[3] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80043ce:	6820      	ldr	r0, [r4, #0]
 80043d0:	f000 fea4 	bl	800511c <SDMMC_GetResponse>
 80043d4:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80
  if(hsd->SdCard.CardType != CARD_SECURED) 
 80043d8:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80043da:	2b03      	cmp	r3, #3
 80043dc:	d145      	bne.n	800446a <HAL_SD_InitCard+0x19a>
  if(hsd->SdCard.CardType != CARD_SECURED) 
 80043de:	6c63      	ldr	r3, [r4, #68]	; 0x44
 80043e0:	2b03      	cmp	r3, #3
 80043e2:	d150      	bne.n	8004486 <HAL_SD_InitCard+0x1b6>
  hsd->SdCard.Class = (SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2) >> 20);
 80043e4:	2104      	movs	r1, #4
 80043e6:	6820      	ldr	r0, [r4, #0]
 80043e8:	f000 fe98 	bl	800511c <SDMMC_GetResponse>
 80043ec:	0d00      	lsrs	r0, r0, #20
 80043ee:	64e0      	str	r0, [r4, #76]	; 0x4c
  if (HAL_SD_GetCardCSD(hsd, &CSD) != HAL_OK)
 80043f0:	a90d      	add	r1, sp, #52	; 0x34
 80043f2:	4620      	mov	r0, r4
 80043f4:	f7ff feb6 	bl	8004164 <HAL_SD_GetCardCSD>
 80043f8:	4605      	mov	r5, r0
 80043fa:	2800      	cmp	r0, #0
 80043fc:	d161      	bne.n	80044c2 <HAL_SD_InitCard+0x1f2>
  errorstate = SDMMC_CmdSelDesel(hsd->Instance, (uint32_t)(((uint32_t)hsd->SdCard.RelCardAdd) << 16));
 80043fe:	6d22      	ldr	r2, [r4, #80]	; 0x50
 8004400:	4603      	mov	r3, r0
 8004402:	0412      	lsls	r2, r2, #16
 8004404:	6820      	ldr	r0, [r4, #0]
 8004406:	f000 ff31 	bl	800526c <SDMMC_CmdSelDesel>
  if(errorstate != HAL_SD_ERROR_NONE)
 800440a:	2800      	cmp	r0, #0
 800440c:	d134      	bne.n	8004478 <HAL_SD_InitCard+0x1a8>
  (void)SDMMC_Init(hsd->Instance, hsd->Init);
 800440e:	f104 0310 	add.w	r3, r4, #16
 8004412:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 8004416:	e88d 0007 	stmia.w	sp, {r0, r1, r2}
 800441a:	1d23      	adds	r3, r4, #4
 800441c:	cb0e      	ldmia	r3, {r1, r2, r3}
 800441e:	6820      	ldr	r0, [r4, #0]
 8004420:	f000 fe3e 	bl	80050a0 <SDMMC_Init>
 8004424:	e76b      	b.n	80042fe <HAL_SD_InitCard+0x2e>
    hsd->SdCard.CardVersion = CARD_V2_X;
 8004426:	2301      	movs	r3, #1
 8004428:	64a3      	str	r3, [r4, #72]	; 0x48
      if(count++ == SDMMC_MAX_VOLT_TRIAL)
 800442a:	f64f 75ff 	movw	r5, #65535	; 0xffff
 800442e:	9b06      	ldr	r3, [sp, #24]
 8004430:	1c5a      	adds	r2, r3, #1
 8004432:	42ab      	cmp	r3, r5
 8004434:	9206      	str	r2, [sp, #24]
 8004436:	d08a      	beq.n	800434e <HAL_SD_InitCard+0x7e>
      errorstate = SDMMC_CmdAppCommand(hsd->Instance, 0);
 8004438:	2100      	movs	r1, #0
 800443a:	6820      	ldr	r0, [r4, #0]
 800443c:	f000 ff92 	bl	8005364 <SDMMC_CmdAppCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 8004440:	4606      	mov	r6, r0
 8004442:	2800      	cmp	r0, #0
 8004444:	d185      	bne.n	8004352 <HAL_SD_InitCard+0x82>
      errorstate = SDMMC_CmdAppOperCommand(hsd->Instance, SDMMC_HIGH_CAPACITY);
 8004446:	f04f 4180 	mov.w	r1, #1073741824	; 0x40000000
 800444a:	6820      	ldr	r0, [r4, #0]
 800444c:	f000 ffa2 	bl	8005394 <SDMMC_CmdAppOperCommand>
      if(errorstate != HAL_SD_ERROR_NONE)
 8004450:	4606      	mov	r6, r0
 8004452:	2800      	cmp	r0, #0
 8004454:	f47f af7d 	bne.w	8004352 <HAL_SD_InitCard+0x82>
      response = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8004458:	4601      	mov	r1, r0
 800445a:	6820      	ldr	r0, [r4, #0]
 800445c:	f000 fe5e 	bl	800511c <SDMMC_GetResponse>
    while(validvoltage == 0U)
 8004460:	0fc3      	lsrs	r3, r0, #31
 8004462:	d0e4      	beq.n	800442e <HAL_SD_InitCard+0x15e>
    if((response & SDMMC_HIGH_CAPACITY) == SDMMC_HIGH_CAPACITY) /* (response &= SD_HIGH_CAPACITY) */
 8004464:	0042      	lsls	r2, r0, #1
 8004466:	d58f      	bpl.n	8004388 <HAL_SD_InitCard+0xb8>
 8004468:	e78f      	b.n	800438a <HAL_SD_InitCard+0xba>
    errorstate = SDMMC_CmdSetRelAdd(hsd->Instance, &sd_rca);
 800446a:	f10d 0116 	add.w	r1, sp, #22
 800446e:	6820      	ldr	r0, [r4, #0]
 8004470:	f000 ffd4 	bl	800541c <SDMMC_CmdSetRelAdd>
    if(errorstate != HAL_SD_ERROR_NONE)
 8004474:	2800      	cmp	r0, #0
 8004476:	d0b2      	beq.n	80043de <HAL_SD_InitCard+0x10e>
    hsd->State = HAL_SD_STATE_READY;
 8004478:	2501      	movs	r5, #1
 800447a:	f884 5034 	strb.w	r5, [r4, #52]	; 0x34
    hsd->ErrorCode |= errorstate;
 800447e:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 8004480:	4308      	orrs	r0, r1
 8004482:	63a0      	str	r0, [r4, #56]	; 0x38
 8004484:	e73b      	b.n	80042fe <HAL_SD_InitCard+0x2e>
    hsd->SdCard.RelCardAdd = sd_rca;
 8004486:	f8bd 1016 	ldrh.w	r1, [sp, #22]
 800448a:	6521      	str	r1, [r4, #80]	; 0x50
    errorstate = SDMMC_CmdSendCSD(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16U));
 800448c:	6820      	ldr	r0, [r4, #0]
 800448e:	0409      	lsls	r1, r1, #16
 8004490:	f000 ffae 	bl	80053f0 <SDMMC_CmdSendCSD>
    if(errorstate != HAL_SD_ERROR_NONE)
 8004494:	2800      	cmp	r0, #0
 8004496:	d1ef      	bne.n	8004478 <HAL_SD_InitCard+0x1a8>
      hsd->CSD[0] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 8004498:	4601      	mov	r1, r0
 800449a:	6820      	ldr	r0, [r4, #0]
 800449c:	f000 fe3e 	bl	800511c <SDMMC_GetResponse>
      hsd->CSD[1] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80044a0:	2104      	movs	r1, #4
      hsd->CSD[0] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 80044a2:	6660      	str	r0, [r4, #100]	; 0x64
      hsd->CSD[1] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80044a4:	6820      	ldr	r0, [r4, #0]
 80044a6:	f000 fe39 	bl	800511c <SDMMC_GetResponse>
      hsd->CSD[2] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80044aa:	2108      	movs	r1, #8
      hsd->CSD[1] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP2);
 80044ac:	66a0      	str	r0, [r4, #104]	; 0x68
      hsd->CSD[2] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80044ae:	6820      	ldr	r0, [r4, #0]
 80044b0:	f000 fe34 	bl	800511c <SDMMC_GetResponse>
      hsd->CSD[3] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80044b4:	210c      	movs	r1, #12
      hsd->CSD[2] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP3);
 80044b6:	66e0      	str	r0, [r4, #108]	; 0x6c
      hsd->CSD[3] = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP4);
 80044b8:	6820      	ldr	r0, [r4, #0]
 80044ba:	f000 fe2f 	bl	800511c <SDMMC_GetResponse>
 80044be:	6720      	str	r0, [r4, #112]	; 0x70
 80044c0:	e790      	b.n	80043e4 <HAL_SD_InitCard+0x114>
    return HAL_SD_ERROR_UNSUPPORTED_FEATURE;
 80044c2:	f04f 5080 	mov.w	r0, #268435456	; 0x10000000
 80044c6:	e7d7      	b.n	8004478 <HAL_SD_InitCard+0x1a8>
    return HAL_SD_ERROR_REQUEST_NOT_APPLICABLE;
 80044c8:	f04f 6080 	mov.w	r0, #67108864	; 0x4000000
 80044cc:	e7d4      	b.n	8004478 <HAL_SD_InitCard+0x1a8>

080044ce <HAL_SD_Init>:
{ 
 80044ce:	b510      	push	{r4, lr}
  if(hsd == NULL)
 80044d0:	4604      	mov	r4, r0
 80044d2:	b908      	cbnz	r0, 80044d8 <HAL_SD_Init+0xa>
    return HAL_ERROR;
 80044d4:	2001      	movs	r0, #1
 80044d6:	bd10      	pop	{r4, pc}
  if(hsd->State == HAL_SD_STATE_RESET)
 80044d8:	f890 3034 	ldrb.w	r3, [r0, #52]	; 0x34
 80044dc:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80044e0:	b913      	cbnz	r3, 80044e8 <HAL_SD_Init+0x1a>
    hsd->Lock = HAL_UNLOCKED;
 80044e2:	7702      	strb	r2, [r0, #28]
    HAL_SD_MspInit(hsd);
 80044e4:	f003 fd5c 	bl	8007fa0 <HAL_SD_MspInit>
  hsd->State = HAL_SD_STATE_BUSY;
 80044e8:	2303      	movs	r3, #3
 80044ea:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
  if (HAL_SD_InitCard(hsd) != HAL_OK)
 80044ee:	4620      	mov	r0, r4
 80044f0:	f7ff feee 	bl	80042d0 <HAL_SD_InitCard>
 80044f4:	2800      	cmp	r0, #0
 80044f6:	d1ed      	bne.n	80044d4 <HAL_SD_Init+0x6>
  hsd->State = HAL_SD_STATE_READY;
 80044f8:	2301      	movs	r3, #1
  hsd->ErrorCode = HAL_SD_ERROR_NONE;
 80044fa:	63a0      	str	r0, [r4, #56]	; 0x38
  hsd->Context = SD_CONTEXT_NONE;
 80044fc:	6320      	str	r0, [r4, #48]	; 0x30
  hsd->State = HAL_SD_STATE_READY;
 80044fe:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}
 8004502:	bd10      	pop	{r4, pc}

08004504 <HAL_SD_GetCardInfo>:
  pCardInfo->CardType     = (uint32_t)(hsd->SdCard.CardType);
 8004504:	6c43      	ldr	r3, [r0, #68]	; 0x44
 8004506:	600b      	str	r3, [r1, #0]
  pCardInfo->CardVersion  = (uint32_t)(hsd->SdCard.CardVersion);
 8004508:	6c83      	ldr	r3, [r0, #72]	; 0x48
 800450a:	604b      	str	r3, [r1, #4]
  pCardInfo->Class        = (uint32_t)(hsd->SdCard.Class);
 800450c:	6cc3      	ldr	r3, [r0, #76]	; 0x4c
 800450e:	608b      	str	r3, [r1, #8]
  pCardInfo->RelCardAdd   = (uint32_t)(hsd->SdCard.RelCardAdd);
 8004510:	6d03      	ldr	r3, [r0, #80]	; 0x50
 8004512:	60cb      	str	r3, [r1, #12]
  pCardInfo->BlockNbr     = (uint32_t)(hsd->SdCard.BlockNbr);
 8004514:	6d43      	ldr	r3, [r0, #84]	; 0x54
 8004516:	610b      	str	r3, [r1, #16]
  pCardInfo->BlockSize    = (uint32_t)(hsd->SdCard.BlockSize);
 8004518:	6d83      	ldr	r3, [r0, #88]	; 0x58
 800451a:	614b      	str	r3, [r1, #20]
  pCardInfo->LogBlockNbr  = (uint32_t)(hsd->SdCard.LogBlockNbr);
 800451c:	6dc3      	ldr	r3, [r0, #92]	; 0x5c
 800451e:	618b      	str	r3, [r1, #24]
  pCardInfo->LogBlockSize = (uint32_t)(hsd->SdCard.LogBlockSize);
 8004520:	6e03      	ldr	r3, [r0, #96]	; 0x60
 8004522:	61cb      	str	r3, [r1, #28]
}
 8004524:	2000      	movs	r0, #0
 8004526:	4770      	bx	lr

08004528 <HAL_SD_GetCardState>:
  {
    return HAL_SD_ERROR_PARAM;
  }
  
  /* Send Status command */
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16));
 8004528:	6d01      	ldr	r1, [r0, #80]	; 0x50
{
 800452a:	b510      	push	{r4, lr}
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16));
 800452c:	0409      	lsls	r1, r1, #16
{
 800452e:	4604      	mov	r4, r0
  errorstate = SDMMC_CmdSendStatus(hsd->Instance, (uint32_t)(hsd->SdCard.RelCardAdd << 16));
 8004530:	6800      	ldr	r0, [r0, #0]
 8004532:	f000 ffc1 	bl	80054b8 <SDMMC_CmdSendStatus>
  if(errorstate != HAL_SD_ERROR_NONE)
 8004536:	4601      	mov	r1, r0
 8004538:	b928      	cbnz	r0, 8004546 <HAL_SD_GetCardState+0x1e>
  {
    return errorstate;
  }
  
  /* Get SD card status */
  *pCardStatus = SDMMC_GetResponse(hsd->Instance, SDMMC_RESP1);
 800453a:	6820      	ldr	r0, [r4, #0]
 800453c:	f000 fdee 	bl	800511c <SDMMC_GetResponse>
  return (HAL_SD_CardStateTypedef)cardstate;
 8004540:	f3c0 2043 	ubfx	r0, r0, #9, #4
}
 8004544:	bd10      	pop	{r4, pc}
    hsd->ErrorCode |= errorstate;
 8004546:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 8004548:	4319      	orrs	r1, r3
 800454a:	63a1      	str	r1, [r4, #56]	; 0x38
  uint32_t resp1 = 0;
 800454c:	2000      	movs	r0, #0
 800454e:	e7f7      	b.n	8004540 <HAL_SD_GetCardState+0x18>

08004550 <HAL_UART_DeInit>:
  * @brief DeInitialize the UART peripheral.
  * @param huart UART handle.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_UART_DeInit(UART_HandleTypeDef *huart)
{
 8004550:	b538      	push	{r3, r4, r5, lr}
  /* Check the UART handle allocation */
  if (huart == NULL)
 8004552:	4605      	mov	r5, r0
 8004554:	b1b0      	cbz	r0, 8004584 <HAL_UART_DeInit+0x34>
  }

  /* Check the parameters */
  assert_param((IS_UART_INSTANCE(huart->Instance)) || (IS_LPUART_INSTANCE(huart->Instance)));

  huart->gState = HAL_UART_STATE_BUSY;
 8004556:	2324      	movs	r3, #36	; 0x24
 8004558:	f880 3071 	strb.w	r3, [r0, #113]	; 0x71

  /* Disable the Peripheral */
  __HAL_UART_DISABLE(huart);
 800455c:	6803      	ldr	r3, [r0, #0]
 800455e:	681a      	ldr	r2, [r3, #0]

  huart->Instance->CR1 = 0x0U;
 8004560:	2400      	movs	r4, #0
  __HAL_UART_DISABLE(huart);
 8004562:	f022 0201 	bic.w	r2, r2, #1
 8004566:	601a      	str	r2, [r3, #0]
  huart->Instance->CR1 = 0x0U;
 8004568:	601c      	str	r4, [r3, #0]
  huart->Instance->CR2 = 0x0U;
 800456a:	605c      	str	r4, [r3, #4]
  huart->Instance->CR3 = 0x0U;
 800456c:	609c      	str	r4, [r3, #8]
  }
  /* DeInit the low level hardware */
  huart->MspDeInitCallback(huart);
#else
  /* DeInit the low level hardware */
  HAL_UART_MspDeInit(huart);
 800456e:	f006 f865 	bl	800a63c <HAL_UART_MspDeInit>
#endif /* (USE_HAL_UART_REGISTER_CALLBACKS) */

  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004572:	676c      	str	r4, [r5, #116]	; 0x74
  huart->gState = HAL_UART_STATE_RESET;
  huart->RxState = HAL_UART_STATE_RESET;

  /* Process Unlock */
  __HAL_UNLOCK(huart);
 8004574:	f885 4070 	strb.w	r4, [r5, #112]	; 0x70
  huart->gState = HAL_UART_STATE_RESET;
 8004578:	f885 4071 	strb.w	r4, [r5, #113]	; 0x71

  return HAL_OK;
 800457c:	4620      	mov	r0, r4
  huart->RxState = HAL_UART_STATE_RESET;
 800457e:	f885 4072 	strb.w	r4, [r5, #114]	; 0x72
  return HAL_OK;
 8004582:	bd38      	pop	{r3, r4, r5, pc}
    return HAL_ERROR;
 8004584:	2001      	movs	r0, #1
}
 8004586:	bd38      	pop	{r3, r4, r5, pc}

08004588 <UART_SetConfig>:
  uint32_t lpuart_ker_ck_pres         = 0x00000000U;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 8004588:	6802      	ldr	r2, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800458a:	69c1      	ldr	r1, [r0, #28]
{
 800458c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800458e:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004590:	6883      	ldr	r3, [r0, #8]
 8004592:	6900      	ldr	r0, [r0, #16]
#if defined(USART_CR1_FIFOEN)
  tmpreg |= (uint32_t)huart->FifoMode;
#endif
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8004594:	6815      	ldr	r5, [r2, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8004596:	4303      	orrs	r3, r0
 8004598:	6960      	ldr	r0, [r4, #20]
 800459a:	4303      	orrs	r3, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 800459c:	48af      	ldr	r0, [pc, #700]	; (800485c <UART_SetConfig+0x2d4>)
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 800459e:	430b      	orrs	r3, r1
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 80045a0:	4028      	ands	r0, r5
 80045a2:	4303      	orrs	r3, r0
 80045a4:	6013      	str	r3, [r2, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 80045a6:	6853      	ldr	r3, [r2, #4]
 80045a8:	68e0      	ldr	r0, [r4, #12]
 80045aa:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 80045ae:	4303      	orrs	r3, r0
 80045b0:	6053      	str	r3, [r2, #4]
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80045b2:	4bab      	ldr	r3, [pc, #684]	; (8004860 <UART_SetConfig+0x2d8>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 80045b4:	69a0      	ldr	r0, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 80045b6:	429a      	cmp	r2, r3
  {
    tmpreg |= huart->Init.OneBitSampling;
 80045b8:	bf1c      	itt	ne
 80045ba:	6a23      	ldrne	r3, [r4, #32]
 80045bc:	4318      	orrne	r0, r3
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 80045be:	6893      	ldr	r3, [r2, #8]
 80045c0:	f423 6330 	bic.w	r3, r3, #2816	; 0xb00
 80045c4:	4303      	orrs	r3, r0
 80045c6:	6093      	str	r3, [r2, #8]
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
#endif

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 80045c8:	4ba6      	ldr	r3, [pc, #664]	; (8004864 <UART_SetConfig+0x2dc>)
 80045ca:	429a      	cmp	r2, r3
 80045cc:	d118      	bne.n	8004600 <UART_SetConfig+0x78>
 80045ce:	f503 4358 	add.w	r3, r3, #55296	; 0xd800
 80045d2:	4aa5      	ldr	r2, [pc, #660]	; (8004868 <UART_SetConfig+0x2e0>)
 80045d4:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80045d8:	f003 0303 	and.w	r3, r3, #3
        }
      }  /*   if ( (tmpreg < (3 * huart->Init.BaudRate) ) || (tmpreg > (4096 * huart->Init.BaudRate) )) */
    } /* if (tmpreg != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80045dc:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80045e0:	5cd3      	ldrb	r3, [r2, r3]
 80045e2:	f040 8123 	bne.w	800482c <UART_SetConfig+0x2a4>
  {
    switch (clocksource)
 80045e6:	2b08      	cmp	r3, #8
 80045e8:	d877      	bhi.n	80046da <UART_SetConfig+0x152>
 80045ea:	e8df f013 	tbh	[pc, r3, lsl #1]
 80045ee:	0100      	.short	0x0100
 80045f0:	00e200b3 	.word	0x00e200b3
 80045f4:	011c0076 	.word	0x011c0076
 80045f8:	00760076 	.word	0x00760076
 80045fc:	00360076 	.word	0x00360076
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004600:	4b9a      	ldr	r3, [pc, #616]	; (800486c <UART_SetConfig+0x2e4>)
 8004602:	429a      	cmp	r2, r3
 8004604:	d107      	bne.n	8004616 <UART_SetConfig+0x8e>
 8004606:	f503 33e6 	add.w	r3, r3, #117760	; 0x1cc00
 800460a:	4a99      	ldr	r2, [pc, #612]	; (8004870 <UART_SetConfig+0x2e8>)
 800460c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004610:	f003 030c 	and.w	r3, r3, #12
 8004614:	e7e2      	b.n	80045dc <UART_SetConfig+0x54>
 8004616:	4b97      	ldr	r3, [pc, #604]	; (8004874 <UART_SetConfig+0x2ec>)
 8004618:	429a      	cmp	r2, r3
 800461a:	d123      	bne.n	8004664 <UART_SetConfig+0xdc>
 800461c:	f503 33e4 	add.w	r3, r3, #116736	; 0x1c800
 8004620:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004624:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8004628:	2b10      	cmp	r3, #16
 800462a:	f000 80f9 	beq.w	8004820 <UART_SetConfig+0x298>
 800462e:	d80b      	bhi.n	8004648 <UART_SetConfig+0xc0>
 8004630:	2b00      	cmp	r3, #0
 8004632:	f000 80d9 	beq.w	80047e8 <UART_SetConfig+0x260>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004636:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
#endif
        break;
      case UART_CLOCKSOURCE_UNDEFINED:
      default:
        ret = HAL_ERROR;
 800463a:	f04f 0201 	mov.w	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 800463e:	f04f 0300 	mov.w	r3, #0
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004642:	f000 80de 	beq.w	8004802 <UART_SetConfig+0x27a>
 8004646:	e091      	b.n	800476c <UART_SetConfig+0x1e4>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004648:	2b20      	cmp	r3, #32
 800464a:	f000 80af 	beq.w	80047ac <UART_SetConfig+0x224>
 800464e:	2b30      	cmp	r3, #48	; 0x30
 8004650:	d1f1      	bne.n	8004636 <UART_SetConfig+0xae>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004652:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8004656:	f040 80a1 	bne.w	800479c <UART_SetConfig+0x214>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 800465a:	6860      	ldr	r0, [r4, #4]
 800465c:	0843      	lsrs	r3, r0, #1
 800465e:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 8004662:	e0ac      	b.n	80047be <UART_SetConfig+0x236>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8004664:	4b84      	ldr	r3, [pc, #528]	; (8004878 <UART_SetConfig+0x2f0>)
 8004666:	429a      	cmp	r2, r3
 8004668:	d11c      	bne.n	80046a4 <UART_SetConfig+0x11c>
 800466a:	f503 33e2 	add.w	r3, r3, #115712	; 0x1c400
 800466e:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004672:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8004676:	2b40      	cmp	r3, #64	; 0x40
 8004678:	f000 80af 	beq.w	80047da <UART_SetConfig+0x252>
 800467c:	d806      	bhi.n	800468c <UART_SetConfig+0x104>
 800467e:	2b00      	cmp	r3, #0
 8004680:	f000 80a0 	beq.w	80047c4 <UART_SetConfig+0x23c>
  if (UART_INSTANCE_LOWPOWER(huart))
 8004684:	4b76      	ldr	r3, [pc, #472]	; (8004860 <UART_SetConfig+0x2d8>)
 8004686:	429a      	cmp	r2, r3
 8004688:	d1d5      	bne.n	8004636 <UART_SetConfig+0xae>
 800468a:	e026      	b.n	80046da <UART_SetConfig+0x152>
  UART_GETCLOCKSOURCE(huart, clocksource);
 800468c:	2b80      	cmp	r3, #128	; 0x80
 800468e:	f000 808a 	beq.w	80047a6 <UART_SetConfig+0x21e>
 8004692:	2bc0      	cmp	r3, #192	; 0xc0
 8004694:	d1f6      	bne.n	8004684 <UART_SetConfig+0xfc>
  if (UART_INSTANCE_LOWPOWER(huart))
 8004696:	4b72      	ldr	r3, [pc, #456]	; (8004860 <UART_SetConfig+0x2d8>)
 8004698:	429a      	cmp	r2, r3
 800469a:	d1da      	bne.n	8004652 <UART_SetConfig+0xca>
        lpuart_ker_ck_pres = (uint32_t)LSE_VALUE;
 800469c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  if (UART_INSTANCE_LOWPOWER(huart))
 80046a0:	2308      	movs	r3, #8
 80046a2:	e015      	b.n	80046d0 <UART_SetConfig+0x148>
  UART_GETCLOCKSOURCE(huart, clocksource);
 80046a4:	4b6e      	ldr	r3, [pc, #440]	; (8004860 <UART_SetConfig+0x2d8>)
 80046a6:	429a      	cmp	r2, r3
 80046a8:	d1c5      	bne.n	8004636 <UART_SetConfig+0xae>
 80046aa:	f503 33c8 	add.w	r3, r3, #102400	; 0x19000
 80046ae:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80046b2:	f403 6340 	and.w	r3, r3, #3072	; 0xc00
 80046b6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80046ba:	f000 808e 	beq.w	80047da <UART_SetConfig+0x252>
 80046be:	d9de      	bls.n	800467e <UART_SetConfig+0xf6>
 80046c0:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80046c4:	d06f      	beq.n	80047a6 <UART_SetConfig+0x21e>
 80046c6:	f5b3 6f40 	cmp.w	r3, #3072	; 0xc00
 80046ca:	e7e3      	b.n	8004694 <UART_SetConfig+0x10c>
        lpuart_ker_ck_pres = (uint32_t)HSI_VALUE;
 80046cc:	486b      	ldr	r0, [pc, #428]	; (800487c <UART_SetConfig+0x2f4>)
  if (UART_INSTANCE_LOWPOWER(huart))
 80046ce:	2302      	movs	r3, #2
      if ((lpuart_ker_ck_pres < (3 * huart->Init.BaudRate)) ||
 80046d0:	6862      	ldr	r2, [r4, #4]
 80046d2:	eb02 0142 	add.w	r1, r2, r2, lsl #1
 80046d6:	4281      	cmp	r1, r0
 80046d8:	d905      	bls.n	80046e6 <UART_SetConfig+0x15e>
        ret = HAL_ERROR;
 80046da:	2201      	movs	r2, #1
  huart->NbTxDataToProcess = 1;
  huart->NbRxDataToProcess = 1;
#endif

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 80046dc:	2300      	movs	r3, #0
 80046de:	6623      	str	r3, [r4, #96]	; 0x60
  huart->TxISR = NULL;
 80046e0:	6663      	str	r3, [r4, #100]	; 0x64

  return ret;
}
 80046e2:	4610      	mov	r0, r2
 80046e4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      if ((lpuart_ker_ck_pres < (3 * huart->Init.BaudRate)) ||
 80046e6:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 80046ea:	d8f6      	bhi.n	80046da <UART_SetConfig+0x152>
        switch (clocksource)
 80046ec:	2b08      	cmp	r3, #8
 80046ee:	d82e      	bhi.n	800474e <UART_SetConfig+0x1c6>
 80046f0:	e8df f003 	tbb	[pc, r3]
 80046f4:	2d1c2d05 	.word	0x2d1c2d05
 80046f8:	2d2d2d24 	.word	0x2d2d2d24
 80046fc:	27          	.byte	0x27
 80046fd:	00          	.byte	0x00
            usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80046fe:	f7fe fe2d 	bl	800335c <HAL_RCC_GetPCLK1Freq>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8004702:	6862      	ldr	r2, [r4, #4]
 8004704:	f44f 7180 	mov.w	r1, #256	; 0x100
 8004708:	0856      	lsrs	r6, r2, #1
 800470a:	2700      	movs	r7, #0
 800470c:	fbe1 6700 	umlal	r6, r7, r1, r0
 8004710:	2300      	movs	r3, #0
 8004712:	4630      	mov	r0, r6
 8004714:	4639      	mov	r1, r7
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
 8004716:	f7fc fa05 	bl	8000b24 <__aeabi_uldivmod>
            break;
 800471a:	2200      	movs	r2, #0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 800471c:	4b58      	ldr	r3, [pc, #352]	; (8004880 <UART_SetConfig+0x2f8>)
 800471e:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 8004722:	4299      	cmp	r1, r3
 8004724:	d8d9      	bhi.n	80046da <UART_SetConfig+0x152>
          huart->Instance->BRR = usartdiv;
 8004726:	6823      	ldr	r3, [r4, #0]
 8004728:	60d8      	str	r0, [r3, #12]
 800472a:	e7d7      	b.n	80046dc <UART_SetConfig+0x154>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate));
 800472c:	4855      	ldr	r0, [pc, #340]	; (8004884 <UART_SetConfig+0x2fc>)
 800472e:	0855      	lsrs	r5, r2, #1
 8004730:	2300      	movs	r3, #0
 8004732:	2100      	movs	r1, #0
 8004734:	1940      	adds	r0, r0, r5
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
 8004736:	f141 0100 	adc.w	r1, r1, #0
 800473a:	e7ec      	b.n	8004716 <UART_SetConfig+0x18e>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800473c:	f7fe fab0 	bl	8002ca0 <HAL_RCC_GetSysClockFreq>
 8004740:	e7df      	b.n	8004702 <UART_SetConfig+0x17a>
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate));
 8004742:	0850      	lsrs	r0, r2, #1
 8004744:	2100      	movs	r1, #0
 8004746:	2300      	movs	r3, #0
 8004748:	f510 0000 	adds.w	r0, r0, #8388608	; 0x800000
 800474c:	e7f3      	b.n	8004736 <UART_SetConfig+0x1ae>
            ret = HAL_ERROR;
 800474e:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 8004750:	2000      	movs	r0, #0
 8004752:	e7e3      	b.n	800471c <UART_SetConfig+0x194>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 8004754:	f7fe fe12 	bl	800337c <HAL_RCC_GetPCLK2Freq>
 8004758:	e04b      	b.n	80047f2 <UART_SetConfig+0x26a>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 800475a:	f7fe fdff 	bl	800335c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 800475e:	6862      	ldr	r2, [r4, #4]
 8004760:	eb00 0352 	add.w	r3, r0, r2, lsr #1
 8004764:	fbb3 f3f2 	udiv	r3, r3, r2
 8004768:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 800476a:	2200      	movs	r2, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 800476c:	f1a3 0010 	sub.w	r0, r3, #16
 8004770:	f64f 71ef 	movw	r1, #65519	; 0xffef
 8004774:	4288      	cmp	r0, r1
 8004776:	d8b0      	bhi.n	80046da <UART_SetConfig+0x152>
      huart->Instance->BRR = usartdiv;
 8004778:	6821      	ldr	r1, [r4, #0]
 800477a:	60cb      	str	r3, [r1, #12]
 800477c:	e7ae      	b.n	80046dc <UART_SetConfig+0x154>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetPCLK2Freq(), huart->Init.BaudRate));
 800477e:	f7fe fdfd 	bl	800337c <HAL_RCC_GetPCLK2Freq>
 8004782:	e7ec      	b.n	800475e <UART_SetConfig+0x1d6>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate));
 8004784:	6860      	ldr	r0, [r4, #4]
 8004786:	0843      	lsrs	r3, r0, #1
 8004788:	f503 0374 	add.w	r3, r3, #15990784	; 0xf40000
 800478c:	f503 5310 	add.w	r3, r3, #9216	; 0x2400
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 8004790:	fbb3 f3f0 	udiv	r3, r3, r0
 8004794:	e7e8      	b.n	8004768 <UART_SetConfig+0x1e0>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8004796:	f7fe fa83 	bl	8002ca0 <HAL_RCC_GetSysClockFreq>
 800479a:	e7e0      	b.n	800475e <UART_SetConfig+0x1d6>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
 800479c:	6860      	ldr	r0, [r4, #4]
 800479e:	0843      	lsrs	r3, r0, #1
 80047a0:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
 80047a4:	e7f4      	b.n	8004790 <UART_SetConfig+0x208>
  if (UART_INSTANCE_LOWPOWER(huart))
 80047a6:	4b2e      	ldr	r3, [pc, #184]	; (8004860 <UART_SetConfig+0x2d8>)
 80047a8:	429a      	cmp	r2, r3
 80047aa:	d08f      	beq.n	80046cc <UART_SetConfig+0x144>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80047ac:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80047b0:	d1e8      	bne.n	8004784 <UART_SetConfig+0x1fc>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate));
 80047b2:	6860      	ldr	r0, [r4, #4]
 80047b4:	0843      	lsrs	r3, r0, #1
 80047b6:	f103 73f4 	add.w	r3, r3, #31981568	; 0x1e80000
 80047ba:	f503 4390 	add.w	r3, r3, #18432	; 0x4800
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(LSE_VALUE, huart->Init.BaudRate));
 80047be:	fbb3 f3f0 	udiv	r3, r3, r0
 80047c2:	e01c      	b.n	80047fe <UART_SetConfig+0x276>
  if (UART_INSTANCE_LOWPOWER(huart))
 80047c4:	4b26      	ldr	r3, [pc, #152]	; (8004860 <UART_SetConfig+0x2d8>)
 80047c6:	429a      	cmp	r2, r3
 80047c8:	d10e      	bne.n	80047e8 <UART_SetConfig+0x260>
        lpuart_ker_ck_pres = HAL_RCC_GetPCLK1Freq();
 80047ca:	f7fe fdc7 	bl	800335c <HAL_RCC_GetPCLK1Freq>
        break;
 80047ce:	2300      	movs	r3, #0
    if (lpuart_ker_ck_pres != 0U)
 80047d0:	2800      	cmp	r0, #0
 80047d2:	f47f af7d 	bne.w	80046d0 <UART_SetConfig+0x148>
 80047d6:	4602      	mov	r2, r0
 80047d8:	e780      	b.n	80046dc <UART_SetConfig+0x154>
  if (UART_INSTANCE_LOWPOWER(huart))
 80047da:	4b21      	ldr	r3, [pc, #132]	; (8004860 <UART_SetConfig+0x2d8>)
 80047dc:	429a      	cmp	r2, r3
 80047de:	d11f      	bne.n	8004820 <UART_SetConfig+0x298>
        lpuart_ker_ck_pres = HAL_RCC_GetSysClockFreq();
 80047e0:	f7fe fa5e 	bl	8002ca0 <HAL_RCC_GetSysClockFreq>
        break;
 80047e4:	2304      	movs	r3, #4
 80047e6:	e7f3      	b.n	80047d0 <UART_SetConfig+0x248>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80047e8:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80047ec:	d1b5      	bne.n	800475a <UART_SetConfig+0x1d2>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetPCLK1Freq(), huart->Init.BaudRate));
 80047ee:	f7fe fdb5 	bl	800335c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 80047f2:	6861      	ldr	r1, [r4, #4]
 80047f4:	084a      	lsrs	r2, r1, #1
 80047f6:	eb02 0340 	add.w	r3, r2, r0, lsl #1
 80047fa:	fbb3 f3f1 	udiv	r3, r3, r1
 80047fe:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 8004800:	2200      	movs	r2, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8004802:	f1a3 0010 	sub.w	r0, r3, #16
 8004806:	f64f 71ef 	movw	r1, #65519	; 0xffef
 800480a:	4288      	cmp	r0, r1
 800480c:	f63f af65 	bhi.w	80046da <UART_SetConfig+0x152>
      brrtemp = usartdiv & 0xFFF0U;
 8004810:	f023 010f 	bic.w	r1, r3, #15
      huart->Instance->BRR = brrtemp;
 8004814:	6820      	ldr	r0, [r4, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8004816:	f3c3 0342 	ubfx	r3, r3, #1, #3
      huart->Instance->BRR = brrtemp;
 800481a:	430b      	orrs	r3, r1
 800481c:	60c3      	str	r3, [r0, #12]
 800481e:	e75d      	b.n	80046dc <UART_SetConfig+0x154>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8004820:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8004824:	d1b7      	bne.n	8004796 <UART_SetConfig+0x20e>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HAL_RCC_GetSysClockFreq(), huart->Init.BaudRate));
 8004826:	f7fe fa3b 	bl	8002ca0 <HAL_RCC_GetSysClockFreq>
 800482a:	e7e2      	b.n	80047f2 <UART_SetConfig+0x26a>
    switch (clocksource)
 800482c:	2b08      	cmp	r3, #8
 800482e:	f63f af54 	bhi.w	80046da <UART_SetConfig+0x152>
 8004832:	a201      	add	r2, pc, #4	; (adr r2, 8004838 <UART_SetConfig+0x2b0>)
 8004834:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8004838:	0800475b 	.word	0x0800475b
 800483c:	0800477f 	.word	0x0800477f
 8004840:	08004785 	.word	0x08004785
 8004844:	080046db 	.word	0x080046db
 8004848:	08004797 	.word	0x08004797
 800484c:	080046db 	.word	0x080046db
 8004850:	080046db 	.word	0x080046db
 8004854:	080046db 	.word	0x080046db
 8004858:	0800479d 	.word	0x0800479d
 800485c:	efff69f3 	.word	0xefff69f3
 8004860:	40008000 	.word	0x40008000
 8004864:	40013800 	.word	0x40013800
 8004868:	0800f558 	.word	0x0800f558
 800486c:	40004400 	.word	0x40004400
 8004870:	0800f55c 	.word	0x0800f55c
 8004874:	40004800 	.word	0x40004800
 8004878:	40004c00 	.word	0x40004c00
 800487c:	00f42400 	.word	0x00f42400
 8004880:	000ffcff 	.word	0x000ffcff
 8004884:	f4240000 	.word	0xf4240000

08004888 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8004888:	6a43      	ldr	r3, [r0, #36]	; 0x24
 800488a:	07da      	lsls	r2, r3, #31
{
 800488c:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800488e:	d506      	bpl.n	800489e <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8004890:	6801      	ldr	r1, [r0, #0]
 8004892:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8004894:	684a      	ldr	r2, [r1, #4]
 8004896:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800489a:	4322      	orrs	r2, r4
 800489c:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800489e:	079c      	lsls	r4, r3, #30
 80048a0:	d506      	bpl.n	80048b0 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 80048a2:	6801      	ldr	r1, [r0, #0]
 80048a4:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 80048a6:	684a      	ldr	r2, [r1, #4]
 80048a8:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 80048ac:	4322      	orrs	r2, r4
 80048ae:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 80048b0:	0759      	lsls	r1, r3, #29
 80048b2:	d506      	bpl.n	80048c2 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 80048b4:	6801      	ldr	r1, [r0, #0]
 80048b6:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80048b8:	684a      	ldr	r2, [r1, #4]
 80048ba:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 80048be:	4322      	orrs	r2, r4
 80048c0:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 80048c2:	071a      	lsls	r2, r3, #28
 80048c4:	d506      	bpl.n	80048d4 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 80048c6:	6801      	ldr	r1, [r0, #0]
 80048c8:	6b44      	ldr	r4, [r0, #52]	; 0x34
 80048ca:	684a      	ldr	r2, [r1, #4]
 80048cc:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80048d0:	4322      	orrs	r2, r4
 80048d2:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 80048d4:	06dc      	lsls	r4, r3, #27
 80048d6:	d506      	bpl.n	80048e6 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 80048d8:	6801      	ldr	r1, [r0, #0]
 80048da:	6b84      	ldr	r4, [r0, #56]	; 0x38
 80048dc:	688a      	ldr	r2, [r1, #8]
 80048de:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80048e2:	4322      	orrs	r2, r4
 80048e4:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 80048e6:	0699      	lsls	r1, r3, #26
 80048e8:	d506      	bpl.n	80048f8 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 80048ea:	6801      	ldr	r1, [r0, #0]
 80048ec:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 80048ee:	688a      	ldr	r2, [r1, #8]
 80048f0:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 80048f4:	4322      	orrs	r2, r4
 80048f6:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 80048f8:	065a      	lsls	r2, r3, #25
 80048fa:	d50f      	bpl.n	800491c <UART_AdvFeatureConfig+0x94>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 80048fc:	6801      	ldr	r1, [r0, #0]
 80048fe:	6c04      	ldr	r4, [r0, #64]	; 0x40
 8004900:	684a      	ldr	r2, [r1, #4]
 8004902:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8004906:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8004908:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800490c:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800490e:	d105      	bne.n	800491c <UART_AdvFeatureConfig+0x94>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 8004910:	684a      	ldr	r2, [r1, #4]
 8004912:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8004914:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 8004918:	4322      	orrs	r2, r4
 800491a:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 800491c:	061b      	lsls	r3, r3, #24
 800491e:	d506      	bpl.n	800492e <UART_AdvFeatureConfig+0xa6>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 8004920:	6802      	ldr	r2, [r0, #0]
 8004922:	6c81      	ldr	r1, [r0, #72]	; 0x48
 8004924:	6853      	ldr	r3, [r2, #4]
 8004926:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 800492a:	430b      	orrs	r3, r1
 800492c:	6053      	str	r3, [r2, #4]
 800492e:	bd10      	pop	{r4, pc}

08004930 <UART_WaitOnFlagUntilTimeout>:
  * @param Tickstart Tick start value
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status, uint32_t Tickstart, uint32_t Timeout)
{
 8004930:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004934:	9d06      	ldr	r5, [sp, #24]
 8004936:	4604      	mov	r4, r0
 8004938:	460f      	mov	r7, r1
 800493a:	4616      	mov	r6, r2
 800493c:	4698      	mov	r8, r3
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 800493e:	6821      	ldr	r1, [r4, #0]
 8004940:	69ca      	ldr	r2, [r1, #28]
 8004942:	ea37 0302 	bics.w	r3, r7, r2
 8004946:	bf0c      	ite	eq
 8004948:	2201      	moveq	r2, #1
 800494a:	2200      	movne	r2, #0
 800494c:	42b2      	cmp	r2, r6
 800494e:	d002      	beq.n	8004956 <UART_WaitOnFlagUntilTimeout+0x26>

        return HAL_TIMEOUT;
      }
    }
  }
  return HAL_OK;
 8004950:	2000      	movs	r0, #0
}
 8004952:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (Timeout != HAL_MAX_DELAY)
 8004956:	1c6b      	adds	r3, r5, #1
 8004958:	d0f2      	beq.n	8004940 <UART_WaitOnFlagUntilTimeout+0x10>
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 800495a:	b99d      	cbnz	r5, 8004984 <UART_WaitOnFlagUntilTimeout+0x54>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE | USART_CR1_PEIE | USART_CR1_TXEIE));
 800495c:	6823      	ldr	r3, [r4, #0]
 800495e:	681a      	ldr	r2, [r3, #0]
 8004960:	f422 72d0 	bic.w	r2, r2, #416	; 0x1a0
 8004964:	601a      	str	r2, [r3, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8004966:	689a      	ldr	r2, [r3, #8]
 8004968:	f022 0201 	bic.w	r2, r2, #1
 800496c:	609a      	str	r2, [r3, #8]
        huart->gState = HAL_UART_STATE_READY;
 800496e:	2320      	movs	r3, #32
 8004970:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
        huart->RxState = HAL_UART_STATE_READY;
 8004974:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
        __HAL_UNLOCK(huart);
 8004978:	2300      	movs	r3, #0
 800497a:	f884 3070 	strb.w	r3, [r4, #112]	; 0x70
 800497e:	2003      	movs	r0, #3
 8004980:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((Timeout == 0U) || ((HAL_GetTick() - Tickstart) > Timeout))
 8004984:	f7fc fa84 	bl	8000e90 <HAL_GetTick>
 8004988:	eba0 0008 	sub.w	r0, r0, r8
 800498c:	4285      	cmp	r5, r0
 800498e:	d2d6      	bcs.n	800493e <UART_WaitOnFlagUntilTimeout+0xe>
 8004990:	e7e4      	b.n	800495c <UART_WaitOnFlagUntilTimeout+0x2c>

08004992 <HAL_UART_Transmit>:
{
 8004992:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 8004996:	461f      	mov	r7, r3
  if (huart->gState == HAL_UART_STATE_READY)
 8004998:	f890 3071 	ldrb.w	r3, [r0, #113]	; 0x71
 800499c:	2b20      	cmp	r3, #32
{
 800499e:	4604      	mov	r4, r0
 80049a0:	460d      	mov	r5, r1
 80049a2:	4690      	mov	r8, r2
  if (huart->gState == HAL_UART_STATE_READY)
 80049a4:	d14a      	bne.n	8004a3c <HAL_UART_Transmit+0xaa>
    if ((pData == NULL) || (Size == 0U))
 80049a6:	2900      	cmp	r1, #0
 80049a8:	d046      	beq.n	8004a38 <HAL_UART_Transmit+0xa6>
 80049aa:	2a00      	cmp	r2, #0
 80049ac:	d044      	beq.n	8004a38 <HAL_UART_Transmit+0xa6>
    __HAL_LOCK(huart);
 80049ae:	f890 3070 	ldrb.w	r3, [r0, #112]	; 0x70
 80049b2:	2b01      	cmp	r3, #1
 80049b4:	d042      	beq.n	8004a3c <HAL_UART_Transmit+0xaa>
 80049b6:	2301      	movs	r3, #1
 80049b8:	f880 3070 	strb.w	r3, [r0, #112]	; 0x70
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 80049bc:	2300      	movs	r3, #0
 80049be:	6743      	str	r3, [r0, #116]	; 0x74
    huart->gState = HAL_UART_STATE_BUSY_TX;
 80049c0:	2321      	movs	r3, #33	; 0x21
 80049c2:	f880 3071 	strb.w	r3, [r0, #113]	; 0x71
    tickstart = HAL_GetTick();
 80049c6:	f7fc fa63 	bl	8000e90 <HAL_GetTick>
    huart->TxXferSize  = Size;
 80049ca:	f8a4 8050 	strh.w	r8, [r4, #80]	; 0x50
    tickstart = HAL_GetTick();
 80049ce:	4606      	mov	r6, r0
    huart->TxXferCount = Size;
 80049d0:	f8a4 8052 	strh.w	r8, [r4, #82]	; 0x52
    while (huart->TxXferCount > 0U)
 80049d4:	f8b4 2052 	ldrh.w	r2, [r4, #82]	; 0x52
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80049d8:	9700      	str	r7, [sp, #0]
    while (huart->TxXferCount > 0U)
 80049da:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80049dc:	4633      	mov	r3, r6
    while (huart->TxXferCount > 0U)
 80049de:	b952      	cbnz	r2, 80049f6 <HAL_UART_Transmit+0x64>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 80049e0:	2140      	movs	r1, #64	; 0x40
 80049e2:	4620      	mov	r0, r4
 80049e4:	f7ff ffa4 	bl	8004930 <UART_WaitOnFlagUntilTimeout>
 80049e8:	b958      	cbnz	r0, 8004a02 <HAL_UART_Transmit+0x70>
    huart->gState = HAL_UART_STATE_READY;
 80049ea:	2320      	movs	r3, #32
 80049ec:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
    __HAL_UNLOCK(huart);
 80049f0:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
    return HAL_OK;
 80049f4:	e006      	b.n	8004a04 <HAL_UART_Transmit+0x72>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 80049f6:	2200      	movs	r2, #0
 80049f8:	2180      	movs	r1, #128	; 0x80
 80049fa:	4620      	mov	r0, r4
 80049fc:	f7ff ff98 	bl	8004930 <UART_WaitOnFlagUntilTimeout>
 8004a00:	b118      	cbz	r0, 8004a0a <HAL_UART_Transmit+0x78>
        return HAL_TIMEOUT;
 8004a02:	2003      	movs	r0, #3
}
 8004a04:	b002      	add	sp, #8
 8004a06:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8004a0a:	68a3      	ldr	r3, [r4, #8]
 8004a0c:	6822      	ldr	r2, [r4, #0]
 8004a0e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 8004a12:	d10d      	bne.n	8004a30 <HAL_UART_Transmit+0x9e>
 8004a14:	6923      	ldr	r3, [r4, #16]
 8004a16:	b95b      	cbnz	r3, 8004a30 <HAL_UART_Transmit+0x9e>
        huart->Instance->TDR = (*tmp & (uint16_t)0x01FFU);
 8004a18:	f835 3b02 	ldrh.w	r3, [r5], #2
 8004a1c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8004a20:	8513      	strh	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 8004a22:	f8b4 3052 	ldrh.w	r3, [r4, #82]	; 0x52
 8004a26:	3b01      	subs	r3, #1
 8004a28:	b29b      	uxth	r3, r3
 8004a2a:	f8a4 3052 	strh.w	r3, [r4, #82]	; 0x52
 8004a2e:	e7d1      	b.n	80049d4 <HAL_UART_Transmit+0x42>
        huart->Instance->TDR = (*pData++ & (uint8_t)0xFFU);
 8004a30:	782b      	ldrb	r3, [r5, #0]
 8004a32:	8513      	strh	r3, [r2, #40]	; 0x28
 8004a34:	3501      	adds	r5, #1
 8004a36:	e7f4      	b.n	8004a22 <HAL_UART_Transmit+0x90>
      return  HAL_ERROR;
 8004a38:	2001      	movs	r0, #1
 8004a3a:	e7e3      	b.n	8004a04 <HAL_UART_Transmit+0x72>
    return HAL_BUSY;
 8004a3c:	2002      	movs	r0, #2
 8004a3e:	e7e1      	b.n	8004a04 <HAL_UART_Transmit+0x72>

08004a40 <UART_CheckIdleState>:
{
 8004a40:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8004a42:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8004a44:	2600      	movs	r6, #0
 8004a46:	6746      	str	r6, [r0, #116]	; 0x74
  tickstart = HAL_GetTick();
 8004a48:	f7fc fa22 	bl	8000e90 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8004a4c:	6823      	ldr	r3, [r4, #0]
 8004a4e:	681b      	ldr	r3, [r3, #0]
 8004a50:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 8004a52:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8004a54:	d417      	bmi.n	8004a86 <UART_CheckIdleState+0x46>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8004a56:	6823      	ldr	r3, [r4, #0]
 8004a58:	681b      	ldr	r3, [r3, #0]
 8004a5a:	075b      	lsls	r3, r3, #29
 8004a5c:	d50a      	bpl.n	8004a74 <UART_CheckIdleState+0x34>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8004a5e:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8004a62:	9300      	str	r3, [sp, #0]
 8004a64:	2200      	movs	r2, #0
 8004a66:	462b      	mov	r3, r5
 8004a68:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8004a6c:	4620      	mov	r0, r4
 8004a6e:	f7ff ff5f 	bl	8004930 <UART_WaitOnFlagUntilTimeout>
 8004a72:	b9a0      	cbnz	r0, 8004a9e <UART_CheckIdleState+0x5e>
  huart->gState = HAL_UART_STATE_READY;
 8004a74:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 8004a76:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 8004a78:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
  __HAL_UNLOCK(huart);
 8004a7c:	f884 0070 	strb.w	r0, [r4, #112]	; 0x70
  huart->RxState = HAL_UART_STATE_READY;
 8004a80:	f884 3072 	strb.w	r3, [r4, #114]	; 0x72
  return HAL_OK;
 8004a84:	e00c      	b.n	8004aa0 <UART_CheckIdleState+0x60>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8004a86:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8004a8a:	9300      	str	r3, [sp, #0]
 8004a8c:	4632      	mov	r2, r6
 8004a8e:	4603      	mov	r3, r0
 8004a90:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8004a94:	4620      	mov	r0, r4
 8004a96:	f7ff ff4b 	bl	8004930 <UART_WaitOnFlagUntilTimeout>
 8004a9a:	2800      	cmp	r0, #0
 8004a9c:	d0db      	beq.n	8004a56 <UART_CheckIdleState+0x16>
      return HAL_TIMEOUT;
 8004a9e:	2003      	movs	r0, #3
}
 8004aa0:	b002      	add	sp, #8
 8004aa2:	bd70      	pop	{r4, r5, r6, pc}

08004aa4 <HAL_UART_Init>:
{
 8004aa4:	b510      	push	{r4, lr}
  if (huart == NULL)
 8004aa6:	4604      	mov	r4, r0
 8004aa8:	b360      	cbz	r0, 8004b04 <HAL_UART_Init+0x60>
  if (huart->gState == HAL_UART_STATE_RESET)
 8004aaa:	f890 3071 	ldrb.w	r3, [r0, #113]	; 0x71
 8004aae:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8004ab2:	b91b      	cbnz	r3, 8004abc <HAL_UART_Init+0x18>
    huart->Lock = HAL_UNLOCKED;
 8004ab4:	f880 2070 	strb.w	r2, [r0, #112]	; 0x70
    HAL_UART_MspInit(huart);
 8004ab8:	f005 fd9c 	bl	800a5f4 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 8004abc:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8004abe:	2324      	movs	r3, #36	; 0x24
 8004ac0:	f884 3071 	strb.w	r3, [r4, #113]	; 0x71
  __HAL_UART_DISABLE(huart);
 8004ac4:	6813      	ldr	r3, [r2, #0]
 8004ac6:	f023 0301 	bic.w	r3, r3, #1
 8004aca:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8004acc:	4620      	mov	r0, r4
 8004ace:	f7ff fd5b 	bl	8004588 <UART_SetConfig>
 8004ad2:	2801      	cmp	r0, #1
 8004ad4:	d016      	beq.n	8004b04 <HAL_UART_Init+0x60>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8004ad6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004ad8:	b113      	cbz	r3, 8004ae0 <HAL_UART_Init+0x3c>
    UART_AdvFeatureConfig(huart);
 8004ada:	4620      	mov	r0, r4
 8004adc:	f7ff fed4 	bl	8004888 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8004ae0:	6823      	ldr	r3, [r4, #0]
 8004ae2:	685a      	ldr	r2, [r3, #4]
 8004ae4:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8004ae8:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8004aea:	689a      	ldr	r2, [r3, #8]
 8004aec:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8004af0:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8004af2:	681a      	ldr	r2, [r3, #0]
 8004af4:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8004af8:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8004afa:	601a      	str	r2, [r3, #0]
}
 8004afc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 8004b00:	f7ff bf9e 	b.w	8004a40 <UART_CheckIdleState>
}
 8004b04:	2001      	movs	r0, #1
 8004b06:	bd10      	pop	{r4, pc}

08004b08 <LL_GPIO_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: GPIO registers are initialized according to GPIO_InitStruct content
  *          - ERROR:   Not applicable
  */
ErrorStatus LL_GPIO_Init(GPIO_TypeDef *GPIOx, LL_GPIO_InitTypeDef *GPIO_InitStruct)
{
 8004b08:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  assert_param(IS_LL_GPIO_MODE(GPIO_InitStruct->Mode));
  assert_param(IS_LL_GPIO_PULL(GPIO_InitStruct->Pull));

  /* ------------------------- Configure the port pins ---------------- */
  /* Initialize  pinpos on first pin set */
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 8004b0c:	680a      	ldr	r2, [r1, #0]
   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
 8004b0e:	fa92 f4a2 	rbit	r4, r2

  /* Configure the port pins */
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
  {
    /* Get current io position */
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);
 8004b12:	f04f 0e01 	mov.w	lr, #1
  pinpos = POSITION_VAL(GPIO_InitStruct->Pin);
 8004b16:	fab4 f484 	clz	r4, r4
  *         @arg @ref LL_GPIO_MODE_ANALOG
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetPinMode(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Mode)
{
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODE0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8004b1a:	2503      	movs	r5, #3
  *         @arg @ref LL_GPIO_AF_15
  * @retval None
  */
__STATIC_INLINE void LL_GPIO_SetAFPin_8_15(GPIO_TypeDef *GPIOx, uint32_t Pin, uint32_t Alternate)
{
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8004b1c:	270f      	movs	r7, #15
  while (((GPIO_InitStruct->Pin) >> pinpos) != 0x00000000U)
 8004b1e:	fa32 f304 	lsrs.w	r3, r2, r4
 8004b22:	d10d      	bne.n	8004b40 <LL_GPIO_Init+0x38>
      }
    }
    pinpos++;
  }

  if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8004b24:	684b      	ldr	r3, [r1, #4]
 8004b26:	3b01      	subs	r3, #1
 8004b28:	2b01      	cmp	r3, #1
 8004b2a:	d806      	bhi.n	8004b3a <LL_GPIO_Init+0x32>
  MODIFY_REG(GPIOx->OTYPER, PinMask, (PinMask * OutputType));
 8004b2c:	6843      	ldr	r3, [r0, #4]
 8004b2e:	68c9      	ldr	r1, [r1, #12]
 8004b30:	ea23 0302 	bic.w	r3, r3, r2
 8004b34:	434a      	muls	r2, r1
 8004b36:	431a      	orrs	r2, r3
 8004b38:	6042      	str	r2, [r0, #4]
    /* Output mode configuration*/
    LL_GPIO_SetPinOutputType(GPIOx, GPIO_InitStruct->Pin, GPIO_InitStruct->OutputType);

  }
  return (SUCCESS);
}
 8004b3a:	2001      	movs	r0, #1
 8004b3c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    currentpin = (GPIO_InitStruct->Pin) & (0x00000001U << pinpos);
 8004b40:	fa0e f304 	lsl.w	r3, lr, r4
    if (currentpin)
 8004b44:	4013      	ands	r3, r2
 8004b46:	d069      	beq.n	8004c1c <LL_GPIO_Init+0x114>
      LL_GPIO_SetPinMode(GPIOx, currentpin, GPIO_InitStruct->Mode);
 8004b48:	f8d1 8004 	ldr.w	r8, [r1, #4]
  MODIFY_REG(GPIOx->MODER, (GPIO_MODER_MODE0 << (POSITION_VAL(Pin) * 2U)), (Mode << (POSITION_VAL(Pin) * 2U)));
 8004b4c:	f8d0 9000 	ldr.w	r9, [r0]
 8004b50:	fa93 fca3 	rbit	ip, r3
 8004b54:	fabc fc8c 	clz	ip, ip
 8004b58:	fa93 f6a3 	rbit	r6, r3
 8004b5c:	fab6 f686 	clz	r6, r6
 8004b60:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 8004b64:	fa05 fc0c 	lsl.w	ip, r5, ip
 8004b68:	0076      	lsls	r6, r6, #1
 8004b6a:	ea29 0c0c 	bic.w	ip, r9, ip
 8004b6e:	fa08 f606 	lsl.w	r6, r8, r6
 8004b72:	ea4c 0606 	orr.w	r6, ip, r6
 8004b76:	6006      	str	r6, [r0, #0]
      if ((GPIO_InitStruct->Mode == LL_GPIO_MODE_OUTPUT) || (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE))
 8004b78:	f108 36ff 	add.w	r6, r8, #4294967295
 8004b7c:	2e01      	cmp	r6, #1
 8004b7e:	d816      	bhi.n	8004bae <LL_GPIO_Init+0xa6>
  MODIFY_REG(GPIOx->OSPEEDR, (GPIO_OSPEEDR_OSPEED0 << (POSITION_VAL(Pin) * 2U)),
 8004b80:	6886      	ldr	r6, [r0, #8]
 8004b82:	fa93 fca3 	rbit	ip, r3
 8004b86:	fabc fc8c 	clz	ip, ip
 8004b8a:	fa93 f9a3 	rbit	r9, r3
 8004b8e:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 8004b92:	fa05 fc0c 	lsl.w	ip, r5, ip
 8004b96:	ea26 0c0c 	bic.w	ip, r6, ip
 8004b9a:	fab9 f989 	clz	r9, r9
 8004b9e:	688e      	ldr	r6, [r1, #8]
 8004ba0:	ea4f 0949 	mov.w	r9, r9, lsl #1
 8004ba4:	fa06 f609 	lsl.w	r6, r6, r9
 8004ba8:	ea4c 0606 	orr.w	r6, ip, r6
 8004bac:	6086      	str	r6, [r0, #8]
  MODIFY_REG(GPIOx->PUPDR, (GPIO_PUPDR_PUPD0 << (POSITION_VAL(Pin) * 2U)), (Pull << (POSITION_VAL(Pin) * 2U)));
 8004bae:	68c6      	ldr	r6, [r0, #12]
 8004bb0:	fa93 fca3 	rbit	ip, r3
 8004bb4:	fabc fc8c 	clz	ip, ip
 8004bb8:	fa93 f9a3 	rbit	r9, r3
 8004bbc:	ea4f 0c4c 	mov.w	ip, ip, lsl #1
 8004bc0:	fa05 fc0c 	lsl.w	ip, r5, ip
 8004bc4:	ea26 0c0c 	bic.w	ip, r6, ip
 8004bc8:	fab9 f989 	clz	r9, r9
 8004bcc:	690e      	ldr	r6, [r1, #16]
 8004bce:	ea4f 0949 	mov.w	r9, r9, lsl #1
 8004bd2:	fa06 f609 	lsl.w	r6, r6, r9
 8004bd6:	ea4c 0606 	orr.w	r6, ip, r6
      if (GPIO_InitStruct->Mode == LL_GPIO_MODE_ALTERNATE)
 8004bda:	f1b8 0f02 	cmp.w	r8, #2
 8004bde:	60c6      	str	r6, [r0, #12]
 8004be0:	d11c      	bne.n	8004c1c <LL_GPIO_Init+0x114>
 8004be2:	fa93 f6a3 	rbit	r6, r3
        if (POSITION_VAL(currentpin) < 0x00000008U)
 8004be6:	fab6 f686 	clz	r6, r6
 8004bea:	2e07      	cmp	r6, #7
 8004bec:	f8d1 c014 	ldr.w	ip, [r1, #20]
 8004bf0:	dc16      	bgt.n	8004c20 <LL_GPIO_Init+0x118>
  MODIFY_REG(GPIOx->AFR[0], (GPIO_AFRL_AFSEL0 << (POSITION_VAL(Pin) * 4U)),
 8004bf2:	f8d0 8020 	ldr.w	r8, [r0, #32]
 8004bf6:	fa93 f6a3 	rbit	r6, r3
 8004bfa:	fab6 f686 	clz	r6, r6
 8004bfe:	fa93 f3a3 	rbit	r3, r3
 8004c02:	fab3 f383 	clz	r3, r3
 8004c06:	00b6      	lsls	r6, r6, #2
 8004c08:	fa07 f606 	lsl.w	r6, r7, r6
 8004c0c:	009b      	lsls	r3, r3, #2
 8004c0e:	ea28 0606 	bic.w	r6, r8, r6
 8004c12:	fa0c fc03 	lsl.w	ip, ip, r3
 8004c16:	ea46 060c 	orr.w	r6, r6, ip
 8004c1a:	6206      	str	r6, [r0, #32]
    pinpos++;
 8004c1c:	3401      	adds	r4, #1
 8004c1e:	e77e      	b.n	8004b1e <LL_GPIO_Init+0x16>
  MODIFY_REG(GPIOx->AFR[1], (GPIO_AFRH_AFSEL8 << (POSITION_VAL(Pin >> 8U) * 4U)),
 8004c20:	f8d0 8024 	ldr.w	r8, [r0, #36]	; 0x24
 8004c24:	0a1b      	lsrs	r3, r3, #8
 8004c26:	fa93 f6a3 	rbit	r6, r3
 8004c2a:	fab6 f686 	clz	r6, r6
 8004c2e:	fa93 f3a3 	rbit	r3, r3
 8004c32:	fab3 f383 	clz	r3, r3
 8004c36:	00b6      	lsls	r6, r6, #2
 8004c38:	fa07 f606 	lsl.w	r6, r7, r6
 8004c3c:	009b      	lsls	r3, r3, #2
 8004c3e:	ea28 0606 	bic.w	r6, r8, r6
 8004c42:	fa0c f303 	lsl.w	r3, ip, r3
 8004c46:	4333      	orrs	r3, r6
 8004c48:	6243      	str	r3, [r0, #36]	; 0x24
 8004c4a:	e7e7      	b.n	8004c1c <LL_GPIO_Init+0x114>

08004c4c <LL_RCC_HSI_IsReady>:
  * @rmtoll CR           HSIRDY        LL_RCC_HSI_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_HSI_IsReady(void)
{
  return (READ_BIT(RCC->CR, RCC_CR_HSIRDY) == (RCC_CR_HSIRDY));
 8004c4c:	4b02      	ldr	r3, [pc, #8]	; (8004c58 <LL_RCC_HSI_IsReady+0xc>)
 8004c4e:	6818      	ldr	r0, [r3, #0]
}
 8004c50:	f3c0 2080 	ubfx	r0, r0, #10, #1
 8004c54:	4770      	bx	lr
 8004c56:	bf00      	nop
 8004c58:	40021000 	.word	0x40021000

08004c5c <LL_RCC_LSE_IsReady>:
  * @rmtoll BDCR         LSERDY        LL_RCC_LSE_IsReady
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_LSE_IsReady(void)
{
  return (READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == (RCC_BDCR_LSERDY));
 8004c5c:	4b02      	ldr	r3, [pc, #8]	; (8004c68 <LL_RCC_LSE_IsReady+0xc>)
 8004c5e:	f8d3 0090 	ldr.w	r0, [r3, #144]	; 0x90
}
 8004c62:	f3c0 0040 	ubfx	r0, r0, #1, #1
 8004c66:	4770      	bx	lr
 8004c68:	40021000 	.word	0x40021000

08004c6c <LL_RCC_MSI_IsEnabledRangeSelect>:
  * @rmtoll CR           MSIRGSEL      LL_RCC_MSI_IsEnabledRangeSelect
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_RCC_MSI_IsEnabledRangeSelect(void)
{
  return (READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == (RCC_CR_MSIRGSEL));
 8004c6c:	4b02      	ldr	r3, [pc, #8]	; (8004c78 <LL_RCC_MSI_IsEnabledRangeSelect+0xc>)
 8004c6e:	6818      	ldr	r0, [r3, #0]
}
 8004c70:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 8004c74:	4770      	bx	lr
 8004c76:	bf00      	nop
 8004c78:	40021000 	.word	0x40021000

08004c7c <RCC_GetHCLKClockFreq>:
  *         @arg @ref LL_RCC_SYSCLK_DIV_256
  *         @arg @ref LL_RCC_SYSCLK_DIV_512
  */
__STATIC_INLINE uint32_t LL_RCC_GetAHBPrescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE));
 8004c7c:	4b03      	ldr	r3, [pc, #12]	; (8004c8c <RCC_GetHCLKClockFreq+0x10>)
  * @retval HCLK clock frequency (in Hz)
  */
uint32_t RCC_GetHCLKClockFreq(uint32_t SYSCLK_Frequency)
{
  /* HCLK clock frequency */
  return __LL_RCC_CALC_HCLK_FREQ(SYSCLK_Frequency, LL_RCC_GetAHBPrescaler());
 8004c7e:	4a04      	ldr	r2, [pc, #16]	; (8004c90 <RCC_GetHCLKClockFreq+0x14>)
 8004c80:	689b      	ldr	r3, [r3, #8]
 8004c82:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8004c86:	5cd3      	ldrb	r3, [r2, r3]
}
 8004c88:	40d8      	lsrs	r0, r3
 8004c8a:	4770      	bx	lr
 8004c8c:	40021000 	.word	0x40021000
 8004c90:	0800fa1f 	.word	0x0800fa1f

08004c94 <RCC_GetPCLK1ClockFreq>:
  *         @arg @ref LL_RCC_APB1_DIV_8
  *         @arg @ref LL_RCC_APB1_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB1Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1));
 8004c94:	4b03      	ldr	r3, [pc, #12]	; (8004ca4 <RCC_GetPCLK1ClockFreq+0x10>)
  * @retval PCLK1 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK1ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK1 clock frequency */
  return __LL_RCC_CALC_PCLK1_FREQ(HCLK_Frequency, LL_RCC_GetAPB1Prescaler());
 8004c96:	4a04      	ldr	r2, [pc, #16]	; (8004ca8 <RCC_GetPCLK1ClockFreq+0x14>)
 8004c98:	689b      	ldr	r3, [r3, #8]
 8004c9a:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8004c9e:	5cd3      	ldrb	r3, [r2, r3]
}
 8004ca0:	40d8      	lsrs	r0, r3
 8004ca2:	4770      	bx	lr
 8004ca4:	40021000 	.word	0x40021000
 8004ca8:	0800fa2f 	.word	0x0800fa2f

08004cac <RCC_GetPCLK2ClockFreq>:
  *         @arg @ref LL_RCC_APB2_DIV_8
  *         @arg @ref LL_RCC_APB2_DIV_16
  */
__STATIC_INLINE uint32_t LL_RCC_GetAPB2Prescaler(void)
{
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2));
 8004cac:	4b03      	ldr	r3, [pc, #12]	; (8004cbc <RCC_GetPCLK2ClockFreq+0x10>)
  * @retval PCLK2 clock frequency (in Hz)
  */
uint32_t RCC_GetPCLK2ClockFreq(uint32_t HCLK_Frequency)
{
  /* PCLK2 clock frequency */
  return __LL_RCC_CALC_PCLK2_FREQ(HCLK_Frequency, LL_RCC_GetAPB2Prescaler());
 8004cae:	4a04      	ldr	r2, [pc, #16]	; (8004cc0 <RCC_GetPCLK2ClockFreq+0x14>)
 8004cb0:	689b      	ldr	r3, [r3, #8]
 8004cb2:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 8004cb6:	5cd3      	ldrb	r3, [r2, r3]
}
 8004cb8:	40d8      	lsrs	r0, r3
 8004cba:	4770      	bx	lr
 8004cbc:	40021000 	.word	0x40021000
 8004cc0:	0800fa2f 	.word	0x0800fa2f

08004cc4 <RCC_PLL_GetFreqDomain_SYS>:
  *         @arg @ref LL_RCC_PLLSOURCE_HSI
  *         @arg @ref LL_RCC_PLLSOURCE_HSE
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetMainSource(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC));
 8004cc4:	4a1e      	ldr	r2, [pc, #120]	; (8004d40 <RCC_PLL_GetFreqDomain_SYS+0x7c>)
 8004cc6:	68d3      	ldr	r3, [r2, #12]
 8004cc8:	f003 0303 	and.w	r3, r3, #3
  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE/ PLLM) * PLLN
     SYSCLK = PLL_VCO / PLLR
  */
  pllsource = LL_RCC_PLL_GetMainSource();

  switch (pllsource)
 8004ccc:	2b02      	cmp	r3, #2
{
 8004cce:	b510      	push	{r4, lr}
  switch (pllsource)
 8004cd0:	d034      	beq.n	8004d3c <RCC_PLL_GetFreqDomain_SYS+0x78>
 8004cd2:	2b03      	cmp	r3, #3
 8004cd4:	d00b      	beq.n	8004cee <RCC_PLL_GetFreqDomain_SYS+0x2a>
 8004cd6:	491b      	ldr	r1, [pc, #108]	; (8004d44 <RCC_PLL_GetFreqDomain_SYS+0x80>)
    case LL_RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
      pllinputfreq = HSE_VALUE;
      break;

    default:
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8004cd8:	f7ff ffc8 	bl	8004c6c <LL_RCC_MSI_IsEnabledRangeSelect>
 8004cdc:	4604      	mov	r4, r0
 8004cde:	b9f0      	cbnz	r0, 8004d1e <RCC_PLL_GetFreqDomain_SYS+0x5a>
 8004ce0:	f7ff ffc4 	bl	8004c6c <LL_RCC_MSI_IsEnabledRangeSelect>
 8004ce4:	b1b0      	cbz	r0, 8004d14 <RCC_PLL_GetFreqDomain_SYS+0x50>
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8004ce6:	6813      	ldr	r3, [r2, #0]
 8004ce8:	f851 0024 	ldr.w	r0, [r1, r4, lsl #2]
 8004cec:	e000      	b.n	8004cf0 <RCC_PLL_GetFreqDomain_SYS+0x2c>
      pllinputfreq = HSE_VALUE;
 8004cee:	4816      	ldr	r0, [pc, #88]	; (8004d48 <RCC_PLL_GetFreqDomain_SYS+0x84>)
  *
  *         (*) value not defined in all devices.
  */
__STATIC_INLINE uint32_t LL_RCC_PLL_GetDivider(void)
{
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM));
 8004cf0:	68d4      	ldr	r4, [r2, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8004cf2:	68d1      	ldr	r1, [r2, #12]
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR));
 8004cf4:	68d3      	ldr	r3, [r2, #12]
                                    (LL_RCC_MSI_IsEnabledRangeSelect() ?
                                     LL_RCC_MSI_GetRange() :
                                     LL_RCC_MSI_GetRangeAfterStandby()));
      break;
  }
  return __LL_RCC_CALC_PLLCLK_FREQ(pllinputfreq, LL_RCC_PLL_GetDivider(),
 8004cf6:	f3c4 1202 	ubfx	r2, r4, #4, #3
 8004cfa:	f3c3 6341 	ubfx	r3, r3, #25, #2
 8004cfe:	3201      	adds	r2, #1
 8004d00:	3301      	adds	r3, #1
 8004d02:	fbb0 f0f2 	udiv	r0, r0, r2
  return (uint32_t)(READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >>  RCC_PLLCFGR_PLLN_Pos);
 8004d06:	f3c1 2206 	ubfx	r2, r1, #8, #7
 8004d0a:	4350      	muls	r0, r2
 8004d0c:	005b      	lsls	r3, r3, #1
                                        LL_RCC_PLL_GetN(), LL_RCC_PLL_GetR());
}
 8004d0e:	fbb0 f0f3 	udiv	r0, r0, r3
 8004d12:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8004d14:	f8d2 4094 	ldr.w	r4, [r2, #148]	; 0x94
      pllinputfreq = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8004d18:	f3c4 2403 	ubfx	r4, r4, #8, #4
 8004d1c:	e7e4      	b.n	8004ce8 <RCC_PLL_GetFreqDomain_SYS+0x24>
 8004d1e:	f7ff ffa5 	bl	8004c6c <LL_RCC_MSI_IsEnabledRangeSelect>
 8004d22:	b128      	cbz	r0, 8004d30 <RCC_PLL_GetFreqDomain_SYS+0x6c>
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8004d24:	6813      	ldr	r3, [r2, #0]
 8004d26:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8004d2a:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
 8004d2e:	e7df      	b.n	8004cf0 <RCC_PLL_GetFreqDomain_SYS+0x2c>
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8004d30:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8004d34:	091b      	lsrs	r3, r3, #4
 8004d36:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8004d3a:	e7f6      	b.n	8004d2a <RCC_PLL_GetFreqDomain_SYS+0x66>
      pllinputfreq = HSI_VALUE;
 8004d3c:	4803      	ldr	r0, [pc, #12]	; (8004d4c <RCC_PLL_GetFreqDomain_SYS+0x88>)
 8004d3e:	e7d7      	b.n	8004cf0 <RCC_PLL_GetFreqDomain_SYS+0x2c>
 8004d40:	40021000 	.word	0x40021000
 8004d44:	0800fa38 	.word	0x0800fa38
 8004d48:	007a1200 	.word	0x007a1200
 8004d4c:	00f42400 	.word	0x00f42400

08004d50 <RCC_GetSystemClockFreq>:
  return (uint32_t)(READ_BIT(RCC->CFGR, RCC_CFGR_SWS));
 8004d50:	4a1b      	ldr	r2, [pc, #108]	; (8004dc0 <RCC_GetSystemClockFreq+0x70>)
 8004d52:	6893      	ldr	r3, [r2, #8]
 8004d54:	f003 030c 	and.w	r3, r3, #12
{
 8004d58:	b510      	push	{r4, lr}
  switch (LL_RCC_GetSysClkSource())
 8004d5a:	2b0c      	cmp	r3, #12
 8004d5c:	d80e      	bhi.n	8004d7c <RCC_GetSystemClockFreq+0x2c>
 8004d5e:	e8df f003 	tbb	[pc, r3]
 8004d62:	0d0d      	.short	0x0d0d
 8004d64:	0d2d0d0d 	.word	0x0d2d0d0d
 8004d68:	0d070d0d 	.word	0x0d070d0d
 8004d6c:	0d0d      	.short	0x0d0d
 8004d6e:	09          	.byte	0x09
 8004d6f:	00          	.byte	0x00
      frequency = HSE_VALUE;
 8004d70:	4814      	ldr	r0, [pc, #80]	; (8004dc4 <RCC_GetSystemClockFreq+0x74>)
 8004d72:	bd10      	pop	{r4, pc}
}
 8004d74:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      frequency = RCC_PLL_GetFreqDomain_SYS();
 8004d78:	f7ff bfa4 	b.w	8004cc4 <RCC_PLL_GetFreqDomain_SYS>
      frequency = __LL_RCC_CALC_MSI_FREQ(LL_RCC_MSI_IsEnabledRangeSelect(),
 8004d7c:	f7ff ff76 	bl	8004c6c <LL_RCC_MSI_IsEnabledRangeSelect>
 8004d80:	4c11      	ldr	r4, [pc, #68]	; (8004dc8 <RCC_GetSystemClockFreq+0x78>)
 8004d82:	4601      	mov	r1, r0
 8004d84:	b958      	cbnz	r0, 8004d9e <RCC_GetSystemClockFreq+0x4e>
 8004d86:	f7ff ff71 	bl	8004c6c <LL_RCC_MSI_IsEnabledRangeSelect>
 8004d8a:	b118      	cbz	r0, 8004d94 <RCC_GetSystemClockFreq+0x44>
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8004d8c:	6813      	ldr	r3, [r2, #0]
 8004d8e:	f854 0021 	ldr.w	r0, [r4, r1, lsl #2]
 8004d92:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8004d94:	f8d2 1094 	ldr.w	r1, [r2, #148]	; 0x94
 8004d98:	f3c1 2103 	ubfx	r1, r1, #8, #4
 8004d9c:	e7f7      	b.n	8004d8e <RCC_GetSystemClockFreq+0x3e>
 8004d9e:	f7ff ff65 	bl	8004c6c <LL_RCC_MSI_IsEnabledRangeSelect>
 8004da2:	b128      	cbz	r0, 8004db0 <RCC_GetSystemClockFreq+0x60>
  return (uint32_t)(READ_BIT(RCC->CR, RCC_CR_MSIRANGE));
 8004da4:	6813      	ldr	r3, [r2, #0]
 8004da6:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8004daa:	f854 0023 	ldr.w	r0, [r4, r3, lsl #2]
 8004dae:	bd10      	pop	{r4, pc}
  return (uint32_t)(READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE));
 8004db0:	f8d2 3094 	ldr.w	r3, [r2, #148]	; 0x94
 8004db4:	091b      	lsrs	r3, r3, #4
 8004db6:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8004dba:	e7f6      	b.n	8004daa <RCC_GetSystemClockFreq+0x5a>
      frequency = HSI_VALUE;
 8004dbc:	4803      	ldr	r0, [pc, #12]	; (8004dcc <RCC_GetSystemClockFreq+0x7c>)
}
 8004dbe:	bd10      	pop	{r4, pc}
 8004dc0:	40021000 	.word	0x40021000
 8004dc4:	007a1200 	.word	0x007a1200
 8004dc8:	0800fa38 	.word	0x0800fa38
 8004dcc:	00f42400 	.word	0x00f42400

08004dd0 <LL_RCC_GetUSARTClockFreq>:
  if (USARTxSource == LL_RCC_USART1_CLKSOURCE)
 8004dd0:	2803      	cmp	r0, #3
{
 8004dd2:	b508      	push	{r3, lr}
  if (USARTxSource == LL_RCC_USART1_CLKSOURCE)
 8004dd4:	d129      	bne.n	8004e2a <LL_RCC_GetUSARTClockFreq+0x5a>
  return (uint32_t)(READ_BIT(RCC->CCIPR, UARTx) | (UARTx << 16U));
 8004dd6:	4b2a      	ldr	r3, [pc, #168]	; (8004e80 <LL_RCC_GetUSARTClockFreq+0xb0>)
    switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 8004dd8:	4a2a      	ldr	r2, [pc, #168]	; (8004e84 <LL_RCC_GetUSARTClockFreq+0xb4>)
 8004dda:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004dde:	f003 0303 	and.w	r3, r3, #3
 8004de2:	f443 3340 	orr.w	r3, r3, #196608	; 0x30000
 8004de6:	4293      	cmp	r3, r2
 8004de8:	d009      	beq.n	8004dfe <LL_RCC_GetUSARTClockFreq+0x2e>
 8004dea:	f1b3 1f03 	cmp.w	r3, #196611	; 0x30003
 8004dee:	d00d      	beq.n	8004e0c <LL_RCC_GetUSARTClockFreq+0x3c>
 8004df0:	3a01      	subs	r2, #1
 8004df2:	4293      	cmp	r3, r2
 8004df4:	d111      	bne.n	8004e1a <LL_RCC_GetUSARTClockFreq+0x4a>
}
 8004df6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
          usart_frequency = RCC_GetSystemClockFreq();
 8004dfa:	f7ff bfa9 	b.w	8004d50 <RCC_GetSystemClockFreq>
        if (LL_RCC_HSI_IsReady())
 8004dfe:	f7ff ff25 	bl	8004c4c <LL_RCC_HSI_IsReady>
 8004e02:	b908      	cbnz	r0, 8004e08 <LL_RCC_GetUSARTClockFreq+0x38>
  uint32_t usart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
 8004e04:	2000      	movs	r0, #0
 8004e06:	bd08      	pop	{r3, pc}
          usart_frequency = HSI_VALUE;
 8004e08:	481f      	ldr	r0, [pc, #124]	; (8004e88 <LL_RCC_GetUSARTClockFreq+0xb8>)
 8004e0a:	bd08      	pop	{r3, pc}
        if (LL_RCC_LSE_IsReady())
 8004e0c:	f7ff ff26 	bl	8004c5c <LL_RCC_LSE_IsReady>
 8004e10:	2800      	cmp	r0, #0
 8004e12:	d0f7      	beq.n	8004e04 <LL_RCC_GetUSARTClockFreq+0x34>
          usart_frequency = LSE_VALUE;
 8004e14:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8004e18:	bd08      	pop	{r3, pc}
        usart_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
 8004e1a:	f7ff ff99 	bl	8004d50 <RCC_GetSystemClockFreq>
 8004e1e:	f7ff ff2d 	bl	8004c7c <RCC_GetHCLKClockFreq>
}
 8004e22:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        usart_frequency = RCC_GetPCLK2ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
 8004e26:	f7ff bf41 	b.w	8004cac <RCC_GetPCLK2ClockFreq>
  else if (USARTxSource == LL_RCC_USART2_CLKSOURCE)
 8004e2a:	280c      	cmp	r0, #12
 8004e2c:	d117      	bne.n	8004e5e <LL_RCC_GetUSARTClockFreq+0x8e>
 8004e2e:	4b14      	ldr	r3, [pc, #80]	; (8004e80 <LL_RCC_GetUSARTClockFreq+0xb0>)
    switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 8004e30:	4a16      	ldr	r2, [pc, #88]	; (8004e8c <LL_RCC_GetUSARTClockFreq+0xbc>)
 8004e32:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004e36:	f003 030c 	and.w	r3, r3, #12
 8004e3a:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8004e3e:	4293      	cmp	r3, r2
 8004e40:	d0dd      	beq.n	8004dfe <LL_RCC_GetUSARTClockFreq+0x2e>
 8004e42:	f1b3 1f0c 	cmp.w	r3, #786444	; 0xc000c
 8004e46:	d0e1      	beq.n	8004e0c <LL_RCC_GetUSARTClockFreq+0x3c>
 8004e48:	3a04      	subs	r2, #4
      switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 8004e4a:	4293      	cmp	r3, r2
 8004e4c:	d0d3      	beq.n	8004df6 <LL_RCC_GetUSARTClockFreq+0x26>
          usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
 8004e4e:	f7ff ff7f 	bl	8004d50 <RCC_GetSystemClockFreq>
 8004e52:	f7ff ff13 	bl	8004c7c <RCC_GetHCLKClockFreq>
}
 8004e56:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
          usart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
 8004e5a:	f7ff bf1b 	b.w	8004c94 <RCC_GetPCLK1ClockFreq>
    if (USARTxSource == LL_RCC_USART3_CLKSOURCE)
 8004e5e:	2830      	cmp	r0, #48	; 0x30
 8004e60:	d1d0      	bne.n	8004e04 <LL_RCC_GetUSARTClockFreq+0x34>
 8004e62:	4b07      	ldr	r3, [pc, #28]	; (8004e80 <LL_RCC_GetUSARTClockFreq+0xb0>)
      switch (LL_RCC_GetUSARTClockSource(USARTxSource))
 8004e64:	4a0a      	ldr	r2, [pc, #40]	; (8004e90 <LL_RCC_GetUSARTClockFreq+0xc0>)
 8004e66:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004e6a:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8004e6e:	f443 1340 	orr.w	r3, r3, #3145728	; 0x300000
 8004e72:	4293      	cmp	r3, r2
 8004e74:	d0c3      	beq.n	8004dfe <LL_RCC_GetUSARTClockFreq+0x2e>
 8004e76:	f1b3 1f30 	cmp.w	r3, #3145776	; 0x300030
 8004e7a:	d0c7      	beq.n	8004e0c <LL_RCC_GetUSARTClockFreq+0x3c>
 8004e7c:	3a10      	subs	r2, #16
 8004e7e:	e7e4      	b.n	8004e4a <LL_RCC_GetUSARTClockFreq+0x7a>
 8004e80:	40021000 	.word	0x40021000
 8004e84:	00030002 	.word	0x00030002
 8004e88:	00f42400 	.word	0x00f42400
 8004e8c:	000c0008 	.word	0x000c0008
 8004e90:	00300020 	.word	0x00300020

08004e94 <LL_RCC_GetUARTClockFreq>:
  if (UARTxSource == LL_RCC_UART4_CLKSOURCE)
 8004e94:	28c0      	cmp	r0, #192	; 0xc0
{
 8004e96:	b508      	push	{r3, lr}
  if (UARTxSource == LL_RCC_UART4_CLKSOURCE)
 8004e98:	d001      	beq.n	8004e9e <LL_RCC_GetUARTClockFreq+0xa>
  uint32_t uart_frequency = LL_RCC_PERIPH_FREQUENCY_NO;
 8004e9a:	2000      	movs	r0, #0
 8004e9c:	bd08      	pop	{r3, pc}
 8004e9e:	4b14      	ldr	r3, [pc, #80]	; (8004ef0 <LL_RCC_GetUARTClockFreq+0x5c>)
    switch (LL_RCC_GetUARTClockSource(UARTxSource))
 8004ea0:	4a14      	ldr	r2, [pc, #80]	; (8004ef4 <LL_RCC_GetUARTClockFreq+0x60>)
 8004ea2:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8004ea6:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 8004eaa:	f443 0340 	orr.w	r3, r3, #12582912	; 0xc00000
 8004eae:	4293      	cmp	r3, r2
 8004eb0:	d009      	beq.n	8004ec6 <LL_RCC_GetUARTClockFreq+0x32>
 8004eb2:	f1b3 1fc0 	cmp.w	r3, #12583104	; 0xc000c0
 8004eb6:	d00c      	beq.n	8004ed2 <LL_RCC_GetUARTClockFreq+0x3e>
 8004eb8:	3a40      	subs	r2, #64	; 0x40
 8004eba:	4293      	cmp	r3, r2
 8004ebc:	d110      	bne.n	8004ee0 <LL_RCC_GetUARTClockFreq+0x4c>
}
 8004ebe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        uart_frequency = RCC_GetSystemClockFreq();
 8004ec2:	f7ff bf45 	b.w	8004d50 <RCC_GetSystemClockFreq>
        if (LL_RCC_HSI_IsReady())
 8004ec6:	f7ff fec1 	bl	8004c4c <LL_RCC_HSI_IsReady>
 8004eca:	2800      	cmp	r0, #0
 8004ecc:	d0e5      	beq.n	8004e9a <LL_RCC_GetUARTClockFreq+0x6>
          uart_frequency = HSI_VALUE;
 8004ece:	480a      	ldr	r0, [pc, #40]	; (8004ef8 <LL_RCC_GetUARTClockFreq+0x64>)
 8004ed0:	bd08      	pop	{r3, pc}
        if (LL_RCC_LSE_IsReady())
 8004ed2:	f7ff fec3 	bl	8004c5c <LL_RCC_LSE_IsReady>
 8004ed6:	2800      	cmp	r0, #0
 8004ed8:	d0df      	beq.n	8004e9a <LL_RCC_GetUARTClockFreq+0x6>
          uart_frequency = LSE_VALUE;
 8004eda:	f44f 4000 	mov.w	r0, #32768	; 0x8000
}
 8004ede:	bd08      	pop	{r3, pc}
        uart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
 8004ee0:	f7ff ff36 	bl	8004d50 <RCC_GetSystemClockFreq>
 8004ee4:	f7ff feca 	bl	8004c7c <RCC_GetHCLKClockFreq>
}
 8004ee8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
        uart_frequency = RCC_GetPCLK1ClockFreq(RCC_GetHCLKClockFreq(RCC_GetSystemClockFreq()));
 8004eec:	f7ff bed2 	b.w	8004c94 <RCC_GetPCLK1ClockFreq>
 8004ef0:	40021000 	.word	0x40021000
 8004ef4:	00c00080 	.word	0x00c00080
 8004ef8:	00f42400 	.word	0x00f42400

08004efc <SDMMC_GetCmdResp2>:
  */
static uint32_t SDMMC_GetCmdResp2(SDMMC_TypeDef *SDMMCx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8004efc:	4b11      	ldr	r3, [pc, #68]	; (8004f44 <SDMMC_GetCmdResp2+0x48>)
 8004efe:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8004f02:	681b      	ldr	r3, [r3, #0]
 8004f04:	fbb3 f2f2 	udiv	r2, r3, r2
 8004f08:	f241 3388 	movw	r3, #5000	; 0x1388
 8004f0c:	4353      	muls	r3, r2
  
  do
  {
    if (count-- == 0U)
 8004f0e:	f113 33ff 	adds.w	r3, r3, #4294967295
 8004f12:	d313      	bcc.n	8004f3c <SDMMC_GetCmdResp2+0x40>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT));
 8004f14:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004f16:	f012 0f45 	tst.w	r2, #69	; 0x45
 8004f1a:	d0f8      	beq.n	8004f0e <SDMMC_GetCmdResp2+0x12>
    
  if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8004f1c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8004f1e:	075b      	lsls	r3, r3, #29
 8004f20:	d503      	bpl.n	8004f2a <SDMMC_GetCmdResp2+0x2e>
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8004f22:	2304      	movs	r3, #4
    
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8004f24:	6383      	str	r3, [r0, #56]	; 0x38
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
  }

  return SDMMC_ERROR_NONE;
}
 8004f26:	4618      	mov	r0, r3
 8004f28:	4770      	bx	lr
  else if (__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8004f2a:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8004f2c:	f013 0301 	ands.w	r3, r3, #1
 8004f30:	d001      	beq.n	8004f36 <SDMMC_GetCmdResp2+0x3a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8004f32:	2301      	movs	r3, #1
 8004f34:	e7f6      	b.n	8004f24 <SDMMC_GetCmdResp2+0x28>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8004f36:	22c5      	movs	r2, #197	; 0xc5
 8004f38:	6382      	str	r2, [r0, #56]	; 0x38
 8004f3a:	e7f4      	b.n	8004f26 <SDMMC_GetCmdResp2+0x2a>
      return SDMMC_ERROR_TIMEOUT;
 8004f3c:	f04f 4300 	mov.w	r3, #2147483648	; 0x80000000
 8004f40:	e7f1      	b.n	8004f26 <SDMMC_GetCmdResp2+0x2a>
 8004f42:	bf00      	nop
 8004f44:	20000024 	.word	0x20000024

08004f48 <SDMMC_GetCmdResp3>:
  */
static uint32_t SDMMC_GetCmdResp3(SDMMC_TypeDef *SDMMCx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8004f48:	4b0e      	ldr	r3, [pc, #56]	; (8004f84 <SDMMC_GetCmdResp3+0x3c>)
 8004f4a:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8004f4e:	681b      	ldr	r3, [r3, #0]
 8004f50:	fbb3 f2f2 	udiv	r2, r3, r2
 8004f54:	f241 3388 	movw	r3, #5000	; 0x1388
 8004f58:	4353      	muls	r3, r2
  
  do
  {
    if (count-- == 0U)
 8004f5a:	f113 33ff 	adds.w	r3, r3, #4294967295
 8004f5e:	d30d      	bcc.n	8004f7c <SDMMC_GetCmdResp3+0x34>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT));
 8004f60:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8004f62:	f012 0f45 	tst.w	r2, #69	; 0x45
 8004f66:	d0f8      	beq.n	8004f5a <SDMMC_GetCmdResp3+0x12>
  
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8004f68:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8004f6a:	f013 0304 	ands.w	r3, r3, #4
  {
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8004f6e:	bf15      	itete	ne
 8004f70:	2304      	movne	r3, #4
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
  }
  else
  {  
    /* Clear all the static flags */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8004f72:	22c5      	moveq	r2, #197	; 0xc5
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8004f74:	6383      	strne	r3, [r0, #56]	; 0x38
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8004f76:	6382      	streq	r2, [r0, #56]	; 0x38
  }
  
  return SDMMC_ERROR_NONE;
 8004f78:	4618      	mov	r0, r3
 8004f7a:	4770      	bx	lr
      return SDMMC_ERROR_TIMEOUT;
 8004f7c:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
}
 8004f80:	4770      	bx	lr
 8004f82:	bf00      	nop
 8004f84:	20000024 	.word	0x20000024

08004f88 <SDMMC_GetCmdResp1>:
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8004f88:	4b43      	ldr	r3, [pc, #268]	; (8005098 <SDMMC_GetCmdResp1+0x110>)
{
 8004f8a:	b510      	push	{r4, lr}
  register uint32_t count = Timeout * (SystemCoreClock / 8U /1000U);
 8004f8c:	681b      	ldr	r3, [r3, #0]
 8004f8e:	f44f 54fa 	mov.w	r4, #8000	; 0x1f40
 8004f92:	fbb3 f3f4 	udiv	r3, r3, r4
 8004f96:	435a      	muls	r2, r3
    if (count-- == 0U)
 8004f98:	2a00      	cmp	r2, #0
 8004f9a:	d048      	beq.n	800502e <SDMMC_GetCmdResp1+0xa6>
  }while(!__SDMMC_GET_FLAG(SDMMCx, flags));
 8004f9c:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8004f9e:	f013 0f45 	tst.w	r3, #69	; 0x45
 8004fa2:	f102 32ff 	add.w	r2, r2, #4294967295
 8004fa6:	d0f7      	beq.n	8004f98 <SDMMC_GetCmdResp1+0x10>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8004fa8:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8004faa:	075b      	lsls	r3, r3, #29
 8004fac:	d503      	bpl.n	8004fb6 <SDMMC_GetCmdResp1+0x2e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8004fae:	2304      	movs	r3, #4
 8004fb0:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_RSP_TIMEOUT;
 8004fb2:	4618      	mov	r0, r3
 8004fb4:	bd10      	pop	{r4, pc}
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 8004fb6:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8004fb8:	07dc      	lsls	r4, r3, #31
 8004fba:	d503      	bpl.n	8004fc4 <SDMMC_GetCmdResp1+0x3c>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8004fbc:	2301      	movs	r3, #1
 8004fbe:	6383      	str	r3, [r0, #56]	; 0x38
    return SDMMC_ERROR_CMD_CRC_FAIL;
 8004fc0:	2001      	movs	r0, #1
 8004fc2:	bd10      	pop	{r4, pc}
  return (uint8_t)(SDMMCx->RESPCMD);
 8004fc4:	6903      	ldr	r3, [r0, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8004fc6:	b2db      	uxtb	r3, r3
 8004fc8:	4299      	cmp	r1, r3
 8004fca:	d1f9      	bne.n	8004fc0 <SDMMC_GetCmdResp1+0x38>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 8004fcc:	23c5      	movs	r3, #197	; 0xc5
 8004fce:	6383      	str	r3, [r0, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
 8004fd0:	6943      	ldr	r3, [r0, #20]
  if((response_r1 & SDMMC_OCR_ERRORBITS) == SDMMC_ALLZERO)
 8004fd2:	4832      	ldr	r0, [pc, #200]	; (800509c <SDMMC_GetCmdResp1+0x114>)
 8004fd4:	4018      	ands	r0, r3
 8004fd6:	2800      	cmp	r0, #0
 8004fd8:	d05c      	beq.n	8005094 <SDMMC_GetCmdResp1+0x10c>
  else if((response_r1 & SDMMC_OCR_ADDR_OUT_OF_RANGE) == SDMMC_OCR_ADDR_OUT_OF_RANGE)
 8004fda:	2b00      	cmp	r3, #0
 8004fdc:	db2a      	blt.n	8005034 <SDMMC_GetCmdResp1+0xac>
  else if((response_r1 & SDMMC_OCR_ADDR_MISALIGNED) == SDMMC_OCR_ADDR_MISALIGNED)
 8004fde:	005a      	lsls	r2, r3, #1
 8004fe0:	d42b      	bmi.n	800503a <SDMMC_GetCmdResp1+0xb2>
  else if((response_r1 & SDMMC_OCR_BLOCK_LEN_ERR) == SDMMC_OCR_BLOCK_LEN_ERR)
 8004fe2:	009c      	lsls	r4, r3, #2
 8004fe4:	d42b      	bmi.n	800503e <SDMMC_GetCmdResp1+0xb6>
  else if((response_r1 & SDMMC_OCR_ERASE_SEQ_ERR) == SDMMC_OCR_ERASE_SEQ_ERR)
 8004fe6:	00d9      	lsls	r1, r3, #3
 8004fe8:	d42b      	bmi.n	8005042 <SDMMC_GetCmdResp1+0xba>
  else if((response_r1 & SDMMC_OCR_BAD_ERASE_PARAM) == SDMMC_OCR_BAD_ERASE_PARAM)
 8004fea:	011a      	lsls	r2, r3, #4
 8004fec:	d42c      	bmi.n	8005048 <SDMMC_GetCmdResp1+0xc0>
  else if((response_r1 & SDMMC_OCR_WRITE_PROT_VIOLATION) == SDMMC_OCR_WRITE_PROT_VIOLATION)
 8004fee:	015c      	lsls	r4, r3, #5
 8004ff0:	d42d      	bmi.n	800504e <SDMMC_GetCmdResp1+0xc6>
  else if((response_r1 & SDMMC_OCR_LOCK_UNLOCK_FAILED) == SDMMC_OCR_LOCK_UNLOCK_FAILED)
 8004ff2:	01d9      	lsls	r1, r3, #7
 8004ff4:	d42e      	bmi.n	8005054 <SDMMC_GetCmdResp1+0xcc>
  else if((response_r1 & SDMMC_OCR_COM_CRC_FAILED) == SDMMC_OCR_COM_CRC_FAILED)
 8004ff6:	021a      	lsls	r2, r3, #8
 8004ff8:	d42f      	bmi.n	800505a <SDMMC_GetCmdResp1+0xd2>
  else if((response_r1 & SDMMC_OCR_ILLEGAL_CMD) == SDMMC_OCR_ILLEGAL_CMD)
 8004ffa:	025c      	lsls	r4, r3, #9
 8004ffc:	d430      	bmi.n	8005060 <SDMMC_GetCmdResp1+0xd8>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_FAILED) == SDMMC_OCR_CARD_ECC_FAILED)
 8004ffe:	0299      	lsls	r1, r3, #10
 8005000:	d431      	bmi.n	8005066 <SDMMC_GetCmdResp1+0xde>
  else if((response_r1 & SDMMC_OCR_CC_ERROR) == SDMMC_OCR_CC_ERROR)
 8005002:	02da      	lsls	r2, r3, #11
 8005004:	d432      	bmi.n	800506c <SDMMC_GetCmdResp1+0xe4>
  else if((response_r1 & SDMMC_OCR_STREAM_READ_UNDERRUN) == SDMMC_OCR_STREAM_READ_UNDERRUN)
 8005006:	035c      	lsls	r4, r3, #13
 8005008:	d433      	bmi.n	8005072 <SDMMC_GetCmdResp1+0xea>
  else if((response_r1 & SDMMC_OCR_STREAM_WRITE_OVERRUN) == SDMMC_OCR_STREAM_WRITE_OVERRUN)
 800500a:	0399      	lsls	r1, r3, #14
 800500c:	d434      	bmi.n	8005078 <SDMMC_GetCmdResp1+0xf0>
  else if((response_r1 & SDMMC_OCR_CID_CSD_OVERWRITE) == SDMMC_OCR_CID_CSD_OVERWRITE)
 800500e:	03da      	lsls	r2, r3, #15
 8005010:	d435      	bmi.n	800507e <SDMMC_GetCmdResp1+0xf6>
  else if((response_r1 & SDMMC_OCR_WP_ERASE_SKIP) == SDMMC_OCR_WP_ERASE_SKIP)
 8005012:	041c      	lsls	r4, r3, #16
 8005014:	d436      	bmi.n	8005084 <SDMMC_GetCmdResp1+0xfc>
  else if((response_r1 & SDMMC_OCR_CARD_ECC_DISABLED) == SDMMC_OCR_CARD_ECC_DISABLED)
 8005016:	0459      	lsls	r1, r3, #17
 8005018:	d437      	bmi.n	800508a <SDMMC_GetCmdResp1+0x102>
  else if((response_r1 & SDMMC_OCR_ERASE_RESET) == SDMMC_OCR_ERASE_RESET)
 800501a:	049a      	lsls	r2, r3, #18
 800501c:	d438      	bmi.n	8005090 <SDMMC_GetCmdResp1+0x108>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 800501e:	f013 0f08 	tst.w	r3, #8
 8005022:	bf14      	ite	ne
 8005024:	f44f 0000 	movne.w	r0, #8388608	; 0x800000
 8005028:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 800502c:	bd10      	pop	{r4, pc}
      return SDMMC_ERROR_TIMEOUT;
 800502e:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 8005032:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_ADDR_OUT_OF_RANGE;
 8005034:	f04f 7000 	mov.w	r0, #33554432	; 0x2000000
 8005038:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_ADDR_MISALIGNED;
 800503a:	2040      	movs	r0, #64	; 0x40
 800503c:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_BLOCK_LEN_ERR;
 800503e:	2080      	movs	r0, #128	; 0x80
 8005040:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_ERASE_SEQ_ERR;
 8005042:	f44f 7080 	mov.w	r0, #256	; 0x100
 8005046:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_BAD_ERASE_PARAM;
 8005048:	f44f 7000 	mov.w	r0, #512	; 0x200
 800504c:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_WRITE_PROT_VIOLATION;
 800504e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8005052:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_LOCK_UNLOCK_FAILED;
 8005054:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8005058:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_COM_CRC_FAILED;
 800505a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800505e:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_ILLEGAL_CMD;
 8005060:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8005064:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_CARD_ECC_FAILED;
 8005066:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800506a:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_CC_ERR;
 800506c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8005070:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_STREAM_READ_UNDERRUN;
 8005072:	f44f 3000 	mov.w	r0, #131072	; 0x20000
 8005076:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_STREAM_WRITE_OVERRUN;
 8005078:	f44f 2080 	mov.w	r0, #262144	; 0x40000
 800507c:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_CID_CSD_OVERWRITE;
 800507e:	f44f 2000 	mov.w	r0, #524288	; 0x80000
 8005082:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_WP_ERASE_SKIP;
 8005084:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 8005088:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_CARD_ECC_DISABLED;
 800508a:	f44f 1000 	mov.w	r0, #2097152	; 0x200000
 800508e:	bd10      	pop	{r4, pc}
    return SDMMC_ERROR_ERASE_RESET;
 8005090:	f44f 0080 	mov.w	r0, #4194304	; 0x400000
}
 8005094:	bd10      	pop	{r4, pc}
 8005096:	bf00      	nop
 8005098:	20000024 	.word	0x20000024
 800509c:	fdffe008 	.word	0xfdffe008

080050a0 <SDMMC_Init>:
{
 80050a0:	b084      	sub	sp, #16
 80050a2:	b510      	push	{r4, lr}
 80050a4:	ac03      	add	r4, sp, #12
 80050a6:	e884 000e 	stmia.w	r4, {r1, r2, r3}
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, Init.ClockEdge           |\
 80050aa:	9904      	ldr	r1, [sp, #16]
 80050ac:	9b03      	ldr	r3, [sp, #12]
 80050ae:	6842      	ldr	r2, [r0, #4]
 80050b0:	430b      	orrs	r3, r1
 80050b2:	9905      	ldr	r1, [sp, #20]
 80050b4:	430b      	orrs	r3, r1
 80050b6:	9906      	ldr	r1, [sp, #24]
 80050b8:	430b      	orrs	r3, r1
 80050ba:	9907      	ldr	r1, [sp, #28]
 80050bc:	430b      	orrs	r3, r1
 80050be:	9908      	ldr	r1, [sp, #32]
}
 80050c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  MODIFY_REG(SDMMCx->CLKCR, CLKCR_CLEAR_MASK, Init.ClockEdge           |\
 80050c4:	f422 42fd 	bic.w	r2, r2, #32384	; 0x7e80
 80050c8:	430b      	orrs	r3, r1
 80050ca:	f022 027f 	bic.w	r2, r2, #127	; 0x7f
 80050ce:	4313      	orrs	r3, r2
 80050d0:	6043      	str	r3, [r0, #4]
}
 80050d2:	b004      	add	sp, #16
 80050d4:	2000      	movs	r0, #0
 80050d6:	4770      	bx	lr

080050d8 <SDMMC_ReadFIFO>:
 80050d8:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 80050dc:	4770      	bx	lr

080050de <SDMMC_WriteFIFO>:
  SDMMCx->FIFO = *pWriteData;
 80050de:	680b      	ldr	r3, [r1, #0]
 80050e0:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
}
 80050e4:	2000      	movs	r0, #0
 80050e6:	4770      	bx	lr

080050e8 <SDMMC_PowerState_ON>:
  SDMMCx->POWER = SDMMC_POWER_PWRCTRL;
 80050e8:	2303      	movs	r3, #3
 80050ea:	6003      	str	r3, [r0, #0]
}
 80050ec:	2000      	movs	r0, #0
 80050ee:	4770      	bx	lr

080050f0 <SDMMC_GetPowerState>:
  return (SDMMCx->POWER & SDMMC_POWER_PWRCTRL);
 80050f0:	6800      	ldr	r0, [r0, #0]
}
 80050f2:	f000 0003 	and.w	r0, r0, #3
 80050f6:	4770      	bx	lr

080050f8 <SDMMC_SendCommand>:
  SDMMCx->ARG = Command->Argument;
 80050f8:	680b      	ldr	r3, [r1, #0]
 80050fa:	6083      	str	r3, [r0, #8]
  MODIFY_REG(SDMMCx->CMD, CMD_CLEAR_MASK, Command->CmdIndex         |\
 80050fc:	68c3      	ldr	r3, [r0, #12]
 80050fe:	684a      	ldr	r2, [r1, #4]
 8005100:	f423 637f 	bic.w	r3, r3, #4080	; 0xff0
 8005104:	f023 030f 	bic.w	r3, r3, #15
 8005108:	4313      	orrs	r3, r2
 800510a:	688a      	ldr	r2, [r1, #8]
 800510c:	4313      	orrs	r3, r2
 800510e:	68ca      	ldr	r2, [r1, #12]
 8005110:	4313      	orrs	r3, r2
 8005112:	690a      	ldr	r2, [r1, #16]
 8005114:	4313      	orrs	r3, r2
 8005116:	60c3      	str	r3, [r0, #12]
}
 8005118:	2000      	movs	r0, #0
 800511a:	4770      	bx	lr

0800511c <SDMMC_GetResponse>:
  tmp = (uint32_t)(&(SDMMCx->RESP1)) + Response;
 800511c:	3014      	adds	r0, #20
  return (*(__IO uint32_t *) tmp);
 800511e:	5840      	ldr	r0, [r0, r1]
}  
 8005120:	4770      	bx	lr

08005122 <SDMMC_ConfigData>:
  SDMMCx->DTIMER = Data->DataTimeOut;
 8005122:	680b      	ldr	r3, [r1, #0]
 8005124:	6243      	str	r3, [r0, #36]	; 0x24
  SDMMCx->DLEN = Data->DataLength;
 8005126:	684b      	ldr	r3, [r1, #4]
 8005128:	6283      	str	r3, [r0, #40]	; 0x28
  MODIFY_REG(SDMMCx->DCTRL, DCTRL_CLEAR_MASK, Data->DataBlockSize |\
 800512a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 800512c:	688a      	ldr	r2, [r1, #8]
 800512e:	f023 03f7 	bic.w	r3, r3, #247	; 0xf7
 8005132:	4313      	orrs	r3, r2
 8005134:	68ca      	ldr	r2, [r1, #12]
 8005136:	4313      	orrs	r3, r2
 8005138:	690a      	ldr	r2, [r1, #16]
 800513a:	4313      	orrs	r3, r2
 800513c:	694a      	ldr	r2, [r1, #20]
 800513e:	4313      	orrs	r3, r2
 8005140:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 8005142:	2000      	movs	r0, #0
 8005144:	4770      	bx	lr

08005146 <SDMMC_CmdBlockLength>:
{
 8005146:	b530      	push	{r4, r5, lr}
 8005148:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800514a:	2340      	movs	r3, #64	; 0x40
 800514c:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800514e:	2300      	movs	r3, #0
{
 8005150:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)BlockSize;
 8005152:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 8005154:	2410      	movs	r4, #16
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8005156:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005158:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800515a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800515e:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_BLOCKLEN;
 8005160:	9402      	str	r4, [sp, #8]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005162:	f7ff ffc9 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SET_BLOCKLEN, SDMMC_CMDTIMEOUT);
 8005166:	f241 3288 	movw	r2, #5000	; 0x1388
 800516a:	4621      	mov	r1, r4
 800516c:	4628      	mov	r0, r5
 800516e:	f7ff ff0b 	bl	8004f88 <SDMMC_GetCmdResp1>
}
 8005172:	b007      	add	sp, #28
 8005174:	bd30      	pop	{r4, r5, pc}

08005176 <SDMMC_CmdReadSingleBlock>:
{
 8005176:	b530      	push	{r4, r5, lr}
 8005178:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800517a:	2340      	movs	r3, #64	; 0x40
 800517c:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800517e:	2300      	movs	r3, #0
{
 8005180:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 8005182:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 8005184:	2411      	movs	r4, #17
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8005186:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005188:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800518a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800518e:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_SINGLE_BLOCK;
 8005190:	9402      	str	r4, [sp, #8]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005192:	f7ff ffb1 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 8005196:	f241 3288 	movw	r2, #5000	; 0x1388
 800519a:	4621      	mov	r1, r4
 800519c:	4628      	mov	r0, r5
 800519e:	f7ff fef3 	bl	8004f88 <SDMMC_GetCmdResp1>
}
 80051a2:	b007      	add	sp, #28
 80051a4:	bd30      	pop	{r4, r5, pc}

080051a6 <SDMMC_CmdReadMultiBlock>:
{
 80051a6:	b530      	push	{r4, r5, lr}
 80051a8:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 80051aa:	2340      	movs	r3, #64	; 0x40
 80051ac:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80051ae:	2300      	movs	r3, #0
{
 80051b0:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)ReadAdd;
 80051b2:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 80051b4:	2412      	movs	r4, #18
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80051b6:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80051b8:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 80051ba:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80051be:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_READ_MULT_BLOCK;
 80051c0:	9402      	str	r4, [sp, #8]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80051c2:	f7ff ff99 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_READ_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 80051c6:	f241 3288 	movw	r2, #5000	; 0x1388
 80051ca:	4621      	mov	r1, r4
 80051cc:	4628      	mov	r0, r5
 80051ce:	f7ff fedb 	bl	8004f88 <SDMMC_GetCmdResp1>
}
 80051d2:	b007      	add	sp, #28
 80051d4:	bd30      	pop	{r4, r5, pc}

080051d6 <SDMMC_CmdWriteSingleBlock>:
{
 80051d6:	b530      	push	{r4, r5, lr}
 80051d8:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 80051da:	2340      	movs	r3, #64	; 0x40
 80051dc:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80051de:	2300      	movs	r3, #0
{
 80051e0:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 80051e2:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 80051e4:	2418      	movs	r4, #24
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80051e6:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80051e8:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 80051ea:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80051ee:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_SINGLE_BLOCK;
 80051f0:	9402      	str	r4, [sp, #8]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80051f2:	f7ff ff81 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_SINGLE_BLOCK, SDMMC_CMDTIMEOUT);
 80051f6:	f241 3288 	movw	r2, #5000	; 0x1388
 80051fa:	4621      	mov	r1, r4
 80051fc:	4628      	mov	r0, r5
 80051fe:	f7ff fec3 	bl	8004f88 <SDMMC_GetCmdResp1>
}
 8005202:	b007      	add	sp, #28
 8005204:	bd30      	pop	{r4, r5, pc}

08005206 <SDMMC_CmdWriteMultiBlock>:
{
 8005206:	b530      	push	{r4, r5, lr}
 8005208:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800520a:	2340      	movs	r3, #64	; 0x40
 800520c:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800520e:	2300      	movs	r3, #0
{
 8005210:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)WriteAdd;
 8005212:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 8005214:	2419      	movs	r4, #25
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8005216:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005218:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800521a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800521e:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_WRITE_MULT_BLOCK;
 8005220:	9402      	str	r4, [sp, #8]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005222:	f7ff ff69 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_WRITE_MULT_BLOCK, SDMMC_CMDTIMEOUT);
 8005226:	f241 3288 	movw	r2, #5000	; 0x1388
 800522a:	4621      	mov	r1, r4
 800522c:	4628      	mov	r0, r5
 800522e:	f7ff feab 	bl	8004f88 <SDMMC_GetCmdResp1>
}
 8005232:	b007      	add	sp, #28
 8005234:	bd30      	pop	{r4, r5, pc}
	...

08005238 <SDMMC_CmdStopTransfer>:
{
 8005238:	b530      	push	{r4, r5, lr}
 800523a:	b087      	sub	sp, #28
  sdmmc_cmdinit.Argument         = 0;
 800523c:	2300      	movs	r3, #0
{
 800523e:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = 0;
 8005240:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 8005242:	240c      	movs	r4, #12
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8005244:	2240      	movs	r2, #64	; 0x40
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8005246:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005248:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800524a:	f44f 6380 	mov.w	r3, #1024	; 0x400
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800524e:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8005250:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_STOP_TRANSMISSION;
 8005252:	9402      	str	r4, [sp, #8]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005254:	f7ff ff50 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_STOP_TRANSMISSION, SDMMC_STOPTRANSFERTIMEOUT);
 8005258:	4a03      	ldr	r2, [pc, #12]	; (8005268 <SDMMC_CmdStopTransfer+0x30>)
 800525a:	4621      	mov	r1, r4
 800525c:	4628      	mov	r0, r5
 800525e:	f7ff fe93 	bl	8004f88 <SDMMC_GetCmdResp1>
}
 8005262:	b007      	add	sp, #28
 8005264:	bd30      	pop	{r4, r5, pc}
 8005266:	bf00      	nop
 8005268:	05f5e100 	.word	0x05f5e100

0800526c <SDMMC_CmdSelDesel>:
{
 800526c:	b530      	push	{r4, r5, lr}
 800526e:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8005270:	2340      	movs	r3, #64	; 0x40
 8005272:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8005274:	2300      	movs	r3, #0
{
 8005276:	4605      	mov	r5, r0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 8005278:	2407      	movs	r4, #7
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800527a:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800527c:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800527e:	f44f 6380 	mov.w	r3, #1024	; 0x400
  sdmmc_cmdinit.Argument         = (uint32_t)Addr;
 8005282:	9201      	str	r2, [sp, #4]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8005284:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEL_DESEL_CARD;
 8005286:	9402      	str	r4, [sp, #8]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005288:	f7ff ff36 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEL_DESEL_CARD, SDMMC_CMDTIMEOUT);
 800528c:	f241 3288 	movw	r2, #5000	; 0x1388
 8005290:	4621      	mov	r1, r4
 8005292:	4628      	mov	r0, r5
 8005294:	f7ff fe78 	bl	8004f88 <SDMMC_GetCmdResp1>
}
 8005298:	b007      	add	sp, #28
 800529a:	bd30      	pop	{r4, r5, pc}

0800529c <SDMMC_CmdGoIdleState>:
{
 800529c:	b510      	push	{r4, lr}
 800529e:	b086      	sub	sp, #24
  sdmmc_cmdinit.Argument         = 0;
 80052a0:	2300      	movs	r3, #0
 80052a2:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_GO_IDLE_STATE;
 80052a4:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_NO;
 80052a6:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80052a8:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80052aa:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 80052ac:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80052b0:	9305      	str	r3, [sp, #20]
{
 80052b2:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80052b4:	f7ff ff20 	bl	80050f8 <SDMMC_SendCommand>
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 80052b8:	4b0b      	ldr	r3, [pc, #44]	; (80052e8 <SDMMC_CmdGoIdleState+0x4c>)
 80052ba:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 80052be:	681b      	ldr	r3, [r3, #0]
 80052c0:	fbb3 f2f2 	udiv	r2, r3, r2
 80052c4:	f241 3388 	movw	r3, #5000	; 0x1388
 80052c8:	4353      	muls	r3, r2
    if (count-- == 0U)
 80052ca:	f113 33ff 	adds.w	r3, r3, #4294967295
 80052ce:	d307      	bcc.n	80052e0 <SDMMC_CmdGoIdleState+0x44>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDSENT));
 80052d0:	6b62      	ldr	r2, [r4, #52]	; 0x34
 80052d2:	0612      	lsls	r2, r2, #24
 80052d4:	d5f9      	bpl.n	80052ca <SDMMC_CmdGoIdleState+0x2e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 80052d6:	23c5      	movs	r3, #197	; 0xc5
 80052d8:	63a3      	str	r3, [r4, #56]	; 0x38
  return SDMMC_ERROR_NONE;
 80052da:	2000      	movs	r0, #0
}
 80052dc:	b006      	add	sp, #24
 80052de:	bd10      	pop	{r4, pc}
      return SDMMC_ERROR_TIMEOUT;
 80052e0:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
  return errorstate;
 80052e4:	e7fa      	b.n	80052dc <SDMMC_CmdGoIdleState+0x40>
 80052e6:	bf00      	nop
 80052e8:	20000024 	.word	0x20000024

080052ec <SDMMC_CmdOperCond>:
{
 80052ec:	b510      	push	{r4, lr}
 80052ee:	b086      	sub	sp, #24
  sdmmc_cmdinit.Argument         = SDMMC_CHECK_PATTERN;
 80052f0:	f44f 73d5 	mov.w	r3, #426	; 0x1aa
 80052f4:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_HS_SEND_EXT_CSD;
 80052f6:	2308      	movs	r3, #8
 80052f8:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 80052fa:	2340      	movs	r3, #64	; 0x40
 80052fc:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80052fe:	2300      	movs	r3, #0
 8005300:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005302:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8005304:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005308:	9305      	str	r3, [sp, #20]
{
 800530a:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800530c:	f7ff fef4 	bl	80050f8 <SDMMC_SendCommand>
  */
static uint32_t SDMMC_GetCmdResp7(SDMMC_TypeDef *SDMMCx)
{
  /* 8 is the number of required instructions cycles for the below loop statement.
  The SDMMC_CMDTIMEOUT is expressed in ms */
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 8005310:	4b13      	ldr	r3, [pc, #76]	; (8005360 <SDMMC_CmdOperCond+0x74>)
 8005312:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8005316:	681b      	ldr	r3, [r3, #0]
 8005318:	fbb3 f2f2 	udiv	r2, r3, r2
 800531c:	f241 3388 	movw	r3, #5000	; 0x1388
 8005320:	4353      	muls	r3, r2
  
  do
  {
    if (count-- == 0U)
 8005322:	f113 33ff 	adds.w	r3, r3, #4294967295
 8005326:	d318      	bcc.n	800535a <SDMMC_CmdOperCond+0x6e>
    {
      return SDMMC_ERROR_TIMEOUT;
    }
    
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT));
 8005328:	6b62      	ldr	r2, [r4, #52]	; 0x34
 800532a:	f012 0f45 	tst.w	r2, #69	; 0x45
 800532e:	d0f8      	beq.n	8005322 <SDMMC_CmdOperCond+0x36>

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 8005330:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005332:	075b      	lsls	r3, r3, #29
 8005334:	d503      	bpl.n	800533e <SDMMC_CmdOperCond+0x52>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8005336:	2004      	movs	r0, #4
  }
  
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8005338:	63a0      	str	r0, [r4, #56]	; 0x38
}
 800533a:	b006      	add	sp, #24
 800533c:	bd10      	pop	{r4, pc}
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800533e:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005340:	f012 0201 	ands.w	r2, r2, #1
 8005344:	d001      	beq.n	800534a <SDMMC_CmdOperCond+0x5e>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8005346:	2001      	movs	r0, #1
 8005348:	e7f6      	b.n	8005338 <SDMMC_CmdOperCond+0x4c>
  else
  {
    /* Nothing to do */
  }

  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CMDREND))
 800534a:	6b60      	ldr	r0, [r4, #52]	; 0x34
 800534c:	f010 0040 	ands.w	r0, r0, #64	; 0x40
 8005350:	d0f3      	beq.n	800533a <SDMMC_CmdOperCond+0x4e>
  {
    /* Card is SD V2.0 compliant */
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CMDREND);
 8005352:	2340      	movs	r3, #64	; 0x40
 8005354:	63a3      	str	r3, [r4, #56]	; 0x38
  }
  
  return SDMMC_ERROR_NONE;
 8005356:	4610      	mov	r0, r2
 8005358:	e7ef      	b.n	800533a <SDMMC_CmdOperCond+0x4e>
      return SDMMC_ERROR_TIMEOUT;
 800535a:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 800535e:	e7ec      	b.n	800533a <SDMMC_CmdOperCond+0x4e>
 8005360:	20000024 	.word	0x20000024

08005364 <SDMMC_CmdAppCommand>:
{
 8005364:	b530      	push	{r4, r5, lr}
 8005366:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8005368:	2340      	movs	r3, #64	; 0x40
 800536a:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 800536c:	2300      	movs	r3, #0
{
 800536e:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = (uint32_t)Argument;
 8005370:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 8005372:	2437      	movs	r4, #55	; 0x37
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8005374:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005376:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8005378:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800537c:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_APP_CMD;
 800537e:	9402      	str	r4, [sp, #8]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005380:	f7ff feba 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_APP_CMD, SDMMC_CMDTIMEOUT);
 8005384:	f241 3288 	movw	r2, #5000	; 0x1388
 8005388:	4621      	mov	r1, r4
 800538a:	4628      	mov	r0, r5
 800538c:	f7ff fdfc 	bl	8004f88 <SDMMC_GetCmdResp1>
}
 8005390:	b007      	add	sp, #28
 8005392:	bd30      	pop	{r4, r5, pc}

08005394 <SDMMC_CmdAppOperCommand>:
{
 8005394:	b510      	push	{r4, lr}
 8005396:	b086      	sub	sp, #24
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SD_APP_OP_COND;
 8005398:	2329      	movs	r3, #41	; 0x29
 800539a:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
 800539c:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 80053a0:	2340      	movs	r3, #64	; 0x40
 80053a2:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
 80053a4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80053a8:	2300      	movs	r3, #0
{
 80053aa:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = SDMMC_VOLTAGE_WINDOW_SD | Argument;
 80053ac:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80053ae:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80053b0:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 80053b2:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80053b6:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80053b8:	f7ff fe9e 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp3(SDMMCx);
 80053bc:	4620      	mov	r0, r4
 80053be:	f7ff fdc3 	bl	8004f48 <SDMMC_GetCmdResp3>
}
 80053c2:	b006      	add	sp, #24
 80053c4:	bd10      	pop	{r4, pc}

080053c6 <SDMMC_CmdSendCID>:
{
 80053c6:	b510      	push	{r4, lr}
 80053c8:	b086      	sub	sp, #24
  sdmmc_cmdinit.Argument         = 0;
 80053ca:	2300      	movs	r3, #0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 80053cc:	2202      	movs	r2, #2
{
 80053ce:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = 0;
 80053d0:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_ALL_SEND_CID;
 80053d2:	9202      	str	r2, [sp, #8]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80053d4:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 80053d6:	22c0      	movs	r2, #192	; 0xc0
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 80053d8:	f44f 6380 	mov.w	r3, #1024	; 0x400
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80053dc:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 80053de:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 80053e0:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80053e2:	f7ff fe89 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 80053e6:	4620      	mov	r0, r4
 80053e8:	f7ff fd88 	bl	8004efc <SDMMC_GetCmdResp2>
}
 80053ec:	b006      	add	sp, #24
 80053ee:	bd10      	pop	{r4, pc}

080053f0 <SDMMC_CmdSendCSD>:
{
 80053f0:	b510      	push	{r4, lr}
 80053f2:	b086      	sub	sp, #24
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_CSD;
 80053f4:	2309      	movs	r3, #9
 80053f6:	9302      	str	r3, [sp, #8]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_LONG;
 80053f8:	23c0      	movs	r3, #192	; 0xc0
 80053fa:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80053fc:	2300      	movs	r3, #0
{
 80053fe:	4604      	mov	r4, r0
  sdmmc_cmdinit.Argument         = Argument;
 8005400:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8005402:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005404:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8005406:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800540a:	9305      	str	r3, [sp, #20]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800540c:	f7ff fe74 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp2(SDMMCx);
 8005410:	4620      	mov	r0, r4
 8005412:	f7ff fd73 	bl	8004efc <SDMMC_GetCmdResp2>
}
 8005416:	b006      	add	sp, #24
 8005418:	bd10      	pop	{r4, pc}
	...

0800541c <SDMMC_CmdSetRelAdd>:
{
 800541c:	b530      	push	{r4, r5, lr}
 800541e:	b087      	sub	sp, #28
  sdmmc_cmdinit.Argument         = 0;
 8005420:	2300      	movs	r3, #0
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 8005422:	2203      	movs	r2, #3
  sdmmc_cmdinit.Argument         = 0;
 8005424:	9301      	str	r3, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SET_REL_ADDR;
 8005426:	9202      	str	r2, [sp, #8]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 8005428:	9304      	str	r3, [sp, #16]
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 800542a:	2240      	movs	r2, #64	; 0x40
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 800542c:	f44f 6380 	mov.w	r3, #1024	; 0x400
{
 8005430:	460d      	mov	r5, r1
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 8005432:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 8005434:	9203      	str	r2, [sp, #12]
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 8005436:	9305      	str	r3, [sp, #20]
{
 8005438:	4604      	mov	r4, r0
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 800543a:	f7ff fe5d 	bl	80050f8 <SDMMC_SendCommand>
  register uint32_t count = SDMMC_CMDTIMEOUT * (SystemCoreClock / 8U /1000U);
 800543e:	4b1d      	ldr	r3, [pc, #116]	; (80054b4 <SDMMC_CmdSetRelAdd+0x98>)
 8005440:	f44f 52fa 	mov.w	r2, #8000	; 0x1f40
 8005444:	681b      	ldr	r3, [r3, #0]
 8005446:	fbb3 f2f2 	udiv	r2, r3, r2
 800544a:	f241 3388 	movw	r3, #5000	; 0x1388
 800544e:	4353      	muls	r3, r2
    if (count-- == 0U)
 8005450:	f113 33ff 	adds.w	r3, r3, #4294967295
 8005454:	d326      	bcc.n	80054a4 <SDMMC_CmdSetRelAdd+0x88>
  }while(!__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL | SDMMC_FLAG_CMDREND | SDMMC_FLAG_CTIMEOUT));
 8005456:	6b62      	ldr	r2, [r4, #52]	; 0x34
 8005458:	f012 0f45 	tst.w	r2, #69	; 0x45
 800545c:	d0f8      	beq.n	8005450 <SDMMC_CmdSetRelAdd+0x34>
  if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT))
 800545e:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005460:	0758      	lsls	r0, r3, #29
 8005462:	d503      	bpl.n	800546c <SDMMC_CmdSetRelAdd+0x50>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CTIMEOUT);
 8005464:	2004      	movs	r0, #4
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8005466:	63a0      	str	r0, [r4, #56]	; 0x38
}
 8005468:	b007      	add	sp, #28
 800546a:	bd30      	pop	{r4, r5, pc}
  else if(__SDMMC_GET_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL))
 800546c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800546e:	07d9      	lsls	r1, r3, #31
 8005470:	d501      	bpl.n	8005476 <SDMMC_CmdSetRelAdd+0x5a>
    __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_FLAG_CCRCFAIL);
 8005472:	2001      	movs	r0, #1
 8005474:	e7f7      	b.n	8005466 <SDMMC_CmdSetRelAdd+0x4a>
  return (uint8_t)(SDMMCx->RESPCMD);
 8005476:	6923      	ldr	r3, [r4, #16]
  if(SDMMC_GetCommandResponse(SDMMCx) != SD_CMD)
 8005478:	b2db      	uxtb	r3, r3
 800547a:	2b03      	cmp	r3, #3
 800547c:	d115      	bne.n	80054aa <SDMMC_CmdSetRelAdd+0x8e>
  __SDMMC_CLEAR_FLAG(SDMMCx, SDMMC_STATIC_CMD_FLAGS);
 800547e:	23c5      	movs	r3, #197	; 0xc5
 8005480:	63a3      	str	r3, [r4, #56]	; 0x38
  return (*(__IO uint32_t *) tmp);
 8005482:	6963      	ldr	r3, [r4, #20]
  if((response_r1 & (SDMMC_R6_GENERAL_UNKNOWN_ERROR | SDMMC_R6_ILLEGAL_CMD | SDMMC_R6_COM_CRC_FAILED)) == SDMMC_ALLZERO)
 8005484:	f413 4060 	ands.w	r0, r3, #57344	; 0xe000
 8005488:	d102      	bne.n	8005490 <SDMMC_CmdSetRelAdd+0x74>
    *pRCA = (uint16_t) (response_r1 >> 16);
 800548a:	0c1b      	lsrs	r3, r3, #16
 800548c:	802b      	strh	r3, [r5, #0]
 800548e:	e7eb      	b.n	8005468 <SDMMC_CmdSetRelAdd+0x4c>
  else if((response_r1 & SDMMC_R6_ILLEGAL_CMD) == SDMMC_R6_ILLEGAL_CMD)
 8005490:	045a      	lsls	r2, r3, #17
 8005492:	d40c      	bmi.n	80054ae <SDMMC_CmdSetRelAdd+0x92>
    return SDMMC_ERROR_GENERAL_UNKNOWN_ERR;
 8005494:	f413 4f00 	tst.w	r3, #32768	; 0x8000
 8005498:	bf14      	ite	ne
 800549a:	f44f 5080 	movne.w	r0, #4096	; 0x1000
 800549e:	f44f 3080 	moveq.w	r0, #65536	; 0x10000
 80054a2:	e7e1      	b.n	8005468 <SDMMC_CmdSetRelAdd+0x4c>
      return SDMMC_ERROR_TIMEOUT;
 80054a4:	f04f 4000 	mov.w	r0, #2147483648	; 0x80000000
 80054a8:	e7de      	b.n	8005468 <SDMMC_CmdSetRelAdd+0x4c>
    return SDMMC_ERROR_CMD_CRC_FAIL;
 80054aa:	2001      	movs	r0, #1
 80054ac:	e7dc      	b.n	8005468 <SDMMC_CmdSetRelAdd+0x4c>
    return SDMMC_ERROR_ILLEGAL_CMD;
 80054ae:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 80054b2:	e7d9      	b.n	8005468 <SDMMC_CmdSetRelAdd+0x4c>
 80054b4:	20000024 	.word	0x20000024

080054b8 <SDMMC_CmdSendStatus>:
{
 80054b8:	b530      	push	{r4, r5, lr}
 80054ba:	b087      	sub	sp, #28
  sdmmc_cmdinit.Response         = SDMMC_RESPONSE_SHORT;
 80054bc:	2340      	movs	r3, #64	; 0x40
 80054be:	9303      	str	r3, [sp, #12]
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80054c0:	2300      	movs	r3, #0
{
 80054c2:	4605      	mov	r5, r0
  sdmmc_cmdinit.Argument         = Argument;
 80054c4:	9101      	str	r1, [sp, #4]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 80054c6:	240d      	movs	r4, #13
  sdmmc_cmdinit.WaitForInterrupt = SDMMC_WAIT_NO;
 80054c8:	9304      	str	r3, [sp, #16]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80054ca:	a901      	add	r1, sp, #4
  sdmmc_cmdinit.CPSM             = SDMMC_CPSM_ENABLE;
 80054cc:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80054d0:	9305      	str	r3, [sp, #20]
  sdmmc_cmdinit.CmdIndex         = SDMMC_CMD_SEND_STATUS;
 80054d2:	9402      	str	r4, [sp, #8]
  (void)SDMMC_SendCommand(SDMMCx, &sdmmc_cmdinit);
 80054d4:	f7ff fe10 	bl	80050f8 <SDMMC_SendCommand>
  errorstate = SDMMC_GetCmdResp1(SDMMCx, SDMMC_CMD_SEND_STATUS, SDMMC_CMDTIMEOUT);
 80054d8:	f241 3288 	movw	r2, #5000	; 0x1388
 80054dc:	4621      	mov	r1, r4
 80054de:	4628      	mov	r0, r5
 80054e0:	f7ff fd52 	bl	8004f88 <SDMMC_GetCmdResp1>
}
 80054e4:	b007      	add	sp, #28
 80054e6:	bd30      	pop	{r4, r5, pc}

080054e8 <LL_USART_Init>:
  * @retval An ErrorStatus enumeration value:
  *          - SUCCESS: USART registers are initialized according to USART_InitStruct content
  *          - ERROR: Problem occurred during USART Registers initialization
  */
ErrorStatus LL_USART_Init(USART_TypeDef *USARTx, LL_USART_InitTypeDef *USART_InitStruct)
{
 80054e8:	b538      	push	{r3, r4, r5, lr}
  * @param  USARTx USART Instance
  * @retval State of bit (1 or 0).
  */
__STATIC_INLINE uint32_t LL_USART_IsEnabled(USART_TypeDef *USARTx)
{
  return (READ_BIT(USARTx->CR1, USART_CR1_UE) == (USART_CR1_UE));
 80054ea:	6803      	ldr	r3, [r0, #0]
  assert_param(IS_LL_USART_HWCONTROL(USART_InitStruct->HardwareFlowControl));
  assert_param(IS_LL_USART_OVERSAMPLING(USART_InitStruct->OverSampling));

  /* USART needs to be in disabled state, in order to be able to configure some bits in
     CRx registers */
  if (LL_USART_IsEnabled(USARTx) == 0U)
 80054ec:	07db      	lsls	r3, r3, #31
{
 80054ee:	4604      	mov	r4, r0
 80054f0:	460d      	mov	r5, r1
  if (LL_USART_IsEnabled(USARTx) == 0U)
 80054f2:	d501      	bpl.n	80054f8 <LL_USART_Init+0x10>
  ErrorStatus status = ERROR;
 80054f4:	2000      	movs	r0, #0
 80054f6:	bd38      	pop	{r3, r4, r5, pc}
     * - DataWidth:          USART_CR1_M bits according to USART_InitStruct->DataWidth value
     * - Parity:             USART_CR1_PCE, USART_CR1_PS bits according to USART_InitStruct->Parity value
     * - TransferDirection:  USART_CR1_TE, USART_CR1_RE bits according to USART_InitStruct->TransferDirection value
     * - Oversampling:       USART_CR1_OVER8 bit according to USART_InitStruct->OverSampling value.
     */
    MODIFY_REG(USARTx->CR1,
 80054f8:	68ea      	ldr	r2, [r5, #12]
 80054fa:	686b      	ldr	r3, [r5, #4]
 80054fc:	6801      	ldr	r1, [r0, #0]
 80054fe:	4313      	orrs	r3, r2
 8005500:	692a      	ldr	r2, [r5, #16]
 8005502:	4313      	orrs	r3, r2
 8005504:	69aa      	ldr	r2, [r5, #24]
 8005506:	4313      	orrs	r3, r2
 8005508:	4a21      	ldr	r2, [pc, #132]	; (8005590 <LL_USART_Init+0xa8>)
 800550a:	400a      	ands	r2, r1
 800550c:	4313      	orrs	r3, r2
 800550e:	6003      	str	r3, [r0, #0]
  *         @arg @ref LL_USART_STOPBITS_2
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetStopBitsLength(USART_TypeDef *USARTx, uint32_t StopBits)
{
  MODIFY_REG(USARTx->CR2, USART_CR2_STOP, StopBits);
 8005510:	6843      	ldr	r3, [r0, #4]
 8005512:	68aa      	ldr	r2, [r5, #8]
 8005514:	f423 5340 	bic.w	r3, r3, #12288	; 0x3000
 8005518:	4313      	orrs	r3, r2
 800551a:	6043      	str	r3, [r0, #4]
  *         @arg @ref LL_USART_HWCONTROL_RTS_CTS
  * @retval None
  */
__STATIC_INLINE void LL_USART_SetHWFlowCtrl(USART_TypeDef *USARTx, uint32_t HardwareFlowControl)
{
  MODIFY_REG(USARTx->CR3, USART_CR3_RTSE | USART_CR3_CTSE, HardwareFlowControl);
 800551c:	6883      	ldr	r3, [r0, #8]
 800551e:	696a      	ldr	r2, [r5, #20]
 8005520:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8005524:	4313      	orrs	r3, r2
 8005526:	6083      	str	r3, [r0, #8]
    LL_USART_SetHWFlowCtrl(USARTx, USART_InitStruct->HardwareFlowControl);

    /*---------------------------- USART BRR Configuration ---------------------
     * Retrieve Clock frequency used for USART Peripheral
     */
    if (USARTx == USART1)
 8005528:	4b1a      	ldr	r3, [pc, #104]	; (8005594 <LL_USART_Init+0xac>)
 800552a:	4298      	cmp	r0, r3
 800552c:	d11a      	bne.n	8005564 <LL_USART_Init+0x7c>
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART1_CLKSOURCE);
 800552e:	2003      	movs	r0, #3
    }
    else if (USARTx == USART2)
    {
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART2_CLKSOURCE);
 8005530:	f7ff fc4e 	bl	8004dd0 <LL_RCC_GetUSARTClockFreq>
       - prescaler value is required
    #endif
       - valid baud rate value (different from 0) is required
       - Peripheral clock as returned by RCC service, should be valid (different from 0).
    */
    if ((periphclk != LL_RCC_PERIPH_FREQUENCY_NO)
 8005534:	2800      	cmp	r0, #0
 8005536:	d0dd      	beq.n	80054f4 <LL_USART_Init+0xc>
        && (USART_InitStruct->BaudRate != 0U))
 8005538:	682a      	ldr	r2, [r5, #0]
 800553a:	2a00      	cmp	r2, #0
 800553c:	d0da      	beq.n	80054f4 <LL_USART_Init+0xc>
#endif
{
  register uint32_t usartdiv = 0x0U;
  register uint32_t brrtemp = 0x0U;

  if (OverSampling == LL_USART_OVERSAMPLING_8)
 800553e:	69ab      	ldr	r3, [r5, #24]
 8005540:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 8005544:	ea4f 0352 	mov.w	r3, r2, lsr #1
 8005548:	d11d      	bne.n	8005586 <LL_USART_Init+0x9e>
  {
#if defined(USART_PRESC_PRESCALER)
    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, (uint16_t)PrescalerValue, BaudRate));
#else
    usartdiv = (uint16_t)(__LL_USART_DIV_SAMPLING8(PeriphClk, BaudRate));
 800554a:	eb03 0340 	add.w	r3, r3, r0, lsl #1
 800554e:	fbb3 f3f2 	udiv	r3, r3, r2
#endif
    brrtemp = usartdiv & 0xFFF0U;
 8005552:	f64f 72f0 	movw	r2, #65520	; 0xfff0
 8005556:	401a      	ands	r2, r3
    brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8005558:	f3c3 0342 	ubfx	r3, r3, #1, #3
 800555c:	4313      	orrs	r3, r2
  else
  {
#if defined(USART_PRESC_PRESCALER)
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, (uint16_t)PrescalerValue, BaudRate));
#else
    USARTx->BRR = (uint16_t)(__LL_USART_DIV_SAMPLING16(PeriphClk, BaudRate));
 800555e:	60e3      	str	r3, [r4, #12]
    {
      status = SUCCESS;
 8005560:	2001      	movs	r0, #1
#endif
  }
  /* Endif (=> USART not in Disabled state => return ERROR) */

  return (status);
}
 8005562:	bd38      	pop	{r3, r4, r5, pc}
    else if (USARTx == USART2)
 8005564:	4b0c      	ldr	r3, [pc, #48]	; (8005598 <LL_USART_Init+0xb0>)
 8005566:	4298      	cmp	r0, r3
 8005568:	d101      	bne.n	800556e <LL_USART_Init+0x86>
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART2_CLKSOURCE);
 800556a:	200c      	movs	r0, #12
 800556c:	e7e0      	b.n	8005530 <LL_USART_Init+0x48>
    else if (USARTx == USART3)
 800556e:	4b0b      	ldr	r3, [pc, #44]	; (800559c <LL_USART_Init+0xb4>)
 8005570:	4298      	cmp	r0, r3
 8005572:	d101      	bne.n	8005578 <LL_USART_Init+0x90>
      periphclk = LL_RCC_GetUSARTClockFreq(LL_RCC_USART3_CLKSOURCE);
 8005574:	2030      	movs	r0, #48	; 0x30
 8005576:	e7db      	b.n	8005530 <LL_USART_Init+0x48>
    else if (USARTx == UART4)
 8005578:	4b09      	ldr	r3, [pc, #36]	; (80055a0 <LL_USART_Init+0xb8>)
 800557a:	4298      	cmp	r0, r3
 800557c:	d1ba      	bne.n	80054f4 <LL_USART_Init+0xc>
      periphclk = LL_RCC_GetUARTClockFreq(LL_RCC_UART4_CLKSOURCE);
 800557e:	20c0      	movs	r0, #192	; 0xc0
 8005580:	f7ff fc88 	bl	8004e94 <LL_RCC_GetUARTClockFreq>
 8005584:	e7d6      	b.n	8005534 <LL_USART_Init+0x4c>
 8005586:	4403      	add	r3, r0
 8005588:	fbb3 f3f2 	udiv	r3, r3, r2
 800558c:	b29b      	uxth	r3, r3
 800558e:	e7e6      	b.n	800555e <LL_USART_Init+0x76>
 8005590:	efff69f3 	.word	0xefff69f3
 8005594:	40013800 	.word	0x40013800
 8005598:	40004400 	.word	0x40004400
 800559c:	40004800 	.word	0x40004800
 80055a0:	40004c00 	.word	0x40004c00

080055a4 <disk_status>:
	BYTE pdrv		/* Physical drive number to identify the drive */
)
{
  DSTATUS stat;

  stat = disk.drv[pdrv]->disk_status(disk.lun[pdrv]);
 80055a4:	4b03      	ldr	r3, [pc, #12]	; (80055b4 <disk_status+0x10>)
 80055a6:	181a      	adds	r2, r3, r0
 80055a8:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80055ac:	7a10      	ldrb	r0, [r2, #8]
 80055ae:	685b      	ldr	r3, [r3, #4]
 80055b0:	685b      	ldr	r3, [r3, #4]
 80055b2:	4718      	bx	r3
 80055b4:	2000028c 	.word	0x2000028c

080055b8 <disk_initialize>:
	BYTE pdrv				/* Physical drive nmuber to identify the drive */
)
{
  DSTATUS stat = RES_OK;

  if(disk.is_initialized[pdrv] == 0)
 80055b8:	4b06      	ldr	r3, [pc, #24]	; (80055d4 <disk_initialize+0x1c>)
 80055ba:	5c1a      	ldrb	r2, [r3, r0]
 80055bc:	b942      	cbnz	r2, 80055d0 <disk_initialize+0x18>
  {
    disk.is_initialized[pdrv] = 1;
 80055be:	2201      	movs	r2, #1
 80055c0:	541a      	strb	r2, [r3, r0]
    stat = disk.drv[pdrv]->disk_initialize(disk.lun[pdrv]);
 80055c2:	181a      	adds	r2, r3, r0
 80055c4:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 80055c8:	7a10      	ldrb	r0, [r2, #8]
 80055ca:	685b      	ldr	r3, [r3, #4]
 80055cc:	681b      	ldr	r3, [r3, #0]
 80055ce:	4718      	bx	r3
  }
  return stat;
}
 80055d0:	2000      	movs	r0, #0
 80055d2:	4770      	bx	lr
 80055d4:	2000028c 	.word	0x2000028c

080055d8 <disk_read>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	        /* Sector address in LBA */
	UINT count		/* Number of sectors to read */
)
{
 80055d8:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 80055da:	4c05      	ldr	r4, [pc, #20]	; (80055f0 <disk_read+0x18>)
 80055dc:	1825      	adds	r5, r4, r0
 80055de:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 80055e2:	6860      	ldr	r0, [r4, #4]
 80055e4:	6884      	ldr	r4, [r0, #8]
 80055e6:	7a28      	ldrb	r0, [r5, #8]
 80055e8:	46a4      	mov	ip, r4
  return res;
}
 80055ea:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_read(disk.lun[pdrv], buff, sector, count);
 80055ec:	4760      	bx	ip
 80055ee:	bf00      	nop
 80055f0:	2000028c 	.word	0x2000028c

080055f4 <disk_write>:
	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
	const BYTE *buff,	/* Data to be written */
	DWORD sector,		/* Sector address in LBA */
	UINT count        	/* Number of sectors to write */
)
{
 80055f4:	b430      	push	{r4, r5}
  DRESULT res;

  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 80055f6:	4c05      	ldr	r4, [pc, #20]	; (800560c <disk_write+0x18>)
 80055f8:	1825      	adds	r5, r4, r0
 80055fa:	eb04 0480 	add.w	r4, r4, r0, lsl #2
 80055fe:	6860      	ldr	r0, [r4, #4]
 8005600:	68c4      	ldr	r4, [r0, #12]
 8005602:	7a28      	ldrb	r0, [r5, #8]
 8005604:	46a4      	mov	ip, r4
  return res;
}
 8005606:	bc30      	pop	{r4, r5}
  res = disk.drv[pdrv]->disk_write(disk.lun[pdrv], buff, sector, count);
 8005608:	4760      	bx	ip
 800560a:	bf00      	nop
 800560c:	2000028c 	.word	0x2000028c

08005610 <disk_ioctl>:
	void *buff		/* Buffer to send/receive control data */
)
{
  DRESULT res;

  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 8005610:	4b05      	ldr	r3, [pc, #20]	; (8005628 <disk_ioctl+0x18>)
{
 8005612:	b410      	push	{r4}
  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 8005614:	181c      	adds	r4, r3, r0
 8005616:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 800561a:	7a20      	ldrb	r0, [r4, #8]
 800561c:	685b      	ldr	r3, [r3, #4]
  return res;
}
 800561e:	f85d 4b04 	ldr.w	r4, [sp], #4
  res = disk.drv[pdrv]->disk_ioctl(disk.lun[pdrv], cmd, buff);
 8005622:	691b      	ldr	r3, [r3, #16]
 8005624:	4718      	bx	r3
 8005626:	bf00      	nop
 8005628:	2000028c 	.word	0x2000028c

0800562c <ld_dword>:
DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
{
	DWORD rv;

	rv = ptr[3];
	rv = rv << 8 | ptr[2];
 800562c:	8842      	ldrh	r2, [r0, #2]
	rv = rv << 8 | ptr[1];
 800562e:	7843      	ldrb	r3, [r0, #1]
	rv = rv << 8 | ptr[0];
 8005630:	7800      	ldrb	r0, [r0, #0]
	rv = rv << 8 | ptr[1];
 8005632:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	return rv;
}
 8005636:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 800563a:	4770      	bx	lr

0800563c <st_dword>:
}

static
void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
{
	*ptr++ = (BYTE)val; val >>= 8;
 800563c:	0a0b      	lsrs	r3, r1, #8
 800563e:	7001      	strb	r1, [r0, #0]
	*ptr++ = (BYTE)val; val >>= 8;
 8005640:	7043      	strb	r3, [r0, #1]
 8005642:	0c0b      	lsrs	r3, r1, #16
	*ptr++ = (BYTE)val; val >>= 8;
 8005644:	0e09      	lsrs	r1, r1, #24
 8005646:	7083      	strb	r3, [r0, #2]
	*ptr++ = (BYTE)val;
 8005648:	70c1      	strb	r1, [r0, #3]
 800564a:	4770      	bx	lr

0800564c <mem_set>:
	}
}

/* Fill memory block */
static
void mem_set (void* dst, int val, UINT cnt) {
 800564c:	4402      	add	r2, r0
	BYTE *d = (BYTE*)dst;

	do {
		*d++ = (BYTE)val;
 800564e:	f800 1b01 	strb.w	r1, [r0], #1
	} while (--cnt);
 8005652:	4290      	cmp	r0, r2
 8005654:	d1fb      	bne.n	800564e <mem_set+0x2>
}
 8005656:	4770      	bx	lr

08005658 <chk_lock>:
static
FRESULT chk_lock (	/* Check if the file can be accessed */
	DIR* dp,		/* Directory object pointing the file to be checked */
	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 8005658:	4b15      	ldr	r3, [pc, #84]	; (80056b0 <chk_lock+0x58>)
 800565a:	b5f0      	push	{r4, r5, r6, r7, lr}
	UINT i, be;

	/* Search file semaphore table */
	for (i = be = 0; i < _FS_LOCK; i++) {
 800565c:	2500      	movs	r5, #0
 800565e:	462a      	mov	r2, r5
 8005660:	461c      	mov	r4, r3
		if (Files[i].fs) {	/* Existing entry */
 8005662:	681e      	ldr	r6, [r3, #0]
 8005664:	b1a6      	cbz	r6, 8005690 <chk_lock+0x38>
			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
 8005666:	6807      	ldr	r7, [r0, #0]
 8005668:	42be      	cmp	r6, r7
 800566a:	d112      	bne.n	8005692 <chk_lock+0x3a>
 800566c:	685f      	ldr	r7, [r3, #4]
 800566e:	6886      	ldr	r6, [r0, #8]
 8005670:	42b7      	cmp	r7, r6
 8005672:	d10e      	bne.n	8005692 <chk_lock+0x3a>
				Files[i].clu == dp->obj.sclust &&
 8005674:	689f      	ldr	r7, [r3, #8]
 8005676:	6946      	ldr	r6, [r0, #20]
 8005678:	42b7      	cmp	r7, r6
 800567a:	d10a      	bne.n	8005692 <chk_lock+0x3a>
	if (i == _FS_LOCK) {	/* The object is not opened */
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
	}

	/* The object has been opened. Reject any open against writing file and all write mode open */
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 800567c:	b9b1      	cbnz	r1, 80056ac <chk_lock+0x54>
 800567e:	eb04 1202 	add.w	r2, r4, r2, lsl #4
 8005682:	8993      	ldrh	r3, [r2, #12]
 8005684:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8005688:	bf14      	ite	ne
 800568a:	2000      	movne	r0, #0
 800568c:	2010      	moveq	r0, #16
 800568e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			be = 1;
 8005690:	2501      	movs	r5, #1
	for (i = be = 0; i < _FS_LOCK; i++) {
 8005692:	3201      	adds	r2, #1
 8005694:	2a02      	cmp	r2, #2
 8005696:	f103 0310 	add.w	r3, r3, #16
 800569a:	d1e2      	bne.n	8005662 <chk_lock+0xa>
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 800569c:	b10d      	cbz	r5, 80056a2 <chk_lock+0x4a>
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 800569e:	2000      	movs	r0, #0
 80056a0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
 80056a2:	2902      	cmp	r1, #2
 80056a4:	bf0c      	ite	eq
 80056a6:	2000      	moveq	r0, #0
 80056a8:	2012      	movne	r0, #18
 80056aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
 80056ac:	2010      	movs	r0, #16
 80056ae:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80056b0:	20000268 	.word	0x20000268

080056b4 <inc_lock>:
static
UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
	DIR* dp,	/* Directory object pointing the file to register or increment */
	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
)
{
 80056b4:	4a1c      	ldr	r2, [pc, #112]	; (8005728 <inc_lock+0x74>)
 80056b6:	b5f0      	push	{r4, r5, r6, r7, lr}
	UINT i;


	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
		if (Files[i].fs == dp->obj.fs &&
 80056b8:	6805      	ldr	r5, [r0, #0]
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 80056ba:	2300      	movs	r3, #0
 80056bc:	4616      	mov	r6, r2
		if (Files[i].fs == dp->obj.fs &&
 80056be:	6814      	ldr	r4, [r2, #0]
 80056c0:	42ac      	cmp	r4, r5
 80056c2:	d107      	bne.n	80056d4 <inc_lock+0x20>
 80056c4:	6857      	ldr	r7, [r2, #4]
 80056c6:	6884      	ldr	r4, [r0, #8]
 80056c8:	42a7      	cmp	r7, r4
 80056ca:	d103      	bne.n	80056d4 <inc_lock+0x20>
			Files[i].clu == dp->obj.sclust &&
 80056cc:	6897      	ldr	r7, [r2, #8]
 80056ce:	6944      	ldr	r4, [r0, #20]
 80056d0:	42a7      	cmp	r7, r4
 80056d2:	d01d      	beq.n	8005710 <inc_lock+0x5c>
	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
 80056d4:	3301      	adds	r3, #1
 80056d6:	2b02      	cmp	r3, #2
 80056d8:	f102 0210 	add.w	r2, r2, #16
 80056dc:	d1ef      	bne.n	80056be <inc_lock+0xa>
			Files[i].ofs == dp->dptr) break;
	}

	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80056de:	6833      	ldr	r3, [r6, #0]
 80056e0:	b113      	cbz	r3, 80056e8 <inc_lock+0x34>
 80056e2:	6933      	ldr	r3, [r6, #16]
 80056e4:	b9eb      	cbnz	r3, 8005722 <inc_lock+0x6e>
 80056e6:	2301      	movs	r3, #1
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
		Files[i].fs = dp->obj.fs;
 80056e8:	011c      	lsls	r4, r3, #4
 80056ea:	1932      	adds	r2, r6, r4
 80056ec:	5135      	str	r5, [r6, r4]
		Files[i].clu = dp->obj.sclust;
 80056ee:	6884      	ldr	r4, [r0, #8]
		Files[i].ofs = dp->dptr;
 80056f0:	6940      	ldr	r0, [r0, #20]
 80056f2:	6090      	str	r0, [r2, #8]
		Files[i].ctr = 0;
 80056f4:	2000      	movs	r0, #0
		Files[i].clu = dp->obj.sclust;
 80056f6:	6054      	str	r4, [r2, #4]
		Files[i].ctr = 0;
 80056f8:	8190      	strh	r0, [r2, #12]
	}

	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 80056fa:	b979      	cbnz	r1, 800571c <inc_lock+0x68>

	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 80056fc:	eb06 1203 	add.w	r2, r6, r3, lsl #4
 8005700:	8992      	ldrh	r2, [r2, #12]
 8005702:	3201      	adds	r2, #1
 8005704:	b292      	uxth	r2, r2
 8005706:	eb06 1603 	add.w	r6, r6, r3, lsl #4

	return i + 1;
 800570a:	1c58      	adds	r0, r3, #1
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 800570c:	81b2      	strh	r2, [r6, #12]
	return i + 1;
 800570e:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
 8005710:	2900      	cmp	r1, #0
 8005712:	d0f3      	beq.n	80056fc <inc_lock+0x48>
 8005714:	eb06 1203 	add.w	r2, r6, r3, lsl #4
 8005718:	8992      	ldrh	r2, [r2, #12]
 800571a:	b912      	cbnz	r2, 8005722 <inc_lock+0x6e>
	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
 800571c:	f44f 7280 	mov.w	r2, #256	; 0x100
 8005720:	e7f1      	b.n	8005706 <inc_lock+0x52>
		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
 8005722:	2000      	movs	r0, #0
 8005724:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005726:	bf00      	nop
 8005728:	20000268 	.word	0x20000268

0800572c <dec_lock>:
{
	WORD n;
	FRESULT res;


	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
 800572c:	3801      	subs	r0, #1
 800572e:	2801      	cmp	r0, #1
 8005730:	d80e      	bhi.n	8005750 <dec_lock+0x24>
		n = Files[i].ctr;
 8005732:	4a09      	ldr	r2, [pc, #36]	; (8005758 <dec_lock+0x2c>)
 8005734:	0103      	lsls	r3, r0, #4
 8005736:	18d1      	adds	r1, r2, r3
 8005738:	8989      	ldrh	r1, [r1, #12]
		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
		if (n > 0) n--;				/* Decrement read mode open count */
 800573a:	f421 7080 	bic.w	r0, r1, #256	; 0x100
 800573e:	b280      	uxth	r0, r0
 8005740:	b108      	cbz	r0, 8005746 <dec_lock+0x1a>
 8005742:	1e48      	subs	r0, r1, #1
 8005744:	b280      	uxth	r0, r0
		Files[i].ctr = n;
 8005746:	18d1      	adds	r1, r2, r3
 8005748:	8188      	strh	r0, [r1, #12]
		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
 800574a:	b918      	cbnz	r0, 8005754 <dec_lock+0x28>
 800574c:	50d0      	str	r0, [r2, r3]
 800574e:	4770      	bx	lr
		res = FR_OK;
	} else {
		res = FR_INT_ERR;			/* Invalid index nunber */
 8005750:	2002      	movs	r0, #2
 8005752:	4770      	bx	lr
		res = FR_OK;
 8005754:	2000      	movs	r0, #0
	}
	return res;
}
 8005756:	4770      	bx	lr
 8005758:	20000268 	.word	0x20000268

0800575c <clust2sect>:
	FATFS* fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800575c:	6943      	ldr	r3, [r0, #20]
	clst -= 2;
 800575e:	3902      	subs	r1, #2
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 8005760:	3b02      	subs	r3, #2
 8005762:	4299      	cmp	r1, r3
	return clst * fs->csize + fs->database;
 8005764:	bf3d      	ittte	cc
 8005766:	8943      	ldrhcc	r3, [r0, #10]
 8005768:	6a80      	ldrcc	r0, [r0, #40]	; 0x28
 800576a:	fb01 0003 	mlacc	r0, r1, r3, r0
	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
 800576e:	2000      	movcs	r0, #0
}
 8005770:	4770      	bx	lr

08005772 <clmt_clust>:
{
	DWORD cl, ncl, *tbl;
	FATFS *fs = fp->obj.fs;


	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8005772:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8005774:	6802      	ldr	r2, [r0, #0]
	tbl = fp->cltbl + 1;	/* Top of CLMT */
 8005776:	3304      	adds	r3, #4
	cl = (DWORD)(ofs / SS(fs) / fs->csize);	/* Cluster order from top of the file */
 8005778:	0a49      	lsrs	r1, r1, #9
 800577a:	8952      	ldrh	r2, [r2, #10]
 800577c:	fbb1 f1f2 	udiv	r1, r1, r2
	for (;;) {
		ncl = *tbl++;			/* Number of cluters in the fragment */
 8005780:	6818      	ldr	r0, [r3, #0]
		if (ncl == 0) return 0;	/* End of table? (error) */
 8005782:	b130      	cbz	r0, 8005792 <clmt_clust+0x20>
		if (cl < ncl) break;	/* In this fragment? */
 8005784:	4281      	cmp	r1, r0
 8005786:	d302      	bcc.n	800578e <clmt_clust+0x1c>
		cl -= ncl; tbl++;		/* Next fragment */
 8005788:	1a09      	subs	r1, r1, r0
 800578a:	3308      	adds	r3, #8
		ncl = *tbl++;			/* Number of cluters in the fragment */
 800578c:	e7f8      	b.n	8005780 <clmt_clust+0xe>
	}
	return cl + *tbl;	/* Return the cluster number */
 800578e:	6858      	ldr	r0, [r3, #4]
 8005790:	4408      	add	r0, r1
}
 8005792:	4770      	bx	lr

08005794 <get_achar>:
)
{
#if !_LFN_UNICODE
	WCHAR chr;

	chr = (BYTE)*(*ptr)++;					/* Get a byte */
 8005794:	6803      	ldr	r3, [r0, #0]
 8005796:	1c5a      	adds	r2, r3, #1
 8005798:	6002      	str	r2, [r0, #0]
 800579a:	781a      	ldrb	r2, [r3, #0]
 800579c:	b290      	uxth	r0, r2
	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
 800579e:	f1a0 0361 	sub.w	r3, r0, #97	; 0x61
 80057a2:	2b19      	cmp	r3, #25
 80057a4:	d802      	bhi.n	80057ac <get_achar+0x18>
 80057a6:	3820      	subs	r0, #32
 80057a8:	b280      	uxth	r0, r0
 80057aa:	4770      	bx	lr
#ifdef _EXCVT
	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
 80057ac:	287f      	cmp	r0, #127	; 0x7f
 80057ae:	bf82      	ittt	hi
 80057b0:	4b02      	ldrhi	r3, [pc, #8]	; (80057bc <get_achar+0x28>)
 80057b2:	189b      	addhi	r3, r3, r2
 80057b4:	f813 0c80 	ldrbhi.w	r0, [r3, #-128]
#endif
	return chr;
#else
	return ff_wtoupper(*(*ptr)++);			/* Get a word and to upper */
#endif
}
 80057b8:	4770      	bx	lr
 80057ba:	bf00      	nop
 80057bc:	0800f569 	.word	0x0800f569

080057c0 <pattern_matching>:
	const TCHAR* pat,	/* Matching pattern */
	const TCHAR* nam,	/* String to be tested */
	int skip,			/* Number of pre-skip chars (number of ?s) */
	int inf				/* Infinite search (* specified) */
)
{
 80057c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80057c2:	b085      	sub	sp, #20
 80057c4:	ac04      	add	r4, sp, #16
 80057c6:	4605      	mov	r5, r0
 80057c8:	f844 1d0c 	str.w	r1, [r4, #-12]!
 80057cc:	461e      	mov	r6, r3
 80057ce:	4611      	mov	r1, r2
	const TCHAR *pp, *np;
	WCHAR pc, nc;
	int nm, nx;


	while (skip--) {				/* Pre-skip name chars */
 80057d0:	b921      	cbnz	r1, 80057dc <pattern_matching+0x1c>
		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
	}
	if (!*pat && inf) return 1;		/* (short circuit) */
 80057d2:	782b      	ldrb	r3, [r5, #0]
 80057d4:	b95b      	cbnz	r3, 80057ee <pattern_matching+0x2e>
 80057d6:	b156      	cbz	r6, 80057ee <pattern_matching+0x2e>
 80057d8:	2001      	movs	r0, #1
 80057da:	e006      	b.n	80057ea <pattern_matching+0x2a>
		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
 80057dc:	4620      	mov	r0, r4
 80057de:	f7ff ffd9 	bl	8005794 <get_achar>
 80057e2:	3901      	subs	r1, #1
 80057e4:	2800      	cmp	r0, #0
 80057e6:	d1f3      	bne.n	80057d0 <pattern_matching+0x10>
 80057e8:	2000      	movs	r0, #0
		}
		get_achar(&nam);			/* nam++ */
	} while (inf && nc);			/* Retry until end of name if infinite search is specified */

	return 0;
}
 80057ea:	b005      	add	sp, #20
 80057ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
		pp = pat; np = nam;			/* Top of pattern and name to match */
 80057ee:	ac04      	add	r4, sp, #16
 80057f0:	9b01      	ldr	r3, [sp, #4]
 80057f2:	f844 3d04 	str.w	r3, [r4, #-4]!
 80057f6:	9502      	str	r5, [sp, #8]
			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
 80057f8:	9b02      	ldr	r3, [sp, #8]
 80057fa:	781b      	ldrb	r3, [r3, #0]
 80057fc:	2b3f      	cmp	r3, #63	; 0x3f
 80057fe:	d001      	beq.n	8005804 <pattern_matching+0x44>
 8005800:	2b2a      	cmp	r3, #42	; 0x2a
 8005802:	d11d      	bne.n	8005840 <pattern_matching+0x80>
 8005804:	2300      	movs	r3, #0
 8005806:	461a      	mov	r2, r3
					if (*pp++ == '?') nm++; else nx = 1;
 8005808:	9902      	ldr	r1, [sp, #8]
 800580a:	1c48      	adds	r0, r1, #1
 800580c:	9002      	str	r0, [sp, #8]
 800580e:	780c      	ldrb	r4, [r1, #0]
				} while (*pp == '?' || *pp == '*');
 8005810:	7849      	ldrb	r1, [r1, #1]
					if (*pp++ == '?') nm++; else nx = 1;
 8005812:	2c3f      	cmp	r4, #63	; 0x3f
 8005814:	bf0c      	ite	eq
 8005816:	3201      	addeq	r2, #1
 8005818:	2301      	movne	r3, #1
				} while (*pp == '?' || *pp == '*');
 800581a:	293f      	cmp	r1, #63	; 0x3f
 800581c:	d0f4      	beq.n	8005808 <pattern_matching+0x48>
 800581e:	292a      	cmp	r1, #42	; 0x2a
 8005820:	d0f2      	beq.n	8005808 <pattern_matching+0x48>
				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recurs upto number of wildcard blocks in the pattern) */
 8005822:	9903      	ldr	r1, [sp, #12]
 8005824:	f7ff ffcc 	bl	80057c0 <pattern_matching>
 8005828:	2800      	cmp	r0, #0
 800582a:	d1d5      	bne.n	80057d8 <pattern_matching+0x18>
				nc = *np; break;	/* Branch mismatched */
 800582c:	9b03      	ldr	r3, [sp, #12]
 800582e:	7819      	ldrb	r1, [r3, #0]
		get_achar(&nam);			/* nam++ */
 8005830:	a801      	add	r0, sp, #4
 8005832:	f7ff ffaf 	bl	8005794 <get_achar>
	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
 8005836:	2e00      	cmp	r6, #0
 8005838:	d0d6      	beq.n	80057e8 <pattern_matching+0x28>
 800583a:	2900      	cmp	r1, #0
 800583c:	d1d7      	bne.n	80057ee <pattern_matching+0x2e>
 800583e:	e7d3      	b.n	80057e8 <pattern_matching+0x28>
			pc = get_achar(&pp);	/* Get a pattern char */
 8005840:	a802      	add	r0, sp, #8
 8005842:	f7ff ffa7 	bl	8005794 <get_achar>
 8005846:	4607      	mov	r7, r0
			nc = get_achar(&np);	/* Get a name char */
 8005848:	4620      	mov	r0, r4
 800584a:	f7ff ffa3 	bl	8005794 <get_achar>
			if (pc != nc) break;	/* Branch mismatched? */
 800584e:	4287      	cmp	r7, r0
			nc = get_achar(&np);	/* Get a name char */
 8005850:	4601      	mov	r1, r0
			if (pc != nc) break;	/* Branch mismatched? */
 8005852:	d1ed      	bne.n	8005830 <pattern_matching+0x70>
			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
 8005854:	2f00      	cmp	r7, #0
 8005856:	d1cf      	bne.n	80057f8 <pattern_matching+0x38>
 8005858:	e7be      	b.n	80057d8 <pattern_matching+0x18>

0800585a <get_ldnumber>:
	char c;
	TCHAR tc;
#endif


	if (*path) {	/* If the pointer is not a null */
 800585a:	6802      	ldr	r2, [r0, #0]
{
 800585c:	b510      	push	{r4, lr}
	if (*path) {	/* If the pointer is not a null */
 800585e:	b152      	cbz	r2, 8005876 <get_ldnumber+0x1c>
 8005860:	4611      	mov	r1, r2
 8005862:	460b      	mov	r3, r1
		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
 8005864:	f811 4b01 	ldrb.w	r4, [r1], #1
 8005868:	2c20      	cmp	r4, #32
 800586a:	d90c      	bls.n	8005886 <get_ldnumber+0x2c>
 800586c:	2c3a      	cmp	r4, #58	; 0x3a
 800586e:	d1f8      	bne.n	8005862 <get_ldnumber+0x8>
		if (*tt == ':') {	/* If a ':' is exist in the path name */
			tp = *path;
			i = *tp++ - '0';
 8005870:	1c51      	adds	r1, r2, #1
			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
 8005872:	428b      	cmp	r3, r1
 8005874:	d002      	beq.n	800587c <get_ldnumber+0x22>
	int vol = -1;
 8005876:	f04f 30ff 	mov.w	r0, #4294967295
#else
		vol = 0;		/* Drive 0 */
#endif
	}
	return vol;
}
 800587a:	bd10      	pop	{r4, pc}
				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
 800587c:	7812      	ldrb	r2, [r2, #0]
 800587e:	2a30      	cmp	r2, #48	; 0x30
 8005880:	d1f9      	bne.n	8005876 <get_ldnumber+0x1c>
					*path = ++tt;
 8005882:	3301      	adds	r3, #1
 8005884:	6003      	str	r3, [r0, #0]
		vol = 0;		/* Drive 0 */
 8005886:	2000      	movs	r0, #0
 8005888:	bd10      	pop	{r4, pc}

0800588a <validate>:
static
FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
	_FDID* obj,		/* Pointer to the _OBJ, the 1st member in the FIL/DIR object, to check validity */
	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
)
{
 800588a:	b538      	push	{r3, r4, r5, lr}
 800588c:	460d      	mov	r5, r1
	FRESULT res;

	if (!obj || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
 800588e:	4604      	mov	r4, r0
 8005890:	b918      	cbnz	r0, 800589a <validate+0x10>
		*fs = 0;
 8005892:	2300      	movs	r3, #0
 8005894:	602b      	str	r3, [r5, #0]
		res = FR_INVALID_OBJECT;	/* The object is invalid */
 8005896:	2009      	movs	r0, #9
 8005898:	bd38      	pop	{r3, r4, r5, pc}
	if (!obj || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
 800589a:	6803      	ldr	r3, [r0, #0]
 800589c:	2b00      	cmp	r3, #0
 800589e:	d0f8      	beq.n	8005892 <validate+0x8>
 80058a0:	781a      	ldrb	r2, [r3, #0]
 80058a2:	2a00      	cmp	r2, #0
 80058a4:	d0f5      	beq.n	8005892 <validate+0x8>
 80058a6:	88d9      	ldrh	r1, [r3, #6]
 80058a8:	8882      	ldrh	r2, [r0, #4]
 80058aa:	4291      	cmp	r1, r2
 80058ac:	d1f1      	bne.n	8005892 <validate+0x8>
 80058ae:	7858      	ldrb	r0, [r3, #1]
 80058b0:	f7ff fe78 	bl	80055a4 <disk_status>
 80058b4:	f010 0001 	ands.w	r0, r0, #1
 80058b8:	d1eb      	bne.n	8005892 <validate+0x8>
	} else {
		*fs = obj->fs;			/* Owner file sytem object */
 80058ba:	6823      	ldr	r3, [r4, #0]
 80058bc:	602b      	str	r3, [r5, #0]
		ENTER_FF(obj->fs);		/* Lock file system */
		res = FR_OK;			/* Valid object */
	}
	return res;
}
 80058be:	bd38      	pop	{r3, r4, r5, pc}

080058c0 <mem_cpy.part.0>:
void mem_cpy (void* dst, const void* src, UINT cnt) {
 80058c0:	3801      	subs	r0, #1
 80058c2:	440a      	add	r2, r1
			*d++ = *s++;
 80058c4:	f811 3b01 	ldrb.w	r3, [r1], #1
 80058c8:	f800 3f01 	strb.w	r3, [r0, #1]!
		} while (--cnt);
 80058cc:	4291      	cmp	r1, r2
 80058ce:	d1f9      	bne.n	80058c4 <mem_cpy.part.0+0x4>
}
 80058d0:	4770      	bx	lr

080058d2 <ld_clust.isra.1>:
	rv = rv << 8 | ptr[0];
 80058d2:	7eca      	ldrb	r2, [r1, #27]
 80058d4:	7e8b      	ldrb	r3, [r1, #26]
	if (fs->fs_type == FS_FAT32) {
 80058d6:	2803      	cmp	r0, #3
	cl = ld_word(dir + DIR_FstClusLO);
 80058d8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	rv = rv << 8 | ptr[0];
 80058dc:	bf01      	itttt	eq
 80058de:	7d48      	ldrbeq	r0, [r1, #21]
 80058e0:	7d0a      	ldrbeq	r2, [r1, #20]
		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
 80058e2:	ea42 2200 	orreq.w	r2, r2, r0, lsl #8
 80058e6:	ea43 4302 	orreq.w	r3, r3, r2, lsl #16
}
 80058ea:	4618      	mov	r0, r3
 80058ec:	4770      	bx	lr

080058ee <st_clust.isra.2>:
	*ptr++ = (BYTE)val; val >>= 8;
 80058ee:	f3c2 2307 	ubfx	r3, r2, #8, #8
 80058f2:	768a      	strb	r2, [r1, #26]
	*ptr++ = (BYTE)val;
 80058f4:	76cb      	strb	r3, [r1, #27]
	if (fs->fs_type == FS_FAT32) {
 80058f6:	7803      	ldrb	r3, [r0, #0]
 80058f8:	2b03      	cmp	r3, #3
		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
 80058fa:	bf01      	itttt	eq
 80058fc:	0c12      	lsreq	r2, r2, #16
	*ptr++ = (BYTE)val; val >>= 8;
 80058fe:	750a      	strbeq	r2, [r1, #20]
 8005900:	0a12      	lsreq	r2, r2, #8
	*ptr++ = (BYTE)val;
 8005902:	754a      	strbeq	r2, [r1, #21]
 8005904:	4770      	bx	lr

08005906 <get_fileinfo.part.3>:
void get_fileinfo (		/* No return code */
 8005906:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		c = (TCHAR)dp->dir[i++];
 8005908:	6a04      	ldr	r4, [r0, #32]
 800590a:	2300      	movs	r3, #0
 800590c:	1e65      	subs	r5, r4, #1
 800590e:	4618      	mov	r0, r3
		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
 8005910:	262e      	movs	r6, #46	; 0x2e
		c = (TCHAR)dp->dir[i++];
 8005912:	f815 2f01 	ldrb.w	r2, [r5, #1]!
		if (c == ' ') continue;				/* Skip padding spaces */
 8005916:	2a20      	cmp	r2, #32
		c = (TCHAR)dp->dir[i++];
 8005918:	f100 0001 	add.w	r0, r0, #1
		if (c == ' ') continue;				/* Skip padding spaces */
 800591c:	d00a      	beq.n	8005934 <get_fileinfo.part.3+0x2e>
		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
 800591e:	2a05      	cmp	r2, #5
 8005920:	bf08      	it	eq
 8005922:	22e5      	moveq	r2, #229	; 0xe5
		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
 8005924:	2809      	cmp	r0, #9
 8005926:	bf02      	ittt	eq
 8005928:	18cf      	addeq	r7, r1, r3
 800592a:	3301      	addeq	r3, #1
 800592c:	727e      	strbeq	r6, [r7, #9]
		fno->fname[j++] = c;
 800592e:	18cf      	adds	r7, r1, r3
 8005930:	3301      	adds	r3, #1
 8005932:	727a      	strb	r2, [r7, #9]
	while (i < 11) {		/* Copy name body and extension */
 8005934:	280b      	cmp	r0, #11
 8005936:	d1ec      	bne.n	8005912 <get_fileinfo.part.3+0xc>
	fno->fname[j] = 0;
 8005938:	440b      	add	r3, r1
 800593a:	2200      	movs	r2, #0
 800593c:	725a      	strb	r2, [r3, #9]
	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
 800593e:	7ae3      	ldrb	r3, [r4, #11]
 8005940:	720b      	strb	r3, [r1, #8]
	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
 8005942:	f104 001c 	add.w	r0, r4, #28
 8005946:	f7ff fe71 	bl	800562c <ld_dword>
 800594a:	6008      	str	r0, [r1, #0]
	tm = ld_dword(dp->dir + DIR_ModTime);			/* Timestamp */
 800594c:	f104 0016 	add.w	r0, r4, #22
 8005950:	f7ff fe6c 	bl	800562c <ld_dword>
	fno->ftime = (WORD)tm; fno->fdate = (WORD)(tm >> 16);
 8005954:	80c8      	strh	r0, [r1, #6]
 8005956:	0c00      	lsrs	r0, r0, #16
 8005958:	8088      	strh	r0, [r1, #4]
 800595a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800595c <sync_window.part.4>:
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
 800595c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
		wsect = fs->winsect;	/* Current sector number */
 800595e:	6ac5      	ldr	r5, [r0, #44]	; 0x2c
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8005960:	f100 0730 	add.w	r7, r0, #48	; 0x30
FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
 8005964:	4604      	mov	r4, r0
		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
 8005966:	2301      	movs	r3, #1
 8005968:	462a      	mov	r2, r5
 800596a:	4639      	mov	r1, r7
 800596c:	7840      	ldrb	r0, [r0, #1]
 800596e:	f7ff fe41 	bl	80055f4 <disk_write>
 8005972:	b9a0      	cbnz	r0, 800599e <sync_window.part.4+0x42>
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 8005974:	6a23      	ldr	r3, [r4, #32]
 8005976:	69a2      	ldr	r2, [r4, #24]
			fs->wflag = 0;
 8005978:	70e0      	strb	r0, [r4, #3]
			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
 800597a:	1aeb      	subs	r3, r5, r3
 800597c:	4293      	cmp	r3, r2
 800597e:	d301      	bcc.n	8005984 <sync_window.part.4+0x28>
	FRESULT res = FR_OK;
 8005980:	2000      	movs	r0, #0
 8005982:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 8005984:	78a6      	ldrb	r6, [r4, #2]
 8005986:	2e01      	cmp	r6, #1
 8005988:	d9fa      	bls.n	8005980 <sync_window.part.4+0x24>
					wsect += fs->fsize;
 800598a:	69a3      	ldr	r3, [r4, #24]
					disk_write(fs->drv, fs->win, wsect, 1);
 800598c:	7860      	ldrb	r0, [r4, #1]
					wsect += fs->fsize;
 800598e:	441d      	add	r5, r3
					disk_write(fs->drv, fs->win, wsect, 1);
 8005990:	462a      	mov	r2, r5
 8005992:	2301      	movs	r3, #1
 8005994:	4639      	mov	r1, r7
 8005996:	f7ff fe2d 	bl	80055f4 <disk_write>
				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
 800599a:	3e01      	subs	r6, #1
 800599c:	e7f3      	b.n	8005986 <sync_window.part.4+0x2a>
			res = FR_DISK_ERR;
 800599e:	2001      	movs	r0, #1
}
 80059a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080059a2 <sync_window>:
	if (fs->wflag) {	/* Write back the sector if it is dirty */
 80059a2:	78c3      	ldrb	r3, [r0, #3]
 80059a4:	b10b      	cbz	r3, 80059aa <sync_window+0x8>
 80059a6:	f7ff bfd9 	b.w	800595c <sync_window.part.4>
}
 80059aa:	4618      	mov	r0, r3
 80059ac:	4770      	bx	lr

080059ae <sync_fs>:
{
 80059ae:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80059b0:	4604      	mov	r4, r0
	res = sync_window(fs);
 80059b2:	f7ff fff6 	bl	80059a2 <sync_window>
 80059b6:	4605      	mov	r5, r0
	if (res == FR_OK) {
 80059b8:	2800      	cmp	r0, #0
 80059ba:	d142      	bne.n	8005a42 <sync_fs+0x94>
		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
 80059bc:	7823      	ldrb	r3, [r4, #0]
 80059be:	2b03      	cmp	r3, #3
 80059c0:	d137      	bne.n	8005a32 <sync_fs+0x84>
 80059c2:	7927      	ldrb	r7, [r4, #4]
 80059c4:	2f01      	cmp	r7, #1
 80059c6:	d134      	bne.n	8005a32 <sync_fs+0x84>
			mem_set(fs->win, 0, SS(fs));
 80059c8:	f104 0630 	add.w	r6, r4, #48	; 0x30
 80059cc:	4601      	mov	r1, r0
 80059ce:	f44f 7200 	mov.w	r2, #512	; 0x200
 80059d2:	4630      	mov	r0, r6
 80059d4:	f7ff fe3a 	bl	800564c <mem_set>
	*ptr++ = (BYTE)val; val >>= 8;
 80059d8:	2355      	movs	r3, #85	; 0x55
 80059da:	f884 322e 	strb.w	r3, [r4, #558]	; 0x22e
	*ptr++ = (BYTE)val;
 80059de:	23aa      	movs	r3, #170	; 0xaa
 80059e0:	f884 322f 	strb.w	r3, [r4, #559]	; 0x22f
	*ptr++ = (BYTE)val; val >>= 8;
 80059e4:	2352      	movs	r3, #82	; 0x52
	*ptr++ = (BYTE)val;
 80059e6:	2241      	movs	r2, #65	; 0x41
	*ptr++ = (BYTE)val; val >>= 8;
 80059e8:	2172      	movs	r1, #114	; 0x72
 80059ea:	f884 3030 	strb.w	r3, [r4, #48]	; 0x30
	*ptr++ = (BYTE)val; val >>= 8;
 80059ee:	f884 3031 	strb.w	r3, [r4, #49]	; 0x31
	*ptr++ = (BYTE)val; val >>= 8;
 80059f2:	2361      	movs	r3, #97	; 0x61
 80059f4:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
	*ptr++ = (BYTE)val;
 80059f8:	f884 2033 	strb.w	r2, [r4, #51]	; 0x33
	*ptr++ = (BYTE)val; val >>= 8;
 80059fc:	f884 2216 	strb.w	r2, [r4, #534]	; 0x216
	*ptr++ = (BYTE)val;
 8005a00:	f884 3217 	strb.w	r3, [r4, #535]	; 0x217
	*ptr++ = (BYTE)val; val >>= 8;
 8005a04:	f884 1214 	strb.w	r1, [r4, #532]	; 0x214
	*ptr++ = (BYTE)val; val >>= 8;
 8005a08:	f884 1215 	strb.w	r1, [r4, #533]	; 0x215
			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
 8005a0c:	f504 7006 	add.w	r0, r4, #536	; 0x218
 8005a10:	6921      	ldr	r1, [r4, #16]
 8005a12:	f7ff fe13 	bl	800563c <st_dword>
			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
 8005a16:	68e1      	ldr	r1, [r4, #12]
 8005a18:	f504 7007 	add.w	r0, r4, #540	; 0x21c
 8005a1c:	f7ff fe0e 	bl	800563c <st_dword>
			fs->winsect = fs->volbase + 1;
 8005a20:	69e2      	ldr	r2, [r4, #28]
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8005a22:	7860      	ldrb	r0, [r4, #1]
			fs->winsect = fs->volbase + 1;
 8005a24:	3201      	adds	r2, #1
 8005a26:	62e2      	str	r2, [r4, #44]	; 0x2c
			disk_write(fs->drv, fs->win, fs->winsect, 1);
 8005a28:	463b      	mov	r3, r7
 8005a2a:	4631      	mov	r1, r6
 8005a2c:	f7ff fde2 	bl	80055f4 <disk_write>
			fs->fsi_flag = 0;
 8005a30:	7125      	strb	r5, [r4, #4]
		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
 8005a32:	2200      	movs	r2, #0
 8005a34:	4611      	mov	r1, r2
 8005a36:	7860      	ldrb	r0, [r4, #1]
 8005a38:	f7ff fdea 	bl	8005610 <disk_ioctl>
 8005a3c:	3000      	adds	r0, #0
 8005a3e:	bf18      	it	ne
 8005a40:	2001      	movne	r0, #1
}
 8005a42:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005a44 <move_window>:
	if (sector != fs->winsect) {	/* Window offset changed? */
 8005a44:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 8005a46:	428b      	cmp	r3, r1
{
 8005a48:	b570      	push	{r4, r5, r6, lr}
 8005a4a:	4606      	mov	r6, r0
 8005a4c:	460d      	mov	r5, r1
	if (sector != fs->winsect) {	/* Window offset changed? */
 8005a4e:	d012      	beq.n	8005a76 <move_window+0x32>
		res = sync_window(fs);		/* Write-back changes */
 8005a50:	f7ff ffa7 	bl	80059a2 <sync_window>
		if (res == FR_OK) {			/* Fill sector window with new data */
 8005a54:	4604      	mov	r4, r0
 8005a56:	b960      	cbnz	r0, 8005a72 <move_window+0x2e>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
 8005a58:	462a      	mov	r2, r5
 8005a5a:	2301      	movs	r3, #1
 8005a5c:	f106 0130 	add.w	r1, r6, #48	; 0x30
 8005a60:	7870      	ldrb	r0, [r6, #1]
 8005a62:	f7ff fdb9 	bl	80055d8 <disk_read>
 8005a66:	2800      	cmp	r0, #0
				res = FR_DISK_ERR;
 8005a68:	bf1c      	itt	ne
 8005a6a:	f04f 35ff 	movne.w	r5, #4294967295
 8005a6e:	2401      	movne	r4, #1
			fs->winsect = sector;
 8005a70:	62f5      	str	r5, [r6, #44]	; 0x2c
}
 8005a72:	4620      	mov	r0, r4
 8005a74:	bd70      	pop	{r4, r5, r6, pc}
	FRESULT res = FR_OK;
 8005a76:	2400      	movs	r4, #0
 8005a78:	e7fb      	b.n	8005a72 <move_window+0x2e>
	...

08005a7c <check_fs>:
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8005a7c:	2300      	movs	r3, #0
{
 8005a7e:	b510      	push	{r4, lr}
	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
 8005a80:	70c3      	strb	r3, [r0, #3]
 8005a82:	f04f 33ff 	mov.w	r3, #4294967295
 8005a86:	62c3      	str	r3, [r0, #44]	; 0x2c
{
 8005a88:	4604      	mov	r4, r0
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 8005a8a:	f7ff ffdb 	bl	8005a44 <move_window>
 8005a8e:	bb30      	cbnz	r0, 8005ade <check_fs+0x62>
	rv = rv << 8 | ptr[0];
 8005a90:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 8005a94:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
 8005a98:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8005a9c:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8005aa0:	4293      	cmp	r3, r2
 8005aa2:	d11e      	bne.n	8005ae2 <check_fs+0x66>
	if (fs->win[BS_JmpBoot] == 0xE9 || (fs->win[BS_JmpBoot] == 0xEB && fs->win[BS_JmpBoot + 2] == 0x90)) {
 8005aa4:	f894 3030 	ldrb.w	r3, [r4, #48]	; 0x30
 8005aa8:	2be9      	cmp	r3, #233	; 0xe9
 8005aaa:	d005      	beq.n	8005ab8 <check_fs+0x3c>
 8005aac:	6b23      	ldr	r3, [r4, #48]	; 0x30
 8005aae:	4a10      	ldr	r2, [pc, #64]	; (8005af0 <check_fs+0x74>)
 8005ab0:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8005ab4:	4293      	cmp	r3, r2
 8005ab6:	d116      	bne.n	8005ae6 <check_fs+0x6a>
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8005ab8:	f104 0066 	add.w	r0, r4, #102	; 0x66
 8005abc:	f7ff fdb6 	bl	800562c <ld_dword>
 8005ac0:	4b0c      	ldr	r3, [pc, #48]	; (8005af4 <check_fs+0x78>)
 8005ac2:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 8005ac6:	4298      	cmp	r0, r3
 8005ac8:	d00f      	beq.n	8005aea <check_fs+0x6e>
		if (ld_dword(fs->win + BS_FilSysType32) == 0x33544146) return 0;			/* Check "FAT3" string */
 8005aca:	f104 0082 	add.w	r0, r4, #130	; 0x82
 8005ace:	f7ff fdad 	bl	800562c <ld_dword>
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8005ad2:	4b09      	ldr	r3, [pc, #36]	; (8005af8 <check_fs+0x7c>)
 8005ad4:	4298      	cmp	r0, r3
 8005ad6:	bf14      	ite	ne
 8005ad8:	2002      	movne	r0, #2
 8005ada:	2000      	moveq	r0, #0
 8005adc:	bd10      	pop	{r4, pc}
	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
 8005ade:	2004      	movs	r0, #4
 8005ae0:	bd10      	pop	{r4, pc}
	if (ld_word(fs->win + BS_55AA) != 0xAA55) return 3;	/* Check boot record signature (always placed here even if the sector size is >512) */
 8005ae2:	2003      	movs	r0, #3
 8005ae4:	bd10      	pop	{r4, pc}
	return 2;
 8005ae6:	2002      	movs	r0, #2
 8005ae8:	bd10      	pop	{r4, pc}
		if ((ld_dword(fs->win + BS_FilSysType) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
 8005aea:	2000      	movs	r0, #0
}
 8005aec:	bd10      	pop	{r4, pc}
 8005aee:	bf00      	nop
 8005af0:	009000eb 	.word	0x009000eb
 8005af4:	00544146 	.word	0x00544146
 8005af8:	33544146 	.word	0x33544146

08005afc <find_volume>:
{
 8005afc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	*rfs = 0;
 8005b00:	2300      	movs	r3, #0
{
 8005b02:	b085      	sub	sp, #20
	*rfs = 0;
 8005b04:	600b      	str	r3, [r1, #0]
{
 8005b06:	460f      	mov	r7, r1
 8005b08:	4615      	mov	r5, r2
	vol = get_ldnumber(path);
 8005b0a:	f7ff fea6 	bl	800585a <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 8005b0e:	1e06      	subs	r6, r0, #0
 8005b10:	f2c0 8140 	blt.w	8005d94 <find_volume+0x298>
	fs = FatFs[vol];					/* Get pointer to the file system object */
 8005b14:	4ba3      	ldr	r3, [pc, #652]	; (8005da4 <find_volume+0x2a8>)
 8005b16:	f853 4026 	ldr.w	r4, [r3, r6, lsl #2]
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8005b1a:	2c00      	cmp	r4, #0
 8005b1c:	f000 813c 	beq.w	8005d98 <find_volume+0x29c>
	*rfs = fs;							/* Return pointer to the file system object */
 8005b20:	603c      	str	r4, [r7, #0]
	if (fs->fs_type) {					/* If the volume has been mounted */
 8005b22:	7823      	ldrb	r3, [r4, #0]
	mode &= (BYTE)~FA_READ;				/* Desired access mode, write access or not */
 8005b24:	f005 05fe 	and.w	r5, r5, #254	; 0xfe
	if (fs->fs_type) {					/* If the volume has been mounted */
 8005b28:	b173      	cbz	r3, 8005b48 <find_volume+0x4c>
		stat = disk_status(fs->drv);
 8005b2a:	7860      	ldrb	r0, [r4, #1]
 8005b2c:	f7ff fd3a 	bl	80055a4 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
 8005b30:	07c1      	lsls	r1, r0, #31
 8005b32:	d409      	bmi.n	8005b48 <find_volume+0x4c>
			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
 8005b34:	2d00      	cmp	r5, #0
 8005b36:	f000 8131 	beq.w	8005d9c <find_volume+0x2a0>
 8005b3a:	f010 0004 	ands.w	r0, r0, #4
 8005b3e:	d000      	beq.n	8005b42 <find_volume+0x46>
				return FR_WRITE_PROTECTED;
 8005b40:	200a      	movs	r0, #10
}
 8005b42:	b005      	add	sp, #20
 8005b44:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	fs->fs_type = 0;					/* Clear the file system object */
 8005b48:	2300      	movs	r3, #0
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8005b4a:	b2f0      	uxtb	r0, r6
	fs->fs_type = 0;					/* Clear the file system object */
 8005b4c:	7023      	strb	r3, [r4, #0]
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
 8005b4e:	7060      	strb	r0, [r4, #1]
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
 8005b50:	f7ff fd32 	bl	80055b8 <disk_initialize>
	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
 8005b54:	07c2      	lsls	r2, r0, #31
 8005b56:	f100 8123 	bmi.w	8005da0 <find_volume+0x2a4>
	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
 8005b5a:	b10d      	cbz	r5, 8005b60 <find_volume+0x64>
 8005b5c:	0743      	lsls	r3, r0, #29
 8005b5e:	d4ef      	bmi.n	8005b40 <find_volume+0x44>
	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT-VBR as SFD */
 8005b60:	2100      	movs	r1, #0
 8005b62:	4620      	mov	r0, r4
 8005b64:	f7ff ff8a 	bl	8005a7c <check_fs>
	if (fmt == 2 || (fmt < 2 && LD2PT(vol) != 0)) {	/* Not an FAT-VBR or forced partition number */
 8005b68:	2802      	cmp	r0, #2
 8005b6a:	f040 80f7 	bne.w	8005d5c <find_volume+0x260>
 8005b6e:	f504 75fb 	add.w	r5, r4, #502	; 0x1f6
 8005b72:	2100      	movs	r1, #0
			br[i] = pt[PTE_System] ? ld_dword(pt + PTE_StLba) : 0;
 8005b74:	f815 0c04 	ldrb.w	r0, [r5, #-4]
 8005b78:	b110      	cbz	r0, 8005b80 <find_volume+0x84>
 8005b7a:	4628      	mov	r0, r5
 8005b7c:	f7ff fd56 	bl	800562c <ld_dword>
 8005b80:	f84d 0021 	str.w	r0, [sp, r1, lsl #2]
		for (i = 0; i < 4; i++) {		/* Get partition offset */
 8005b84:	3101      	adds	r1, #1
 8005b86:	2904      	cmp	r1, #4
 8005b88:	f105 0510 	add.w	r5, r5, #16
 8005b8c:	d1f2      	bne.n	8005b74 <find_volume+0x78>
 8005b8e:	2500      	movs	r5, #0
			bsect = br[i];
 8005b90:	f85d 6025 	ldr.w	r6, [sp, r5, lsl #2]
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8005b94:	2e00      	cmp	r6, #0
 8005b96:	f000 80d8 	beq.w	8005d4a <find_volume+0x24e>
 8005b9a:	4631      	mov	r1, r6
 8005b9c:	4620      	mov	r0, r4
 8005b9e:	f7ff ff6d 	bl	8005a7c <check_fs>
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8005ba2:	2801      	cmp	r0, #1
 8005ba4:	f200 80d2 	bhi.w	8005d4c <find_volume+0x250>
	rv = rv << 8 | ptr[0];
 8005ba8:	f894 203c 	ldrb.w	r2, [r4, #60]	; 0x3c
 8005bac:	f894 303b 	ldrb.w	r3, [r4, #59]	; 0x3b
 8005bb0:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
 8005bb4:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8005bb8:	f040 80d4 	bne.w	8005d64 <find_volume+0x268>
	rv = rv << 8 | ptr[0];
 8005bbc:	f894 3047 	ldrb.w	r3, [r4, #71]	; 0x47
 8005bc0:	f894 5046 	ldrb.w	r5, [r4, #70]	; 0x46
		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
 8005bc4:	ea55 2503 	orrs.w	r5, r5, r3, lsl #8
 8005bc8:	d104      	bne.n	8005bd4 <find_volume+0xd8>
 8005bca:	f104 0054 	add.w	r0, r4, #84	; 0x54
 8005bce:	f7ff fd2d 	bl	800562c <ld_dword>
 8005bd2:	4605      	mov	r5, r0
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8005bd4:	f894 9040 	ldrb.w	r9, [r4, #64]	; 0x40
		fs->fsize = fasize;
 8005bd8:	61a5      	str	r5, [r4, #24]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8005bda:	f109 33ff 	add.w	r3, r9, #4294967295
 8005bde:	2b01      	cmp	r3, #1
		fs->n_fats = fs->win[BPB_NumFATs];				/* Number of FATs */
 8005be0:	f884 9002 	strb.w	r9, [r4, #2]
		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
 8005be4:	f200 80be 	bhi.w	8005d64 <find_volume+0x268>
		fs->csize = fs->win[BPB_SecPerClus];			/* Cluster size */
 8005be8:	f894 703d 	ldrb.w	r7, [r4, #61]	; 0x3d
 8005bec:	b2bb      	uxth	r3, r7
 8005bee:	8163      	strh	r3, [r4, #10]
		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
 8005bf0:	2b00      	cmp	r3, #0
 8005bf2:	f000 80b7 	beq.w	8005d64 <find_volume+0x268>
 8005bf6:	1e7b      	subs	r3, r7, #1
 8005bf8:	423b      	tst	r3, r7
 8005bfa:	f040 80b3 	bne.w	8005d64 <find_volume+0x268>
	rv = rv << 8 | ptr[0];
 8005bfe:	f894 3042 	ldrb.w	r3, [r4, #66]	; 0x42
 8005c02:	f894 8041 	ldrb.w	r8, [r4, #65]	; 0x41
 8005c06:	ea48 2803 	orr.w	r8, r8, r3, lsl #8
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8005c0a:	f018 0f0f 	tst.w	r8, #15
		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
 8005c0e:	f8a4 8008 	strh.w	r8, [r4, #8]
		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
 8005c12:	f040 80a7 	bne.w	8005d64 <find_volume+0x268>
	rv = rv << 8 | ptr[0];
 8005c16:	f894 1044 	ldrb.w	r1, [r4, #68]	; 0x44
 8005c1a:	f894 0043 	ldrb.w	r0, [r4, #67]	; 0x43
		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
 8005c1e:	ea50 2001 	orrs.w	r0, r0, r1, lsl #8
 8005c22:	d103      	bne.n	8005c2c <find_volume+0x130>
 8005c24:	f104 0050 	add.w	r0, r4, #80	; 0x50
 8005c28:	f7ff fd00 	bl	800562c <ld_dword>
	rv = rv << 8 | ptr[0];
 8005c2c:	f894 303f 	ldrb.w	r3, [r4, #63]	; 0x3f
 8005c30:	f894 203e 	ldrb.w	r2, [r4, #62]	; 0x3e
		if (nrsv == 0) return FR_NO_FILESYSTEM;			/* (Must not be 0) */
 8005c34:	ea52 2203 	orrs.w	r2, r2, r3, lsl #8
 8005c38:	f000 8094 	beq.w	8005d64 <find_volume+0x268>
		fasize *= fs->n_fats;							/* Number of sectors for FAT area */
 8005c3c:	fb05 f309 	mul.w	r3, r5, r9
		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
 8005c40:	eb02 1e18 	add.w	lr, r2, r8, lsr #4
 8005c44:	449e      	add	lr, r3
		if (tsect < sysect) return FR_NO_FILESYSTEM;	/* (Invalid volume size) */
 8005c46:	4570      	cmp	r0, lr
 8005c48:	f0c0 808c 	bcc.w	8005d64 <find_volume+0x268>
		nclst = (tsect - sysect) / fs->csize;			/* Number of clusters */
 8005c4c:	eba0 010e 	sub.w	r1, r0, lr
 8005c50:	fbb1 f1f7 	udiv	r1, r1, r7
		if (nclst == 0) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
 8005c54:	2900      	cmp	r1, #0
 8005c56:	f000 8085 	beq.w	8005d64 <find_volume+0x268>
		if (nclst <= MAX_FAT16) fmt = FS_FAT16;
 8005c5a:	f64f 70f5 	movw	r0, #65525	; 0xfff5
 8005c5e:	4281      	cmp	r1, r0
 8005c60:	f200 8084 	bhi.w	8005d6c <find_volume+0x270>
		if (nclst <= MAX_FAT12) fmt = FS_FAT12;
 8005c64:	f640 77f5 	movw	r7, #4085	; 0xff5
 8005c68:	42b9      	cmp	r1, r7
 8005c6a:	bf8c      	ite	hi
 8005c6c:	2702      	movhi	r7, #2
 8005c6e:	2701      	movls	r7, #1
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8005c70:	3102      	adds	r1, #2
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8005c72:	4432      	add	r2, r6
		fs->database = bsect + sysect;					/* Data start sector */
 8005c74:	eb06 000e 	add.w	r0, r6, lr
		if (fmt == FS_FAT32) {
 8005c78:	2f03      	cmp	r7, #3
		fs->n_fatent = nclst + 2;						/* Number of FAT entries */
 8005c7a:	6161      	str	r1, [r4, #20]
		fs->volbase = bsect;							/* Volume start sector */
 8005c7c:	61e6      	str	r6, [r4, #28]
		fs->fatbase = bsect + nrsv; 					/* FAT start sector */
 8005c7e:	6222      	str	r2, [r4, #32]
		fs->database = bsect + sysect;					/* Data start sector */
 8005c80:	62a0      	str	r0, [r4, #40]	; 0x28
		if (fmt == FS_FAT32) {
 8005c82:	d175      	bne.n	8005d70 <find_volume+0x274>
	rv = rv << 8 | ptr[0];
 8005c84:	f894 205b 	ldrb.w	r2, [r4, #91]	; 0x5b
 8005c88:	f894 305a 	ldrb.w	r3, [r4, #90]	; 0x5a
			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
 8005c8c:	ea53 2302 	orrs.w	r3, r3, r2, lsl #8
 8005c90:	d168      	bne.n	8005d64 <find_volume+0x268>
			if (fs->n_rootdir) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be 0) */
 8005c92:	f1b8 0f00 	cmp.w	r8, #0
 8005c96:	d165      	bne.n	8005d64 <find_volume+0x268>
			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
 8005c98:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8005c9c:	f7ff fcc6 	bl	800562c <ld_dword>
 8005ca0:	6260      	str	r0, [r4, #36]	; 0x24
			szbfat = fs->n_fatent * 4;					/* (Needed FAT size) */
 8005ca2:	0089      	lsls	r1, r1, #2
		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
 8005ca4:	f201 11ff 	addw	r1, r1, #511	; 0x1ff
 8005ca8:	ebb5 2f51 	cmp.w	r5, r1, lsr #9
 8005cac:	d35a      	bcc.n	8005d64 <find_volume+0x268>
		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
 8005cae:	f04f 33ff 	mov.w	r3, #4294967295
 8005cb2:	6123      	str	r3, [r4, #16]
 8005cb4:	60e3      	str	r3, [r4, #12]
		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
 8005cb6:	2f03      	cmp	r7, #3
		fs->fsi_flag = 0x80;
 8005cb8:	f04f 0380 	mov.w	r3, #128	; 0x80
 8005cbc:	7123      	strb	r3, [r4, #4]
		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
 8005cbe:	d12f      	bne.n	8005d20 <find_volume+0x224>
	rv = rv << 8 | ptr[0];
 8005cc0:	f894 2061 	ldrb.w	r2, [r4, #97]	; 0x61
 8005cc4:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
 8005cc8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			&& ld_word(fs->win + BPB_FSInfo32) == 1
 8005ccc:	2b01      	cmp	r3, #1
 8005cce:	d127      	bne.n	8005d20 <find_volume+0x224>
			&& move_window(fs, bsect + 1) == FR_OK)
 8005cd0:	1c71      	adds	r1, r6, #1
 8005cd2:	4620      	mov	r0, r4
 8005cd4:	f7ff feb6 	bl	8005a44 <move_window>
 8005cd8:	bb10      	cbnz	r0, 8005d20 <find_volume+0x224>
	rv = rv << 8 | ptr[0];
 8005cda:	f894 222f 	ldrb.w	r2, [r4, #559]	; 0x22f
 8005cde:	f894 322e 	ldrb.w	r3, [r4, #558]	; 0x22e
			fs->fsi_flag = 0;
 8005ce2:	7120      	strb	r0, [r4, #4]
	rv = rv << 8 | ptr[0];
 8005ce4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
 8005ce8:	f64a 2255 	movw	r2, #43605	; 0xaa55
 8005cec:	4293      	cmp	r3, r2
 8005cee:	d117      	bne.n	8005d20 <find_volume+0x224>
				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
 8005cf0:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8005cf4:	f7ff fc9a 	bl	800562c <ld_dword>
 8005cf8:	4b2b      	ldr	r3, [pc, #172]	; (8005da8 <find_volume+0x2ac>)
 8005cfa:	4298      	cmp	r0, r3
 8005cfc:	d110      	bne.n	8005d20 <find_volume+0x224>
				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
 8005cfe:	f504 7005 	add.w	r0, r4, #532	; 0x214
 8005d02:	f7ff fc93 	bl	800562c <ld_dword>
 8005d06:	4b29      	ldr	r3, [pc, #164]	; (8005dac <find_volume+0x2b0>)
 8005d08:	4298      	cmp	r0, r3
 8005d0a:	d109      	bne.n	8005d20 <find_volume+0x224>
				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
 8005d0c:	f504 7006 	add.w	r0, r4, #536	; 0x218
 8005d10:	f7ff fc8c 	bl	800562c <ld_dword>
 8005d14:	6120      	str	r0, [r4, #16]
				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
 8005d16:	f504 7007 	add.w	r0, r4, #540	; 0x21c
 8005d1a:	f7ff fc87 	bl	800562c <ld_dword>
 8005d1e:	60e0      	str	r0, [r4, #12]
	fs->id = ++Fsid;		/* File system mount ID */
 8005d20:	4a23      	ldr	r2, [pc, #140]	; (8005db0 <find_volume+0x2b4>)
	fs->fs_type = fmt;		/* FAT sub-type */
 8005d22:	7027      	strb	r7, [r4, #0]
	fs->id = ++Fsid;		/* File system mount ID */
 8005d24:	8813      	ldrh	r3, [r2, #0]
 8005d26:	3301      	adds	r3, #1
 8005d28:	b29b      	uxth	r3, r3
 8005d2a:	8013      	strh	r3, [r2, #0]
 8005d2c:	80e3      	strh	r3, [r4, #6]
		if (Files[i].fs == fs) Files[i].fs = 0;
 8005d2e:	4b21      	ldr	r3, [pc, #132]	; (8005db4 <find_volume+0x2b8>)
 8005d30:	681a      	ldr	r2, [r3, #0]
 8005d32:	4294      	cmp	r4, r2
 8005d34:	bf04      	itt	eq
 8005d36:	2200      	moveq	r2, #0
 8005d38:	601a      	streq	r2, [r3, #0]
 8005d3a:	691a      	ldr	r2, [r3, #16]
 8005d3c:	4294      	cmp	r4, r2
 8005d3e:	f04f 0000 	mov.w	r0, #0
 8005d42:	f47f aefe 	bne.w	8005b42 <find_volume+0x46>
 8005d46:	6118      	str	r0, [r3, #16]
 8005d48:	e6fb      	b.n	8005b42 <find_volume+0x46>
			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
 8005d4a:	2003      	movs	r0, #3
		} while (LD2PT(vol) == 0 && fmt >= 2 && ++i < 4);
 8005d4c:	3501      	adds	r5, #1
 8005d4e:	2d04      	cmp	r5, #4
 8005d50:	f47f af1e 	bne.w	8005b90 <find_volume+0x94>
	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
 8005d54:	2804      	cmp	r0, #4
 8005d56:	d105      	bne.n	8005d64 <find_volume+0x268>
 8005d58:	2001      	movs	r0, #1
 8005d5a:	e6f2      	b.n	8005b42 <find_volume+0x46>
 8005d5c:	2804      	cmp	r0, #4
 8005d5e:	d0fb      	beq.n	8005d58 <find_volume+0x25c>
	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
 8005d60:	2801      	cmp	r0, #1
 8005d62:	d901      	bls.n	8005d68 <find_volume+0x26c>
 8005d64:	200d      	movs	r0, #13
 8005d66:	e6ec      	b.n	8005b42 <find_volume+0x46>
	bsect = 0;
 8005d68:	2600      	movs	r6, #0
 8005d6a:	e71d      	b.n	8005ba8 <find_volume+0xac>
		fmt = FS_FAT32;
 8005d6c:	2703      	movs	r7, #3
 8005d6e:	e77f      	b.n	8005c70 <find_volume+0x174>
			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
 8005d70:	f1b8 0f00 	cmp.w	r8, #0
 8005d74:	d0f6      	beq.n	8005d64 <find_volume+0x268>
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8005d76:	2f02      	cmp	r7, #2
 8005d78:	ea4f 0041 	mov.w	r0, r1, lsl #1
 8005d7c:	bf18      	it	ne
 8005d7e:	1840      	addne	r0, r0, r1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8005d80:	4413      	add	r3, r2
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8005d82:	bf18      	it	ne
 8005d84:	f001 0101 	andne.w	r1, r1, #1
			fs->dirbase = fs->fatbase + fasize;			/* Root directory start sector */
 8005d88:	6263      	str	r3, [r4, #36]	; 0x24
				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
 8005d8a:	bf0c      	ite	eq
 8005d8c:	4601      	moveq	r1, r0
 8005d8e:	eb01 0150 	addne.w	r1, r1, r0, lsr #1
 8005d92:	e787      	b.n	8005ca4 <find_volume+0x1a8>
	if (vol < 0) return FR_INVALID_DRIVE;
 8005d94:	200b      	movs	r0, #11
 8005d96:	e6d4      	b.n	8005b42 <find_volume+0x46>
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
 8005d98:	200c      	movs	r0, #12
 8005d9a:	e6d2      	b.n	8005b42 <find_volume+0x46>
			return FR_OK;				/* The file system object is valid */
 8005d9c:	4628      	mov	r0, r5
 8005d9e:	e6d0      	b.n	8005b42 <find_volume+0x46>
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
 8005da0:	2003      	movs	r0, #3
 8005da2:	e6ce      	b.n	8005b42 <find_volume+0x46>
 8005da4:	20000264 	.word	0x20000264
 8005da8:	41615252 	.word	0x41615252
 8005dac:	61417272 	.word	0x61417272
 8005db0:	20000288 	.word	0x20000288
 8005db4:	20000268 	.word	0x20000268

08005db8 <put_fat>:
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8005db8:	2901      	cmp	r1, #1
{
 8005dba:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8005dbe:	4605      	mov	r5, r0
 8005dc0:	460c      	mov	r4, r1
 8005dc2:	4617      	mov	r7, r2
	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
 8005dc4:	d972      	bls.n	8005eac <put_fat+0xf4>
 8005dc6:	6943      	ldr	r3, [r0, #20]
 8005dc8:	4299      	cmp	r1, r3
 8005dca:	d26f      	bcs.n	8005eac <put_fat+0xf4>
		switch (fs->fs_type) {
 8005dcc:	7803      	ldrb	r3, [r0, #0]
 8005dce:	2b02      	cmp	r3, #2
 8005dd0:	d03f      	beq.n	8005e52 <put_fat+0x9a>
 8005dd2:	2b03      	cmp	r3, #3
 8005dd4:	d050      	beq.n	8005e78 <put_fat+0xc0>
 8005dd6:	2b01      	cmp	r3, #1
 8005dd8:	d168      	bne.n	8005eac <put_fat+0xf4>
			bc = (UINT)clst; bc += bc / 2;
 8005dda:	eb01 0851 	add.w	r8, r1, r1, lsr #1
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8005dde:	6a01      	ldr	r1, [r0, #32]
 8005de0:	eb01 2158 	add.w	r1, r1, r8, lsr #9
 8005de4:	f7ff fe2e 	bl	8005a44 <move_window>
 8005de8:	4606      	mov	r6, r0
			if (res != FR_OK) break;
 8005dea:	bb38      	cbnz	r0, 8005e3c <put_fat+0x84>
			p = fs->win + bc++ % SS(fs);
 8005dec:	f105 0930 	add.w	r9, r5, #48	; 0x30
 8005df0:	f108 0a01 	add.w	sl, r8, #1
 8005df4:	f3c8 0808 	ubfx	r8, r8, #0, #9
			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
 8005df8:	f014 0401 	ands.w	r4, r4, #1
 8005dfc:	bf1f      	itttt	ne
 8005dfe:	f819 3008 	ldrbne.w	r3, [r9, r8]
 8005e02:	f003 020f 	andne.w	r2, r3, #15
 8005e06:	013b      	lslne	r3, r7, #4
 8005e08:	f003 03f0 	andne.w	r3, r3, #240	; 0xf0
 8005e0c:	bf14      	ite	ne
 8005e0e:	4313      	orrne	r3, r2
 8005e10:	b2fb      	uxtbeq	r3, r7
 8005e12:	f809 3008 	strb.w	r3, [r9, r8]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8005e16:	6a29      	ldr	r1, [r5, #32]
			fs->wflag = 1;
 8005e18:	2301      	movs	r3, #1
 8005e1a:	70eb      	strb	r3, [r5, #3]
			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
 8005e1c:	eb01 215a 	add.w	r1, r1, sl, lsr #9
 8005e20:	4628      	mov	r0, r5
 8005e22:	f7ff fe0f 	bl	8005a44 <move_window>
			if (res != FR_OK) break;
 8005e26:	4606      	mov	r6, r0
 8005e28:	b940      	cbnz	r0, 8005e3c <put_fat+0x84>
			p = fs->win + bc % SS(fs);
 8005e2a:	f3ca 0a08 	ubfx	sl, sl, #0, #9
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8005e2e:	b144      	cbz	r4, 8005e42 <put_fat+0x8a>
 8005e30:	f3c7 1707 	ubfx	r7, r7, #4, #8
 8005e34:	f809 700a 	strb.w	r7, [r9, sl]
			fs->wflag = 1;
 8005e38:	2301      	movs	r3, #1
 8005e3a:	70eb      	strb	r3, [r5, #3]
}
 8005e3c:	4630      	mov	r0, r6
 8005e3e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
 8005e42:	f819 300a 	ldrb.w	r3, [r9, sl]
 8005e46:	f3c7 2703 	ubfx	r7, r7, #8, #4
 8005e4a:	f023 030f 	bic.w	r3, r3, #15
 8005e4e:	431f      	orrs	r7, r3
 8005e50:	e7f0      	b.n	8005e34 <put_fat+0x7c>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
 8005e52:	6a01      	ldr	r1, [r0, #32]
 8005e54:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 8005e58:	f7ff fdf4 	bl	8005a44 <move_window>
			if (res != FR_OK) break;
 8005e5c:	4606      	mov	r6, r0
 8005e5e:	2800      	cmp	r0, #0
 8005e60:	d1ec      	bne.n	8005e3c <put_fat+0x84>
			st_word(fs->win + clst * 2 % SS(fs), (WORD)val);
 8005e62:	0064      	lsls	r4, r4, #1
 8005e64:	f105 0330 	add.w	r3, r5, #48	; 0x30
 8005e68:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
 8005e6c:	191a      	adds	r2, r3, r4
	*ptr++ = (BYTE)val; val >>= 8;
 8005e6e:	551f      	strb	r7, [r3, r4]
 8005e70:	f3c7 2707 	ubfx	r7, r7, #8, #8
	*ptr++ = (BYTE)val;
 8005e74:	7057      	strb	r7, [r2, #1]
 8005e76:	e7df      	b.n	8005e38 <put_fat+0x80>
			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
 8005e78:	6a01      	ldr	r1, [r0, #32]
 8005e7a:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 8005e7e:	f7ff fde1 	bl	8005a44 <move_window>
			if (res != FR_OK) break;
 8005e82:	4606      	mov	r6, r0
 8005e84:	2800      	cmp	r0, #0
 8005e86:	d1d9      	bne.n	8005e3c <put_fat+0x84>
				val = (val & 0x0FFFFFFF) | (ld_dword(fs->win + clst * 4 % SS(fs)) & 0xF0000000);
 8005e88:	00a4      	lsls	r4, r4, #2
 8005e8a:	f105 0330 	add.w	r3, r5, #48	; 0x30
 8005e8e:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
 8005e92:	441c      	add	r4, r3
 8005e94:	4620      	mov	r0, r4
 8005e96:	f7ff fbc9 	bl	800562c <ld_dword>
 8005e9a:	f027 4770 	bic.w	r7, r7, #4026531840	; 0xf0000000
 8005e9e:	f000 4170 	and.w	r1, r0, #4026531840	; 0xf0000000
			st_dword(fs->win + clst * 4 % SS(fs), val);
 8005ea2:	4339      	orrs	r1, r7
 8005ea4:	4620      	mov	r0, r4
 8005ea6:	f7ff fbc9 	bl	800563c <st_dword>
 8005eaa:	e7c5      	b.n	8005e38 <put_fat+0x80>
	FRESULT res = FR_INT_ERR;
 8005eac:	2602      	movs	r6, #2
 8005eae:	e7c5      	b.n	8005e3c <put_fat+0x84>

08005eb0 <get_fat.isra.8>:
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8005eb0:	2901      	cmp	r1, #1
DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
 8005eb2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005eb4:	4605      	mov	r5, r0
 8005eb6:	460c      	mov	r4, r1
	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
 8005eb8:	d952      	bls.n	8005f60 <get_fat.isra.8+0xb0>
 8005eba:	6943      	ldr	r3, [r0, #20]
 8005ebc:	4299      	cmp	r1, r3
 8005ebe:	d24f      	bcs.n	8005f60 <get_fat.isra.8+0xb0>
		switch (fs->fs_type) {
 8005ec0:	7803      	ldrb	r3, [r0, #0]
 8005ec2:	2b02      	cmp	r3, #2
 8005ec4:	d029      	beq.n	8005f1a <get_fat.isra.8+0x6a>
 8005ec6:	2b03      	cmp	r3, #3
 8005ec8:	d038      	beq.n	8005f3c <get_fat.isra.8+0x8c>
 8005eca:	2b01      	cmp	r3, #1
 8005ecc:	d148      	bne.n	8005f60 <get_fat.isra.8+0xb0>
			bc = (UINT)clst; bc += bc / 2;
 8005ece:	eb01 0651 	add.w	r6, r1, r1, lsr #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8005ed2:	6a01      	ldr	r1, [r0, #32]
 8005ed4:	eb01 2156 	add.w	r1, r1, r6, lsr #9
 8005ed8:	f7ff fdb4 	bl	8005a44 <move_window>
 8005edc:	b110      	cbz	r0, 8005ee4 <get_fat.isra.8+0x34>
		val = 0xFFFFFFFF;	/* Default value falls on disk error */
 8005ede:	f04f 30ff 	mov.w	r0, #4294967295
 8005ee2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			wc = fs->win[bc++ % SS(fs)];
 8005ee4:	1c77      	adds	r7, r6, #1
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8005ee6:	6a29      	ldr	r1, [r5, #32]
			wc = fs->win[bc++ % SS(fs)];
 8005ee8:	f3c6 0608 	ubfx	r6, r6, #0, #9
 8005eec:	442e      	add	r6, r5
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8005eee:	eb01 2157 	add.w	r1, r1, r7, lsr #9
 8005ef2:	4628      	mov	r0, r5
			wc = fs->win[bc++ % SS(fs)];
 8005ef4:	f896 6030 	ldrb.w	r6, [r6, #48]	; 0x30
			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
 8005ef8:	f7ff fda4 	bl	8005a44 <move_window>
 8005efc:	2800      	cmp	r0, #0
 8005efe:	d1ee      	bne.n	8005ede <get_fat.isra.8+0x2e>
			wc |= fs->win[bc % SS(fs)] << 8;
 8005f00:	f3c7 0708 	ubfx	r7, r7, #0, #9
 8005f04:	443d      	add	r5, r7
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8005f06:	07e3      	lsls	r3, r4, #31
			wc |= fs->win[bc % SS(fs)] << 8;
 8005f08:	f895 0030 	ldrb.w	r0, [r5, #48]	; 0x30
 8005f0c:	ea46 2000 	orr.w	r0, r6, r0, lsl #8
			val = (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
 8005f10:	bf4c      	ite	mi
 8005f12:	0900      	lsrmi	r0, r0, #4
 8005f14:	f3c0 000b 	ubfxpl	r0, r0, #0, #12
 8005f18:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
 8005f1a:	6a01      	ldr	r1, [r0, #32]
 8005f1c:	eb01 2114 	add.w	r1, r1, r4, lsr #8
 8005f20:	f7ff fd90 	bl	8005a44 <move_window>
 8005f24:	2800      	cmp	r0, #0
 8005f26:	d1da      	bne.n	8005ede <get_fat.isra.8+0x2e>
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8005f28:	0064      	lsls	r4, r4, #1
 8005f2a:	3530      	adds	r5, #48	; 0x30
 8005f2c:	f404 74ff 	and.w	r4, r4, #510	; 0x1fe
 8005f30:	192b      	adds	r3, r5, r4
	rv = rv << 8 | ptr[0];
 8005f32:	5d28      	ldrb	r0, [r5, r4]
 8005f34:	785b      	ldrb	r3, [r3, #1]
			val = ld_word(fs->win + clst * 2 % SS(fs));
 8005f36:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
 8005f3a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
 8005f3c:	6a01      	ldr	r1, [r0, #32]
 8005f3e:	eb01 11d4 	add.w	r1, r1, r4, lsr #7
 8005f42:	f7ff fd7f 	bl	8005a44 <move_window>
 8005f46:	2800      	cmp	r0, #0
 8005f48:	d1c9      	bne.n	8005ede <get_fat.isra.8+0x2e>
			val = ld_dword(fs->win + clst * 4 % SS(fs)) & 0x0FFFFFFF;
 8005f4a:	00a4      	lsls	r4, r4, #2
 8005f4c:	f105 0030 	add.w	r0, r5, #48	; 0x30
 8005f50:	f404 74fe 	and.w	r4, r4, #508	; 0x1fc
 8005f54:	4420      	add	r0, r4
 8005f56:	f7ff fb69 	bl	800562c <ld_dword>
 8005f5a:	f020 4070 	bic.w	r0, r0, #4026531840	; 0xf0000000
 8005f5e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
			val = 1;	/* Internal error */
 8005f60:	2001      	movs	r0, #1
}
 8005f62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08005f64 <create_chain>:
{
 8005f64:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005f68:	4680      	mov	r8, r0
	FATFS *fs = obj->fs;
 8005f6a:	6805      	ldr	r5, [r0, #0]
	if (clst == 0) {	/* Create a new chain */
 8005f6c:	460f      	mov	r7, r1
 8005f6e:	b971      	cbnz	r1, 8005f8e <create_chain+0x2a>
		scl = fs->last_clst;				/* Get suggested cluster to start from */
 8005f70:	68ee      	ldr	r6, [r5, #12]
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8005f72:	b1f6      	cbz	r6, 8005fb2 <create_chain+0x4e>
 8005f74:	696b      	ldr	r3, [r5, #20]
 8005f76:	429e      	cmp	r6, r3
 8005f78:	bf28      	it	cs
 8005f7a:	2601      	movcs	r6, #1
 8005f7c:	4634      	mov	r4, r6
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8005f7e:	696b      	ldr	r3, [r5, #20]
			ncl++;							/* Next cluster */
 8005f80:	3401      	adds	r4, #1
			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
 8005f82:	429c      	cmp	r4, r3
 8005f84:	d318      	bcc.n	8005fb8 <create_chain+0x54>
				if (ncl > scl) return 0;	/* No free cluster */
 8005f86:	2e01      	cmp	r6, #1
 8005f88:	d815      	bhi.n	8005fb6 <create_chain+0x52>
 8005f8a:	2400      	movs	r4, #0
 8005f8c:	e009      	b.n	8005fa2 <create_chain+0x3e>
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8005f8e:	4628      	mov	r0, r5
 8005f90:	f7ff ff8e 	bl	8005eb0 <get_fat.isra.8>
		if (cs < 2) return 1;				/* Invalid FAT value */
 8005f94:	2801      	cmp	r0, #1
		cs = get_fat(obj, clst);			/* Check the cluster status */
 8005f96:	4604      	mov	r4, r0
		if (cs < 2) return 1;				/* Invalid FAT value */
 8005f98:	d937      	bls.n	800600a <create_chain+0xa6>
		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
 8005f9a:	1c43      	adds	r3, r0, #1
 8005f9c:	d104      	bne.n	8005fa8 <create_chain+0x44>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 8005f9e:	f04f 34ff 	mov.w	r4, #4294967295
}
 8005fa2:	4620      	mov	r0, r4
 8005fa4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
 8005fa8:	696b      	ldr	r3, [r5, #20]
 8005faa:	4298      	cmp	r0, r3
 8005fac:	d3f9      	bcc.n	8005fa2 <create_chain+0x3e>
 8005fae:	463e      	mov	r6, r7
 8005fb0:	e7e4      	b.n	8005f7c <create_chain+0x18>
		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
 8005fb2:	2601      	movs	r6, #1
 8005fb4:	e7e2      	b.n	8005f7c <create_chain+0x18>
				ncl = 2;
 8005fb6:	2402      	movs	r4, #2
			cs = get_fat(obj, ncl);			/* Get the cluster status */
 8005fb8:	4621      	mov	r1, r4
 8005fba:	f8d8 0000 	ldr.w	r0, [r8]
 8005fbe:	f7ff ff77 	bl	8005eb0 <get_fat.isra.8>
			if (cs == 0) break;				/* Found a free cluster */
 8005fc2:	b130      	cbz	r0, 8005fd2 <create_chain+0x6e>
			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
 8005fc4:	2801      	cmp	r0, #1
 8005fc6:	d020      	beq.n	800600a <create_chain+0xa6>
 8005fc8:	3001      	adds	r0, #1
 8005fca:	d0e8      	beq.n	8005f9e <create_chain+0x3a>
			if (ncl == scl) return 0;		/* No free cluster */
 8005fcc:	42b4      	cmp	r4, r6
 8005fce:	d1d6      	bne.n	8005f7e <create_chain+0x1a>
 8005fd0:	e7db      	b.n	8005f8a <create_chain+0x26>
		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
 8005fd2:	f04f 32ff 	mov.w	r2, #4294967295
 8005fd6:	4621      	mov	r1, r4
 8005fd8:	4628      	mov	r0, r5
 8005fda:	f7ff feed 	bl	8005db8 <put_fat>
		if (res == FR_OK && clst != 0) {
 8005fde:	b990      	cbnz	r0, 8006006 <create_chain+0xa2>
 8005fe0:	b957      	cbnz	r7, 8005ff8 <create_chain+0x94>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8005fe2:	696a      	ldr	r2, [r5, #20]
 8005fe4:	692b      	ldr	r3, [r5, #16]
		fs->last_clst = ncl;
 8005fe6:	60ec      	str	r4, [r5, #12]
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 8005fe8:	3a02      	subs	r2, #2
 8005fea:	4293      	cmp	r3, r2
 8005fec:	d90f      	bls.n	800600e <create_chain+0xaa>
		fs->fsi_flag |= 1;
 8005fee:	792b      	ldrb	r3, [r5, #4]
 8005ff0:	f043 0301 	orr.w	r3, r3, #1
 8005ff4:	712b      	strb	r3, [r5, #4]
 8005ff6:	e7d4      	b.n	8005fa2 <create_chain+0x3e>
			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
 8005ff8:	4622      	mov	r2, r4
 8005ffa:	4639      	mov	r1, r7
 8005ffc:	4628      	mov	r0, r5
 8005ffe:	f7ff fedb 	bl	8005db8 <put_fat>
	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
 8006002:	2800      	cmp	r0, #0
 8006004:	d0ed      	beq.n	8005fe2 <create_chain+0x7e>
		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Generate error status */
 8006006:	2801      	cmp	r0, #1
 8006008:	d0c9      	beq.n	8005f9e <create_chain+0x3a>
 800600a:	2401      	movs	r4, #1
 800600c:	e7c9      	b.n	8005fa2 <create_chain+0x3e>
		if (fs->free_clst <= fs->n_fatent - 2) fs->free_clst--;
 800600e:	3b01      	subs	r3, #1
 8006010:	612b      	str	r3, [r5, #16]
 8006012:	e7ec      	b.n	8005fee <create_chain+0x8a>

08006014 <remove_chain>:
{
 8006014:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006016:	460d      	mov	r5, r1
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8006018:	2d01      	cmp	r5, #1
{
 800601a:	4607      	mov	r7, r0
 800601c:	4611      	mov	r1, r2
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 800601e:	d801      	bhi.n	8006024 <remove_chain+0x10>
 8006020:	2002      	movs	r0, #2
 8006022:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	FATFS *fs = obj->fs;
 8006024:	6804      	ldr	r4, [r0, #0]
	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
 8006026:	6963      	ldr	r3, [r4, #20]
 8006028:	429d      	cmp	r5, r3
 800602a:	d2f9      	bcs.n	8006020 <remove_chain+0xc>
	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
 800602c:	b12a      	cbz	r2, 800603a <remove_chain+0x26>
		res = put_fat(fs, pclst, 0xFFFFFFFF);
 800602e:	f04f 32ff 	mov.w	r2, #4294967295
 8006032:	4620      	mov	r0, r4
 8006034:	f7ff fec0 	bl	8005db8 <put_fat>
		if (res != FR_OK) return res;
 8006038:	bb08      	cbnz	r0, 800607e <remove_chain+0x6a>
		nxt = get_fat(obj, clst);			/* Get cluster status */
 800603a:	4629      	mov	r1, r5
 800603c:	6838      	ldr	r0, [r7, #0]
 800603e:	f7ff ff37 	bl	8005eb0 <get_fat.isra.8>
		if (nxt == 0) break;				/* Empty cluster? */
 8006042:	4606      	mov	r6, r0
 8006044:	b908      	cbnz	r0, 800604a <remove_chain+0x36>
	return FR_OK;
 8006046:	2000      	movs	r0, #0
 8006048:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
 800604a:	2801      	cmp	r0, #1
 800604c:	d0e8      	beq.n	8006020 <remove_chain+0xc>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800604e:	1c43      	adds	r3, r0, #1
 8006050:	d014      	beq.n	800607c <remove_chain+0x68>
			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
 8006052:	2200      	movs	r2, #0
 8006054:	4629      	mov	r1, r5
 8006056:	4620      	mov	r0, r4
 8006058:	f7ff feae 	bl	8005db8 <put_fat>
			if (res != FR_OK) return res;
 800605c:	b978      	cbnz	r0, 800607e <remove_chain+0x6a>
		if (fs->free_clst < fs->n_fatent - 2) {	/* Update FSINFO */
 800605e:	6962      	ldr	r2, [r4, #20]
 8006060:	6923      	ldr	r3, [r4, #16]
 8006062:	1e91      	subs	r1, r2, #2
 8006064:	428b      	cmp	r3, r1
 8006066:	d205      	bcs.n	8006074 <remove_chain+0x60>
			fs->free_clst++;
 8006068:	3301      	adds	r3, #1
 800606a:	6123      	str	r3, [r4, #16]
			fs->fsi_flag |= 1;
 800606c:	7923      	ldrb	r3, [r4, #4]
 800606e:	f043 0301 	orr.w	r3, r3, #1
 8006072:	7123      	strb	r3, [r4, #4]
	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
 8006074:	4296      	cmp	r6, r2
 8006076:	4635      	mov	r5, r6
 8006078:	d3df      	bcc.n	800603a <remove_chain+0x26>
 800607a:	e7e4      	b.n	8006046 <remove_chain+0x32>
		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
 800607c:	2001      	movs	r0, #1
}
 800607e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006080 <dir_sdi.constprop.14>:
	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
 8006080:	6882      	ldr	r2, [r0, #8]
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 8006082:	b538      	push	{r3, r4, r5, lr}
	dp->dptr = ofs;				/* Set current offset */
 8006084:	2300      	movs	r3, #0
FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
 8006086:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
 8006088:	6804      	ldr	r4, [r0, #0]
	dp->dptr = ofs;				/* Set current offset */
 800608a:	6143      	str	r3, [r0, #20]
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 800608c:	b992      	cbnz	r2, 80060b4 <dir_sdi.constprop.14+0x34>
 800608e:	7823      	ldrb	r3, [r4, #0]
 8006090:	2b02      	cmp	r3, #2
 8006092:	d901      	bls.n	8006098 <dir_sdi.constprop.14+0x18>
		clst = fs->dirbase;
 8006094:	6a63      	ldr	r3, [r4, #36]	; 0x24
	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
 8006096:	b973      	cbnz	r3, 80060b6 <dir_sdi.constprop.14+0x36>
		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
 8006098:	8923      	ldrh	r3, [r4, #8]
 800609a:	b90b      	cbnz	r3, 80060a0 <dir_sdi.constprop.14+0x20>
 800609c:	2002      	movs	r0, #2
 800609e:	bd38      	pop	{r3, r4, r5, pc}
		dp->sect = fs->dirbase;
 80060a0:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80060a2:	61eb      	str	r3, [r5, #28]
	if (!dp->sect) return FR_INT_ERR;
 80060a4:	69eb      	ldr	r3, [r5, #28]
	dp->clust = clst;					/* Current cluster# */
 80060a6:	61aa      	str	r2, [r5, #24]
	if (!dp->sect) return FR_INT_ERR;
 80060a8:	2b00      	cmp	r3, #0
 80060aa:	d0f7      	beq.n	800609c <dir_sdi.constprop.14+0x1c>
	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
 80060ac:	3430      	adds	r4, #48	; 0x30
 80060ae:	622c      	str	r4, [r5, #32]
	return FR_OK;
 80060b0:	2000      	movs	r0, #0
 80060b2:	bd38      	pop	{r3, r4, r5, pc}
	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
 80060b4:	4613      	mov	r3, r2
		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
 80060b6:	8961      	ldrh	r1, [r4, #10]
 80060b8:	461a      	mov	r2, r3
		while (ofs >= csz) {				/* Follow cluster chain */
 80060ba:	b961      	cbnz	r1, 80060d6 <dir_sdi.constprop.14+0x56>
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 80060bc:	4611      	mov	r1, r2
 80060be:	6828      	ldr	r0, [r5, #0]
 80060c0:	f7ff fef6 	bl	8005eb0 <get_fat.isra.8>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80060c4:	1c43      	adds	r3, r0, #1
			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
 80060c6:	4602      	mov	r2, r0
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80060c8:	d00b      	beq.n	80060e2 <dir_sdi.constprop.14+0x62>
			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
 80060ca:	2801      	cmp	r0, #1
 80060cc:	d9e6      	bls.n	800609c <dir_sdi.constprop.14+0x1c>
 80060ce:	6963      	ldr	r3, [r4, #20]
 80060d0:	4298      	cmp	r0, r3
 80060d2:	d3f3      	bcc.n	80060bc <dir_sdi.constprop.14+0x3c>
 80060d4:	e7e2      	b.n	800609c <dir_sdi.constprop.14+0x1c>
		dp->sect = clust2sect(fs, clst);
 80060d6:	4619      	mov	r1, r3
 80060d8:	4620      	mov	r0, r4
 80060da:	f7ff fb3f 	bl	800575c <clust2sect>
 80060de:	61e8      	str	r0, [r5, #28]
 80060e0:	e7e0      	b.n	80060a4 <dir_sdi.constprop.14+0x24>
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 80060e2:	2001      	movs	r0, #1
}
 80060e4:	bd38      	pop	{r3, r4, r5, pc}

080060e6 <dir_next>:
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 80060e6:	69c3      	ldr	r3, [r0, #28]
{
 80060e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80060ec:	4605      	mov	r5, r0
 80060ee:	460f      	mov	r7, r1
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 80060f0:	b1ab      	cbz	r3, 800611e <dir_next+0x38>
	ofs = dp->dptr + SZDIRE;	/* Next entry */
 80060f2:	6942      	ldr	r2, [r0, #20]
 80060f4:	f102 0820 	add.w	r8, r2, #32
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 80060f8:	f5b8 1f00 	cmp.w	r8, #2097152	; 0x200000
 80060fc:	d20f      	bcs.n	800611e <dir_next+0x38>
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 80060fe:	f3c8 0908 	ubfx	r9, r8, #0, #9
	FATFS *fs = dp->obj.fs;
 8006102:	6804      	ldr	r4, [r0, #0]
	if (ofs % SS(fs) == 0) {	/* Sector changed? */
 8006104:	f1b9 0f00 	cmp.w	r9, #0
 8006108:	d14f      	bne.n	80061aa <dir_next+0xc4>
		if (!dp->clust) {		/* Static table */
 800610a:	6981      	ldr	r1, [r0, #24]
		dp->sect++;				/* Next sector */
 800610c:	3301      	adds	r3, #1
 800610e:	61c3      	str	r3, [r0, #28]
		if (!dp->clust) {		/* Static table */
 8006110:	b941      	cbnz	r1, 8006124 <dir_next+0x3e>
			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
 8006112:	8923      	ldrh	r3, [r4, #8]
 8006114:	ebb3 1f58 	cmp.w	r3, r8, lsr #5
 8006118:	d847      	bhi.n	80061aa <dir_next+0xc4>
				dp->sect = 0; return FR_NO_FILE;
 800611a:	2300      	movs	r3, #0
 800611c:	61eb      	str	r3, [r5, #28]
	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
 800611e:	2004      	movs	r0, #4
 8006120:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
 8006124:	8963      	ldrh	r3, [r4, #10]
 8006126:	3b01      	subs	r3, #1
 8006128:	ea13 2358 	ands.w	r3, r3, r8, lsr #9
 800612c:	d13d      	bne.n	80061aa <dir_next+0xc4>
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 800612e:	4620      	mov	r0, r4
 8006130:	f7ff febe 	bl	8005eb0 <get_fat.isra.8>
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8006134:	2801      	cmp	r0, #1
				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
 8006136:	4606      	mov	r6, r0
				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
 8006138:	d802      	bhi.n	8006140 <dir_next+0x5a>
 800613a:	2002      	movs	r0, #2
 800613c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
 8006140:	1c42      	adds	r2, r0, #1
 8006142:	d102      	bne.n	800614a <dir_next+0x64>
 8006144:	2001      	movs	r0, #1
 8006146:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
 800614a:	6963      	ldr	r3, [r4, #20]
 800614c:	4298      	cmp	r0, r3
 800614e:	d326      	bcc.n	800619e <dir_next+0xb8>
					if (!stretch) {								/* If no stretch, report EOT */
 8006150:	2f00      	cmp	r7, #0
 8006152:	d0e2      	beq.n	800611a <dir_next+0x34>
					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
 8006154:	69a9      	ldr	r1, [r5, #24]
 8006156:	4628      	mov	r0, r5
 8006158:	f7ff ff04 	bl	8005f64 <create_chain>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 800615c:	4606      	mov	r6, r0
 800615e:	2800      	cmp	r0, #0
 8006160:	d037      	beq.n	80061d2 <dir_next+0xec>
					if (clst == 1) return FR_INT_ERR;			/* Internal error */
 8006162:	2801      	cmp	r0, #1
 8006164:	d0e9      	beq.n	800613a <dir_next+0x54>
					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
 8006166:	1c43      	adds	r3, r0, #1
 8006168:	d0ec      	beq.n	8006144 <dir_next+0x5e>
					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
 800616a:	4620      	mov	r0, r4
 800616c:	f7ff fc19 	bl	80059a2 <sync_window>
 8006170:	4607      	mov	r7, r0
 8006172:	2800      	cmp	r0, #0
 8006174:	d1e6      	bne.n	8006144 <dir_next+0x5e>
					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
 8006176:	4601      	mov	r1, r0
 8006178:	f44f 7200 	mov.w	r2, #512	; 0x200
 800617c:	f104 0030 	add.w	r0, r4, #48	; 0x30
 8006180:	f7ff fa64 	bl	800564c <mem_set>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 8006184:	4631      	mov	r1, r6
 8006186:	4620      	mov	r0, r4
 8006188:	f7ff fae8 	bl	800575c <clust2sect>
						fs->wflag = 1;
 800618c:	f04f 0a01 	mov.w	sl, #1
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 8006190:	62e0      	str	r0, [r4, #44]	; 0x2c
 8006192:	8963      	ldrh	r3, [r4, #10]
 8006194:	429f      	cmp	r7, r3
 8006196:	d310      	bcc.n	80061ba <dir_next+0xd4>
					fs->winsect -= n;							/* Restore window offset */
 8006198:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800619a:	1bdf      	subs	r7, r3, r7
 800619c:	62e7      	str	r7, [r4, #44]	; 0x2c
				dp->clust = clst;		/* Initialize data for new cluster */
 800619e:	61ae      	str	r6, [r5, #24]
				dp->sect = clust2sect(fs, clst);
 80061a0:	4631      	mov	r1, r6
 80061a2:	4620      	mov	r0, r4
 80061a4:	f7ff fada 	bl	800575c <clust2sect>
 80061a8:	61e8      	str	r0, [r5, #28]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 80061aa:	3430      	adds	r4, #48	; 0x30
 80061ac:	444c      	add	r4, r9
	dp->dptr = ofs;						/* Current entry */
 80061ae:	f8c5 8014 	str.w	r8, [r5, #20]
	dp->dir = fs->win + ofs % SS(fs);	/* Pointer to the entry in the win[] */
 80061b2:	622c      	str	r4, [r5, #32]
	return FR_OK;
 80061b4:	2000      	movs	r0, #0
 80061b6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
						fs->wflag = 1;
 80061ba:	f884 a003 	strb.w	sl, [r4, #3]
 80061be:	4620      	mov	r0, r4
 80061c0:	f7ff fbcc 	bl	800595c <sync_window.part.4>
						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
 80061c4:	2800      	cmp	r0, #0
 80061c6:	d1bd      	bne.n	8006144 <dir_next+0x5e>
					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
 80061c8:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 80061ca:	3301      	adds	r3, #1
 80061cc:	3701      	adds	r7, #1
 80061ce:	62e3      	str	r3, [r4, #44]	; 0x2c
 80061d0:	e7df      	b.n	8006192 <dir_next+0xac>
					if (clst == 0) return FR_DENIED;			/* No free cluster */
 80061d2:	2007      	movs	r0, #7
}
 80061d4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080061d8 <follow_path>:
{
 80061d8:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	FATFS *fs = obj->fs;
 80061dc:	6807      	ldr	r7, [r0, #0]
{
 80061de:	4604      	mov	r4, r0
		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
 80061e0:	780b      	ldrb	r3, [r1, #0]
 80061e2:	2b2f      	cmp	r3, #47	; 0x2f
 80061e4:	460d      	mov	r5, r1
 80061e6:	f101 0101 	add.w	r1, r1, #1
 80061ea:	d0f9      	beq.n	80061e0 <follow_path+0x8>
 80061ec:	2b5c      	cmp	r3, #92	; 0x5c
 80061ee:	d0f7      	beq.n	80061e0 <follow_path+0x8>
		obj->sclust = 0;					/* Start from root directory */
 80061f0:	2300      	movs	r3, #0
 80061f2:	60a3      	str	r3, [r4, #8]
	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
 80061f4:	782b      	ldrb	r3, [r5, #0]
 80061f6:	2b1f      	cmp	r3, #31
 80061f8:	d959      	bls.n	80062ae <follow_path+0xd6>
			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
 80061fa:	f8df 815c 	ldr.w	r8, [pc, #348]	; 8006358 <follow_path+0x180>
	p = *path; sfn = dp->fn;
 80061fe:	f104 0624 	add.w	r6, r4, #36	; 0x24
	mem_set(sfn, ' ', 11);
 8006202:	220b      	movs	r2, #11
 8006204:	2120      	movs	r1, #32
 8006206:	4630      	mov	r0, r6
 8006208:	f7ff fa20 	bl	800564c <mem_set>
	si = i = 0; ni = 8;
 800620c:	2200      	movs	r2, #0
 800620e:	f105 3eff 	add.w	lr, r5, #4294967295
 8006212:	4611      	mov	r1, r2
 8006214:	2008      	movs	r0, #8
		c = (BYTE)p[si++];
 8006216:	f81e 3f01 	ldrb.w	r3, [lr, #1]!
		if (c <= ' ') break; 			/* Break if end of the path name */
 800621a:	2b20      	cmp	r3, #32
		c = (BYTE)p[si++];
 800621c:	f101 0101 	add.w	r1, r1, #1
		if (c <= ' ') break; 			/* Break if end of the path name */
 8006220:	d90b      	bls.n	800623a <follow_path+0x62>
		if (c == '/' || c == '\\') {	/* Break if a separator is found */
 8006222:	2b2f      	cmp	r3, #47	; 0x2f
 8006224:	d14b      	bne.n	80062be <follow_path+0xe6>
 8006226:	1868      	adds	r0, r5, r1
 8006228:	1b41      	subs	r1, r0, r5
			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator if exist */
 800622a:	f810 eb01 	ldrb.w	lr, [r0], #1
 800622e:	f1be 0f2f 	cmp.w	lr, #47	; 0x2f
 8006232:	d0f9      	beq.n	8006228 <follow_path+0x50>
 8006234:	f1be 0f5c 	cmp.w	lr, #92	; 0x5c
 8006238:	d0f6      	beq.n	8006228 <follow_path+0x50>
	*path = p + si;						/* Return pointer to the next segment */
 800623a:	440d      	add	r5, r1
	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
 800623c:	2a00      	cmp	r2, #0
 800623e:	d054      	beq.n	80062ea <follow_path+0x112>
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8006240:	f894 2024 	ldrb.w	r2, [r4, #36]	; 0x24
	FATFS *fs = dp->obj.fs;
 8006244:	f8d4 9000 	ldr.w	r9, [r4]
	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
 8006248:	2ae5      	cmp	r2, #229	; 0xe5
 800624a:	bf04      	itt	eq
 800624c:	2205      	moveq	r2, #5
 800624e:	f884 2024 	strbeq.w	r2, [r4, #36]	; 0x24
	sfn[NSFLAG] = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of the path */
 8006252:	2b21      	cmp	r3, #33	; 0x21
 8006254:	bf34      	ite	cc
 8006256:	2304      	movcc	r3, #4
 8006258:	2300      	movcs	r3, #0
 800625a:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
	res = dir_sdi(dp, 0);			/* Rewind directory object */
 800625e:	4620      	mov	r0, r4
 8006260:	f7ff ff0e 	bl	8006080 <dir_sdi.constprop.14>
	if (res != FR_OK) return res;
 8006264:	2800      	cmp	r0, #0
 8006266:	d145      	bne.n	80062f4 <follow_path+0x11c>
		res = move_window(fs, dp->sect);
 8006268:	69e1      	ldr	r1, [r4, #28]
 800626a:	4648      	mov	r0, r9
 800626c:	f7ff fbea 	bl	8005a44 <move_window>
		if (res != FR_OK) break;
 8006270:	2800      	cmp	r0, #0
 8006272:	d13f      	bne.n	80062f4 <follow_path+0x11c>
		c = dp->dir[DIR_Name];
 8006274:	6a23      	ldr	r3, [r4, #32]
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 8006276:	781a      	ldrb	r2, [r3, #0]
 8006278:	2a00      	cmp	r2, #0
 800627a:	d046      	beq.n	800630a <follow_path+0x132>
		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
 800627c:	7ada      	ldrb	r2, [r3, #11]
 800627e:	f002 023f 	and.w	r2, r2, #63	; 0x3f
 8006282:	71a2      	strb	r2, [r4, #6]
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 8006284:	7ada      	ldrb	r2, [r3, #11]
 8006286:	0711      	lsls	r1, r2, #28
 8006288:	d40c      	bmi.n	80062a4 <follow_path+0xcc>
 800628a:	f103 0e0b 	add.w	lr, r3, #11
 800628e:	4631      	mov	r1, r6
		r = *d++ - *s++;
 8006290:	f813 2b01 	ldrb.w	r2, [r3], #1
 8006294:	f811 cb01 	ldrb.w	ip, [r1], #1
	} while (--cnt && r == 0);
 8006298:	459e      	cmp	lr, r3
		r = *d++ - *s++;
 800629a:	eba2 020c 	sub.w	r2, r2, ip
	} while (--cnt && r == 0);
 800629e:	d027      	beq.n	80062f0 <follow_path+0x118>
 80062a0:	2a00      	cmp	r2, #0
 80062a2:	d0f5      	beq.n	8006290 <follow_path+0xb8>
		res = dir_next(dp, 0);	/* Next entry */
 80062a4:	2100      	movs	r1, #0
 80062a6:	4620      	mov	r0, r4
 80062a8:	f7ff ff1d 	bl	80060e6 <dir_next>
 80062ac:	e7da      	b.n	8006264 <follow_path+0x8c>
		dp->fn[NSFLAG] = NS_NONAME;
 80062ae:	2380      	movs	r3, #128	; 0x80
 80062b0:	f884 302f 	strb.w	r3, [r4, #47]	; 0x2f
		res = dir_sdi(dp, 0);
 80062b4:	4620      	mov	r0, r4
}
 80062b6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		res = dir_sdi(dp, 0);
 80062ba:	f7ff bee1 	b.w	8006080 <dir_sdi.constprop.14>
		if (c == '/' || c == '\\') {	/* Break if a separator is found */
 80062be:	2b5c      	cmp	r3, #92	; 0x5c
 80062c0:	d0b1      	beq.n	8006226 <follow_path+0x4e>
		if (c == '.' || i >= ni) {		/* End of body or over size? */
 80062c2:	2b2e      	cmp	r3, #46	; 0x2e
 80062c4:	d036      	beq.n	8006334 <follow_path+0x15c>
 80062c6:	4290      	cmp	r0, r2
 80062c8:	d90f      	bls.n	80062ea <follow_path+0x112>
		if (c >= 0x80) {				/* Extended character? */
 80062ca:	f013 0f80 	tst.w	r3, #128	; 0x80
			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
 80062ce:	bf18      	it	ne
 80062d0:	3b80      	subne	r3, #128	; 0x80
 80062d2:	f8df 9088 	ldr.w	r9, [pc, #136]	; 800635c <follow_path+0x184>
 80062d6:	bf18      	it	ne
 80062d8:	f818 3003 	ldrbne.w	r3, [r8, r3]
	while (*str && *str != chr) str++;
 80062dc:	f819 cf01 	ldrb.w	ip, [r9, #1]!
 80062e0:	f1bc 0f00 	cmp.w	ip, #0
 80062e4:	d02b      	beq.n	800633e <follow_path+0x166>
 80062e6:	4563      	cmp	r3, ip
 80062e8:	d1f8      	bne.n	80062dc <follow_path+0x104>
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Over size or invalid dot */
 80062ea:	2006      	movs	r0, #6
	return res;
 80062ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
 80062f0:	2a00      	cmp	r2, #0
 80062f2:	d1d7      	bne.n	80062a4 <follow_path+0xcc>
			ns = dp->fn[NSFLAG];
 80062f4:	f894 302f 	ldrb.w	r3, [r4, #47]	; 0x2f
			if (res != FR_OK) {				/* Failed to find the object */
 80062f8:	b148      	cbz	r0, 800630e <follow_path+0x136>
				if (res == FR_NO_FILE) {	/* Object is not found */
 80062fa:	2804      	cmp	r0, #4
 80062fc:	d129      	bne.n	8006352 <follow_path+0x17a>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 80062fe:	f013 0f04 	tst.w	r3, #4
 8006302:	bf08      	it	eq
 8006304:	2005      	moveq	r0, #5
 8006306:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
 800630a:	2004      	movs	r0, #4
 800630c:	e7f2      	b.n	80062f4 <follow_path+0x11c>
			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
 800630e:	075a      	lsls	r2, r3, #29
 8006310:	d41f      	bmi.n	8006352 <follow_path+0x17a>
			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
 8006312:	79a3      	ldrb	r3, [r4, #6]
 8006314:	06db      	lsls	r3, r3, #27
 8006316:	d50a      	bpl.n	800632e <follow_path+0x156>
				obj->sclust = ld_clust(fs, fs->win + dp->dptr % SS(fs));	/* Open next directory */
 8006318:	6963      	ldr	r3, [r4, #20]
 800631a:	7838      	ldrb	r0, [r7, #0]
 800631c:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8006320:	f107 0130 	add.w	r1, r7, #48	; 0x30
 8006324:	4419      	add	r1, r3
 8006326:	f7ff fad4 	bl	80058d2 <ld_clust.isra.1>
 800632a:	60a0      	str	r0, [r4, #8]
			res = create_name(dp, &path);	/* Get a segment name of the path */
 800632c:	e767      	b.n	80061fe <follow_path+0x26>
						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
 800632e:	2005      	movs	r0, #5
 8006330:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			if (ni == 11 || c != '.') return FR_INVALID_NAME;	/* Over size or invalid dot */
 8006334:	280b      	cmp	r0, #11
 8006336:	d0d8      	beq.n	80062ea <follow_path+0x112>
			i = 8; ni = 11;				/* Goto extension */
 8006338:	2208      	movs	r2, #8
 800633a:	200b      	movs	r0, #11
 800633c:	e76b      	b.n	8006216 <follow_path+0x3e>
			if (IsLower(c)) c -= 0x20;	/* To upper */
 800633e:	f1a3 0c61 	sub.w	ip, r3, #97	; 0x61
 8006342:	f1bc 0f19 	cmp.w	ip, #25
 8006346:	d801      	bhi.n	800634c <follow_path+0x174>
 8006348:	3b20      	subs	r3, #32
 800634a:	b2db      	uxtb	r3, r3
			sfn[i++] = c;
 800634c:	54b3      	strb	r3, [r6, r2]
 800634e:	3201      	adds	r2, #1
 8006350:	e761      	b.n	8006216 <follow_path+0x3e>
}
 8006352:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8006356:	bf00      	nop
 8006358:	0800f569 	.word	0x0800f569
 800635c:	0800f5e8 	.word	0x0800f5e8

08006360 <dir_read.constprop.10>:
FRESULT dir_read (
 8006360:	b538      	push	{r3, r4, r5, lr}
 8006362:	4604      	mov	r4, r0
	FATFS *fs = dp->obj.fs;
 8006364:	6805      	ldr	r5, [r0, #0]
	FRESULT res = FR_NO_FILE;
 8006366:	2004      	movs	r0, #4
	while (dp->sect) {
 8006368:	69e1      	ldr	r1, [r4, #28]
 800636a:	b909      	cbnz	r1, 8006370 <dir_read.constprop.10+0x10>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 800636c:	b1a8      	cbz	r0, 800639a <dir_read.constprop.10+0x3a>
 800636e:	e01c      	b.n	80063aa <dir_read.constprop.10+0x4a>
		res = move_window(fs, dp->sect);
 8006370:	4628      	mov	r0, r5
 8006372:	f7ff fb67 	bl	8005a44 <move_window>
		if (res != FR_OK) break;
 8006376:	b9c0      	cbnz	r0, 80063aa <dir_read.constprop.10+0x4a>
		c = dp->dir[DIR_Name];	/* Test for the entry type */
 8006378:	6a23      	ldr	r3, [r4, #32]
 800637a:	781a      	ldrb	r2, [r3, #0]
		if (c == 0) {
 800637c:	b1c2      	cbz	r2, 80063b0 <dir_read.constprop.10+0x50>
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 800637e:	7adb      	ldrb	r3, [r3, #11]
			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 8006380:	2ae5      	cmp	r2, #229	; 0xe5
			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
 8006382:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8006386:	71a3      	strb	r3, [r4, #6]
			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
 8006388:	d009      	beq.n	800639e <dir_read.constprop.10+0x3e>
 800638a:	2a2e      	cmp	r2, #46	; 0x2e
 800638c:	d007      	beq.n	800639e <dir_read.constprop.10+0x3e>
 800638e:	2b0f      	cmp	r3, #15
 8006390:	d005      	beq.n	800639e <dir_read.constprop.10+0x3e>
 8006392:	f023 0320 	bic.w	r3, r3, #32
 8006396:	2b08      	cmp	r3, #8
 8006398:	d001      	beq.n	800639e <dir_read.constprop.10+0x3e>
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 800639a:	2000      	movs	r0, #0
 800639c:	bd38      	pop	{r3, r4, r5, pc}
		res = dir_next(dp, 0);		/* Next entry */
 800639e:	2100      	movs	r1, #0
 80063a0:	4620      	mov	r0, r4
 80063a2:	f7ff fea0 	bl	80060e6 <dir_next>
		if (res != FR_OK) break;
 80063a6:	2800      	cmp	r0, #0
 80063a8:	d0de      	beq.n	8006368 <dir_read.constprop.10+0x8>
	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
 80063aa:	2300      	movs	r3, #0
 80063ac:	61e3      	str	r3, [r4, #28]
}
 80063ae:	bd38      	pop	{r3, r4, r5, pc}
			res = FR_NO_FILE; break; /* Reached to end of the directory */
 80063b0:	2004      	movs	r0, #4
 80063b2:	e7fa      	b.n	80063aa <dir_read.constprop.10+0x4a>

080063b4 <dir_register>:
{
 80063b4:	b570      	push	{r4, r5, r6, lr}
 80063b6:	4605      	mov	r5, r0
	FATFS *fs = dp->obj.fs;
 80063b8:	6806      	ldr	r6, [r0, #0]
	res = dir_sdi(dp, 0);
 80063ba:	f7ff fe61 	bl	8006080 <dir_sdi.constprop.14>
	if (res == FR_OK) {
 80063be:	4604      	mov	r4, r0
 80063c0:	bb28      	cbnz	r0, 800640e <dir_register+0x5a>
			res = move_window(fs, dp->sect);
 80063c2:	69e9      	ldr	r1, [r5, #28]
 80063c4:	4630      	mov	r0, r6
 80063c6:	f7ff fb3d 	bl	8005a44 <move_window>
			if (res != FR_OK) break;
 80063ca:	4604      	mov	r4, r0
 80063cc:	b9f8      	cbnz	r0, 800640e <dir_register+0x5a>
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 80063ce:	6a2b      	ldr	r3, [r5, #32]
 80063d0:	781b      	ldrb	r3, [r3, #0]
 80063d2:	2be5      	cmp	r3, #229	; 0xe5
 80063d4:	d114      	bne.n	8006400 <dir_register+0x4c>
		res = move_window(fs, dp->sect);
 80063d6:	69e9      	ldr	r1, [r5, #28]
 80063d8:	4630      	mov	r0, r6
 80063da:	f7ff fb33 	bl	8005a44 <move_window>
		if (res == FR_OK) {
 80063de:	4604      	mov	r4, r0
 80063e0:	b960      	cbnz	r0, 80063fc <dir_register+0x48>
			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
 80063e2:	4601      	mov	r1, r0
 80063e4:	2220      	movs	r2, #32
 80063e6:	6a28      	ldr	r0, [r5, #32]
 80063e8:	f7ff f930 	bl	800564c <mem_set>
 80063ec:	220b      	movs	r2, #11
 80063ee:	f105 0124 	add.w	r1, r5, #36	; 0x24
 80063f2:	6a28      	ldr	r0, [r5, #32]
 80063f4:	f7ff fa64 	bl	80058c0 <mem_cpy.part.0>
			fs->wflag = 1;
 80063f8:	2301      	movs	r3, #1
 80063fa:	70f3      	strb	r3, [r6, #3]
}
 80063fc:	4620      	mov	r0, r4
 80063fe:	bd70      	pop	{r4, r5, r6, pc}
			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
 8006400:	2b00      	cmp	r3, #0
 8006402:	d0e8      	beq.n	80063d6 <dir_register+0x22>
			res = dir_next(dp, 1);
 8006404:	2101      	movs	r1, #1
 8006406:	4628      	mov	r0, r5
 8006408:	f7ff fe6d 	bl	80060e6 <dir_next>
 800640c:	e7d7      	b.n	80063be <dir_register+0xa>
	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
 800640e:	2c04      	cmp	r4, #4
 8006410:	bf08      	it	eq
 8006412:	2407      	moveq	r4, #7
 8006414:	e7f2      	b.n	80063fc <dir_register+0x48>
	...

08006418 <f_mount>:
FRESULT f_mount (
	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
)
{
 8006418:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 800641a:	9001      	str	r0, [sp, #4]
	FATFS *cfs;
	int vol;
	FRESULT res;
	const TCHAR *rp = path;
 800641c:	a804      	add	r0, sp, #16
{
 800641e:	9100      	str	r1, [sp, #0]
	const TCHAR *rp = path;
 8006420:	f840 1d04 	str.w	r1, [r0, #-4]!
{
 8006424:	4616      	mov	r6, r2


	/* Get logical drive number */
	vol = get_ldnumber(&rp);
 8006426:	f7ff fa18 	bl	800585a <get_ldnumber>
	if (vol < 0) return FR_INVALID_DRIVE;
 800642a:	1e05      	subs	r5, r0, #0
 800642c:	db1f      	blt.n	800646e <f_mount+0x56>
	cfs = FatFs[vol];					/* Pointer to fs object */
 800642e:	4912      	ldr	r1, [pc, #72]	; (8006478 <f_mount+0x60>)
 8006430:	f851 4025 	ldr.w	r4, [r1, r5, lsl #2]

	if (cfs) {
 8006434:	b15c      	cbz	r4, 800644e <f_mount+0x36>
		if (Files[i].fs == fs) Files[i].fs = 0;
 8006436:	4b11      	ldr	r3, [pc, #68]	; (800647c <f_mount+0x64>)
 8006438:	681a      	ldr	r2, [r3, #0]
 800643a:	4294      	cmp	r4, r2
 800643c:	bf04      	itt	eq
 800643e:	2200      	moveq	r2, #0
 8006440:	601a      	streq	r2, [r3, #0]
 8006442:	691a      	ldr	r2, [r3, #16]
 8006444:	2000      	movs	r0, #0
 8006446:	4294      	cmp	r4, r2
 8006448:	bf08      	it	eq
 800644a:	6118      	streq	r0, [r3, #16]
		clear_lock(cfs);
#endif
#if _FS_REENTRANT						/* Discard sync object of the current volume */
		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
#endif
		cfs->fs_type = 0;				/* Clear old fs object */
 800644c:	7020      	strb	r0, [r4, #0]
	}

	if (fs) {
 800644e:	9801      	ldr	r0, [sp, #4]
 8006450:	b108      	cbz	r0, 8006456 <f_mount+0x3e>
		fs->fs_type = 0;				/* Clear new fs object */
 8006452:	2300      	movs	r3, #0
 8006454:	7003      	strb	r3, [r0, #0]
#if _FS_REENTRANT						/* Create sync object for the new volume */
		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;					/* Register new fs object */
 8006456:	f841 0025 	str.w	r0, [r1, r5, lsl #2]

	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 800645a:	b130      	cbz	r0, 800646a <f_mount+0x52>
 800645c:	2e01      	cmp	r6, #1
 800645e:	d108      	bne.n	8006472 <f_mount+0x5a>

	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
 8006460:	2200      	movs	r2, #0
 8006462:	a901      	add	r1, sp, #4
 8006464:	4668      	mov	r0, sp
 8006466:	f7ff fb49 	bl	8005afc <find_volume>
	LEAVE_FF(fs, res);
}
 800646a:	b004      	add	sp, #16
 800646c:	bd70      	pop	{r4, r5, r6, pc}
	if (vol < 0) return FR_INVALID_DRIVE;
 800646e:	200b      	movs	r0, #11
 8006470:	e7fb      	b.n	800646a <f_mount+0x52>
	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
 8006472:	2000      	movs	r0, #0
 8006474:	e7f9      	b.n	800646a <f_mount+0x52>
 8006476:	bf00      	nop
 8006478:	20000264 	.word	0x20000264
 800647c:	20000268 	.word	0x20000268

08006480 <f_open>:
FRESULT f_open (
	FIL* fp,			/* Pointer to the blank file object */
	const TCHAR* path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
 8006480:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006484:	b090      	sub	sp, #64	; 0x40
 8006486:	4690      	mov	r8, r2
 8006488:	9101      	str	r1, [sp, #4]
	FSIZE_t ofs;
#endif
	DEF_NAMBUF


	if (!fp) return FR_INVALID_OBJECT;
 800648a:	4604      	mov	r4, r0
 800648c:	2800      	cmp	r0, #0
 800648e:	f000 80ce 	beq.w	800662e <f_open+0x1ae>

	/* Get logical drive */
	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_CREATE_NEW | FA_OPEN_ALWAYS | FA_OPEN_APPEND | FA_SEEKEND;
 8006492:	f002 053f 	and.w	r5, r2, #63	; 0x3f
	res = find_volume(&path, &fs, mode);
 8006496:	462a      	mov	r2, r5
 8006498:	a902      	add	r1, sp, #8
 800649a:	a801      	add	r0, sp, #4
 800649c:	f7ff fb2e 	bl	8005afc <find_volume>
	if (res == FR_OK) {
 80064a0:	4607      	mov	r7, r0
 80064a2:	bb38      	cbnz	r0, 80064f4 <f_open+0x74>
		dj.obj.fs = fs;
 80064a4:	ae10      	add	r6, sp, #64	; 0x40
 80064a6:	9b02      	ldr	r3, [sp, #8]
 80064a8:	f846 3d34 	str.w	r3, [r6, #-52]!
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
 80064ac:	9901      	ldr	r1, [sp, #4]
 80064ae:	4630      	mov	r0, r6
 80064b0:	f7ff fe92 	bl	80061d8 <follow_path>
#if !_FS_READONLY	/* R/W configuration */
		if (res == FR_OK) {
 80064b4:	b958      	cbnz	r0, 80064ce <f_open+0x4e>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
 80064b6:	f99d 303b 	ldrsb.w	r3, [sp, #59]	; 0x3b
 80064ba:	2b00      	cmp	r3, #0
 80064bc:	db1e      	blt.n	80064fc <f_open+0x7c>
				res = FR_INVALID_NAME;
			}
#if _FS_LOCK != 0
			else {
				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 80064be:	f015 0f3e 	tst.w	r5, #62	; 0x3e
 80064c2:	bf14      	ite	ne
 80064c4:	2101      	movne	r1, #1
 80064c6:	2100      	moveq	r1, #0
 80064c8:	4630      	mov	r0, r6
 80064ca:	f7ff f8c5 	bl	8005658 <chk_lock>
			}
#endif
		}
		/* Create or Open a file */
		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
 80064ce:	f018 0f1c 	tst.w	r8, #28
 80064d2:	d073      	beq.n	80065bc <f_open+0x13c>
			if (res != FR_OK) {					/* No file, create new */
 80064d4:	b1a0      	cbz	r0, 8006500 <f_open+0x80>
				if (res == FR_NO_FILE) {		/* There is no file to open, create a new entry */
 80064d6:	2804      	cmp	r0, #4
 80064d8:	d109      	bne.n	80064ee <f_open+0x6e>
	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
 80064da:	4b71      	ldr	r3, [pc, #452]	; (80066a0 <f_open+0x220>)
 80064dc:	681a      	ldr	r2, [r3, #0]
 80064de:	2a00      	cmp	r2, #0
 80064e0:	f000 80da 	beq.w	8006698 <f_open+0x218>
 80064e4:	691b      	ldr	r3, [r3, #16]
 80064e6:	2b00      	cmp	r3, #0
 80064e8:	f000 80d6 	beq.w	8006698 <f_open+0x218>
#if _FS_LOCK != 0
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 80064ec:	2012      	movs	r0, #18
#else
					res = dir_register(&dj);
#endif
				}
				mode |= FA_CREATE_ALWAYS;		/* File is created */
 80064ee:	f045 0508 	orr.w	r5, r5, #8
					res = FR_DENIED;
				} else {
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
				}
			}
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 80064f2:	b170      	cbz	r0, 8006512 <f_open+0x92>
		}

		FREE_NAMBUF();
	}

	if (res != FR_OK) fp->obj.fs = 0;	/* Invalidate file object on error */
 80064f4:	2300      	movs	r3, #0
 80064f6:	6023      	str	r3, [r4, #0]
 80064f8:	4607      	mov	r7, r0
 80064fa:	e092      	b.n	8006622 <f_open+0x1a2>
				res = FR_INVALID_NAME;
 80064fc:	2006      	movs	r0, #6
 80064fe:	e7e6      	b.n	80064ce <f_open+0x4e>
				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
 8006500:	f89d 3012 	ldrb.w	r3, [sp, #18]
 8006504:	f013 0f11 	tst.w	r3, #17
 8006508:	d163      	bne.n	80065d2 <f_open+0x152>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 800650a:	f018 0f04 	tst.w	r8, #4
 800650e:	f040 80bd 	bne.w	800668c <f_open+0x20c>
			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
 8006512:	0728      	lsls	r0, r5, #28
 8006514:	d53c      	bpl.n	8006590 <f_open+0x110>
				dw = GET_FATTIME();
 8006516:	f001 fcc9 	bl	8007eac <get_fattime>
 800651a:	4602      	mov	r2, r0
					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
 800651c:	4601      	mov	r1, r0
 800651e:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8006520:	300e      	adds	r0, #14
 8006522:	f7ff f88b 	bl	800563c <st_dword>
					st_dword(dj.dir + DIR_ModTime, dw);	/* Set modified time */
 8006526:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8006528:	4611      	mov	r1, r2
 800652a:	3016      	adds	r0, #22
 800652c:	f7ff f886 	bl	800563c <st_dword>
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 8006530:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 8006532:	f8dd 9008 	ldr.w	r9, [sp, #8]
					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
 8006536:	2220      	movs	r2, #32
 8006538:	72da      	strb	r2, [r3, #11]
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 800653a:	f8dd a02c 	ldr.w	sl, [sp, #44]	; 0x2c
 800653e:	f899 0000 	ldrb.w	r0, [r9]
 8006542:	4651      	mov	r1, sl
 8006544:	f7ff f9c5 	bl	80058d2 <ld_clust.isra.1>
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 8006548:	2200      	movs	r2, #0
 800654a:	4651      	mov	r1, sl
					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
 800654c:	4680      	mov	r8, r0
					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
 800654e:	4648      	mov	r0, r9
 8006550:	f7ff f9cd 	bl	80058ee <st_clust.isra.2>
					st_dword(dj.dir + DIR_FileSize, 0);
 8006554:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	*ptr++ = (BYTE)val; val >>= 8;
 8006556:	2200      	movs	r2, #0
 8006558:	771a      	strb	r2, [r3, #28]
	*ptr++ = (BYTE)val; val >>= 8;
 800655a:	775a      	strb	r2, [r3, #29]
	*ptr++ = (BYTE)val; val >>= 8;
 800655c:	779a      	strb	r2, [r3, #30]
	*ptr++ = (BYTE)val;
 800655e:	77da      	strb	r2, [r3, #31]
					fs->wflag = 1;
 8006560:	9b02      	ldr	r3, [sp, #8]
 8006562:	2101      	movs	r1, #1
 8006564:	70d9      	strb	r1, [r3, #3]
					if (cl) {							/* Remove the cluster chain if exist */
 8006566:	f1b8 0f00 	cmp.w	r8, #0
 800656a:	d011      	beq.n	8006590 <f_open+0x110>
						res = remove_chain(&dj.obj, cl, 0);
 800656c:	4641      	mov	r1, r8
 800656e:	4630      	mov	r0, r6
						dw = fs->winsect;
 8006570:	f8d3 902c 	ldr.w	r9, [r3, #44]	; 0x2c
						res = remove_chain(&dj.obj, cl, 0);
 8006574:	f7ff fd4e 	bl	8006014 <remove_chain>
						if (res == FR_OK) {
 8006578:	2800      	cmp	r0, #0
 800657a:	d1bb      	bne.n	80064f4 <f_open+0x74>
							res = move_window(fs, dw);
 800657c:	4649      	mov	r1, r9
 800657e:	9802      	ldr	r0, [sp, #8]
 8006580:	f7ff fa60 	bl	8005a44 <move_window>
							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
 8006584:	9a02      	ldr	r2, [sp, #8]
 8006586:	f108 33ff 	add.w	r3, r8, #4294967295
 800658a:	60d3      	str	r3, [r2, #12]
		if (res == FR_OK) {
 800658c:	2800      	cmp	r0, #0
 800658e:	d1b1      	bne.n	80064f4 <f_open+0x74>
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 8006590:	9b02      	ldr	r3, [sp, #8]
			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
 8006592:	0728      	lsls	r0, r5, #28
			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
 8006594:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8006596:	6263      	str	r3, [r4, #36]	; 0x24
				mode |= FA_MODIFIED;
 8006598:	bf48      	it	mi
 800659a:	f045 0540 	orrmi.w	r5, r5, #64	; 0x40
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 800659e:	f015 0ffe 	tst.w	r5, #254	; 0xfe
			fp->dir_ptr = dj.dir;
 80065a2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80065a4:	62a3      	str	r3, [r4, #40]	; 0x28
			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
 80065a6:	bf14      	ite	ne
 80065a8:	2101      	movne	r1, #1
 80065aa:	2100      	moveq	r1, #0
 80065ac:	4630      	mov	r0, r6
 80065ae:	f7ff f881 	bl	80056b4 <inc_lock>
 80065b2:	6120      	str	r0, [r4, #16]
			if (!fp->obj.lockid) res = FR_INT_ERR;
 80065b4:	2800      	cmp	r0, #0
 80065b6:	d13c      	bne.n	8006632 <f_open+0x1b2>
 80065b8:	2002      	movs	r0, #2
 80065ba:	e79b      	b.n	80064f4 <f_open+0x74>
			if (res == FR_OK) {					/* Following succeeded */
 80065bc:	2800      	cmp	r0, #0
 80065be:	d199      	bne.n	80064f4 <f_open+0x74>
				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
 80065c0:	f89d 3012 	ldrb.w	r3, [sp, #18]
 80065c4:	06da      	lsls	r2, r3, #27
 80065c6:	d463      	bmi.n	8006690 <f_open+0x210>
					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
 80065c8:	f018 0f02 	tst.w	r8, #2
 80065cc:	d0e0      	beq.n	8006590 <f_open+0x110>
 80065ce:	07db      	lsls	r3, r3, #31
 80065d0:	d5de      	bpl.n	8006590 <f_open+0x110>
					res = FR_DENIED;
 80065d2:	2007      	movs	r0, #7
 80065d4:	e78e      	b.n	80064f4 <f_open+0x74>
					clst = get_fat(&fp->obj, clst);
 80065d6:	6820      	ldr	r0, [r4, #0]
 80065d8:	f7ff fc6a 	bl	8005eb0 <get_fat.isra.8>
					if (clst <= 1) res = FR_INT_ERR;
 80065dc:	2801      	cmp	r0, #1
					clst = get_fat(&fp->obj, clst);
 80065de:	4601      	mov	r1, r0
					if (clst <= 1) res = FR_INT_ERR;
 80065e0:	d923      	bls.n	800662a <f_open+0x1aa>
 80065e2:	1c42      	adds	r2, r0, #1
 80065e4:	4250      	negs	r0, r2
 80065e6:	4150      	adcs	r0, r2
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 80065e8:	eba5 0508 	sub.w	r5, r5, r8
 80065ec:	2800      	cmp	r0, #0
 80065ee:	d049      	beq.n	8006684 <f_open+0x204>
				fp->clust = clst;
 80065f0:	61e1      	str	r1, [r4, #28]
				if (res == FR_OK && ofs % SS(fs)) {	/* Fill sector buffer if not on the sector boundary */
 80065f2:	2800      	cmp	r0, #0
 80065f4:	f47f af7e 	bne.w	80064f4 <f_open+0x74>
 80065f8:	f3c5 0308 	ubfx	r3, r5, #0, #9
 80065fc:	b18b      	cbz	r3, 8006622 <f_open+0x1a2>
					if ((sc = clust2sect(fs, clst)) == 0) {
 80065fe:	f8dd 8008 	ldr.w	r8, [sp, #8]
 8006602:	4640      	mov	r0, r8
 8006604:	f7ff f8aa 	bl	800575c <clust2sect>
 8006608:	2800      	cmp	r0, #0
 800660a:	d0d5      	beq.n	80065b8 <f_open+0x138>
						fp->sect = sc + (DWORD)(ofs / SS(fs));
 800660c:	eb00 2255 	add.w	r2, r0, r5, lsr #9
 8006610:	6222      	str	r2, [r4, #32]
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 8006612:	2301      	movs	r3, #1
 8006614:	4631      	mov	r1, r6
 8006616:	f898 0001 	ldrb.w	r0, [r8, #1]
 800661a:	f7fe ffdd 	bl	80055d8 <disk_read>
 800661e:	2800      	cmp	r0, #0
 8006620:	d138      	bne.n	8006694 <f_open+0x214>

	LEAVE_FF(fs, res);
}
 8006622:	4638      	mov	r0, r7
 8006624:	b010      	add	sp, #64	; 0x40
 8006626:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
					if (clst <= 1) res = FR_INT_ERR;
 800662a:	2002      	movs	r0, #2
 800662c:	e7dc      	b.n	80065e8 <f_open+0x168>
	if (!fp) return FR_INVALID_OBJECT;
 800662e:	2709      	movs	r7, #9
 8006630:	e7f7      	b.n	8006622 <f_open+0x1a2>
				fp->obj.sclust = ld_clust(fs, dj.dir);					/* Get object allocation info */
 8006632:	9e02      	ldr	r6, [sp, #8]
 8006634:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 8006638:	7830      	ldrb	r0, [r6, #0]
 800663a:	4641      	mov	r1, r8
 800663c:	f7ff f949 	bl	80058d2 <ld_clust.isra.1>
 8006640:	60a0      	str	r0, [r4, #8]
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 8006642:	f108 001c 	add.w	r0, r8, #28
 8006646:	f7fe fff1 	bl	800562c <ld_dword>
			fp->obj.id = fs->id;
 800664a:	88f3      	ldrh	r3, [r6, #6]
			fp->obj.fs = fs;	 	/* Validate the file object */
 800664c:	6026      	str	r6, [r4, #0]
			fp->cltbl = 0;			/* Disable fast seek mode */
 800664e:	2100      	movs	r1, #0
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 8006650:	f104 0630 	add.w	r6, r4, #48	; 0x30
				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
 8006654:	60e0      	str	r0, [r4, #12]
			fp->obj.id = fs->id;
 8006656:	80a3      	strh	r3, [r4, #4]
			fp->cltbl = 0;			/* Disable fast seek mode */
 8006658:	62e1      	str	r1, [r4, #44]	; 0x2c
			fp->flag = mode;		/* Set file access mode */
 800665a:	7525      	strb	r5, [r4, #20]
			fp->err = 0;			/* Clear error flag */
 800665c:	7561      	strb	r1, [r4, #21]
			fp->sect = 0;			/* Invalidate current data sector */
 800665e:	6221      	str	r1, [r4, #32]
			fp->fptr = 0;			/* Set file pointer top of the file */
 8006660:	61a1      	str	r1, [r4, #24]
			mem_set(fp->buf, 0, _MAX_SS);	/* Clear sector buffer */
 8006662:	f44f 7200 	mov.w	r2, #512	; 0x200
 8006666:	4630      	mov	r0, r6
 8006668:	f7fe fff0 	bl	800564c <mem_set>
			if ((mode & FA_SEEKEND) && fp->obj.objsize > 0) {	/* Seek to end of file if FA_OPEN_APPEND is specified */
 800666c:	06ab      	lsls	r3, r5, #26
 800666e:	d5d8      	bpl.n	8006622 <f_open+0x1a2>
 8006670:	68e5      	ldr	r5, [r4, #12]
 8006672:	2d00      	cmp	r5, #0
 8006674:	d0d5      	beq.n	8006622 <f_open+0x1a2>
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8006676:	9b02      	ldr	r3, [sp, #8]
				clst = fp->obj.sclust;				/* Follow the cluster chain */
 8006678:	68a1      	ldr	r1, [r4, #8]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 800667a:	f8b3 800a 	ldrh.w	r8, [r3, #10]
				fp->fptr = fp->obj.objsize;			/* Offset to seek */
 800667e:	61a5      	str	r5, [r4, #24]
				bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size in byte */
 8006680:	ea4f 2848 	mov.w	r8, r8, lsl #9
				for (ofs = fp->obj.objsize; res == FR_OK && ofs > bcs; ofs -= bcs) {
 8006684:	45a8      	cmp	r8, r5
 8006686:	d3a6      	bcc.n	80065d6 <f_open+0x156>
 8006688:	2000      	movs	r0, #0
 800668a:	e7b1      	b.n	80065f0 <f_open+0x170>
					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
 800668c:	2008      	movs	r0, #8
 800668e:	e731      	b.n	80064f4 <f_open+0x74>
					res = FR_NO_FILE;
 8006690:	2004      	movs	r0, #4
 8006692:	e72f      	b.n	80064f4 <f_open+0x74>
						if (disk_read(fs->drv, fp->buf, fp->sect, 1) != RES_OK) res = FR_DISK_ERR;
 8006694:	2001      	movs	r0, #1
 8006696:	e72d      	b.n	80064f4 <f_open+0x74>
					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
 8006698:	4630      	mov	r0, r6
 800669a:	f7ff fe8b 	bl	80063b4 <dir_register>
 800669e:	e726      	b.n	80064ee <f_open+0x6e>
 80066a0:	20000268 	.word	0x20000268

080066a4 <f_read>:
	FIL* fp, 	/* Pointer to the file object */
	void* buff,	/* Pointer to data buffer */
	UINT btr,	/* Number of bytes to read */
	UINT* br	/* Pointer to number of bytes read */
)
{
 80066a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80066a8:	469b      	mov	fp, r3
 80066aa:	b085      	sub	sp, #20
	FSIZE_t remain;
	UINT rcnt, cc, csect;
	BYTE *rbuff = (BYTE*)buff;


	*br = 0;	/* Clear read byte counter */
 80066ac:	2300      	movs	r3, #0
{
 80066ae:	4689      	mov	r9, r1
	*br = 0;	/* Clear read byte counter */
 80066b0:	f8cb 3000 	str.w	r3, [fp]
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 80066b4:	a903      	add	r1, sp, #12
{
 80066b6:	4604      	mov	r4, r0
 80066b8:	4615      	mov	r5, r2
	res = validate(&fp->obj, &fs);				/* Check validity of the file object */
 80066ba:	f7ff f8e6 	bl	800588a <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 80066be:	4606      	mov	r6, r0
 80066c0:	bb00      	cbnz	r0, 8006704 <f_read+0x60>
 80066c2:	7d66      	ldrb	r6, [r4, #21]
 80066c4:	b9f6      	cbnz	r6, 8006704 <f_read+0x60>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 80066c6:	7d23      	ldrb	r3, [r4, #20]
 80066c8:	07da      	lsls	r2, r3, #31
 80066ca:	f140 8096 	bpl.w	80067fa <f_read+0x156>
	remain = fp->obj.objsize - fp->fptr;
 80066ce:	68e3      	ldr	r3, [r4, #12]
 80066d0:	69a7      	ldr	r7, [r4, #24]
 80066d2:	1bdf      	subs	r7, r3, r7
 80066d4:	42af      	cmp	r7, r5
 80066d6:	bf28      	it	cs
 80066d8:	462f      	movcs	r7, r5
		if (rcnt > btr) rcnt = btr;					/* Clip it by btr if needed */
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(rbuff, fs->win + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
#else
		mem_cpy(rbuff, fp->buf + fp->fptr % SS(fs), rcnt);	/* Extract partial sector */
 80066da:	f104 0a30 	add.w	sl, r4, #48	; 0x30
	for ( ;  btr;								/* Repeat until all data read */
 80066de:	b18f      	cbz	r7, 8006704 <f_read+0x60>
		if (fp->fptr % SS(fs) == 0) {			/* On the sector boundary? */
 80066e0:	69a1      	ldr	r1, [r4, #24]
 80066e2:	f3c1 0308 	ubfx	r3, r1, #0, #9
 80066e6:	2b00      	cmp	r3, #0
 80066e8:	d179      	bne.n	80067de <f_read+0x13a>
			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
 80066ea:	9b03      	ldr	r3, [sp, #12]
 80066ec:	895b      	ldrh	r3, [r3, #10]
 80066ee:	3b01      	subs	r3, #1
			if (csect == 0) {					/* On the cluster boundary? */
 80066f0:	ea13 2351 	ands.w	r3, r3, r1, lsr #9
 80066f4:	9301      	str	r3, [sp, #4]
 80066f6:	d119      	bne.n	800672c <f_read+0x88>
				if (fp->fptr == 0) {			/* On the top of the file? */
 80066f8:	b941      	cbnz	r1, 800670c <f_read+0x68>
					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
 80066fa:	68a0      	ldr	r0, [r4, #8]
				if (clst < 2) ABORT(fs, FR_INT_ERR);
 80066fc:	2801      	cmp	r0, #1
 80066fe:	d810      	bhi.n	8006722 <f_read+0x7e>
 8006700:	2602      	movs	r6, #2
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8006702:	7566      	strb	r6, [r4, #21]
#endif
	}

	LEAVE_FF(fs, FR_OK);
}
 8006704:	4630      	mov	r0, r6
 8006706:	b005      	add	sp, #20
 8006708:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if (fp->cltbl) {
 800670c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800670e:	b11b      	cbz	r3, 8006718 <f_read+0x74>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 8006710:	4620      	mov	r0, r4
 8006712:	f7ff f82e 	bl	8005772 <clmt_clust>
 8006716:	e7f1      	b.n	80066fc <f_read+0x58>
						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
 8006718:	69e1      	ldr	r1, [r4, #28]
 800671a:	6820      	ldr	r0, [r4, #0]
 800671c:	f7ff fbc8 	bl	8005eb0 <get_fat.isra.8>
 8006720:	e7ec      	b.n	80066fc <f_read+0x58>
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8006722:	1c43      	adds	r3, r0, #1
 8006724:	d101      	bne.n	800672a <f_read+0x86>
 8006726:	2601      	movs	r6, #1
 8006728:	e7eb      	b.n	8006702 <f_read+0x5e>
				fp->clust = clst;				/* Update current cluster */
 800672a:	61e0      	str	r0, [r4, #28]
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 800672c:	9b03      	ldr	r3, [sp, #12]
 800672e:	69e1      	ldr	r1, [r4, #28]
 8006730:	9300      	str	r3, [sp, #0]
 8006732:	4618      	mov	r0, r3
 8006734:	f7ff f812 	bl	800575c <clust2sect>
			if (!sect) ABORT(fs, FR_INT_ERR);
 8006738:	2800      	cmp	r0, #0
 800673a:	d0e1      	beq.n	8006700 <f_read+0x5c>
			sect += csect;
 800673c:	9b01      	ldr	r3, [sp, #4]
			if (cc) {							/* Read maximum contiguous sectors directly */
 800673e:	0a7d      	lsrs	r5, r7, #9
			sect += csect;
 8006740:	eb03 0800 	add.w	r8, r3, r0
			if (cc) {							/* Read maximum contiguous sectors directly */
 8006744:	d02d      	beq.n	80067a2 <f_read+0xfe>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 8006746:	9b00      	ldr	r3, [sp, #0]
 8006748:	9a01      	ldr	r2, [sp, #4]
 800674a:	895b      	ldrh	r3, [r3, #10]
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800674c:	9800      	ldr	r0, [sp, #0]
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 800674e:	442a      	add	r2, r5
 8006750:	429a      	cmp	r2, r3
					cc = fs->csize - csect;
 8006752:	bf88      	it	hi
 8006754:	9a01      	ldrhi	r2, [sp, #4]
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8006756:	7840      	ldrb	r0, [r0, #1]
					cc = fs->csize - csect;
 8006758:	bf88      	it	hi
 800675a:	1a9d      	subhi	r5, r3, r2
				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 800675c:	462b      	mov	r3, r5
 800675e:	4642      	mov	r2, r8
 8006760:	4649      	mov	r1, r9
 8006762:	f7fe ff39 	bl	80055d8 <disk_read>
 8006766:	2800      	cmp	r0, #0
 8006768:	d1dd      	bne.n	8006726 <f_read+0x82>
				if ((fp->flag & FA_DIRTY) && fp->sect - sect < cc) {
 800676a:	f994 3014 	ldrsb.w	r3, [r4, #20]
 800676e:	2b00      	cmp	r3, #0
 8006770:	da0b      	bge.n	800678a <f_read+0xe6>
 8006772:	6a20      	ldr	r0, [r4, #32]
 8006774:	eba0 0008 	sub.w	r0, r0, r8
 8006778:	4285      	cmp	r5, r0
 800677a:	d906      	bls.n	800678a <f_read+0xe6>
 800677c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8006780:	4651      	mov	r1, sl
 8006782:	eb09 2040 	add.w	r0, r9, r0, lsl #9
 8006786:	f7ff f89b 	bl	80058c0 <mem_cpy.part.0>
				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
 800678a:	026d      	lsls	r5, r5, #9
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
 800678c:	69a3      	ldr	r3, [r4, #24]
 800678e:	442b      	add	r3, r5
 8006790:	61a3      	str	r3, [r4, #24]
 8006792:	f8db 3000 	ldr.w	r3, [fp]
 8006796:	442b      	add	r3, r5
 8006798:	44a9      	add	r9, r5
 800679a:	f8cb 3000 	str.w	r3, [fp]
 800679e:	1b7f      	subs	r7, r7, r5
 80067a0:	e79d      	b.n	80066de <f_read+0x3a>
			if (fp->sect != sect) {			/* Load data sector if not in cache */
 80067a2:	6a22      	ldr	r2, [r4, #32]
 80067a4:	4590      	cmp	r8, r2
 80067a6:	d018      	beq.n	80067da <f_read+0x136>
				if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 80067a8:	f994 3014 	ldrsb.w	r3, [r4, #20]
 80067ac:	2b00      	cmp	r3, #0
 80067ae:	da0b      	bge.n	80067c8 <f_read+0x124>
					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80067b0:	9800      	ldr	r0, [sp, #0]
 80067b2:	2301      	movs	r3, #1
 80067b4:	4651      	mov	r1, sl
 80067b6:	7840      	ldrb	r0, [r0, #1]
 80067b8:	f7fe ff1c 	bl	80055f4 <disk_write>
 80067bc:	2800      	cmp	r0, #0
 80067be:	d1b2      	bne.n	8006726 <f_read+0x82>
					fp->flag &= (BYTE)~FA_DIRTY;
 80067c0:	7d23      	ldrb	r3, [r4, #20]
 80067c2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80067c6:	7523      	strb	r3, [r4, #20]
				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 80067c8:	9803      	ldr	r0, [sp, #12]
 80067ca:	2301      	movs	r3, #1
 80067cc:	4642      	mov	r2, r8
 80067ce:	4651      	mov	r1, sl
 80067d0:	7840      	ldrb	r0, [r0, #1]
 80067d2:	f7fe ff01 	bl	80055d8 <disk_read>
 80067d6:	2800      	cmp	r0, #0
 80067d8:	d1a5      	bne.n	8006726 <f_read+0x82>
			fp->sect = sect;
 80067da:	f8c4 8020 	str.w	r8, [r4, #32]
		rcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 80067de:	69a1      	ldr	r1, [r4, #24]
 80067e0:	f3c1 0108 	ubfx	r1, r1, #0, #9
 80067e4:	f5c1 7500 	rsb	r5, r1, #512	; 0x200
 80067e8:	42bd      	cmp	r5, r7
 80067ea:	bf28      	it	cs
 80067ec:	463d      	movcs	r5, r7
 80067ee:	462a      	mov	r2, r5
 80067f0:	4451      	add	r1, sl
 80067f2:	4648      	mov	r0, r9
 80067f4:	f7ff f864 	bl	80058c0 <mem_cpy.part.0>
 80067f8:	e7c8      	b.n	800678c <f_read+0xe8>
	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
 80067fa:	2607      	movs	r6, #7
 80067fc:	e782      	b.n	8006704 <f_read+0x60>

080067fe <f_write>:
	FIL* fp,			/* Pointer to the file object */
	const void* buff,	/* Pointer to the data to be written */
	UINT btw,			/* Number of bytes to write */
	UINT* bw			/* Pointer to number of bytes written */
)
{
 80067fe:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006802:	469b      	mov	fp, r3
 8006804:	b085      	sub	sp, #20
	DWORD clst, sect;
	UINT wcnt, cc, csect;
	const BYTE *wbuff = (const BYTE*)buff;


	*bw = 0;	/* Clear write byte counter */
 8006806:	2300      	movs	r3, #0
{
 8006808:	4689      	mov	r9, r1
	*bw = 0;	/* Clear write byte counter */
 800680a:	f8cb 3000 	str.w	r3, [fp]
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 800680e:	a903      	add	r1, sp, #12
{
 8006810:	4604      	mov	r4, r0
 8006812:	4617      	mov	r7, r2
	res = validate(&fp->obj, &fs);			/* Check validity of the file object */
 8006814:	f7ff f839 	bl	800588a <validate>
	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
 8006818:	4606      	mov	r6, r0
 800681a:	bb58      	cbnz	r0, 8006874 <f_write+0x76>
 800681c:	7d66      	ldrb	r6, [r4, #21]
 800681e:	bb4e      	cbnz	r6, 8006874 <f_write+0x76>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8006820:	7d23      	ldrb	r3, [r4, #20]
 8006822:	079a      	lsls	r2, r3, #30
 8006824:	f140 80ae 	bpl.w	8006984 <f_write+0x186>

	/* Check fptr wrap-around (file size cannot reach 4GiB on FATxx) */
	if ((!_FS_EXFAT || fs->fs_type != FS_EXFAT) && (DWORD)(fp->fptr + btw) < (DWORD)fp->fptr) {
 8006828:	69a3      	ldr	r3, [r4, #24]
 800682a:	42fb      	cmn	r3, r7
		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
 800682c:	bf28      	it	cs
 800682e:	43df      	mvncs	r7, r3
#if _FS_TINY
		if (move_window(fs, fp->sect) != FR_OK) ABORT(fs, FR_DISK_ERR);	/* Move sector window */
		mem_cpy(fs->win + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
		fs->wflag = 1;
#else
		mem_cpy(fp->buf + fp->fptr % SS(fs), wbuff, wcnt);	/* Fit data to the sector */
 8006830:	f104 0a30 	add.w	sl, r4, #48	; 0x30
	for ( ;  btw;							/* Repeat until all data written */
 8006834:	b1d7      	cbz	r7, 800686c <f_write+0x6e>
		if (fp->fptr % SS(fs) == 0) {		/* On the sector boundary? */
 8006836:	69a1      	ldr	r1, [r4, #24]
 8006838:	f3c1 0308 	ubfx	r3, r1, #0, #9
 800683c:	2b00      	cmp	r3, #0
 800683e:	f040 808f 	bne.w	8006960 <f_write+0x162>
			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
 8006842:	9b03      	ldr	r3, [sp, #12]
 8006844:	895b      	ldrh	r3, [r3, #10]
 8006846:	3b01      	subs	r3, #1
			if (csect == 0) {				/* On the cluster boundary? */
 8006848:	ea13 2351 	ands.w	r3, r3, r1, lsr #9
 800684c:	9301      	str	r3, [sp, #4]
 800684e:	d124      	bne.n	800689a <f_write+0x9c>
				if (fp->fptr == 0) {		/* On the top of the file? */
 8006850:	b931      	cbnz	r1, 8006860 <f_write+0x62>
					clst = fp->obj.sclust;	/* Follow from the origin */
 8006852:	68a0      	ldr	r0, [r4, #8]
					if (clst == 0) {		/* If no cluster is allocated, */
 8006854:	b9a0      	cbnz	r0, 8006880 <f_write+0x82>
						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
 8006856:	4601      	mov	r1, r0
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 8006858:	4620      	mov	r0, r4
 800685a:	f7ff fb83 	bl	8005f64 <create_chain>
 800685e:	e004      	b.n	800686a <f_write+0x6c>
					if (fp->cltbl) {
 8006860:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006862:	b15b      	cbz	r3, 800687c <f_write+0x7e>
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
 8006864:	4620      	mov	r0, r4
 8006866:	f7fe ff84 	bl	8005772 <clmt_clust>
				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
 800686a:	b948      	cbnz	r0, 8006880 <f_write+0x82>
		fp->flag |= FA_DIRTY;
#endif
	}

	fp->flag |= FA_MODIFIED;				/* Set file change flag */
 800686c:	7d23      	ldrb	r3, [r4, #20]
 800686e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8006872:	7523      	strb	r3, [r4, #20]

	LEAVE_FF(fs, FR_OK);
}
 8006874:	4630      	mov	r0, r6
 8006876:	b005      	add	sp, #20
 8006878:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
 800687c:	69e1      	ldr	r1, [r4, #28]
 800687e:	e7eb      	b.n	8006858 <f_write+0x5a>
				if (clst == 1) ABORT(fs, FR_INT_ERR);
 8006880:	2801      	cmp	r0, #1
 8006882:	d102      	bne.n	800688a <f_write+0x8c>
 8006884:	2602      	movs	r6, #2
				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8006886:	7566      	strb	r6, [r4, #21]
 8006888:	e7f4      	b.n	8006874 <f_write+0x76>
 800688a:	1c43      	adds	r3, r0, #1
 800688c:	d101      	bne.n	8006892 <f_write+0x94>
 800688e:	2601      	movs	r6, #1
 8006890:	e7f9      	b.n	8006886 <f_write+0x88>
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8006892:	68a3      	ldr	r3, [r4, #8]
				fp->clust = clst;			/* Update current cluster */
 8006894:	61e0      	str	r0, [r4, #28]
				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
 8006896:	b903      	cbnz	r3, 800689a <f_write+0x9c>
 8006898:	60a0      	str	r0, [r4, #8]
			if (fp->flag & FA_DIRTY) {		/* Write-back sector cache */
 800689a:	f994 3014 	ldrsb.w	r3, [r4, #20]
 800689e:	2b00      	cmp	r3, #0
 80068a0:	da0c      	bge.n	80068bc <f_write+0xbe>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80068a2:	9803      	ldr	r0, [sp, #12]
 80068a4:	6a22      	ldr	r2, [r4, #32]
 80068a6:	7840      	ldrb	r0, [r0, #1]
 80068a8:	2301      	movs	r3, #1
 80068aa:	4651      	mov	r1, sl
 80068ac:	f7fe fea2 	bl	80055f4 <disk_write>
 80068b0:	2800      	cmp	r0, #0
 80068b2:	d1ec      	bne.n	800688e <f_write+0x90>
				fp->flag &= (BYTE)~FA_DIRTY;
 80068b4:	7d23      	ldrb	r3, [r4, #20]
 80068b6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80068ba:	7523      	strb	r3, [r4, #20]
			sect = clust2sect(fs, fp->clust);	/* Get current sector */
 80068bc:	9b03      	ldr	r3, [sp, #12]
 80068be:	69e1      	ldr	r1, [r4, #28]
 80068c0:	9300      	str	r3, [sp, #0]
 80068c2:	4618      	mov	r0, r3
 80068c4:	f7fe ff4a 	bl	800575c <clust2sect>
			if (!sect) ABORT(fs, FR_INT_ERR);
 80068c8:	2800      	cmp	r0, #0
 80068ca:	d0db      	beq.n	8006884 <f_write+0x86>
			sect += csect;
 80068cc:	9b01      	ldr	r3, [sp, #4]
			if (cc) {						/* Write maximum contiguous sectors directly */
 80068ce:	0a7d      	lsrs	r5, r7, #9
			sect += csect;
 80068d0:	eb03 0800 	add.w	r8, r3, r0
			if (cc) {						/* Write maximum contiguous sectors directly */
 80068d4:	d032      	beq.n	800693c <f_write+0x13e>
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 80068d6:	9b00      	ldr	r3, [sp, #0]
 80068d8:	9a01      	ldr	r2, [sp, #4]
 80068da:	895b      	ldrh	r3, [r3, #10]
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80068dc:	9800      	ldr	r0, [sp, #0]
				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
 80068de:	442a      	add	r2, r5
 80068e0:	429a      	cmp	r2, r3
					cc = fs->csize - csect;
 80068e2:	bf88      	it	hi
 80068e4:	9a01      	ldrhi	r2, [sp, #4]
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80068e6:	7840      	ldrb	r0, [r0, #1]
					cc = fs->csize - csect;
 80068e8:	bf88      	it	hi
 80068ea:	1a9d      	subhi	r5, r3, r2
				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) ABORT(fs, FR_DISK_ERR);
 80068ec:	462b      	mov	r3, r5
 80068ee:	4642      	mov	r2, r8
 80068f0:	4649      	mov	r1, r9
 80068f2:	f7fe fe7f 	bl	80055f4 <disk_write>
 80068f6:	2800      	cmp	r0, #0
 80068f8:	d1c9      	bne.n	800688e <f_write+0x90>
				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
 80068fa:	6a21      	ldr	r1, [r4, #32]
 80068fc:	eba1 0108 	sub.w	r1, r1, r8
 8006900:	428d      	cmp	r5, r1
 8006902:	d90a      	bls.n	800691a <f_write+0x11c>
 8006904:	f44f 7200 	mov.w	r2, #512	; 0x200
 8006908:	eb09 2141 	add.w	r1, r9, r1, lsl #9
 800690c:	4650      	mov	r0, sl
 800690e:	f7fe ffd7 	bl	80058c0 <mem_cpy.part.0>
					fp->flag &= (BYTE)~FA_DIRTY;
 8006912:	7d23      	ldrb	r3, [r4, #20]
 8006914:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8006918:	7523      	strb	r3, [r4, #20]
				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
 800691a:	026d      	lsls	r5, r5, #9
		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
 800691c:	69a3      	ldr	r3, [r4, #24]
 800691e:	68e2      	ldr	r2, [r4, #12]
 8006920:	442b      	add	r3, r5
 8006922:	61a3      	str	r3, [r4, #24]
 8006924:	429a      	cmp	r2, r3
 8006926:	bf2c      	ite	cs
 8006928:	60e2      	strcs	r2, [r4, #12]
 800692a:	60e3      	strcc	r3, [r4, #12]
 800692c:	f8db 3000 	ldr.w	r3, [fp]
 8006930:	442b      	add	r3, r5
 8006932:	44a9      	add	r9, r5
 8006934:	f8cb 3000 	str.w	r3, [fp]
 8006938:	1b7f      	subs	r7, r7, r5
 800693a:	e77b      	b.n	8006834 <f_write+0x36>
			if (fp->sect != sect && 		/* Fill sector cache with file data */
 800693c:	6a23      	ldr	r3, [r4, #32]
 800693e:	4598      	cmp	r8, r3
 8006940:	d00c      	beq.n	800695c <f_write+0x15e>
 8006942:	69a2      	ldr	r2, [r4, #24]
 8006944:	68e3      	ldr	r3, [r4, #12]
 8006946:	429a      	cmp	r2, r3
 8006948:	d208      	bcs.n	800695c <f_write+0x15e>
				disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
 800694a:	9800      	ldr	r0, [sp, #0]
 800694c:	2301      	movs	r3, #1
 800694e:	4642      	mov	r2, r8
 8006950:	4651      	mov	r1, sl
 8006952:	7840      	ldrb	r0, [r0, #1]
 8006954:	f7fe fe40 	bl	80055d8 <disk_read>
				fp->fptr < fp->obj.objsize &&
 8006958:	2800      	cmp	r0, #0
 800695a:	d198      	bne.n	800688e <f_write+0x90>
			fp->sect = sect;
 800695c:	f8c4 8020 	str.w	r8, [r4, #32]
		wcnt = SS(fs) - (UINT)fp->fptr % SS(fs);	/* Number of bytes left in the sector */
 8006960:	69a0      	ldr	r0, [r4, #24]
 8006962:	f3c0 0008 	ubfx	r0, r0, #0, #9
 8006966:	f5c0 7500 	rsb	r5, r0, #512	; 0x200
 800696a:	42bd      	cmp	r5, r7
 800696c:	bf28      	it	cs
 800696e:	463d      	movcs	r5, r7
 8006970:	462a      	mov	r2, r5
 8006972:	4649      	mov	r1, r9
 8006974:	4450      	add	r0, sl
 8006976:	f7fe ffa3 	bl	80058c0 <mem_cpy.part.0>
		fp->flag |= FA_DIRTY;
 800697a:	7d23      	ldrb	r3, [r4, #20]
 800697c:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8006980:	7523      	strb	r3, [r4, #20]
 8006982:	e7cb      	b.n	800691c <f_write+0x11e>
	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
 8006984:	2607      	movs	r6, #7
 8006986:	e775      	b.n	8006874 <f_write+0x76>

08006988 <f_sync>:
/*-----------------------------------------------------------------------*/

FRESULT f_sync (
	FIL* fp		/* Pointer to the file object */
)
{
 8006988:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
#if _FS_EXFAT
	DIR dj;
	DEF_NAMBUF
#endif

	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 800698a:	a901      	add	r1, sp, #4
{
 800698c:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);	/* Check validity of the file object */
 800698e:	f7fe ff7c 	bl	800588a <validate>
	if (res == FR_OK) {
 8006992:	4605      	mov	r5, r0
 8006994:	2800      	cmp	r0, #0
 8006996:	d13a      	bne.n	8006a0e <f_sync+0x86>
		if (fp->flag & FA_MODIFIED) {	/* Is there any change to the file? */
 8006998:	7d23      	ldrb	r3, [r4, #20]
 800699a:	065a      	lsls	r2, r3, #25
 800699c:	d537      	bpl.n	8006a0e <f_sync+0x86>
#if !_FS_TINY
			if (fp->flag & FA_DIRTY) {	/* Write-back cached data if needed */
 800699e:	061b      	lsls	r3, r3, #24
 80069a0:	d50c      	bpl.n	80069bc <f_sync+0x34>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 80069a2:	9801      	ldr	r0, [sp, #4]
 80069a4:	6a22      	ldr	r2, [r4, #32]
 80069a6:	7840      	ldrb	r0, [r0, #1]
 80069a8:	2301      	movs	r3, #1
 80069aa:	f104 0130 	add.w	r1, r4, #48	; 0x30
 80069ae:	f7fe fe21 	bl	80055f4 <disk_write>
 80069b2:	bb78      	cbnz	r0, 8006a14 <f_sync+0x8c>
				fp->flag &= (BYTE)~FA_DIRTY;
 80069b4:	7d23      	ldrb	r3, [r4, #20]
 80069b6:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80069ba:	7523      	strb	r3, [r4, #20]
			}
#endif
			/* Update the directory entry */
			tm = GET_FATTIME();				/* Modified time */
 80069bc:	f001 fa76 	bl	8007eac <get_fattime>
					FREE_NAMBUF();
				}
			} else
#endif
			{
				res = move_window(fs, fp->dir_sect);
 80069c0:	6a61      	ldr	r1, [r4, #36]	; 0x24
			tm = GET_FATTIME();				/* Modified time */
 80069c2:	4607      	mov	r7, r0
				res = move_window(fs, fp->dir_sect);
 80069c4:	9801      	ldr	r0, [sp, #4]
 80069c6:	f7ff f83d 	bl	8005a44 <move_window>
				if (res == FR_OK) {
 80069ca:	4605      	mov	r5, r0
 80069cc:	b9f8      	cbnz	r0, 8006a0e <f_sync+0x86>
					dir = fp->dir_ptr;
 80069ce:	6aa6      	ldr	r6, [r4, #40]	; 0x28
					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
 80069d0:	7af3      	ldrb	r3, [r6, #11]
 80069d2:	f043 0320 	orr.w	r3, r3, #32
 80069d6:	72f3      	strb	r3, [r6, #11]
					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
 80069d8:	68a2      	ldr	r2, [r4, #8]
 80069da:	6820      	ldr	r0, [r4, #0]
 80069dc:	4631      	mov	r1, r6
 80069de:	f7fe ff86 	bl	80058ee <st_clust.isra.2>
					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
 80069e2:	68e1      	ldr	r1, [r4, #12]
 80069e4:	f106 001c 	add.w	r0, r6, #28
 80069e8:	f7fe fe28 	bl	800563c <st_dword>
					st_dword(dir + DIR_ModTime, tm);				/* Update modified time */
 80069ec:	4639      	mov	r1, r7
 80069ee:	f106 0016 	add.w	r0, r6, #22
 80069f2:	f7fe fe23 	bl	800563c <st_dword>
					st_word(dir + DIR_LstAccDate, 0);
					fs->wflag = 1;
 80069f6:	9801      	ldr	r0, [sp, #4]
	*ptr++ = (BYTE)val; val >>= 8;
 80069f8:	74b5      	strb	r5, [r6, #18]
					fs->wflag = 1;
 80069fa:	2301      	movs	r3, #1
	*ptr++ = (BYTE)val;
 80069fc:	74f5      	strb	r5, [r6, #19]
					fs->wflag = 1;
 80069fe:	70c3      	strb	r3, [r0, #3]
					res = sync_fs(fs);					/* Restore it to the directory */
 8006a00:	f7fe ffd5 	bl	80059ae <sync_fs>
					fp->flag &= (BYTE)~FA_MODIFIED;
 8006a04:	7d23      	ldrb	r3, [r4, #20]
 8006a06:	f023 0340 	bic.w	r3, r3, #64	; 0x40
					res = sync_fs(fs);					/* Restore it to the directory */
 8006a0a:	4605      	mov	r5, r0
					fp->flag &= (BYTE)~FA_MODIFIED;
 8006a0c:	7523      	strb	r3, [r4, #20]
			}
		}
	}

	LEAVE_FF(fs, res);
}
 8006a0e:	4628      	mov	r0, r5
 8006a10:	b003      	add	sp, #12
 8006a12:	bdf0      	pop	{r4, r5, r6, r7, pc}
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) LEAVE_FF(fs, FR_DISK_ERR);
 8006a14:	2501      	movs	r5, #1
 8006a16:	e7fa      	b.n	8006a0e <f_sync+0x86>

08006a18 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL* fp		/* Pointer to the file object to be closed */
)
{
 8006a18:	b513      	push	{r0, r1, r4, lr}
 8006a1a:	4604      	mov	r4, r0
	FRESULT res;
	FATFS *fs;

#if !_FS_READONLY
	res = f_sync(fp);					/* Flush cached data */
 8006a1c:	f7ff ffb4 	bl	8006988 <f_sync>
	if (res == FR_OK)
 8006a20:	b948      	cbnz	r0, 8006a36 <f_close+0x1e>
#endif
	{
		res = validate(&fp->obj, &fs);	/* Lock volume */
 8006a22:	a901      	add	r1, sp, #4
 8006a24:	4620      	mov	r0, r4
 8006a26:	f7fe ff30 	bl	800588a <validate>
		if (res == FR_OK) {
 8006a2a:	b920      	cbnz	r0, 8006a36 <f_close+0x1e>
#if _FS_LOCK != 0
			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
 8006a2c:	6920      	ldr	r0, [r4, #16]
 8006a2e:	f7fe fe7d 	bl	800572c <dec_lock>
			if (res == FR_OK)
 8006a32:	b900      	cbnz	r0, 8006a36 <f_close+0x1e>
#endif
			{
				fp->obj.fs = 0;			/* Invalidate file object */
 8006a34:	6020      	str	r0, [r4, #0]
			unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
		}
	}
	return res;
}
 8006a36:	b002      	add	sp, #8
 8006a38:	bd10      	pop	{r4, pc}

08006a3a <f_lseek>:

FRESULT f_lseek (
	FIL* fp,		/* Pointer to the file object */
	FSIZE_t ofs		/* File pointer from top of file */
)
{
 8006a3a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006a3e:	460d      	mov	r5, r1
	FSIZE_t ifptr;
#if _USE_FASTSEEK
	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
#endif

	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 8006a40:	a901      	add	r1, sp, #4
{
 8006a42:	4604      	mov	r4, r0
	res = validate(&fp->obj, &fs);		/* Check validity of the file object */
 8006a44:	f7fe ff21 	bl	800588a <validate>
	if (res == FR_OK) res = (FRESULT)fp->err;
 8006a48:	4606      	mov	r6, r0
 8006a4a:	b9e0      	cbnz	r0, 8006a86 <f_lseek+0x4c>
 8006a4c:	7d66      	ldrb	r6, [r4, #21]
#if _FS_EXFAT && !_FS_READONLY
	if (res == FR_OK && fs->fs_type == FS_EXFAT) {
		res = fill_last_frag(&fp->obj, fp->clust, 0xFFFFFFFF);	/* Fill last fragment on the FAT if needed */
	}
#endif
	if (res != FR_OK) LEAVE_FF(fs, res);
 8006a4e:	b9d6      	cbnz	r6, 8006a86 <f_lseek+0x4c>

#if _USE_FASTSEEK
	if (fp->cltbl) {	/* Fast seek */
 8006a50:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8006a52:	2b00      	cmp	r3, #0
 8006a54:	d078      	beq.n	8006b48 <f_lseek+0x10e>
		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
 8006a56:	1c6a      	adds	r2, r5, #1
 8006a58:	d139      	bne.n	8006ace <f_lseek+0x94>
			tbl = fp->cltbl;
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
			cl = fp->obj.sclust;		/* Origin of the chain */
 8006a5a:	f8d4 8008 	ldr.w	r8, [r4, #8]
			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
 8006a5e:	f8d3 b000 	ldr.w	fp, [r3]
 8006a62:	1d1f      	adds	r7, r3, #4
 8006a64:	2502      	movs	r5, #2
			if (cl) {
 8006a66:	f1b8 0f00 	cmp.w	r8, #0
 8006a6a:	d028      	beq.n	8006abe <f_lseek+0x84>
 8006a6c:	46c1      	mov	r9, r8
				do {
					/* Get a fragment */
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8006a6e:	f04f 0a00 	mov.w	sl, #0
					do {
						pcl = cl; ncl++;
						cl = get_fat(&fp->obj, cl);
 8006a72:	4649      	mov	r1, r9
 8006a74:	6820      	ldr	r0, [r4, #0]
 8006a76:	f7ff fa1b 	bl	8005eb0 <get_fat.isra.8>
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8006a7a:	2801      	cmp	r0, #1
						pcl = cl; ncl++;
 8006a7c:	f10a 0a01 	add.w	sl, sl, #1
						if (cl <= 1) ABORT(fs, FR_INT_ERR);
 8006a80:	d807      	bhi.n	8006a92 <f_lseek+0x58>
 8006a82:	2602      	movs	r6, #2
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8006a84:	7566      	strb	r6, [r4, #21]
			fp->sect = nsect;
		}
	}

	LEAVE_FF(fs, res);
}
 8006a86:	4630      	mov	r0, r6
 8006a88:	b003      	add	sp, #12
 8006a8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8006a8e:	4680      	mov	r8, r0
 8006a90:	e7ec      	b.n	8006a6c <f_lseek+0x32>
						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8006a92:	1c43      	adds	r3, r0, #1
 8006a94:	d101      	bne.n	8006a9a <f_lseek+0x60>
 8006a96:	2601      	movs	r6, #1
 8006a98:	e7f4      	b.n	8006a84 <f_lseek+0x4a>
					} while (cl == pcl + 1);
 8006a9a:	f109 0301 	add.w	r3, r9, #1
 8006a9e:	4298      	cmp	r0, r3
 8006aa0:	4681      	mov	r9, r0
 8006aa2:	d0e6      	beq.n	8006a72 <f_lseek+0x38>
					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
 8006aa4:	3502      	adds	r5, #2
					if (ulen <= tlen) {		/* Store the length and top of the fragment */
 8006aa6:	45ab      	cmp	fp, r5
						*tbl++ = ncl; *tbl++ = tcl;
 8006aa8:	bf21      	itttt	cs
 8006aaa:	463b      	movcs	r3, r7
 8006aac:	f843 ab08 	strcs.w	sl, [r3], #8
 8006ab0:	f8c7 8004 	strcs.w	r8, [r7, #4]
 8006ab4:	461f      	movcs	r7, r3
				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
 8006ab6:	9b01      	ldr	r3, [sp, #4]
 8006ab8:	695b      	ldr	r3, [r3, #20]
 8006aba:	4298      	cmp	r0, r3
 8006abc:	d3e7      	bcc.n	8006a8e <f_lseek+0x54>
			*fp->cltbl = ulen;	/* Number of items used */
 8006abe:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
			if (ulen <= tlen) {
 8006ac0:	455d      	cmp	r5, fp
			*fp->cltbl = ulen;	/* Number of items used */
 8006ac2:	601d      	str	r5, [r3, #0]
			if (ulen <= tlen) {
 8006ac4:	f200 80d4 	bhi.w	8006c70 <f_lseek+0x236>
				*tbl = 0;		/* Terminate table */
 8006ac8:	2300      	movs	r3, #0
 8006aca:	603b      	str	r3, [r7, #0]
 8006acc:	e7db      	b.n	8006a86 <f_lseek+0x4c>
 8006ace:	68e0      	ldr	r0, [r4, #12]
 8006ad0:	4285      	cmp	r5, r0
 8006ad2:	bf28      	it	cs
 8006ad4:	4605      	movcs	r5, r0
			fp->fptr = ofs;				/* Set file pointer */
 8006ad6:	61a5      	str	r5, [r4, #24]
			if (ofs) {
 8006ad8:	2d00      	cmp	r5, #0
 8006ada:	d0d4      	beq.n	8006a86 <f_lseek+0x4c>
				fp->clust = clmt_clust(fp, ofs - 1);
 8006adc:	f105 38ff 	add.w	r8, r5, #4294967295
 8006ae0:	4641      	mov	r1, r8
 8006ae2:	4620      	mov	r0, r4
 8006ae4:	f7fe fe45 	bl	8005772 <clmt_clust>
				dsc = clust2sect(fs, fp->clust);
 8006ae8:	9f01      	ldr	r7, [sp, #4]
				fp->clust = clmt_clust(fp, ofs - 1);
 8006aea:	61e0      	str	r0, [r4, #28]
 8006aec:	4601      	mov	r1, r0
				dsc = clust2sect(fs, fp->clust);
 8006aee:	4638      	mov	r0, r7
 8006af0:	f7fe fe34 	bl	800575c <clust2sect>
				if (!dsc) ABORT(fs, FR_INT_ERR);
 8006af4:	2800      	cmp	r0, #0
 8006af6:	d0c4      	beq.n	8006a82 <f_lseek+0x48>
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8006af8:	f3c5 0508 	ubfx	r5, r5, #0, #9
 8006afc:	2d00      	cmp	r5, #0
 8006afe:	d0c2      	beq.n	8006a86 <f_lseek+0x4c>
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 8006b00:	897d      	ldrh	r5, [r7, #10]
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8006b02:	6a22      	ldr	r2, [r4, #32]
				dsc += (DWORD)((ofs - 1) / SS(fs)) & (fs->csize - 1);
 8006b04:	3d01      	subs	r5, #1
 8006b06:	ea05 2558 	and.w	r5, r5, r8, lsr #9
 8006b0a:	4405      	add	r5, r0
				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
 8006b0c:	4295      	cmp	r5, r2
 8006b0e:	d0ba      	beq.n	8006a86 <f_lseek+0x4c>
					if (fp->flag & FA_DIRTY) {		/* Write-back dirty sector cache */
 8006b10:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8006b14:	2b00      	cmp	r3, #0
 8006b16:	f104 0830 	add.w	r8, r4, #48	; 0x30
 8006b1a:	da0a      	bge.n	8006b32 <f_lseek+0xf8>
						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8006b1c:	2301      	movs	r3, #1
 8006b1e:	4641      	mov	r1, r8
 8006b20:	7878      	ldrb	r0, [r7, #1]
 8006b22:	f7fe fd67 	bl	80055f4 <disk_write>
 8006b26:	2800      	cmp	r0, #0
 8006b28:	d1b5      	bne.n	8006a96 <f_lseek+0x5c>
						fp->flag &= (BYTE)~FA_DIRTY;
 8006b2a:	7d23      	ldrb	r3, [r4, #20]
 8006b2c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8006b30:	7523      	strb	r3, [r4, #20]
					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Load current sector */
 8006b32:	9801      	ldr	r0, [sp, #4]
 8006b34:	2301      	movs	r3, #1
 8006b36:	462a      	mov	r2, r5
 8006b38:	4641      	mov	r1, r8
 8006b3a:	7840      	ldrb	r0, [r0, #1]
 8006b3c:	f7fe fd4c 	bl	80055d8 <disk_read>
 8006b40:	2800      	cmp	r0, #0
 8006b42:	d1a8      	bne.n	8006a96 <f_lseek+0x5c>
					fp->sect = dsc;
 8006b44:	6225      	str	r5, [r4, #32]
 8006b46:	e79e      	b.n	8006a86 <f_lseek+0x4c>
		if (ofs > fp->obj.objsize && (_FS_READONLY || !(fp->flag & FA_WRITE))) {	/* In read-only mode, clip offset with the file size */
 8006b48:	68e3      	ldr	r3, [r4, #12]
 8006b4a:	429d      	cmp	r5, r3
 8006b4c:	d904      	bls.n	8006b58 <f_lseek+0x11e>
 8006b4e:	7d22      	ldrb	r2, [r4, #20]
 8006b50:	f012 0f02 	tst.w	r2, #2
 8006b54:	bf08      	it	eq
 8006b56:	461d      	moveq	r5, r3
		fp->fptr = nsect = 0;
 8006b58:	2200      	movs	r2, #0
		ifptr = fp->fptr;
 8006b5a:	69a3      	ldr	r3, [r4, #24]
		fp->fptr = nsect = 0;
 8006b5c:	61a2      	str	r2, [r4, #24]
		if (ofs) {
 8006b5e:	2d00      	cmp	r5, #0
 8006b60:	d132      	bne.n	8006bc8 <f_lseek+0x18e>
		fp->fptr = nsect = 0;
 8006b62:	462f      	mov	r7, r5
 8006b64:	e009      	b.n	8006b7a <f_lseek+0x140>
 8006b66:	2700      	movs	r7, #0
		if (!_FS_READONLY && fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
 8006b68:	68e3      	ldr	r3, [r4, #12]
 8006b6a:	69a5      	ldr	r5, [r4, #24]
 8006b6c:	429d      	cmp	r5, r3
			fp->flag |= FA_MODIFIED;
 8006b6e:	bf81      	itttt	hi
 8006b70:	7d23      	ldrbhi	r3, [r4, #20]
			fp->obj.objsize = fp->fptr;
 8006b72:	60e5      	strhi	r5, [r4, #12]
			fp->flag |= FA_MODIFIED;
 8006b74:	f043 0340 	orrhi.w	r3, r3, #64	; 0x40
 8006b78:	7523      	strbhi	r3, [r4, #20]
		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
 8006b7a:	f3c5 0508 	ubfx	r5, r5, #0, #9
 8006b7e:	2d00      	cmp	r5, #0
 8006b80:	d081      	beq.n	8006a86 <f_lseek+0x4c>
 8006b82:	6a22      	ldr	r2, [r4, #32]
 8006b84:	42ba      	cmp	r2, r7
 8006b86:	f43f af7e 	beq.w	8006a86 <f_lseek+0x4c>
			if (fp->flag & FA_DIRTY) {			/* Write-back dirty sector cache */
 8006b8a:	f994 3014 	ldrsb.w	r3, [r4, #20]
 8006b8e:	2b00      	cmp	r3, #0
 8006b90:	f104 0530 	add.w	r5, r4, #48	; 0x30
 8006b94:	da0c      	bge.n	8006bb0 <f_lseek+0x176>
				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);
 8006b96:	9801      	ldr	r0, [sp, #4]
 8006b98:	2301      	movs	r3, #1
 8006b9a:	4629      	mov	r1, r5
 8006b9c:	7840      	ldrb	r0, [r0, #1]
 8006b9e:	f7fe fd29 	bl	80055f4 <disk_write>
 8006ba2:	2800      	cmp	r0, #0
 8006ba4:	f47f af77 	bne.w	8006a96 <f_lseek+0x5c>
				fp->flag &= (BYTE)~FA_DIRTY;
 8006ba8:	7d23      	ldrb	r3, [r4, #20]
 8006baa:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8006bae:	7523      	strb	r3, [r4, #20]
			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) ABORT(fs, FR_DISK_ERR);	/* Fill sector cache */
 8006bb0:	9801      	ldr	r0, [sp, #4]
 8006bb2:	2301      	movs	r3, #1
 8006bb4:	463a      	mov	r2, r7
 8006bb6:	4629      	mov	r1, r5
 8006bb8:	7840      	ldrb	r0, [r0, #1]
 8006bba:	f7fe fd0d 	bl	80055d8 <disk_read>
 8006bbe:	2800      	cmp	r0, #0
 8006bc0:	f47f af69 	bne.w	8006a96 <f_lseek+0x5c>
			fp->sect = nsect;
 8006bc4:	6227      	str	r7, [r4, #32]
 8006bc6:	e75e      	b.n	8006a86 <f_lseek+0x4c>
			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
 8006bc8:	9a01      	ldr	r2, [sp, #4]
 8006bca:	8957      	ldrh	r7, [r2, #10]
 8006bcc:	027f      	lsls	r7, r7, #9
			if (ifptr > 0 &&
 8006bce:	b303      	cbz	r3, 8006c12 <f_lseek+0x1d8>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
 8006bd0:	3b01      	subs	r3, #1
 8006bd2:	1e6a      	subs	r2, r5, #1
 8006bd4:	fbb3 f1f7 	udiv	r1, r3, r7
 8006bd8:	fbb2 f2f7 	udiv	r2, r2, r7
			if (ifptr > 0 &&
 8006bdc:	428a      	cmp	r2, r1
 8006bde:	d318      	bcc.n	8006c12 <f_lseek+0x1d8>
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8006be0:	427a      	negs	r2, r7
 8006be2:	4013      	ands	r3, r2
				clst = fp->clust;
 8006be4:	69e1      	ldr	r1, [r4, #28]
				fp->fptr = (ifptr - 1) & ~(FSIZE_t)(bcs - 1);	/* start from the current cluster */
 8006be6:	61a3      	str	r3, [r4, #24]
				ofs -= fp->fptr;
 8006be8:	1aed      	subs	r5, r5, r3
			if (clst != 0) {
 8006bea:	2900      	cmp	r1, #0
 8006bec:	d0bb      	beq.n	8006b66 <f_lseek+0x12c>
				while (ofs > bcs) {						/* Cluster following loop */
 8006bee:	42bd      	cmp	r5, r7
 8006bf0:	d81e      	bhi.n	8006c30 <f_lseek+0x1f6>
				fp->fptr += ofs;
 8006bf2:	69a3      	ldr	r3, [r4, #24]
 8006bf4:	442b      	add	r3, r5
 8006bf6:	61a3      	str	r3, [r4, #24]
				if (ofs % SS(fs)) {
 8006bf8:	f3c5 0308 	ubfx	r3, r5, #0, #9
 8006bfc:	2b00      	cmp	r3, #0
 8006bfe:	d0b2      	beq.n	8006b66 <f_lseek+0x12c>
					nsect = clust2sect(fs, clst);	/* Current sector */
 8006c00:	9801      	ldr	r0, [sp, #4]
 8006c02:	f7fe fdab 	bl	800575c <clust2sect>
					if (!nsect) ABORT(fs, FR_INT_ERR);
 8006c06:	2800      	cmp	r0, #0
 8006c08:	f43f af3b 	beq.w	8006a82 <f_lseek+0x48>
					nsect += (DWORD)(ofs / SS(fs));
 8006c0c:	eb00 2755 	add.w	r7, r0, r5, lsr #9
 8006c10:	e7aa      	b.n	8006b68 <f_lseek+0x12e>
				clst = fp->obj.sclust;					/* start from the first cluster */
 8006c12:	68a1      	ldr	r1, [r4, #8]
				if (clst == 0) {						/* If no cluster chain, create a new chain */
 8006c14:	b951      	cbnz	r1, 8006c2c <f_lseek+0x1f2>
					clst = create_chain(&fp->obj, 0);
 8006c16:	4620      	mov	r0, r4
 8006c18:	f7ff f9a4 	bl	8005f64 <create_chain>
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 8006c1c:	2801      	cmp	r0, #1
					clst = create_chain(&fp->obj, 0);
 8006c1e:	4601      	mov	r1, r0
					if (clst == 1) ABORT(fs, FR_INT_ERR);
 8006c20:	f43f af2f 	beq.w	8006a82 <f_lseek+0x48>
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8006c24:	3001      	adds	r0, #1
 8006c26:	f43f af36 	beq.w	8006a96 <f_lseek+0x5c>
					fp->obj.sclust = clst;
 8006c2a:	60a1      	str	r1, [r4, #8]
				fp->clust = clst;
 8006c2c:	61e1      	str	r1, [r4, #28]
 8006c2e:	e7dc      	b.n	8006bea <f_lseek+0x1b0>
					ofs -= bcs; fp->fptr += bcs;
 8006c30:	69a3      	ldr	r3, [r4, #24]
 8006c32:	443b      	add	r3, r7
 8006c34:	61a3      	str	r3, [r4, #24]
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8006c36:	7d23      	ldrb	r3, [r4, #20]
 8006c38:	079a      	lsls	r2, r3, #30
					ofs -= bcs; fp->fptr += bcs;
 8006c3a:	eba5 0507 	sub.w	r5, r5, r7
					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
 8006c3e:	d506      	bpl.n	8006c4e <f_lseek+0x214>
						clst = create_chain(&fp->obj, clst);	/* Follow chain with forceed stretch */
 8006c40:	4620      	mov	r0, r4
 8006c42:	f7ff f98f 	bl	8005f64 <create_chain>
						if (clst == 0) {				/* Clip file size in case of disk full */
 8006c46:	4601      	mov	r1, r0
 8006c48:	b928      	cbnz	r0, 8006c56 <f_lseek+0x21c>
							ofs = 0; break;
 8006c4a:	4605      	mov	r5, r0
 8006c4c:	e7d1      	b.n	8006bf2 <f_lseek+0x1b8>
						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
 8006c4e:	6820      	ldr	r0, [r4, #0]
 8006c50:	f7ff f92e 	bl	8005eb0 <get_fat.isra.8>
 8006c54:	4601      	mov	r1, r0
					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
 8006c56:	1c4b      	adds	r3, r1, #1
 8006c58:	f43f af1d 	beq.w	8006a96 <f_lseek+0x5c>
					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
 8006c5c:	2901      	cmp	r1, #1
 8006c5e:	f67f af10 	bls.w	8006a82 <f_lseek+0x48>
 8006c62:	9b01      	ldr	r3, [sp, #4]
 8006c64:	695b      	ldr	r3, [r3, #20]
 8006c66:	4299      	cmp	r1, r3
 8006c68:	f4bf af0b 	bcs.w	8006a82 <f_lseek+0x48>
					fp->clust = clst;
 8006c6c:	61e1      	str	r1, [r4, #28]
 8006c6e:	e7be      	b.n	8006bee <f_lseek+0x1b4>
				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
 8006c70:	2611      	movs	r6, #17
 8006c72:	e708      	b.n	8006a86 <f_lseek+0x4c>

08006c74 <f_opendir>:

FRESULT f_opendir (
	DIR* dp,			/* Pointer to directory object to create */
	const TCHAR* path	/* Pointer to the directory path */
)
{
 8006c74:	b530      	push	{r4, r5, lr}
 8006c76:	b085      	sub	sp, #20
	FATFS *fs;
	_FDID *obj;
	DEF_NAMBUF


	if (!dp) return FR_INVALID_OBJECT;
 8006c78:	4605      	mov	r5, r0
{
 8006c7a:	9101      	str	r1, [sp, #4]
	if (!dp) return FR_INVALID_OBJECT;
 8006c7c:	2800      	cmp	r0, #0
 8006c7e:	d03a      	beq.n	8006cf6 <f_opendir+0x82>

	/* Get logical drive */
	obj = &dp->obj;
	res = find_volume(&path, &fs, 0);
 8006c80:	2200      	movs	r2, #0
 8006c82:	a903      	add	r1, sp, #12
 8006c84:	a801      	add	r0, sp, #4
 8006c86:	f7fe ff39 	bl	8005afc <find_volume>
	if (res == FR_OK) {
 8006c8a:	4604      	mov	r4, r0
 8006c8c:	b9f8      	cbnz	r0, 8006cce <f_opendir+0x5a>
		obj->fs = fs;
 8006c8e:	9b03      	ldr	r3, [sp, #12]
 8006c90:	602b      	str	r3, [r5, #0]
		INIT_NAMBUF(fs);
		res = follow_path(dp, path);			/* Follow the path to the directory */
 8006c92:	9901      	ldr	r1, [sp, #4]
 8006c94:	4628      	mov	r0, r5
 8006c96:	f7ff fa9f 	bl	80061d8 <follow_path>
		if (res == FR_OK) {						/* Follow completed */
 8006c9a:	4604      	mov	r4, r0
 8006c9c:	b9a0      	cbnz	r0, 8006cc8 <f_opendir+0x54>
			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
 8006c9e:	f995 302f 	ldrsb.w	r3, [r5, #47]	; 0x2f
 8006ca2:	2b00      	cmp	r3, #0
 8006ca4:	db08      	blt.n	8006cb8 <f_opendir+0x44>
				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
 8006ca6:	79ab      	ldrb	r3, [r5, #6]
 8006ca8:	06db      	lsls	r3, r3, #27
 8006caa:	d520      	bpl.n	8006cee <f_opendir+0x7a>
						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
					} else
#endif
					{
						obj->sclust = ld_clust(fs, dp->dir);	/* Get object allocation info */
 8006cac:	9b03      	ldr	r3, [sp, #12]
 8006cae:	6a29      	ldr	r1, [r5, #32]
 8006cb0:	7818      	ldrb	r0, [r3, #0]
 8006cb2:	f7fe fe0e 	bl	80058d2 <ld_clust.isra.1>
 8006cb6:	60a8      	str	r0, [r5, #8]
				} else {						/* This object is a file */
					res = FR_NO_PATH;
				}
			}
			if (res == FR_OK) {
				obj->id = fs->id;
 8006cb8:	9b03      	ldr	r3, [sp, #12]
 8006cba:	88db      	ldrh	r3, [r3, #6]
 8006cbc:	80ab      	strh	r3, [r5, #4]
				res = dir_sdi(dp, 0);			/* Rewind directory */
 8006cbe:	4628      	mov	r0, r5
 8006cc0:	f7ff f9de 	bl	8006080 <dir_sdi.constprop.14>
#if _FS_LOCK != 0
				if (res == FR_OK) {
 8006cc4:	4604      	mov	r4, r0
 8006cc6:	b128      	cbz	r0, 8006cd4 <f_opendir+0x60>
				}
#endif
			}
		}
		FREE_NAMBUF();
		if (res == FR_NO_FILE) res = FR_NO_PATH;
 8006cc8:	2c04      	cmp	r4, #4
 8006cca:	bf08      	it	eq
 8006ccc:	2405      	moveq	r4, #5
	}
	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
 8006cce:	2300      	movs	r3, #0
 8006cd0:	602b      	str	r3, [r5, #0]
 8006cd2:	e007      	b.n	8006ce4 <f_opendir+0x70>
					if (obj->sclust) {
 8006cd4:	68ab      	ldr	r3, [r5, #8]
 8006cd6:	b143      	cbz	r3, 8006cea <f_opendir+0x76>
						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
 8006cd8:	4621      	mov	r1, r4
 8006cda:	4628      	mov	r0, r5
 8006cdc:	f7fe fcea 	bl	80056b4 <inc_lock>
 8006ce0:	6128      	str	r0, [r5, #16]
						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
 8006ce2:	b130      	cbz	r0, 8006cf2 <f_opendir+0x7e>

	LEAVE_FF(fs, res);
}
 8006ce4:	4620      	mov	r0, r4
 8006ce6:	b005      	add	sp, #20
 8006ce8:	bd30      	pop	{r4, r5, pc}
						obj->lockid = 0;	/* Root directory need not to be locked */
 8006cea:	612c      	str	r4, [r5, #16]
 8006cec:	e7fa      	b.n	8006ce4 <f_opendir+0x70>
					res = FR_NO_PATH;
 8006cee:	2405      	movs	r4, #5
 8006cf0:	e7ed      	b.n	8006cce <f_opendir+0x5a>
						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
 8006cf2:	2412      	movs	r4, #18
 8006cf4:	e7eb      	b.n	8006cce <f_opendir+0x5a>
	if (!dp) return FR_INVALID_OBJECT;
 8006cf6:	2409      	movs	r4, #9
 8006cf8:	e7f4      	b.n	8006ce4 <f_opendir+0x70>

08006cfa <f_closedir>:
/*-----------------------------------------------------------------------*/

FRESULT f_closedir (
	DIR *dp		/* Pointer to the directory object to be closed */
)
{
 8006cfa:	b537      	push	{r0, r1, r2, r4, r5, lr}
	FRESULT res;
	FATFS *fs;


	res = validate(&dp->obj, &fs);			/* Check validity of the file object */
 8006cfc:	a901      	add	r1, sp, #4
{
 8006cfe:	4605      	mov	r5, r0
	res = validate(&dp->obj, &fs);			/* Check validity of the file object */
 8006d00:	f7fe fdc3 	bl	800588a <validate>
	if (res == FR_OK) {
 8006d04:	4604      	mov	r4, r0
 8006d06:	b918      	cbnz	r0, 8006d10 <f_closedir+0x16>
#if _FS_LOCK != 0
		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
 8006d08:	6928      	ldr	r0, [r5, #16]
 8006d0a:	b920      	cbnz	r0, 8006d16 <f_closedir+0x1c>
			res = dec_lock(dp->obj.lockid);
		}
		if (res == FR_OK)
#endif
		{
			dp->obj.fs = 0;			/* Invalidate directory object */
 8006d0c:	2300      	movs	r3, #0
 8006d0e:	602b      	str	r3, [r5, #0]
#if _FS_REENTRANT
		unlock_fs(fs, FR_OK);		/* Unlock volume */
#endif
	}
	return res;
}
 8006d10:	4620      	mov	r0, r4
 8006d12:	b003      	add	sp, #12
 8006d14:	bd30      	pop	{r4, r5, pc}
			res = dec_lock(dp->obj.lockid);
 8006d16:	f7fe fd09 	bl	800572c <dec_lock>
		if (res == FR_OK)
 8006d1a:	2800      	cmp	r0, #0
 8006d1c:	d0f6      	beq.n	8006d0c <f_closedir+0x12>
 8006d1e:	4604      	mov	r4, r0
 8006d20:	e7f6      	b.n	8006d10 <f_closedir+0x16>

08006d22 <f_readdir>:

FRESULT f_readdir (
	DIR* dp,			/* Pointer to the open directory object */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 8006d22:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8006d24:	460d      	mov	r5, r1
	FRESULT res;
	FATFS *fs;
	DEF_NAMBUF


	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 8006d26:	a901      	add	r1, sp, #4
{
 8006d28:	4604      	mov	r4, r0
	res = validate(&dp->obj, &fs);	/* Check validity of the directory object */
 8006d2a:	f7fe fdae 	bl	800588a <validate>
	if (res == FR_OK) {
 8006d2e:	b918      	cbnz	r0, 8006d38 <f_readdir+0x16>
		if (!fno) {
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 8006d30:	4620      	mov	r0, r4
		if (!fno) {
 8006d32:	b91d      	cbnz	r5, 8006d3c <f_readdir+0x1a>
			res = dir_sdi(dp, 0);			/* Rewind the directory object */
 8006d34:	f7ff f9a4 	bl	8006080 <dir_sdi.constprop.14>
			}
			FREE_NAMBUF();
		}
	}
	LEAVE_FF(fs, res);
}
 8006d38:	b003      	add	sp, #12
 8006d3a:	bd30      	pop	{r4, r5, pc}
			res = dir_read(dp, 0);			/* Read an item */
 8006d3c:	f7ff fb10 	bl	8006360 <dir_read.constprop.10>
			if (res == FR_OK) {				/* A valid entry is found */
 8006d40:	f010 03fb 	ands.w	r3, r0, #251	; 0xfb
 8006d44:	d1f8      	bne.n	8006d38 <f_readdir+0x16>
	fno->fname[0] = 0;		/* Invaidate file info */
 8006d46:	726b      	strb	r3, [r5, #9]
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 8006d48:	69e3      	ldr	r3, [r4, #28]
 8006d4a:	b11b      	cbz	r3, 8006d54 <f_readdir+0x32>
 8006d4c:	4629      	mov	r1, r5
 8006d4e:	4620      	mov	r0, r4
 8006d50:	f7fe fdd9 	bl	8005906 <get_fileinfo.part.3>
				res = dir_next(dp, 0);		/* Increment index for next */
 8006d54:	2100      	movs	r1, #0
 8006d56:	4620      	mov	r0, r4
 8006d58:	f7ff f9c5 	bl	80060e6 <dir_next>
				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
 8006d5c:	2804      	cmp	r0, #4
 8006d5e:	bf08      	it	eq
 8006d60:	2000      	moveq	r0, #0
 8006d62:	e7e9      	b.n	8006d38 <f_readdir+0x16>

08006d64 <f_findnext>:

FRESULT f_findnext (
	DIR* dp,		/* Pointer to the open directory object */
	FILINFO* fno	/* Pointer to the file information structure */
)
{
 8006d64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8006d66:	4606      	mov	r6, r0
 8006d68:	460d      	mov	r5, r1


	for (;;) {
		res = f_readdir(dp, fno);		/* Get a directory item */
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
 8006d6a:	f101 0709 	add.w	r7, r1, #9
		res = f_readdir(dp, fno);		/* Get a directory item */
 8006d6e:	4629      	mov	r1, r5
 8006d70:	4630      	mov	r0, r6
 8006d72:	f7ff ffd6 	bl	8006d22 <f_readdir>
		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
 8006d76:	4604      	mov	r4, r0
 8006d78:	b950      	cbnz	r0, 8006d90 <f_findnext+0x2c>
 8006d7a:	b14d      	cbz	r5, 8006d90 <f_findnext+0x2c>
 8006d7c:	7a6b      	ldrb	r3, [r5, #9]
 8006d7e:	b13b      	cbz	r3, 8006d90 <f_findnext+0x2c>
		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
 8006d80:	4603      	mov	r3, r0
 8006d82:	4602      	mov	r2, r0
 8006d84:	4639      	mov	r1, r7
 8006d86:	6b30      	ldr	r0, [r6, #48]	; 0x30
 8006d88:	f7fe fd1a 	bl	80057c0 <pattern_matching>
 8006d8c:	2800      	cmp	r0, #0
 8006d8e:	d0ee      	beq.n	8006d6e <f_findnext+0xa>
#if _USE_LFN != 0 && _USE_FIND == 2
		if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
#endif
	}
	return res;
}
 8006d90:	4620      	mov	r0, r4
 8006d92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

08006d94 <f_findfirst>:
	DIR* dp,				/* Pointer to the blank directory object */
	FILINFO* fno,			/* Pointer to the file information structure */
	const TCHAR* path,		/* Pointer to the directory to open */
	const TCHAR* pattern	/* Pointer to the matching pattern */
)
{
 8006d94:	b538      	push	{r3, r4, r5, lr}
 8006d96:	460d      	mov	r5, r1
	FRESULT res;


	dp->pat = pattern;		/* Save pointer to pattern string */
 8006d98:	6303      	str	r3, [r0, #48]	; 0x30
	res = f_opendir(dp, path);		/* Open the target directory */
 8006d9a:	4611      	mov	r1, r2
{
 8006d9c:	4604      	mov	r4, r0
	res = f_opendir(dp, path);		/* Open the target directory */
 8006d9e:	f7ff ff69 	bl	8006c74 <f_opendir>
	if (res == FR_OK) {
 8006da2:	b928      	cbnz	r0, 8006db0 <f_findfirst+0x1c>
		res = f_findnext(dp, fno);	/* Find the first item */
 8006da4:	4629      	mov	r1, r5
 8006da6:	4620      	mov	r0, r4
	}
	return res;
}
 8006da8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		res = f_findnext(dp, fno);	/* Find the first item */
 8006dac:	f7ff bfda 	b.w	8006d64 <f_findnext>
}
 8006db0:	bd38      	pop	{r3, r4, r5, pc}

08006db2 <f_stat>:

FRESULT f_stat (
	const TCHAR* path,	/* Pointer to the file path */
	FILINFO* fno		/* Pointer to file information to return */
)
{
 8006db2:	b530      	push	{r4, r5, lr}
 8006db4:	b091      	sub	sp, #68	; 0x44
 8006db6:	460d      	mov	r5, r1
 8006db8:	9001      	str	r0, [sp, #4]
	DIR dj;
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &dj.obj.fs, 0);
 8006dba:	2200      	movs	r2, #0
 8006dbc:	a903      	add	r1, sp, #12
 8006dbe:	a801      	add	r0, sp, #4
 8006dc0:	f7fe fe9c 	bl	8005afc <find_volume>
	if (res == FR_OK) {
 8006dc4:	4604      	mov	r4, r0
 8006dc6:	b988      	cbnz	r0, 8006dec <f_stat+0x3a>
		INIT_NAMBUF(dj.obj.fs);
		res = follow_path(&dj, path);	/* Follow the file path */
 8006dc8:	9901      	ldr	r1, [sp, #4]
 8006dca:	a803      	add	r0, sp, #12
 8006dcc:	f7ff fa04 	bl	80061d8 <follow_path>
		if (res == FR_OK) {				/* Follow completed */
 8006dd0:	4604      	mov	r4, r0
 8006dd2:	b958      	cbnz	r0, 8006dec <f_stat+0x3a>
			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
 8006dd4:	f99d 303b 	ldrsb.w	r3, [sp, #59]	; 0x3b
 8006dd8:	2b00      	cmp	r3, #0
 8006dda:	db0a      	blt.n	8006df2 <f_stat+0x40>
				res = FR_INVALID_NAME;
			} else {							/* Found an object */
				if (fno) get_fileinfo(&dj, fno);
 8006ddc:	b135      	cbz	r5, 8006dec <f_stat+0x3a>
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 8006dde:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	fno->fname[0] = 0;		/* Invaidate file info */
 8006de0:	7268      	strb	r0, [r5, #9]
	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
 8006de2:	b11b      	cbz	r3, 8006dec <f_stat+0x3a>
 8006de4:	4629      	mov	r1, r5
 8006de6:	a803      	add	r0, sp, #12
 8006de8:	f7fe fd8d 	bl	8005906 <get_fileinfo.part.3>
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(dj.obj.fs, res);
}
 8006dec:	4620      	mov	r0, r4
 8006dee:	b011      	add	sp, #68	; 0x44
 8006df0:	bd30      	pop	{r4, r5, pc}
				res = FR_INVALID_NAME;
 8006df2:	2406      	movs	r4, #6
 8006df4:	e7fa      	b.n	8006dec <f_stat+0x3a>

08006df6 <f_unlink>:
/*-----------------------------------------------------------------------*/

FRESULT f_unlink (
	const TCHAR* path		/* Pointer to the file or directory path */
)
{
 8006df6:	b570      	push	{r4, r5, r6, lr}
 8006df8:	b09e      	sub	sp, #120	; 0x78
#endif
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, FA_WRITE);
 8006dfa:	2202      	movs	r2, #2
{
 8006dfc:	9001      	str	r0, [sp, #4]
	res = find_volume(&path, &fs, FA_WRITE);
 8006dfe:	a903      	add	r1, sp, #12
 8006e00:	a801      	add	r0, sp, #4
 8006e02:	f7fe fe7b 	bl	8005afc <find_volume>
	dj.obj.fs = fs;
 8006e06:	9b03      	ldr	r3, [sp, #12]
 8006e08:	9304      	str	r3, [sp, #16]
	if (res == FR_OK) {
 8006e0a:	b990      	cbnz	r0, 8006e32 <f_unlink+0x3c>
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);		/* Follow the file path */
 8006e0c:	9901      	ldr	r1, [sp, #4]
 8006e0e:	a804      	add	r0, sp, #16
 8006e10:	f7ff f9e2 	bl	80061d8 <follow_path>
		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
		}
#if _FS_LOCK != 0
		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
 8006e14:	b968      	cbnz	r0, 8006e32 <f_unlink+0x3c>
 8006e16:	2102      	movs	r1, #2
 8006e18:	a804      	add	r0, sp, #16
 8006e1a:	f7fe fc1d 	bl	8005658 <chk_lock>
#endif
		if (res == FR_OK) {					/* The object is accessible */
 8006e1e:	b940      	cbnz	r0, 8006e32 <f_unlink+0x3c>
			if (dj.fn[NSFLAG] & NS_NONAME) {
 8006e20:	f99d 303f 	ldrsb.w	r3, [sp, #63]	; 0x3f
 8006e24:	2b00      	cmp	r3, #0
 8006e26:	db0e      	blt.n	8006e46 <f_unlink+0x50>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
			} else {
				if (dj.obj.attr & AM_RDO) {
 8006e28:	f89d 6016 	ldrb.w	r6, [sp, #22]
 8006e2c:	07f2      	lsls	r2, r6, #31
 8006e2e:	d50c      	bpl.n	8006e4a <f_unlink+0x54>
					res = FR_DENIED;		/* Cannot remove R/O object */
 8006e30:	2007      	movs	r0, #7
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
 8006e32:	b01e      	add	sp, #120	; 0x78
 8006e34:	bd70      	pop	{r4, r5, r6, pc}
					res = remove_chain(&dj.obj, dclst, 0);
 8006e36:	4602      	mov	r2, r0
 8006e38:	4621      	mov	r1, r4
 8006e3a:	a804      	add	r0, sp, #16
 8006e3c:	f7ff f8ea 	bl	8006014 <remove_chain>
				if (res == FR_OK) res = sync_fs(fs);
 8006e40:	2800      	cmp	r0, #0
 8006e42:	d1f6      	bne.n	8006e32 <f_unlink+0x3c>
 8006e44:	e025      	b.n	8006e92 <f_unlink+0x9c>
				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
 8006e46:	2006      	movs	r0, #6
	LEAVE_FF(fs, res);
 8006e48:	e7f3      	b.n	8006e32 <f_unlink+0x3c>
					dclst = ld_clust(fs, dj.dir);
 8006e4a:	9d03      	ldr	r5, [sp, #12]
 8006e4c:	990c      	ldr	r1, [sp, #48]	; 0x30
 8006e4e:	7828      	ldrb	r0, [r5, #0]
 8006e50:	f7fe fd3f 	bl	80058d2 <ld_clust.isra.1>
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 8006e54:	06f3      	lsls	r3, r6, #27
					dclst = ld_clust(fs, dj.dir);
 8006e56:	4604      	mov	r4, r0
				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory? */
 8006e58:	d50d      	bpl.n	8006e76 <f_unlink+0x80>
						res = dir_sdi(&sdj, 0);
 8006e5a:	a811      	add	r0, sp, #68	; 0x44
						sdj.obj.fs = fs;						/* Open the sub-directory */
 8006e5c:	9511      	str	r5, [sp, #68]	; 0x44
						sdj.obj.sclust = dclst;
 8006e5e:	9413      	str	r4, [sp, #76]	; 0x4c
						res = dir_sdi(&sdj, 0);
 8006e60:	f7ff f90e 	bl	8006080 <dir_sdi.constprop.14>
						if (res == FR_OK) {
 8006e64:	2800      	cmp	r0, #0
 8006e66:	d1e4      	bne.n	8006e32 <f_unlink+0x3c>
							res = dir_read(&sdj, 0);			/* Read an item */
 8006e68:	a811      	add	r0, sp, #68	; 0x44
 8006e6a:	f7ff fa79 	bl	8006360 <dir_read.constprop.10>
							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
 8006e6e:	2800      	cmp	r0, #0
 8006e70:	d0de      	beq.n	8006e30 <f_unlink+0x3a>
							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
 8006e72:	2804      	cmp	r0, #4
 8006e74:	d1dd      	bne.n	8006e32 <f_unlink+0x3c>
	FATFS *fs = dp->obj.fs;
 8006e76:	9d04      	ldr	r5, [sp, #16]
	res = move_window(fs, dp->sect);
 8006e78:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8006e7a:	4628      	mov	r0, r5
 8006e7c:	f7fe fde2 	bl	8005a44 <move_window>
	if (res == FR_OK) {
 8006e80:	2800      	cmp	r0, #0
 8006e82:	d1d6      	bne.n	8006e32 <f_unlink+0x3c>
		dp->dir[DIR_Name] = DDEM;
 8006e84:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8006e86:	22e5      	movs	r2, #229	; 0xe5
 8006e88:	701a      	strb	r2, [r3, #0]
		fs->wflag = 1;
 8006e8a:	2301      	movs	r3, #1
 8006e8c:	70eb      	strb	r3, [r5, #3]
				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
 8006e8e:	2c00      	cmp	r4, #0
 8006e90:	d1d1      	bne.n	8006e36 <f_unlink+0x40>
				if (res == FR_OK) res = sync_fs(fs);
 8006e92:	9803      	ldr	r0, [sp, #12]
 8006e94:	f7fe fd8b 	bl	80059ae <sync_fs>
 8006e98:	e7cb      	b.n	8006e32 <f_unlink+0x3c>

08006e9a <f_mkdir>:
/*-----------------------------------------------------------------------*/

FRESULT f_mkdir (
	const TCHAR* path		/* Pointer to the directory path */
)
{
 8006e9a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006e9e:	b090      	sub	sp, #64	; 0x40
	DWORD dsc, dcl, pcl, tm;
	DEF_NAMBUF


	/* Get logical drive */
	res = find_volume(&path, &fs, FA_WRITE);
 8006ea0:	2202      	movs	r2, #2
{
 8006ea2:	9001      	str	r0, [sp, #4]
	res = find_volume(&path, &fs, FA_WRITE);
 8006ea4:	a902      	add	r1, sp, #8
 8006ea6:	a801      	add	r0, sp, #4
 8006ea8:	f7fe fe28 	bl	8005afc <find_volume>
	dj.obj.fs = fs;
 8006eac:	9b02      	ldr	r3, [sp, #8]
 8006eae:	9303      	str	r3, [sp, #12]
	res = find_volume(&path, &fs, FA_WRITE);
 8006eb0:	4604      	mov	r4, r0
 8006eb2:	4605      	mov	r5, r0
	if (res == FR_OK) {
 8006eb4:	2800      	cmp	r0, #0
 8006eb6:	f040 8094 	bne.w	8006fe2 <f_mkdir+0x148>
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);			/* Follow the file path */
 8006eba:	9901      	ldr	r1, [sp, #4]
 8006ebc:	a803      	add	r0, sp, #12
 8006ebe:	f7ff f98b 	bl	80061d8 <follow_path>
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 8006ec2:	4604      	mov	r4, r0
 8006ec4:	2800      	cmp	r0, #0
 8006ec6:	f000 8090 	beq.w	8006fea <f_mkdir+0x150>
		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
			res = FR_INVALID_NAME;
		}
		if (res == FR_NO_FILE) {				/* Can create a new directory */
 8006eca:	2804      	cmp	r0, #4
 8006ecc:	f040 8089 	bne.w	8006fe2 <f_mkdir+0x148>
			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
 8006ed0:	4629      	mov	r1, r5
 8006ed2:	a803      	add	r0, sp, #12
 8006ed4:	f7ff f846 	bl	8005f64 <create_chain>
			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
 8006ed8:	9a02      	ldr	r2, [sp, #8]
 8006eda:	8953      	ldrh	r3, [r2, #10]
 8006edc:	025b      	lsls	r3, r3, #9
 8006ede:	9306      	str	r3, [sp, #24]
			res = FR_OK;
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 8006ee0:	4605      	mov	r5, r0
 8006ee2:	2800      	cmp	r0, #0
 8006ee4:	d055      	beq.n	8006f92 <f_mkdir+0xf8>
			if (dcl == 1) res = FR_INT_ERR;
 8006ee6:	2801      	cmp	r0, #1
 8006ee8:	d055      	beq.n	8006f96 <f_mkdir+0xfc>
			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
 8006eea:	1c43      	adds	r3, r0, #1
 8006eec:	d17f      	bne.n	8006fee <f_mkdir+0x154>
 8006eee:	2401      	movs	r4, #1
			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
			tm = GET_FATTIME();
 8006ef0:	f000 ffdc 	bl	8007eac <get_fattime>
 8006ef4:	4680      	mov	r8, r0
			if (res == FR_OK) {					/* Initialize the new directory table */
 8006ef6:	2c00      	cmp	r4, #0
 8006ef8:	d145      	bne.n	8006f86 <f_mkdir+0xec>
				dsc = clust2sect(fs, dcl);
 8006efa:	9e02      	ldr	r6, [sp, #8]
 8006efc:	4629      	mov	r1, r5
 8006efe:	4630      	mov	r0, r6
 8006f00:	f7fe fc2c 	bl	800575c <clust2sect>
				dir = fs->win;
 8006f04:	f106 0730 	add.w	r7, r6, #48	; 0x30
				mem_set(dir, 0, SS(fs));
 8006f08:	4621      	mov	r1, r4
 8006f0a:	f44f 7200 	mov.w	r2, #512	; 0x200
				dsc = clust2sect(fs, dcl);
 8006f0e:	4681      	mov	r9, r0
				mem_set(dir, 0, SS(fs));
 8006f10:	4638      	mov	r0, r7
 8006f12:	f7fe fb9b 	bl	800564c <mem_set>
				if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
 8006f16:	220b      	movs	r2, #11
 8006f18:	2120      	movs	r1, #32
 8006f1a:	4638      	mov	r0, r7
 8006f1c:	f7fe fb96 	bl	800564c <mem_set>
					dir[DIR_Name] = '.';
 8006f20:	f04f 0a2e 	mov.w	sl, #46	; 0x2e
					dir[DIR_Attr] = AM_DIR;
 8006f24:	2310      	movs	r3, #16
 8006f26:	f886 303b 	strb.w	r3, [r6, #59]	; 0x3b
					st_dword(dir + DIR_ModTime, tm);
 8006f2a:	4641      	mov	r1, r8
 8006f2c:	f106 0046 	add.w	r0, r6, #70	; 0x46
					dir[DIR_Name] = '.';
 8006f30:	f886 a030 	strb.w	sl, [r6, #48]	; 0x30
					st_dword(dir + DIR_ModTime, tm);
 8006f34:	f7fe fb82 	bl	800563c <st_dword>
					st_clust(fs, dir, dcl);
					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
 8006f38:	f106 0450 	add.w	r4, r6, #80	; 0x50
					st_clust(fs, dir, dcl);
 8006f3c:	462a      	mov	r2, r5
 8006f3e:	4639      	mov	r1, r7
 8006f40:	9802      	ldr	r0, [sp, #8]
 8006f42:	f7fe fcd4 	bl	80058ee <st_clust.isra.2>
 8006f46:	2220      	movs	r2, #32
 8006f48:	4620      	mov	r0, r4
 8006f4a:	4639      	mov	r1, r7
 8006f4c:	f7fe fcb8 	bl	80058c0 <mem_cpy.part.0>
					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
 8006f50:	9802      	ldr	r0, [sp, #8]
					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 8006f52:	f886 a051 	strb.w	sl, [r6, #81]	; 0x51
					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
 8006f56:	7803      	ldrb	r3, [r0, #0]
					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
 8006f58:	9a05      	ldr	r2, [sp, #20]
					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase) pcl = 0;
 8006f5a:	2b03      	cmp	r3, #3
 8006f5c:	d103      	bne.n	8006f66 <f_mkdir+0xcc>
 8006f5e:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8006f60:	429a      	cmp	r2, r3
 8006f62:	bf08      	it	eq
 8006f64:	2200      	moveq	r2, #0
					st_clust(fs, dir + SZDIRE, pcl);
 8006f66:	4621      	mov	r1, r4
 8006f68:	f7fe fcc1 	bl	80058ee <st_clust.isra.2>
				}
				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 8006f6c:	9b02      	ldr	r3, [sp, #8]
 8006f6e:	895e      	ldrh	r6, [r3, #10]
					fs->winsect = dsc++;
					fs->wflag = 1;
 8006f70:	f04f 0a01 	mov.w	sl, #1
 8006f74:	44b1      	add	r9, r6
 8006f76:	eba9 0306 	sub.w	r3, r9, r6
				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 8006f7a:	b976      	cbnz	r6, 8006f9a <f_mkdir+0x100>
					if (res != FR_OK) break;
					mem_set(dir, 0, SS(fs));
				}
			}
			if (res == FR_OK) {
				res = dir_register(&dj);	/* Register the object to the directoy */
 8006f7c:	a803      	add	r0, sp, #12
 8006f7e:	f7ff fa19 	bl	80063b4 <dir_register>
			}
			if (res == FR_OK) {
 8006f82:	4604      	mov	r4, r0
 8006f84:	b1d0      	cbz	r0, 8006fbc <f_mkdir+0x122>
				}
				if (res == FR_OK) {
					res = sync_fs(fs);
				}
			} else {
				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
 8006f86:	2200      	movs	r2, #0
 8006f88:	4629      	mov	r1, r5
 8006f8a:	a803      	add	r0, sp, #12
 8006f8c:	f7ff f842 	bl	8006014 <remove_chain>
 8006f90:	e027      	b.n	8006fe2 <f_mkdir+0x148>
			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
 8006f92:	2407      	movs	r4, #7
 8006f94:	e7ac      	b.n	8006ef0 <f_mkdir+0x56>
			if (dcl == 1) res = FR_INT_ERR;
 8006f96:	2402      	movs	r4, #2
 8006f98:	e7aa      	b.n	8006ef0 <f_mkdir+0x56>
					fs->winsect = dsc++;
 8006f9a:	9802      	ldr	r0, [sp, #8]
 8006f9c:	62c3      	str	r3, [r0, #44]	; 0x2c
					fs->wflag = 1;
 8006f9e:	f880 a003 	strb.w	sl, [r0, #3]
 8006fa2:	f7fe fcdb 	bl	800595c <sync_window.part.4>
					if (res != FR_OK) break;
 8006fa6:	4604      	mov	r4, r0
 8006fa8:	2800      	cmp	r0, #0
 8006faa:	d1ec      	bne.n	8006f86 <f_mkdir+0xec>
					mem_set(dir, 0, SS(fs));
 8006fac:	4601      	mov	r1, r0
 8006fae:	f44f 7200 	mov.w	r2, #512	; 0x200
 8006fb2:	4638      	mov	r0, r7
 8006fb4:	f7fe fb4a 	bl	800564c <mem_set>
				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
 8006fb8:	3e01      	subs	r6, #1
 8006fba:	e7dc      	b.n	8006f76 <f_mkdir+0xdc>
					dir = dj.dir;
 8006fbc:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
					st_dword(dir + DIR_ModTime, tm);	/* Created time */
 8006fbe:	4641      	mov	r1, r8
 8006fc0:	f104 0016 	add.w	r0, r4, #22
 8006fc4:	f7fe fb3a 	bl	800563c <st_dword>
					st_clust(fs, dir, dcl);				/* Table start cluster */
 8006fc8:	4621      	mov	r1, r4
 8006fca:	462a      	mov	r2, r5
 8006fcc:	9802      	ldr	r0, [sp, #8]
 8006fce:	f7fe fc8e 	bl	80058ee <st_clust.isra.2>
					dir[DIR_Attr] = AM_DIR;				/* Attribute */
 8006fd2:	2310      	movs	r3, #16
					fs->wflag = 1;
 8006fd4:	9802      	ldr	r0, [sp, #8]
					dir[DIR_Attr] = AM_DIR;				/* Attribute */
 8006fd6:	72e3      	strb	r3, [r4, #11]
					fs->wflag = 1;
 8006fd8:	2301      	movs	r3, #1
 8006fda:	70c3      	strb	r3, [r0, #3]
					res = sync_fs(fs);
 8006fdc:	f7fe fce7 	bl	80059ae <sync_fs>
 8006fe0:	4604      	mov	r4, r0
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
 8006fe2:	4620      	mov	r0, r4
 8006fe4:	b010      	add	sp, #64	; 0x40
 8006fe6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
 8006fea:	2408      	movs	r4, #8
	LEAVE_FF(fs, res);
 8006fec:	e7f9      	b.n	8006fe2 <f_mkdir+0x148>
			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
 8006fee:	4610      	mov	r0, r2
 8006ff0:	f7fe fcd7 	bl	80059a2 <sync_window>
 8006ff4:	4604      	mov	r4, r0
 8006ff6:	e77b      	b.n	8006ef0 <f_mkdir+0x56>

08006ff8 <f_rename>:

FRESULT f_rename (
	const TCHAR* path_old,	/* Pointer to the object name to be renamed */
	const TCHAR* path_new	/* Pointer to the new name */
)
{
 8006ff8:	b570      	push	{r4, r5, r6, lr}
 8006ffa:	b0a4      	sub	sp, #144	; 0x90
 8006ffc:	9001      	str	r0, [sp, #4]
 8006ffe:	a824      	add	r0, sp, #144	; 0x90
 8007000:	f840 1d90 	str.w	r1, [r0, #-144]!
	BYTE buf[_FS_EXFAT ? SZDIRE * 2 : 24], *dir;
	DWORD dw;
	DEF_NAMBUF


	get_ldnumber(&path_new);						/* Snip drive number of new name off */
 8007004:	f7fe fc29 	bl	800585a <get_ldnumber>
	res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive of the old object */
 8007008:	2202      	movs	r2, #2
 800700a:	a903      	add	r1, sp, #12
 800700c:	a801      	add	r0, sp, #4
 800700e:	f7fe fd75 	bl	8005afc <find_volume>
	if (res == FR_OK) {
 8007012:	2800      	cmp	r0, #0
 8007014:	d174      	bne.n	8007100 <f_rename+0x108>
		djo.obj.fs = fs;
 8007016:	ac24      	add	r4, sp, #144	; 0x90
 8007018:	9b03      	ldr	r3, [sp, #12]
 800701a:	f844 3d68 	str.w	r3, [r4, #-104]!
		INIT_NAMBUF(fs);
		res = follow_path(&djo, path_old);		/* Check old object */
 800701e:	9901      	ldr	r1, [sp, #4]
 8007020:	4620      	mov	r0, r4
 8007022:	f7ff f8d9 	bl	80061d8 <follow_path>
		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
 8007026:	2800      	cmp	r0, #0
 8007028:	d16a      	bne.n	8007100 <f_rename+0x108>
 800702a:	f89d 3057 	ldrb.w	r3, [sp, #87]	; 0x57
 800702e:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 8007032:	d167      	bne.n	8007104 <f_rename+0x10c>
#if _FS_LOCK != 0
		if (res == FR_OK) {
			res = chk_lock(&djo, 2);
 8007034:	2102      	movs	r1, #2
 8007036:	4620      	mov	r0, r4
 8007038:	f7fe fb0e 	bl	8005658 <chk_lock>
		}
#endif
		if (res == FR_OK) {						/* Object to be renamed is found */
 800703c:	2800      	cmp	r0, #0
 800703e:	d15f      	bne.n	8007100 <f_rename+0x108>
 8007040:	9912      	ldr	r1, [sp, #72]	; 0x48
 8007042:	2215      	movs	r2, #21
 8007044:	310b      	adds	r1, #11
 8007046:	a804      	add	r0, sp, #16
 8007048:	f7fe fc3a 	bl	80058c0 <mem_cpy.part.0>
 800704c:	4621      	mov	r1, r4
 800704e:	a817      	add	r0, sp, #92	; 0x5c
 8007050:	2234      	movs	r2, #52	; 0x34
 8007052:	f7fe fc35 	bl	80058c0 <mem_cpy.part.0>
			} else
#endif
			{	/* At FAT12/FAT16/FAT32 */
				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about the object except name */
				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
 8007056:	9900      	ldr	r1, [sp, #0]
 8007058:	a817      	add	r0, sp, #92	; 0x5c
 800705a:	f7ff f8bd 	bl	80061d8 <follow_path>
				if (res == FR_OK) {						/* Is new name already in use by any other object? */
 800705e:	b948      	cbnz	r0, 8007074 <f_rename+0x7c>
					res = (djn.obj.sclust == djo.obj.sclust && djn.dptr == djo.dptr) ? FR_NO_FILE : FR_EXIST;
 8007060:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8007062:	9a19      	ldr	r2, [sp, #100]	; 0x64
 8007064:	429a      	cmp	r2, r3
 8007066:	d103      	bne.n	8007070 <f_rename+0x78>
 8007068:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800706a:	9a1c      	ldr	r2, [sp, #112]	; 0x70
 800706c:	429a      	cmp	r2, r3
 800706e:	d003      	beq.n	8007078 <f_rename+0x80>
 8007070:	2008      	movs	r0, #8
 8007072:	e045      	b.n	8007100 <f_rename+0x108>
				}
				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
 8007074:	2804      	cmp	r0, #4
 8007076:	d143      	bne.n	8007100 <f_rename+0x108>
					res = dir_register(&djn);			/* Register the new entry */
 8007078:	a817      	add	r0, sp, #92	; 0x5c
 800707a:	f7ff f99b 	bl	80063b4 <dir_register>
					if (res == FR_OK) {
 800707e:	2800      	cmp	r0, #0
 8007080:	d13e      	bne.n	8007100 <f_rename+0x108>
						dir = djn.dir;					/* Copy information about object except name */
 8007082:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
 8007084:	2213      	movs	r2, #19
 8007086:	f10d 0112 	add.w	r1, sp, #18
 800708a:	f105 000d 	add.w	r0, r5, #13
 800708e:	f7fe fc17 	bl	80058c0 <mem_cpy.part.0>
						mem_cpy(dir + 13, buf + 2, 19);
						dir[DIR_Attr] = buf[0] | AM_ARC;
 8007092:	f89d 3010 	ldrb.w	r3, [sp, #16]
						fs->wflag = 1;
 8007096:	9c03      	ldr	r4, [sp, #12]
						dir[DIR_Attr] = buf[0] | AM_ARC;
 8007098:	f043 0320 	orr.w	r3, r3, #32
						fs->wflag = 1;
 800709c:	2601      	movs	r6, #1
						dir[DIR_Attr] = buf[0] | AM_ARC;
 800709e:	72eb      	strb	r3, [r5, #11]
						fs->wflag = 1;
 80070a0:	70e6      	strb	r6, [r4, #3]
						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
 80070a2:	7aeb      	ldrb	r3, [r5, #11]
 80070a4:	06db      	lsls	r3, r3, #27
 80070a6:	d51d      	bpl.n	80070e4 <f_rename+0xec>
 80070a8:	9b19      	ldr	r3, [sp, #100]	; 0x64
 80070aa:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 80070ac:	429a      	cmp	r2, r3
 80070ae:	d019      	beq.n	80070e4 <f_rename+0xec>
							dw = clust2sect(fs, ld_clust(fs, dir));
 80070b0:	4629      	mov	r1, r5
 80070b2:	7820      	ldrb	r0, [r4, #0]
 80070b4:	f7fe fc0d 	bl	80058d2 <ld_clust.isra.1>
 80070b8:	4601      	mov	r1, r0
 80070ba:	4620      	mov	r0, r4
 80070bc:	f7fe fb4e 	bl	800575c <clust2sect>
							if (!dw) {
 80070c0:	4601      	mov	r1, r0
 80070c2:	b308      	cbz	r0, 8007108 <f_rename+0x110>
								res = FR_INT_ERR;
							} else {
/* Start of critical section where an interruption can cause a cross-link */
								res = move_window(fs, dw);
 80070c4:	4620      	mov	r0, r4
 80070c6:	f7fe fcbd 	bl	8005a44 <move_window>
								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
								if (res == FR_OK && dir[1] == '.') {
 80070ca:	b9c8      	cbnz	r0, 8007100 <f_rename+0x108>
								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
 80070cc:	9803      	ldr	r0, [sp, #12]
								if (res == FR_OK && dir[1] == '.') {
 80070ce:	f890 3051 	ldrb.w	r3, [r0, #81]	; 0x51
 80070d2:	2b2e      	cmp	r3, #46	; 0x2e
 80070d4:	d106      	bne.n	80070e4 <f_rename+0xec>
									st_clust(fs, dir, djn.obj.sclust);
 80070d6:	9a19      	ldr	r2, [sp, #100]	; 0x64
 80070d8:	f100 0150 	add.w	r1, r0, #80	; 0x50
 80070dc:	f7fe fc07 	bl	80058ee <st_clust.isra.2>
									fs->wflag = 1;
 80070e0:	9b03      	ldr	r3, [sp, #12]
 80070e2:	70de      	strb	r6, [r3, #3]
	FATFS *fs = dp->obj.fs;
 80070e4:	9c0a      	ldr	r4, [sp, #40]	; 0x28
	res = move_window(fs, dp->sect);
 80070e6:	9911      	ldr	r1, [sp, #68]	; 0x44
 80070e8:	4620      	mov	r0, r4
 80070ea:	f7fe fcab 	bl	8005a44 <move_window>
	if (res == FR_OK) {
 80070ee:	b938      	cbnz	r0, 8007100 <f_rename+0x108>
		dp->dir[DIR_Name] = DDEM;
 80070f0:	9b12      	ldr	r3, [sp, #72]	; 0x48
 80070f2:	22e5      	movs	r2, #229	; 0xe5
 80070f4:	701a      	strb	r2, [r3, #0]
		fs->wflag = 1;
 80070f6:	2301      	movs	r3, #1
 80070f8:	70e3      	strb	r3, [r4, #3]
				}
			}
			if (res == FR_OK) {
				res = dir_remove(&djo);		/* Remove old entry */
				if (res == FR_OK) {
					res = sync_fs(fs);
 80070fa:	9803      	ldr	r0, [sp, #12]
 80070fc:	f7fe fc57 	bl	80059ae <sync_fs>
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
 8007100:	b024      	add	sp, #144	; 0x90
 8007102:	bd70      	pop	{r4, r5, r6, pc}
		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
 8007104:	2006      	movs	r0, #6
 8007106:	e7fb      	b.n	8007100 <f_rename+0x108>
								res = FR_INT_ERR;
 8007108:	2002      	movs	r0, #2
 800710a:	e7f9      	b.n	8007100 <f_rename+0x108>

0800710c <f_utime>:

FRESULT f_utime (
	const TCHAR* path,	/* Pointer to the file/directory name */
	const FILINFO* fno	/* Pointer to the time stamp to be set */
)
{
 800710c:	b510      	push	{r4, lr}
 800710e:	b090      	sub	sp, #64	; 0x40
 8007110:	460c      	mov	r4, r1
 8007112:	9001      	str	r0, [sp, #4]
	DIR dj;
	FATFS *fs;
	DEF_NAMBUF


	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive */
 8007114:	2202      	movs	r2, #2
 8007116:	a902      	add	r1, sp, #8
 8007118:	a801      	add	r0, sp, #4
 800711a:	f7fe fcef 	bl	8005afc <find_volume>
	dj.obj.fs = fs;
 800711e:	9b02      	ldr	r3, [sp, #8]
 8007120:	9303      	str	r3, [sp, #12]
	if (res == FR_OK) {
 8007122:	b950      	cbnz	r0, 800713a <f_utime+0x2e>
		INIT_NAMBUF(fs);
		res = follow_path(&dj, path);	/* Follow the file path */
 8007124:	9901      	ldr	r1, [sp, #4]
 8007126:	a803      	add	r0, sp, #12
 8007128:	f7ff f856 	bl	80061d8 <follow_path>
		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
 800712c:	b928      	cbnz	r0, 800713a <f_utime+0x2e>
 800712e:	f89d 303b 	ldrb.w	r3, [sp, #59]	; 0x3b
 8007132:	f013 0fa0 	tst.w	r3, #160	; 0xa0
 8007136:	d002      	beq.n	800713e <f_utime+0x32>
 8007138:	2006      	movs	r0, #6
		}
		FREE_NAMBUF();
	}

	LEAVE_FF(fs, res);
}
 800713a:	b010      	add	sp, #64	; 0x40
 800713c:	bd10      	pop	{r4, pc}
				st_dword(dj.dir + DIR_ModTime, (DWORD)fno->fdate << 16 | fno->ftime);
 800713e:	88e3      	ldrh	r3, [r4, #6]
 8007140:	88a1      	ldrh	r1, [r4, #4]
 8007142:	980b      	ldr	r0, [sp, #44]	; 0x2c
 8007144:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 8007148:	3016      	adds	r0, #22
 800714a:	f7fe fa77 	bl	800563c <st_dword>
				fs->wflag = 1;
 800714e:	9802      	ldr	r0, [sp, #8]
 8007150:	2301      	movs	r3, #1
 8007152:	70c3      	strb	r3, [r0, #3]
				res = sync_fs(fs);
 8007154:	f7fe fc2b 	bl	80059ae <sync_fs>
	LEAVE_FF(fs, res);
 8007158:	e7ef      	b.n	800713a <f_utime+0x2e>

0800715a <f_gets>:
TCHAR* f_gets (
	TCHAR* buff,	/* Pointer to the string buffer to read */
	int len,		/* Size of string buffer (characters) */
	FIL* fp			/* Pointer to the file object */
)
{
 800715a:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 800715e:	4606      	mov	r6, r0
 8007160:	4690      	mov	r8, r2
	int n = 0;
	TCHAR c, *p = buff;
 8007162:	4605      	mov	r5, r0
	int n = 0;
 8007164:	2400      	movs	r4, #0
	BYTE s[2];
	UINT rc;


	while (n < len - 1) {	/* Read characters until buffer gets filled */
 8007166:	1e4f      	subs	r7, r1, #1
 8007168:	42bc      	cmp	r4, r7
 800716a:	da12      	bge.n	8007192 <f_gets+0x38>
		}
		c = ff_convert(c, 1);	/* OEM -> Unicode */
		if (!c) c = '?';
#endif
#else						/* Read a character without conversion */
		f_read(fp, s, 1, &rc);
 800716c:	ab01      	add	r3, sp, #4
 800716e:	2201      	movs	r2, #1
 8007170:	4669      	mov	r1, sp
 8007172:	4640      	mov	r0, r8
 8007174:	f7ff fa96 	bl	80066a4 <f_read>
		if (rc != 1) break;
 8007178:	9b01      	ldr	r3, [sp, #4]
 800717a:	2b01      	cmp	r3, #1
 800717c:	d109      	bne.n	8007192 <f_gets+0x38>
		c = s[0];
 800717e:	f89d 3000 	ldrb.w	r3, [sp]
#endif
		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
 8007182:	2b0d      	cmp	r3, #13
 8007184:	d0f0      	beq.n	8007168 <f_gets+0xe>
		*p++ = c;
		n++;
		if (c == '\n') break;		/* Break on EOL */
 8007186:	2b0a      	cmp	r3, #10
		*p++ = c;
 8007188:	f805 3b01 	strb.w	r3, [r5], #1
		n++;
 800718c:	f104 0401 	add.w	r4, r4, #1
		if (c == '\n') break;		/* Break on EOL */
 8007190:	d1ea      	bne.n	8007168 <f_gets+0xe>
	}
	*p = 0;
 8007192:	2300      	movs	r3, #0
	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
 8007194:	429c      	cmp	r4, r3
}
 8007196:	bf14      	ite	ne
 8007198:	4630      	movne	r0, r6
 800719a:	4618      	moveq	r0, r3
	*p = 0;
 800719c:	702b      	strb	r3, [r5, #0]
}
 800719e:	b002      	add	sp, #8
 80071a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080071a4 <FATFS_LinkDriverEx>:
  * @param  lun : only used for USB Key Disk to add multi-lun management
            else the parameter must be equal to 0
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriverEx(const Diskio_drvTypeDef *drv, char *path, uint8_t lun)
{
 80071a4:	b530      	push	{r4, r5, lr}
  uint8_t ret = 1;
  uint8_t DiskNum = 0;

  if(disk.nbr < _VOLUMES)
 80071a6:	4b0f      	ldr	r3, [pc, #60]	; (80071e4 <FATFS_LinkDriverEx+0x40>)
 80071a8:	7a5d      	ldrb	r5, [r3, #9]
 80071aa:	f005 04ff 	and.w	r4, r5, #255	; 0xff
 80071ae:	b9b5      	cbnz	r5, 80071de <FATFS_LinkDriverEx+0x3a>
  {
    disk.is_initialized[disk.nbr] = 0;
 80071b0:	7a5d      	ldrb	r5, [r3, #9]
 80071b2:	555c      	strb	r4, [r3, r5]
    disk.drv[disk.nbr] = drv;
 80071b4:	7a5d      	ldrb	r5, [r3, #9]
 80071b6:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 80071ba:	6068      	str	r0, [r5, #4]
    disk.lun[disk.nbr] = lun;
 80071bc:	7a58      	ldrb	r0, [r3, #9]
 80071be:	4418      	add	r0, r3
 80071c0:	7202      	strb	r2, [r0, #8]
    DiskNum = disk.nbr++;
 80071c2:	7a5a      	ldrb	r2, [r3, #9]
 80071c4:	b2d2      	uxtb	r2, r2
 80071c6:	1c50      	adds	r0, r2, #1
 80071c8:	b2c0      	uxtb	r0, r0
 80071ca:	7258      	strb	r0, [r3, #9]
    path[0] = DiskNum + '0';
    path[1] = ':';
 80071cc:	233a      	movs	r3, #58	; 0x3a
    path[0] = DiskNum + '0';
 80071ce:	3230      	adds	r2, #48	; 0x30
    path[1] = ':';
 80071d0:	704b      	strb	r3, [r1, #1]
    path[2] = '/';
 80071d2:	232f      	movs	r3, #47	; 0x2f
    path[0] = DiskNum + '0';
 80071d4:	700a      	strb	r2, [r1, #0]
    path[2] = '/';
 80071d6:	708b      	strb	r3, [r1, #2]
    path[3] = 0;
 80071d8:	70cc      	strb	r4, [r1, #3]
 80071da:	4620      	mov	r0, r4
 80071dc:	bd30      	pop	{r4, r5, pc}
  uint8_t ret = 1;
 80071de:	2001      	movs	r0, #1
    ret = 0;
  }

  return ret;
}
 80071e0:	bd30      	pop	{r4, r5, pc}
 80071e2:	bf00      	nop
 80071e4:	2000028c 	.word	0x2000028c

080071e8 <FATFS_LinkDriver>:
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_LinkDriver(const Diskio_drvTypeDef *drv, char *path)
{
  return FATFS_LinkDriverEx(drv, path, 0);
 80071e8:	2200      	movs	r2, #0
 80071ea:	f7ff bfdb 	b.w	80071a4 <FATFS_LinkDriverEx>
	...

080071f0 <FATFS_UnLinkDriverEx>:
uint8_t FATFS_UnLinkDriverEx(char *path, uint8_t lun)
{
  uint8_t DiskNum = 0;
  uint8_t ret = 1;

  if(disk.nbr >= 1)
 80071f0:	4a0a      	ldr	r2, [pc, #40]	; (800721c <FATFS_UnLinkDriverEx+0x2c>)
 80071f2:	7a53      	ldrb	r3, [r2, #9]
 80071f4:	b17b      	cbz	r3, 8007216 <FATFS_UnLinkDriverEx+0x26>
  {
    DiskNum = path[0] - '0';
 80071f6:	7803      	ldrb	r3, [r0, #0]
 80071f8:	3b30      	subs	r3, #48	; 0x30
    if(disk.drv[DiskNum] != 0)
 80071fa:	b2db      	uxtb	r3, r3
 80071fc:	eb02 0183 	add.w	r1, r2, r3, lsl #2
 8007200:	6848      	ldr	r0, [r1, #4]
 8007202:	b140      	cbz	r0, 8007216 <FATFS_UnLinkDriverEx+0x26>
    {
      disk.drv[DiskNum] = 0;
      disk.lun[DiskNum] = 0;
 8007204:	4413      	add	r3, r2
      disk.drv[DiskNum] = 0;
 8007206:	2000      	movs	r0, #0
      disk.lun[DiskNum] = 0;
 8007208:	7218      	strb	r0, [r3, #8]
      disk.nbr--;
 800720a:	7a53      	ldrb	r3, [r2, #9]
      disk.drv[DiskNum] = 0;
 800720c:	6048      	str	r0, [r1, #4]
      disk.nbr--;
 800720e:	3b01      	subs	r3, #1
 8007210:	b2db      	uxtb	r3, r3
 8007212:	7253      	strb	r3, [r2, #9]
 8007214:	4770      	bx	lr
  uint8_t ret = 1;
 8007216:	2001      	movs	r0, #1
      ret = 0;
    }
  }

  return ret;
}
 8007218:	4770      	bx	lr
 800721a:	bf00      	nop
 800721c:	2000028c 	.word	0x2000028c

08007220 <FATFS_UnLinkDriver>:
  * @param  path: pointer to the logical drive path
  * @retval Returns 0 in case of success, otherwise 1.
  */
uint8_t FATFS_UnLinkDriver(char *path)
{
  return FATFS_UnLinkDriverEx(path, 0);
 8007220:	2100      	movs	r1, #0
 8007222:	f7ff bfe5 	b.w	80071f0 <FATFS_UnLinkDriverEx>
	...

08007228 <Battery_GetLevel_Raw>:
	return vBatPercent;
}

/* Reads the ADC */
uint16_t Battery_GetLevel_Raw(void)
{
 8007228:	b530      	push	{r4, r5, lr}
 800722a:	b089      	sub	sp, #36	; 0x24
	__IO uint16_t adc_value = 0;
 800722c:	2300      	movs	r3, #0

	HAL_ADC_PollForConversion(&hadc1, 10);
 800722e:	210a      	movs	r1, #10
 8007230:	4818      	ldr	r0, [pc, #96]	; (8007294 <Battery_GetLevel_Raw+0x6c>)
	__IO uint16_t adc_value = 0;
 8007232:	f8ad 301e 	strh.w	r3, [sp, #30]
	HAL_ADC_PollForConversion(&hadc1, 10);
 8007236:	f7f9 ff35 	bl	80010a4 <HAL_ADC_PollForConversion>

	/* Check if the continuous conversion of regular channel is finished */
	if ((HAL_ADC_GetState(&hadc1) & HAL_ADC_STATE_REG_EOC)
 800723a:	4816      	ldr	r0, [pc, #88]	; (8007294 <Battery_GetLevel_Raw+0x6c>)
 800723c:	f7fa f974 	bl	8001528 <HAL_ADC_GetState>
 8007240:	f410 7400 	ands.w	r4, r0, #512	; 0x200
 8007244:	d00a      	beq.n	800725c <Battery_GetLevel_Raw+0x34>
			== HAL_ADC_STATE_REG_EOC)
	{
		/* Get the converted value of regular channel */
		adc_value = HAL_ADC_GetValue(&hadc1);
 8007246:	4813      	ldr	r0, [pc, #76]	; (8007294 <Battery_GetLevel_Raw+0x6c>)
 8007248:	f7f9 ff7a 	bl	8001140 <HAL_ADC_GetValue>
 800724c:	b280      	uxth	r0, r0
 800724e:	f8ad 001e 	strh.w	r0, [sp, #30]
				GetTempInfoStruct());
		
		ErrorAddLog(LOG_FUNC_BATTERY, LOG_SUB_DATA, LOG_TYPE_NONE, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
	}

	return adc_value;
 8007252:	f8bd 001e 	ldrh.w	r0, [sp, #30]
}
 8007256:	b280      	uxth	r0, r0
 8007258:	b009      	add	sp, #36	; 0x24
 800725a:	bd30      	pop	{r4, r5, pc}
		InfoLogAdd(
 800725c:	f001 ff26 	bl	80090ac <GetTempInfoStruct>
 8007260:	2511      	movs	r5, #17
 8007262:	462b      	mov	r3, r5
 8007264:	9004      	str	r0, [sp, #16]
 8007266:	2212      	movs	r2, #18
 8007268:	2113      	movs	r1, #19
 800726a:	9403      	str	r4, [sp, #12]
 800726c:	9402      	str	r4, [sp, #8]
 800726e:	9401      	str	r4, [sp, #4]
 8007270:	9500      	str	r5, [sp, #0]
 8007272:	2015      	movs	r0, #21
 8007274:	f005 f860 	bl	800c338 <InfoLogAdd>
		ErrorAddLog(LOG_FUNC_BATTERY, LOG_SUB_DATA, LOG_TYPE_NONE, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 8007278:	f001 ff10 	bl	800909c <GetErrorStruct>
 800727c:	9402      	str	r4, [sp, #8]
 800727e:	9003      	str	r0, [sp, #12]
 8007280:	9401      	str	r4, [sp, #4]
 8007282:	9400      	str	r4, [sp, #0]
 8007284:	462b      	mov	r3, r5
 8007286:	462a      	mov	r2, r5
 8007288:	2112      	movs	r1, #18
 800728a:	2013      	movs	r0, #19
 800728c:	f005 f804 	bl	800c298 <ErrorAddLog>
 8007290:	e7df      	b.n	8007252 <Battery_GetLevel_Raw+0x2a>
 8007292:	bf00      	nop
 8007294:	2000c42c 	.word	0x2000c42c

08007298 <Battery_GetLevel>:
{
 8007298:	b507      	push	{r0, r1, r2, lr}
	float bat_raw = (float) Battery_GetLevel_Raw();
 800729a:	f7ff ffc5 	bl	8007228 <Battery_GetLevel_Raw>
 800729e:	ee07 0a90 	vmov	s15, r0
 80072a2:	eeb8 7a67 	vcvt.f32.u32	s14, s15
	float milliV = bat_raw * ratioBat;
 80072a6:	eddf 7a13 	vldr	s15, [pc, #76]	; 80072f4 <Battery_GetLevel+0x5c>
	uint8_t vBatPercent = (100 * (milliV - ADCmin) / (ADCmax - ADCmin));
 80072aa:	ed9f 6a13 	vldr	s12, [pc, #76]	; 80072f8 <Battery_GetLevel+0x60>
 80072ae:	eddf 5a13 	vldr	s11, [pc, #76]	; 80072fc <Battery_GetLevel+0x64>
	float milliV = bat_raw * ratioBat;
 80072b2:	ee27 7a27 	vmul.f32	s14, s14, s15
	uint8_t vBatPercent = (100 * (milliV - ADCmin) / (ADCmax - ADCmin));
 80072b6:	eddf 7a12 	vldr	s15, [pc, #72]	; 8007300 <Battery_GetLevel+0x68>
 80072ba:	ee77 6a67 	vsub.f32	s13, s14, s15
 80072be:	ee66 6a86 	vmul.f32	s13, s13, s12
 80072c2:	ee86 6aa5 	vdiv.f32	s12, s13, s11
 80072c6:	eefc 6ac6 	vcvt.u32.f32	s13, s12
 80072ca:	edcd 6a01 	vstr	s13, [sp, #4]
 80072ce:	f89d 0004 	ldrb.w	r0, [sp, #4]
	if ((vBatPercent >= 100) && (milliV > ADCmin))
 80072d2:	2863      	cmp	r0, #99	; 0x63
 80072d4:	d905      	bls.n	80072e2 <Battery_GetLevel+0x4a>
		vBatPercent = 100;
 80072d6:	eeb4 7a67 	vcmp.f32	s14, s15
 80072da:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 80072de:	bfc8      	it	gt
 80072e0:	2064      	movgt	r0, #100	; 0x64
		vBatPercent = 0;
 80072e2:	eeb4 7a67 	vcmp.f32	s14, s15
 80072e6:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
}
 80072ea:	bf48      	it	mi
 80072ec:	2000      	movmi	r0, #0
 80072ee:	b003      	add	sp, #12
 80072f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80072f4:	3f3b8bb9 	.word	0x3f3b8bb9
 80072f8:	42c80000 	.word	0x42c80000
 80072fc:	44058000 	.word	0x44058000
 8007300:	450da000 	.word	0x450da000

08007304 <Battery_init>:

/*
 * Initialization of the adc.
 */
void Battery_init(void)
{
 8007304:	b530      	push	{r4, r5, lr}
	DisEnableBatteryPin(1);
 8007306:	2001      	movs	r0, #1
{
 8007308:	b087      	sub	sp, #28
	DisEnableBatteryPin(1);
 800730a:	f002 fd57 	bl	8009dbc <DisEnableBatteryPin>

	if (HAL_ADCEx_Calibration_Start(&hadc1, ADC_SINGLE_ENDED) != HAL_OK)
 800730e:	217f      	movs	r1, #127	; 0x7f
 8007310:	481e      	ldr	r0, [pc, #120]	; (800738c <Battery_init+0x88>)
 8007312:	f7fa fad7 	bl	80018c4 <HAL_ADCEx_Calibration_Start>
 8007316:	4604      	mov	r4, r0
 8007318:	b1e0      	cbz	r0, 8007354 <Battery_init+0x50>
	{
		InfoLogAdd(
 800731a:	f001 fec7 	bl	80090ac <GetTempInfoStruct>
 800731e:	2400      	movs	r4, #0
 8007320:	2511      	movs	r5, #17
 8007322:	2324      	movs	r3, #36	; 0x24
 8007324:	2227      	movs	r2, #39	; 0x27
 8007326:	9004      	str	r0, [sp, #16]
 8007328:	2113      	movs	r1, #19
 800732a:	2015      	movs	r0, #21
 800732c:	9403      	str	r4, [sp, #12]
 800732e:	9402      	str	r4, [sp, #8]
 8007330:	9401      	str	r4, [sp, #4]
 8007332:	9500      	str	r5, [sp, #0]
 8007334:	f005 f800 	bl	800c338 <InfoLogAdd>
				0,
				0,
				0,
				GetTempInfoStruct());

		ErrorAddLog(LOG_FUNC_BATTERY, LOG_SUB_INIT, LOG_TYPE_CALIBRATION, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 8007338:	f001 feb0 	bl	800909c <GetErrorStruct>
 800733c:	9402      	str	r4, [sp, #8]
 800733e:	9003      	str	r0, [sp, #12]
 8007340:	9401      	str	r4, [sp, #4]
 8007342:	9400      	str	r4, [sp, #0]
 8007344:	462b      	mov	r3, r5
 8007346:	2224      	movs	r2, #36	; 0x24
					0,
					0,
					0,
					GetTempInfoStruct());

			ErrorAddLog(LOG_FUNC_BATTERY, LOG_SUB_INIT, LOG_TYPE_START, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 8007348:	2127      	movs	r1, #39	; 0x27
 800734a:	2013      	movs	r0, #19
 800734c:	f004 ffa4 	bl	800c298 <ErrorAddLog>
		}
	}
}
 8007350:	b007      	add	sp, #28
 8007352:	bd30      	pop	{r4, r5, pc}
		if (HAL_ADC_Start(&hadc1) != HAL_OK)
 8007354:	480d      	ldr	r0, [pc, #52]	; (800738c <Battery_init+0x88>)
 8007356:	f7fa f995 	bl	8001684 <HAL_ADC_Start>
 800735a:	2800      	cmp	r0, #0
 800735c:	d0f8      	beq.n	8007350 <Battery_init+0x4c>
			InfoLogAdd(
 800735e:	f001 fea5 	bl	80090ac <GetTempInfoStruct>
 8007362:	2511      	movs	r5, #17
 8007364:	2316      	movs	r3, #22
 8007366:	2227      	movs	r2, #39	; 0x27
 8007368:	9004      	str	r0, [sp, #16]
 800736a:	2113      	movs	r1, #19
 800736c:	2015      	movs	r0, #21
 800736e:	9403      	str	r4, [sp, #12]
 8007370:	9402      	str	r4, [sp, #8]
 8007372:	9401      	str	r4, [sp, #4]
 8007374:	9500      	str	r5, [sp, #0]
 8007376:	f004 ffdf 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(LOG_FUNC_BATTERY, LOG_SUB_INIT, LOG_TYPE_START, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 800737a:	f001 fe8f 	bl	800909c <GetErrorStruct>
 800737e:	9402      	str	r4, [sp, #8]
 8007380:	9003      	str	r0, [sp, #12]
 8007382:	9401      	str	r4, [sp, #4]
 8007384:	9400      	str	r4, [sp, #0]
 8007386:	462b      	mov	r3, r5
 8007388:	2216      	movs	r2, #22
 800738a:	e7dd      	b.n	8007348 <Battery_init+0x44>
 800738c:	2000c42c 	.word	0x2000c42c

08007390 <MX_ADC_DeInit>:

void MX_ADC_DeInit(void)
{
	HAL_ADC_DeInit(&hadc1);
 8007390:	4801      	ldr	r0, [pc, #4]	; (8007398 <MX_ADC_DeInit+0x8>)
 8007392:	f7fa b9f7 	b.w	8001784 <HAL_ADC_DeInit>
 8007396:	bf00      	nop
 8007398:	2000c42c 	.word	0x2000c42c

0800739c <SD_Write.part.4>:


/*
 *	Writes data to SD to file 'filename' from address 'ram_address' to address 'ram_address' + 'size'.
 */
uint8_t SD_Write(FIL userfile, char* filename, uint32_t ram_address, uint32_t size)
 800739c:	b530      	push	{r4, r5, lr}
 800739e:	b089      	sub	sp, #36	; 0x24
		LOG_STATUS_FAIL, 1, 0, 0, GetTempInfoStruct());
	}
	else
	{
		/* Writes the data */
		if (f_write(&SDFile, (uint32_t*) ram_address, size, (void *) &byteswritten) != FR_OK)
 80073a0:	460a      	mov	r2, r1
 80073a2:	ab07      	add	r3, sp, #28
 80073a4:	4601      	mov	r1, r0
 80073a6:	4814      	ldr	r0, [pc, #80]	; (80073f8 <SD_Write.part.4+0x5c>)
 80073a8:	f7ff fa29 	bl	80067fe <f_write>
 80073ac:	2500      	movs	r5, #0
 80073ae:	4604      	mov	r4, r0
 80073b0:	b1e8      	cbz	r0, 80073ee <SD_Write.part.4+0x52>
		{
			ErrorAddLog(
 80073b2:	f001 fe73 	bl	800909c <GetErrorStruct>
 80073b6:	2401      	movs	r4, #1
 80073b8:	2215      	movs	r2, #21
 80073ba:	2311      	movs	r3, #17
 80073bc:	2117      	movs	r1, #23
 80073be:	9003      	str	r0, [sp, #12]
 80073c0:	9502      	str	r5, [sp, #8]
 80073c2:	4610      	mov	r0, r2
 80073c4:	9501      	str	r5, [sp, #4]
 80073c6:	9400      	str	r4, [sp, #0]
 80073c8:	f004 ff66 	bl	800c298 <ErrorAddLog>
					1,
					0,
					0,
					GetErrorStruct());

			InfoLogAdd(ERRORLEVEL_WARNING,
 80073cc:	f001 fe6e 	bl	80090ac <GetTempInfoStruct>
 80073d0:	2311      	movs	r3, #17
 80073d2:	9300      	str	r3, [sp, #0]
 80073d4:	2315      	movs	r3, #21
 80073d6:	9004      	str	r0, [sp, #16]
 80073d8:	9503      	str	r5, [sp, #12]
 80073da:	9502      	str	r5, [sp, #8]
 80073dc:	9401      	str	r4, [sp, #4]
 80073de:	2217      	movs	r2, #23
 80073e0:	4619      	mov	r1, r3
 80073e2:	2014      	movs	r0, #20
 80073e4:	f004 ffa8 	bl	800c338 <InfoLogAdd>
//		}
		/* Critical to close the file. Else the data will be corrupted. */
		f_close(&SDFile);
	}

	return HAL_OK;
 80073e8:	4620      	mov	r0, r4
}
 80073ea:	b009      	add	sp, #36	; 0x24
 80073ec:	bd30      	pop	{r4, r5, pc}
		f_close(&SDFile);
 80073ee:	4802      	ldr	r0, [pc, #8]	; (80073f8 <SD_Write.part.4+0x5c>)
 80073f0:	f7ff fb12 	bl	8006a18 <f_close>
 80073f4:	e7f8      	b.n	80073e8 <SD_Write.part.4+0x4c>
 80073f6:	bf00      	nop
 80073f8:	200003dc 	.word	0x200003dc

080073fc <SD_Init>:
{
 80073fc:	b530      	push	{r4, r5, lr}
 80073fe:	b087      	sub	sp, #28
	BSP_SD_Init();
 8007400:	f000 fd04 	bl	8007e0c <BSP_SD_Init>
	FRESULT res = f_mount(&SDFatFS, (TCHAR const*) SDPath, 1);
 8007404:	2201      	movs	r2, #1
 8007406:	4915      	ldr	r1, [pc, #84]	; (800745c <SD_Init+0x60>)
 8007408:	4815      	ldr	r0, [pc, #84]	; (8007460 <SD_Init+0x64>)
 800740a:	f7ff f805 	bl	8006418 <f_mount>
	printf("Mount result = %d\n\r", res);
 800740e:	4601      	mov	r1, r0
	FRESULT res = f_mount(&SDFatFS, (TCHAR const*) SDPath, 1);
 8007410:	4604      	mov	r4, r0
	printf("Mount result = %d\n\r", res);
 8007412:	4814      	ldr	r0, [pc, #80]	; (8007464 <SD_Init+0x68>)
 8007414:	f005 ff82 	bl	800d31c <iprintf>
 8007418:	2500      	movs	r5, #0
	if (res != FR_OK)
 800741a:	b1e4      	cbz	r4, 8007456 <SD_Init+0x5a>
		ErrorAddLog(
 800741c:	f001 fe3e 	bl	800909c <GetErrorStruct>
 8007420:	2311      	movs	r3, #17
 8007422:	2223      	movs	r2, #35	; 0x23
 8007424:	2127      	movs	r1, #39	; 0x27
 8007426:	9003      	str	r0, [sp, #12]
 8007428:	9502      	str	r5, [sp, #8]
 800742a:	2015      	movs	r0, #21
 800742c:	9501      	str	r5, [sp, #4]
 800742e:	9500      	str	r5, [sp, #0]
 8007430:	f004 ff32 	bl	800c298 <ErrorAddLog>
		InfoLogAdd(ERRORLEVEL_WARNING,
 8007434:	f001 fe3a 	bl	80090ac <GetTempInfoStruct>
 8007438:	2311      	movs	r3, #17
 800743a:	9004      	str	r0, [sp, #16]
 800743c:	9300      	str	r3, [sp, #0]
 800743e:	2014      	movs	r0, #20
 8007440:	9503      	str	r5, [sp, #12]
 8007442:	9502      	str	r5, [sp, #8]
 8007444:	9501      	str	r5, [sp, #4]
 8007446:	2323      	movs	r3, #35	; 0x23
 8007448:	2227      	movs	r2, #39	; 0x27
 800744a:	2115      	movs	r1, #21
 800744c:	f004 ff74 	bl	800c338 <InfoLogAdd>
 8007450:	2001      	movs	r0, #1
}
 8007452:	b007      	add	sp, #28
 8007454:	bd30      	pop	{r4, r5, pc}
	return HAL_OK;
 8007456:	4620      	mov	r0, r4
 8007458:	e7fb      	b.n	8007452 <SD_Init+0x56>
 800745a:	bf00      	nop
 800745c:	200003d5 	.word	0x200003d5
 8007460:	2000060c 	.word	0x2000060c
 8007464:	0800f74a 	.word	0x0800f74a

08007468 <InitFoldersSD>:
{
 8007468:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	SD_Init();
 800746a:	f7ff ffc7 	bl	80073fc <SD_Init>
	if (f_stat(TRANSMIT_PATH, &fno) == FR_NO_FILE)
 800746e:	4669      	mov	r1, sp
 8007470:	480e      	ldr	r0, [pc, #56]	; (80074ac <InitFoldersSD+0x44>)
 8007472:	f7ff fc9e 	bl	8006db2 <f_stat>
 8007476:	2804      	cmp	r0, #4
 8007478:	d102      	bne.n	8007480 <InitFoldersSD+0x18>
		f_mkdir(TRANSMIT_PATH);
 800747a:	480c      	ldr	r0, [pc, #48]	; (80074ac <InitFoldersSD+0x44>)
 800747c:	f7ff fd0d 	bl	8006e9a <f_mkdir>
	if (f_stat(ERROR_PATH, &fno) == FR_NO_FILE)
 8007480:	4669      	mov	r1, sp
 8007482:	480b      	ldr	r0, [pc, #44]	; (80074b0 <InitFoldersSD+0x48>)
 8007484:	f7ff fc95 	bl	8006db2 <f_stat>
 8007488:	2804      	cmp	r0, #4
 800748a:	d102      	bne.n	8007492 <InitFoldersSD+0x2a>
		f_mkdir(ERROR_PATH);
 800748c:	4808      	ldr	r0, [pc, #32]	; (80074b0 <InitFoldersSD+0x48>)
 800748e:	f7ff fd04 	bl	8006e9a <f_mkdir>
	if (f_stat(INFO_PATH, &fno) == FR_NO_FILE)
 8007492:	4669      	mov	r1, sp
 8007494:	4807      	ldr	r0, [pc, #28]	; (80074b4 <InitFoldersSD+0x4c>)
 8007496:	f7ff fc8c 	bl	8006db2 <f_stat>
 800749a:	2804      	cmp	r0, #4
 800749c:	d102      	bne.n	80074a4 <InitFoldersSD+0x3c>
		f_mkdir(INFO_PATH);
 800749e:	4805      	ldr	r0, [pc, #20]	; (80074b4 <InitFoldersSD+0x4c>)
 80074a0:	f7ff fcfb 	bl	8006e9a <f_mkdir>
}
 80074a4:	b007      	add	sp, #28
 80074a6:	f85d fb04 	ldr.w	pc, [sp], #4
 80074aa:	bf00      	nop
 80074ac:	0800f6e2 	.word	0x0800f6e2
 80074b0:	0800f6eb 	.word	0x0800f6eb
 80074b4:	0800f6f1 	.word	0x0800f6f1

080074b8 <SD_Verify>:
{
 80074b8:	b084      	sub	sp, #16
 80074ba:	e92d 46f0 	stmdb	sp!, {r4, r5, r6, r7, r9, sl, lr}
 80074be:	b0c7      	sub	sp, #284	; 0x11c
 80074c0:	ac4e      	add	r4, sp, #312	; 0x138
 80074c2:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	uint32_t temp_bytesread = 0;
 80074c6:	2300      	movs	r3, #0
{
 80074c8:	9fdc      	ldr	r7, [sp, #880]	; 0x370
	uint32_t temp_bytesread = 0;
 80074ca:	9305      	str	r3, [sp, #20]
	if (SD_Init() != HAL_OK)
 80074cc:	f7ff ff96 	bl	80073fc <SD_Init>
 80074d0:	4604      	mov	r4, r0
 80074d2:	b988      	cbnz	r0, 80074f8 <SD_Verify+0x40>
		if (f_open(&SDFile, filename, FA_READ) != FR_OK)
 80074d4:	2201      	movs	r2, #1
 80074d6:	99da      	ldr	r1, [sp, #872]	; 0x368
 80074d8:	482d      	ldr	r0, [pc, #180]	; (8007590 <SD_Verify+0xd8>)
 80074da:	f7fe ffd1 	bl	8006480 <f_open>
 80074de:	b168      	cbz	r0, 80074fc <SD_Verify+0x44>
			ErrorAddLog(
 80074e0:	f001 fddc 	bl	800909c <GetErrorStruct>
 80074e4:	9402      	str	r4, [sp, #8]
 80074e6:	9003      	str	r0, [sp, #12]
 80074e8:	9401      	str	r4, [sp, #4]
 80074ea:	9400      	str	r4, [sp, #0]
 80074ec:	2311      	movs	r3, #17
 80074ee:	2218      	movs	r2, #24
						ErrorAddLog(
 80074f0:	2115      	movs	r1, #21
 80074f2:	4608      	mov	r0, r1
 80074f4:	f004 fed0 	bl	800c298 <ErrorAddLog>
		return HAL_ERROR;
 80074f8:	2401      	movs	r4, #1
 80074fa:	e01b      	b.n	8007534 <SD_Verify+0x7c>
			if (f_lseek(&SDFile, f_size(&userfile) - size) != FR_OK)
 80074fc:	9951      	ldr	r1, [sp, #324]	; 0x144
 80074fe:	4824      	ldr	r0, [pc, #144]	; (8007590 <SD_Verify+0xd8>)
 8007500:	1bc9      	subs	r1, r1, r7
 8007502:	f7ff fa9a 	bl	8006a3a <f_lseek>
 8007506:	b940      	cbnz	r0, 800751a <SD_Verify+0x62>
					if (f_read(
 8007508:	f8df a084 	ldr.w	sl, [pc, #132]	; 8007590 <SD_Verify+0xd8>
 800750c:	4625      	mov	r5, r4
				for (total_bytesread = 0; total_bytesread < size; total_bytesread += temp_bytesread)
 800750e:	42bd      	cmp	r5, r7
 8007510:	d316      	bcc.n	8007540 <SD_Verify+0x88>
			f_close(&SDFile);
 8007512:	481f      	ldr	r0, [pc, #124]	; (8007590 <SD_Verify+0xd8>)
 8007514:	f7ff fa80 	bl	8006a18 <f_close>
	return HAL_OK;
 8007518:	e00c      	b.n	8007534 <SD_Verify+0x7c>
				ErrorAddLog(
 800751a:	f001 fdbf 	bl	800909c <GetErrorStruct>
 800751e:	9402      	str	r4, [sp, #8]
 8007520:	9401      	str	r4, [sp, #4]
 8007522:	2401      	movs	r4, #1
 8007524:	9003      	str	r0, [sp, #12]
 8007526:	9400      	str	r4, [sp, #0]
 8007528:	2311      	movs	r3, #17
 800752a:	2219      	movs	r2, #25
							ErrorAddLog(
 800752c:	2126      	movs	r1, #38	; 0x26
 800752e:	2015      	movs	r0, #21
 8007530:	f004 feb2 	bl	800c298 <ErrorAddLog>
}
 8007534:	4620      	mov	r0, r4
 8007536:	b047      	add	sp, #284	; 0x11c
 8007538:	e8bd 46f0 	ldmia.w	sp!, {r4, r5, r6, r7, r9, sl, lr}
 800753c:	b004      	add	sp, #16
 800753e:	4770      	bx	lr
					if (f_read(
 8007540:	ab05      	add	r3, sp, #20
 8007542:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007546:	a906      	add	r1, sp, #24
 8007548:	4650      	mov	r0, sl
 800754a:	f7ff f8ab 	bl	80066a4 <f_read>
 800754e:	4606      	mov	r6, r0
 8007550:	b148      	cbz	r0, 8007566 <SD_Verify+0xae>
						ErrorAddLog(
 8007552:	f001 fda3 	bl	800909c <GetErrorStruct>
 8007556:	2300      	movs	r3, #0
 8007558:	9302      	str	r3, [sp, #8]
 800755a:	9301      	str	r3, [sp, #4]
 800755c:	9300      	str	r3, [sp, #0]
 800755e:	9003      	str	r0, [sp, #12]
 8007560:	2311      	movs	r3, #17
 8007562:	2214      	movs	r2, #20
 8007564:	e7c4      	b.n	80074f0 <SD_Verify+0x38>
						if (memcmp(
 8007566:	f8dd 9014 	ldr.w	r9, [sp, #20]
 800756a:	9bdb      	ldr	r3, [sp, #876]	; 0x36c
 800756c:	464a      	mov	r2, r9
 800756e:	18e9      	adds	r1, r5, r3
 8007570:	a806      	add	r0, sp, #24
 8007572:	f005 fba9 	bl	800ccc8 <memcmp>
 8007576:	b148      	cbz	r0, 800758c <SD_Verify+0xd4>
							ErrorAddLog(
 8007578:	f001 fd90 	bl	800909c <GetErrorStruct>
 800757c:	2401      	movs	r4, #1
 800757e:	9003      	str	r0, [sp, #12]
 8007580:	9602      	str	r6, [sp, #8]
 8007582:	9601      	str	r6, [sp, #4]
 8007584:	9400      	str	r4, [sp, #0]
 8007586:	2311      	movs	r3, #17
 8007588:	2225      	movs	r2, #37	; 0x25
 800758a:	e7cf      	b.n	800752c <SD_Verify+0x74>
				for (total_bytesread = 0; total_bytesread < size; total_bytesread += temp_bytesread)
 800758c:	444d      	add	r5, r9
 800758e:	e7be      	b.n	800750e <SD_Verify+0x56>
 8007590:	200003dc 	.word	0x200003dc

08007594 <SD_DeInit>:
{
 8007594:	b508      	push	{r3, lr}
	f_mount(NULL, "", 0);
 8007596:	2200      	movs	r2, #0
 8007598:	4904      	ldr	r1, [pc, #16]	; (80075ac <SD_DeInit+0x18>)
 800759a:	4610      	mov	r0, r2
 800759c:	f7fe ff3c 	bl	8006418 <f_mount>
	FATFS_UnLinkDriver(SDPath);
 80075a0:	4803      	ldr	r0, [pc, #12]	; (80075b0 <SD_DeInit+0x1c>)
}
 80075a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	FATFS_UnLinkDriver(SDPath);
 80075a6:	f7ff be3b 	b.w	8007220 <FATFS_UnLinkDriver>
 80075aa:	bf00      	nop
 80075ac:	0800f701 	.word	0x0800f701
 80075b0:	200003d5 	.word	0x200003d5

080075b4 <SD_set_timestamp>:
{
 80075b4:	b510      	push	{r4, lr}
 80075b6:	b090      	sub	sp, #64	; 0x40
 80075b8:	4604      	mov	r4, r0
	HAL_RTC_GetTime(&hrtc, &timeStruct, RTC_FORMAT_BIN);
 80075ba:	2200      	movs	r2, #0
 80075bc:	a905      	add	r1, sp, #20
 80075be:	481b      	ldr	r0, [pc, #108]	; (800762c <SD_set_timestamp+0x78>)
 80075c0:	f7fc fb73 	bl	8003caa <HAL_RTC_GetTime>
	HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BIN);
 80075c4:	2200      	movs	r2, #0
 80075c6:	a904      	add	r1, sp, #16
 80075c8:	4818      	ldr	r0, [pc, #96]	; (800762c <SD_set_timestamp+0x78>)
 80075ca:	f7fc fb96 	bl	8003cfa <HAL_RTC_GetDate>
	fileinfo.fdate = (WORD) (((sDate.Year + 20) * 512U) | sDate.Month * 32U | sDate.Date);
 80075ce:	f89d 2011 	ldrb.w	r2, [sp, #17]
 80075d2:	f89d 3012 	ldrb.w	r3, [sp, #18]
 80075d6:	ea43 1342 	orr.w	r3, r3, r2, lsl #5
 80075da:	f89d 2013 	ldrb.w	r2, [sp, #19]
 80075de:	3214      	adds	r2, #20
 80075e0:	ea43 2342 	orr.w	r3, r3, r2, lsl #9
 80075e4:	f8ad 302c 	strh.w	r3, [sp, #44]	; 0x2c
	fileinfo.ftime = (WORD) (timeStruct.Hours * 2048U | timeStruct.Minutes * 32U
 80075e8:	f89d 3015 	ldrb.w	r3, [sp, #21]
 80075ec:	f89d 2014 	ldrb.w	r2, [sp, #20]
 80075f0:	015b      	lsls	r3, r3, #5
 80075f2:	ea43 23c2 	orr.w	r3, r3, r2, lsl #11
 80075f6:	f89d 2016 	ldrb.w	r2, [sp, #22]
	if (f_utime(filename, &fileinfo) != FR_OK)
 80075fa:	4620      	mov	r0, r4
	fileinfo.ftime = (WORD) (timeStruct.Hours * 2048U | timeStruct.Minutes * 32U
 80075fc:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
	if (f_utime(filename, &fileinfo) != FR_OK)
 8007600:	a90a      	add	r1, sp, #40	; 0x28
	fileinfo.ftime = (WORD) (timeStruct.Hours * 2048U | timeStruct.Minutes * 32U
 8007602:	f8ad 302e 	strh.w	r3, [sp, #46]	; 0x2e
	if (f_utime(filename, &fileinfo) != FR_OK)
 8007606:	f7ff fd81 	bl	800710c <f_utime>
 800760a:	2400      	movs	r4, #0
 800760c:	b160      	cbz	r0, 8007628 <SD_set_timestamp+0x74>
		ErrorAddLog(LOG_FUNC_SD, LOG_SUB_WRITE, LOG_TYPE_TIMESTAMP,
 800760e:	f001 fd45 	bl	800909c <GetErrorStruct>
 8007612:	9402      	str	r4, [sp, #8]
 8007614:	9003      	str	r0, [sp, #12]
 8007616:	9401      	str	r4, [sp, #4]
 8007618:	2015      	movs	r0, #21
 800761a:	9400      	str	r4, [sp, #0]
 800761c:	2311      	movs	r3, #17
 800761e:	221a      	movs	r2, #26
 8007620:	2117      	movs	r1, #23
 8007622:	f004 fe39 	bl	800c298 <ErrorAddLog>
 8007626:	2001      	movs	r0, #1
}
 8007628:	b010      	add	sp, #64	; 0x40
 800762a:	bd10      	pop	{r4, pc}
 800762c:	2000c59c 	.word	0x2000c59c

08007630 <SD_DoFileExist>:
{
 8007630:	b51f      	push	{r0, r1, r2, r3, r4, lr}
 8007632:	4614      	mov	r4, r2
	sprintf(temp_fileName, filename, fileID);
 8007634:	4602      	mov	r2, r0
 8007636:	4668      	mov	r0, sp
 8007638:	f005 ff10 	bl	800d45c <siprintf>
	if (f_stat(temp_fileName, fno) == FR_NO_FILE)
 800763c:	4621      	mov	r1, r4
 800763e:	4668      	mov	r0, sp
 8007640:	f7ff fbb7 	bl	8006db2 <f_stat>
}
 8007644:	3804      	subs	r0, #4
 8007646:	bf18      	it	ne
 8007648:	2001      	movne	r0, #1
 800764a:	b004      	add	sp, #16
 800764c:	bd10      	pop	{r4, pc}

0800764e <SD_getNumFiles>:
{
 800764e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8007650:	4605      	mov	r5, r0
 8007652:	460e      	mov	r6, r1
	for (i = 1; i < SD_MAX_FILE_ID; i++)
 8007654:	2401      	movs	r4, #1
		if (SD_DoFileExist(i, filename, fno) == 0)
 8007656:	4632      	mov	r2, r6
 8007658:	4629      	mov	r1, r5
 800765a:	4620      	mov	r0, r4
 800765c:	f7ff ffe8 	bl	8007630 <SD_DoFileExist>
 8007660:	b930      	cbnz	r0, 8007670 <SD_getNumFiles+0x22>
			if (i == 1)
 8007662:	2c01      	cmp	r4, #1
 8007664:	d001      	beq.n	800766a <SD_getNumFiles+0x1c>
				return i - 1;
 8007666:	3c01      	subs	r4, #1
 8007668:	b2e4      	uxtb	r4, r4
}
 800766a:	4620      	mov	r0, r4
 800766c:	b004      	add	sp, #16
 800766e:	bd70      	pop	{r4, r5, r6, pc}
	for (i = 1; i < SD_MAX_FILE_ID; i++)
 8007670:	3401      	adds	r4, #1
 8007672:	b2e4      	uxtb	r4, r4
 8007674:	2c63      	cmp	r4, #99	; 0x63
 8007676:	d1ee      	bne.n	8007656 <SD_getNumFiles+0x8>
	ErrorAddLog(
 8007678:	f001 fd10 	bl	800909c <GetErrorStruct>
 800767c:	2300      	movs	r3, #0
 800767e:	9302      	str	r3, [sp, #8]
 8007680:	9301      	str	r3, [sp, #4]
 8007682:	2311      	movs	r3, #17
 8007684:	9003      	str	r0, [sp, #12]
 8007686:	9400      	str	r4, [sp, #0]
 8007688:	461a      	mov	r2, r3
 800768a:	211a      	movs	r1, #26
 800768c:	2015      	movs	r0, #21
 800768e:	f004 fe03 	bl	800c298 <ErrorAddLog>
	return SD_MAX_FILE_ID;
 8007692:	e7ea      	b.n	800766a <SD_getNumFiles+0x1c>

08007694 <SD_getFileName>:
{
 8007694:	b530      	push	{r4, r5, lr}
 8007696:	b087      	sub	sp, #28
 8007698:	460d      	mov	r5, r1
	uint8_t numFiles = SD_getNumFiles(filename, &fileinfo);
 800769a:	4669      	mov	r1, sp
{
 800769c:	4604      	mov	r4, r0
	uint8_t numFiles = SD_getNumFiles(filename, &fileinfo);
 800769e:	f7ff ffd6 	bl	800764e <SD_getNumFiles>
	if (numFiles == SD_MAX_FILE_ID)
 80076a2:	2863      	cmp	r0, #99	; 0x63
	uint8_t numFiles = SD_getNumFiles(filename, &fileinfo);
 80076a4:	4602      	mov	r2, r0
	if (numFiles == SD_MAX_FILE_ID)
 80076a6:	d105      	bne.n	80076b4 <SD_getFileName+0x20>
		printf("getFilename error\r\n");
 80076a8:	4808      	ldr	r0, [pc, #32]	; (80076cc <SD_getFileName+0x38>)
 80076aa:	f005 febf 	bl	800d42c <puts>
		return HAL_ERROR;
 80076ae:	2001      	movs	r0, #1
}
 80076b0:	b007      	add	sp, #28
 80076b2:	bd30      	pop	{r4, r5, pc}
		if (fileinfo.fsize >= maxFileSize)
 80076b4:	9b00      	ldr	r3, [sp, #0]
		sprintf(sd_fileName, filename, numFiles);
 80076b6:	4806      	ldr	r0, [pc, #24]	; (80076d0 <SD_getFileName+0x3c>)
		if (fileinfo.fsize >= maxFileSize)
 80076b8:	42ab      	cmp	r3, r5
			numFiles = numFiles + 1;
 80076ba:	bf24      	itt	cs
 80076bc:	3201      	addcs	r2, #1
 80076be:	b2d2      	uxtbcs	r2, r2
		sprintf(sd_fileName, filename, numFiles);
 80076c0:	4621      	mov	r1, r4
 80076c2:	f005 fecb 	bl	800d45c <siprintf>
	return HAL_OK;
 80076c6:	2000      	movs	r0, #0
 80076c8:	e7f2      	b.n	80076b0 <SD_getFileName+0x1c>
 80076ca:	bf00      	nop
 80076cc:	0800f76f 	.word	0x0800f76f
 80076d0:	2000c0fa 	.word	0x2000c0fa

080076d4 <ArchivePATHFile>:
{
 80076d4:	b530      	push	{r4, r5, lr}
 80076d6:	b089      	sub	sp, #36	; 0x24
 80076d8:	4604      	mov	r4, r0
 80076da:	460d      	mov	r5, r1
	char archivePath[32] = { 0 };
 80076dc:	2220      	movs	r2, #32
 80076de:	2100      	movs	r1, #0
 80076e0:	4668      	mov	r0, sp
 80076e2:	f005 fb0b 	bl	800ccfc <memset>
	sprintf(archivePath, "%s/%s", PATH, fname);
 80076e6:	4623      	mov	r3, r4
 80076e8:	462a      	mov	r2, r5
 80076ea:	490f      	ldr	r1, [pc, #60]	; (8007728 <ArchivePATHFile+0x54>)
 80076ec:	4668      	mov	r0, sp
 80076ee:	f005 feb5 	bl	800d45c <siprintf>
	res = f_rename(fname, archivePath);
 80076f2:	4669      	mov	r1, sp
 80076f4:	4620      	mov	r0, r4
 80076f6:	f7ff fc7f 	bl	8006ff8 <f_rename>
	if (res == FR_EXIST)
 80076fa:	2808      	cmp	r0, #8
	res = f_rename(fname, archivePath);
 80076fc:	4601      	mov	r1, r0
	if (res == FR_EXIST)
 80076fe:	d107      	bne.n	8007710 <ArchivePATHFile+0x3c>
		printf("File already in archive folder, delete current one in root\n\r");
 8007700:	480a      	ldr	r0, [pc, #40]	; (800772c <ArchivePATHFile+0x58>)
 8007702:	f005 fe0b 	bl	800d31c <iprintf>
		f_unlink(fname);
 8007706:	4620      	mov	r0, r4
 8007708:	f7ff fb75 	bl	8006df6 <f_unlink>
}
 800770c:	b009      	add	sp, #36	; 0x24
 800770e:	bd30      	pop	{r4, r5, pc}
	else if (res == FR_OK)
 8007710:	b928      	cbnz	r0, 800771e <ArchivePATHFile+0x4a>
		printf("Programmed File %s moved to %s\n\r", fname, archivePath);
 8007712:	466a      	mov	r2, sp
 8007714:	4621      	mov	r1, r4
 8007716:	4806      	ldr	r0, [pc, #24]	; (8007730 <ArchivePATHFile+0x5c>)
 8007718:	f005 fe00 	bl	800d31c <iprintf>
 800771c:	e7f6      	b.n	800770c <ArchivePATHFile+0x38>
		printf("res = %d\r\n", res);
 800771e:	4805      	ldr	r0, [pc, #20]	; (8007734 <ArchivePATHFile+0x60>)
 8007720:	f005 fdfc 	bl	800d31c <iprintf>
}
 8007724:	e7f2      	b.n	800770c <ArchivePATHFile+0x38>
 8007726:	bf00      	nop
 8007728:	0800f634 	.word	0x0800f634
 800772c:	0800f63a 	.word	0x0800f63a
 8007730:	0800f677 	.word	0x0800f677
 8007734:	0800f698 	.word	0x0800f698

08007738 <FindFile>:
{
 8007738:	b510      	push	{r4, lr}
 800773a:	b094      	sub	sp, #80	; 0x50
	fr = f_findfirst(&dj, &fno, "", "*-*.txt");
 800773c:	4b0e      	ldr	r3, [pc, #56]	; (8007778 <FindFile+0x40>)
 800773e:	4a0f      	ldr	r2, [pc, #60]	; (800777c <FindFile+0x44>)
 8007740:	a901      	add	r1, sp, #4
 8007742:	a807      	add	r0, sp, #28
 8007744:	f7ff fb26 	bl	8006d94 <f_findfirst>
	if (fr == FR_OK && fno.fname[0])
 8007748:	b9a0      	cbnz	r0, 8007774 <FindFile+0x3c>
 800774a:	f89d 400d 	ldrb.w	r4, [sp, #13]
 800774e:	b144      	cbz	r4, 8007762 <FindFile+0x2a>
		printf("FiLE: %s\r\n", fno.fname);
 8007750:	f10d 010d 	add.w	r1, sp, #13
 8007754:	480a      	ldr	r0, [pc, #40]	; (8007780 <FindFile+0x48>)
 8007756:	f005 fde1 	bl	800d31c <iprintf>
		printf("File Found\r\n");
 800775a:	480a      	ldr	r0, [pc, #40]	; (8007784 <FindFile+0x4c>)
 800775c:	f005 fe66 	bl	800d42c <puts>
		retVal = true;
 8007760:	2401      	movs	r4, #1
	f_closedir(&dj);
 8007762:	a807      	add	r0, sp, #28
 8007764:	f7ff fac9 	bl	8006cfa <f_closedir>
	printf("End of FindFile\r\n");
 8007768:	4807      	ldr	r0, [pc, #28]	; (8007788 <FindFile+0x50>)
 800776a:	f005 fe5f 	bl	800d42c <puts>
}
 800776e:	4620      	mov	r0, r4
 8007770:	b014      	add	sp, #80	; 0x50
 8007772:	bd10      	pop	{r4, pc}
	uint8_t retVal = false;
 8007774:	2400      	movs	r4, #0
 8007776:	e7f4      	b.n	8007762 <FindFile+0x2a>
 8007778:	0800f6b2 	.word	0x0800f6b2
 800777c:	0800f701 	.word	0x0800f701
 8007780:	0800f6ba 	.word	0x0800f6ba
 8007784:	0800f6c5 	.word	0x0800f6c5
 8007788:	0800f6d1 	.word	0x0800f6d1

0800778c <ArchiveFiles>:
{
 800778c:	b500      	push	{lr}
	printf("Trying to archive\r\n");
 800778e:	480f      	ldr	r0, [pc, #60]	; (80077cc <ArchiveFiles+0x40>)
{
 8007790:	b095      	sub	sp, #84	; 0x54
	printf("Trying to archive\r\n");
 8007792:	f005 fe4b 	bl	800d42c <puts>
	fr = f_findfirst(&dj, &fno, "", "*-*.txt"); /* Start to search for photo files */
 8007796:	4b0e      	ldr	r3, [pc, #56]	; (80077d0 <ArchiveFiles+0x44>)
 8007798:	4a0e      	ldr	r2, [pc, #56]	; (80077d4 <ArchiveFiles+0x48>)
 800779a:	a901      	add	r1, sp, #4
 800779c:	a807      	add	r0, sp, #28
 800779e:	f7ff faf9 	bl	8006d94 <f_findfirst>
	if (fr == FR_OK)
 80077a2:	b960      	cbnz	r0, 80077be <ArchiveFiles+0x32>
		printf("File to Archive: %s\r\n", fno.fname);
 80077a4:	f10d 010d 	add.w	r1, sp, #13
 80077a8:	480b      	ldr	r0, [pc, #44]	; (80077d8 <ArchiveFiles+0x4c>)
 80077aa:	f005 fdb7 	bl	800d31c <iprintf>
		ArchivePATHFile(fno.fname, TRANSMIT_PATH);
 80077ae:	f10d 000d 	add.w	r0, sp, #13
 80077b2:	490a      	ldr	r1, [pc, #40]	; (80077dc <ArchiveFiles+0x50>)
 80077b4:	f7ff ff8e 	bl	80076d4 <ArchivePATHFile>
		printf("File Archived\r\n");
 80077b8:	4809      	ldr	r0, [pc, #36]	; (80077e0 <ArchiveFiles+0x54>)
 80077ba:	f005 fe37 	bl	800d42c <puts>
	f_closedir(&dj);
 80077be:	a807      	add	r0, sp, #28
 80077c0:	f7ff fa9b 	bl	8006cfa <f_closedir>
}
 80077c4:	b015      	add	sp, #84	; 0x54
 80077c6:	f85d fb04 	ldr.w	pc, [sp], #4
 80077ca:	bf00      	nop
 80077cc:	0800f5f8 	.word	0x0800f5f8
 80077d0:	0800f6b2 	.word	0x0800f6b2
 80077d4:	0800f701 	.word	0x0800f701
 80077d8:	0800f60b 	.word	0x0800f60b
 80077dc:	0800f6e2 	.word	0x0800f6e2
 80077e0:	0800f621 	.word	0x0800f621

080077e4 <ArchiveInfoFilesExceptNewest>:
{
 80077e4:	b530      	push	{r4, r5, lr}
 80077e6:	b095      	sub	sp, #84	; 0x54
 80077e8:	4604      	mov	r4, r0
	fr = f_findfirst(&dj, &fno, "", "I_*");
 80077ea:	4b0f      	ldr	r3, [pc, #60]	; (8007828 <ArchiveInfoFilesExceptNewest+0x44>)
 80077ec:	4a0f      	ldr	r2, [pc, #60]	; (800782c <ArchiveInfoFilesExceptNewest+0x48>)
			ArchivePATHFile(fno.fname, INFO_PATH);
 80077ee:	4d10      	ldr	r5, [pc, #64]	; (8007830 <ArchiveInfoFilesExceptNewest+0x4c>)
	fr = f_findfirst(&dj, &fno, "", "I_*");
 80077f0:	a901      	add	r1, sp, #4
 80077f2:	a807      	add	r0, sp, #28
 80077f4:	f7ff face 	bl	8006d94 <f_findfirst>
	while (fr == FR_OK && fno.fname[0])
 80077f8:	b910      	cbnz	r0, 8007800 <ArchiveInfoFilesExceptNewest+0x1c>
 80077fa:	f89d 300d 	ldrb.w	r3, [sp, #13]
 80077fe:	b90b      	cbnz	r3, 8007804 <ArchiveInfoFilesExceptNewest+0x20>
}
 8007800:	b015      	add	sp, #84	; 0x54
 8007802:	bd30      	pop	{r4, r5, pc}
		if (strcmp(fno.fname, exceptFile) == 0)
 8007804:	4621      	mov	r1, r4
 8007806:	f10d 000d 	add.w	r0, sp, #13
 800780a:	f7f8 fce9 	bl	80001e0 <strcmp>
 800780e:	b920      	cbnz	r0, 800781a <ArchiveInfoFilesExceptNewest+0x36>
			fr = f_findnext(&dj, &fno);
 8007810:	a901      	add	r1, sp, #4
 8007812:	a807      	add	r0, sp, #28
 8007814:	f7ff faa6 	bl	8006d64 <f_findnext>
 8007818:	e7ee      	b.n	80077f8 <ArchiveInfoFilesExceptNewest+0x14>
			ArchivePATHFile(fno.fname, INFO_PATH);
 800781a:	4629      	mov	r1, r5
 800781c:	f10d 000d 	add.w	r0, sp, #13
 8007820:	f7ff ff58 	bl	80076d4 <ArchivePATHFile>
 8007824:	e7f4      	b.n	8007810 <ArchiveInfoFilesExceptNewest+0x2c>
 8007826:	bf00      	nop
 8007828:	0800f630 	.word	0x0800f630
 800782c:	0800f701 	.word	0x0800f701
 8007830:	0800f6f1 	.word	0x0800f6f1

08007834 <SDReadAndSendPackets>:
{
 8007834:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007836:	f2ad 5d54 	subw	sp, sp, #1364	; 0x554
 800783a:	4607      	mov	r7, r0
	SaraConfig *sC = GetSaraConfigurationStruct();
 800783c:	f001 fc62 	bl	8009104 <GetSaraConfigurationStruct>
 8007840:	4604      	mov	r4, r0
	radioFlags *rE = GetErrorFlagsStruct();
 8007842:	f001 fc63 	bl	800910c <GetErrorFlagsStruct>
	char data[256] = { 0 };
 8007846:	f44f 7280 	mov.w	r2, #256	; 0x100
 800784a:	2100      	movs	r1, #0
	radioFlags *rE = GetErrorFlagsStruct();
 800784c:	4605      	mov	r5, r0
	char data[256] = { 0 };
 800784e:	a808      	add	r0, sp, #32
 8007850:	f005 fa54 	bl	800ccfc <memset>
	char dummyData[256] = { 0 };
 8007854:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007858:	2100      	movs	r1, #0
 800785a:	a848      	add	r0, sp, #288	; 0x120
 800785c:	f005 fa4e 	bl	800ccfc <memset>
	const char cC[16] = "&CHECKCOUNTER";
 8007860:	4b3e      	ldr	r3, [pc, #248]	; (800795c <SDReadAndSendPackets+0x128>)
 8007862:	aa04      	add	r2, sp, #16
 8007864:	f103 0e08 	add.w	lr, r3, #8
 8007868:	6818      	ldr	r0, [r3, #0]
 800786a:	6859      	ldr	r1, [r3, #4]
 800786c:	4616      	mov	r6, r2
 800786e:	c603      	stmia	r6!, {r0, r1}
 8007870:	3308      	adds	r3, #8
 8007872:	4573      	cmp	r3, lr
 8007874:	4632      	mov	r2, r6
 8007876:	d1f7      	bne.n	8007868 <SDReadAndSendPackets+0x34>
 8007878:	6818      	ldr	r0, [r3, #0]
 800787a:	889b      	ldrh	r3, [r3, #4]
 800787c:	6030      	str	r0, [r6, #0]
 800787e:	80b3      	strh	r3, [r6, #4]
	if (f_open(&sendFile, filename, FA_READ) != FR_OK)
 8007880:	2201      	movs	r2, #1
	const char cC[16] = "&CHECKCOUNTER";
 8007882:	2600      	movs	r6, #0
	if (f_open(&sendFile, filename, FA_READ) != FR_OK)
 8007884:	4639      	mov	r1, r7
 8007886:	a8c8      	add	r0, sp, #800	; 0x320
	const char cC[16] = "&CHECKCOUNTER";
 8007888:	f8ad 601e 	strh.w	r6, [sp, #30]
	if (f_open(&sendFile, filename, FA_READ) != FR_OK)
 800788c:	f7fe fdf8 	bl	8006480 <f_open>
 8007890:	b178      	cbz	r0, 80078b2 <SDReadAndSendPackets+0x7e>
		ErrorAddLog(LOG_FUNC_SD, LOG_SUB_READ, LOG_TYPE_OPEN,
 8007892:	f001 fc03 	bl	800909c <GetErrorStruct>
 8007896:	2115      	movs	r1, #21
 8007898:	9003      	str	r0, [sp, #12]
 800789a:	9602      	str	r6, [sp, #8]
 800789c:	4608      	mov	r0, r1
 800789e:	9601      	str	r6, [sp, #4]
 80078a0:	9600      	str	r6, [sp, #0]
 80078a2:	2311      	movs	r3, #17
 80078a4:	2218      	movs	r2, #24
 80078a6:	f004 fcf7 	bl	800c298 <ErrorAddLog>
		return HAL_ERROR;
 80078aa:	2001      	movs	r0, #1
}
 80078ac:	f20d 5d54 	addw	sp, sp, #1364	; 0x554
 80078b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (sC->firstMessageToReSend != 1)
 80078b2:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 80078b6:	2b01      	cmp	r3, #1
 80078b8:	d004      	beq.n	80078c4 <SDReadAndSendPackets+0x90>
 80078ba:	2601      	movs	r6, #1
			for (int i = 1; i < sC->firstMessageToReSend; i++)
 80078bc:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 80078c0:	429e      	cmp	r6, r3
 80078c2:	db40      	blt.n	8007946 <SDReadAndSendPackets+0x112>
			printf("data: %s \r\n", data);
 80078c4:	4f26      	ldr	r7, [pc, #152]	; (8007960 <SDReadAndSendPackets+0x12c>)
 80078c6:	f104 0660 	add.w	r6, r4, #96	; 0x60
		while (f_gets(data, 256, &sendFile) != NULL)
 80078ca:	aac8      	add	r2, sp, #800	; 0x320
 80078cc:	f44f 7180 	mov.w	r1, #256	; 0x100
 80078d0:	a808      	add	r0, sp, #32
 80078d2:	f7ff fc42 	bl	800715a <f_gets>
 80078d6:	b1b8      	cbz	r0, 8007908 <SDReadAndSendPackets+0xd4>
			MqttPushPublishSD(sC->connectPubTopic, (const char*) data, 0, 0);
 80078d8:	2300      	movs	r3, #0
 80078da:	461a      	mov	r2, r3
 80078dc:	a908      	add	r1, sp, #32
 80078de:	4630      	mov	r0, r6
 80078e0:	f003 ffea 	bl	800b8b8 <MqttPushPublishSD>
			printf("data: %s \r\n", data);
 80078e4:	a908      	add	r1, sp, #32
 80078e6:	4638      	mov	r0, r7
 80078e8:	f005 fd18 	bl	800d31c <iprintf>
			memset(data, '\0', 256);
 80078ec:	f44f 7280 	mov.w	r2, #256	; 0x100
 80078f0:	2100      	movs	r1, #0
 80078f2:	a808      	add	r0, sp, #32
 80078f4:	f005 fa02 	bl	800ccfc <memset>
			rE->counterMessage++;
 80078f8:	8b2b      	ldrh	r3, [r5, #24]
			if (rE->counterMessage == sC->lastMessageToReSend)
 80078fa:	f8d4 20ac 	ldr.w	r2, [r4, #172]	; 0xac
			rE->counterMessage++;
 80078fe:	3301      	adds	r3, #1
 8007900:	b29b      	uxth	r3, r3
			if (rE->counterMessage == sC->lastMessageToReSend)
 8007902:	4293      	cmp	r3, r2
			rE->counterMessage++;
 8007904:	832b      	strh	r3, [r5, #24]
			if (rE->counterMessage == sC->lastMessageToReSend)
 8007906:	d1e0      	bne.n	80078ca <SDReadAndSendPackets+0x96>
		uint8_t rxBuff[256] = { 0 };
 8007908:	f44f 7280 	mov.w	r2, #256	; 0x100
 800790c:	2100      	movs	r1, #0
 800790e:	a888      	add	r0, sp, #544	; 0x220
 8007910:	f005 f9f4 	bl	800ccfc <memset>
		SaraWaitForResponse(rxBuff, 256, 200);
 8007914:	22c8      	movs	r2, #200	; 0xc8
 8007916:	f44f 7180 	mov.w	r1, #256	; 0x100
 800791a:	a888      	add	r0, sp, #544	; 0x220
 800791c:	f004 f824 	bl	800b968 <SaraWaitForResponse>
		rE->counterMessage--;
 8007920:	8b2b      	ldrh	r3, [r5, #24]
 8007922:	3b01      	subs	r3, #1
 8007924:	832b      	strh	r3, [r5, #24]
		MqttPushPublishSD(sC->connectPubTopic, cC, 0, 0);
 8007926:	2300      	movs	r3, #0
 8007928:	461a      	mov	r2, r3
 800792a:	a904      	add	r1, sp, #16
 800792c:	4630      	mov	r0, r6
 800792e:	f003 ffc3 	bl	800b8b8 <MqttPushPublishSD>
		sC->firstMessageToReSend = 1;
 8007932:	2301      	movs	r3, #1
 8007934:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
		sC->lastMessageToReSend = 1;
 8007938:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
		f_close(&sendFile);
 800793c:	a8c8      	add	r0, sp, #800	; 0x320
 800793e:	f7ff f86b 	bl	8006a18 <f_close>
	return HAL_OK;
 8007942:	2000      	movs	r0, #0
 8007944:	e7b2      	b.n	80078ac <SDReadAndSendPackets+0x78>
				f_gets(dummyData, 256, &sendFile);
 8007946:	aac8      	add	r2, sp, #800	; 0x320
 8007948:	f44f 7180 	mov.w	r1, #256	; 0x100
 800794c:	a848      	add	r0, sp, #288	; 0x120
 800794e:	f7ff fc04 	bl	800715a <f_gets>
				rE->counterMessage++;
 8007952:	8b2b      	ldrh	r3, [r5, #24]
 8007954:	3301      	adds	r3, #1
 8007956:	832b      	strh	r3, [r5, #24]
			for (int i = 1; i < sC->firstMessageToReSend; i++)
 8007958:	3601      	adds	r6, #1
 800795a:	e7af      	b.n	80078bc <SDReadAndSendPackets+0x88>
 800795c:	0800f53c 	.word	0x0800f53c
 8007960:	0800f6f6 	.word	0x0800f6f6

08007964 <FindAndSendFile>:
{
 8007964:	b510      	push	{r4, lr}
 8007966:	b094      	sub	sp, #80	; 0x50
	radioFlags *rE = GetErrorFlagsStruct();
 8007968:	f001 fbd0 	bl	800910c <GetErrorFlagsStruct>
	rE->counterMessage = 1;
 800796c:	2301      	movs	r3, #1
 800796e:	8303      	strh	r3, [r0, #24]
	fr = f_findfirst(&dj, &fno, "", "*-*.txt"); /* Start to search for photo files */
 8007970:	a901      	add	r1, sp, #4
 8007972:	4b0c      	ldr	r3, [pc, #48]	; (80079a4 <FindAndSendFile+0x40>)
 8007974:	4a0c      	ldr	r2, [pc, #48]	; (80079a8 <FindAndSendFile+0x44>)
 8007976:	a807      	add	r0, sp, #28
 8007978:	f7ff fa0c 	bl	8006d94 <f_findfirst>
	printf("FileName: %s\r\n", fno.fname);
 800797c:	f10d 010d 	add.w	r1, sp, #13
	fr = f_findfirst(&dj, &fno, "", "*-*.txt"); /* Start to search for photo files */
 8007980:	4604      	mov	r4, r0
	printf("FileName: %s\r\n", fno.fname);
 8007982:	480a      	ldr	r0, [pc, #40]	; (80079ac <FindAndSendFile+0x48>)
 8007984:	f005 fcca 	bl	800d31c <iprintf>
	if (fr == FR_OK && fno.fname[0])
 8007988:	b934      	cbnz	r4, 8007998 <FindAndSendFile+0x34>
 800798a:	f89d 300d 	ldrb.w	r3, [sp, #13]
 800798e:	b11b      	cbz	r3, 8007998 <FindAndSendFile+0x34>
		SDReadAndSendPackets(fno.fname);
 8007990:	f10d 000d 	add.w	r0, sp, #13
 8007994:	f7ff ff4e 	bl	8007834 <SDReadAndSendPackets>
	f_closedir(&dj);
 8007998:	a807      	add	r0, sp, #28
 800799a:	f7ff f9ae 	bl	8006cfa <f_closedir>
}
 800799e:	b014      	add	sp, #80	; 0x50
 80079a0:	bd10      	pop	{r4, pc}
 80079a2:	bf00      	nop
 80079a4:	0800f6b2 	.word	0x0800f6b2
 80079a8:	0800f701 	.word	0x0800f701
 80079ac:	0800f6a3 	.word	0x0800f6a3

080079b0 <SDWriteChars>:
{
 80079b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char BatTime[32] = { 0 };
 80079b4:	2220      	movs	r2, #32
{
 80079b6:	f2ad 4d74 	subw	sp, sp, #1140	; 0x474
 80079ba:	4604      	mov	r4, r0
	char BatTime[32] = { 0 };
 80079bc:	2100      	movs	r1, #0
 80079be:	eb0d 0002 	add.w	r0, sp, r2
 80079c2:	f005 f99b 	bl	800ccfc <memset>
	char spectra[256] = { 0 };
 80079c6:	f44f 7280 	mov.w	r2, #256	; 0x100
 80079ca:	2100      	movs	r1, #0
 80079cc:	a810      	add	r0, sp, #64	; 0x40
 80079ce:	f005 f995 	bl	800ccfc <memset>
	char message[256] = { 0 };
 80079d2:	f44f 7280 	mov.w	r2, #256	; 0x100
 80079d6:	2100      	movs	r1, #0
 80079d8:	a850      	add	r0, sp, #320	; 0x140
 80079da:	f005 f98f 	bl	800ccfc <memset>
	Data *data = GetDataStruct();
 80079de:	f001 fb59 	bl	8009094 <GetDataStruct>
	int sensCount = data->sensCounter;
 80079e2:	f645 2308 	movw	r3, #23048	; 0x5a08
	if (f_open(&charFile, filename, FA_OPEN_APPEND | FA_WRITE) != FR_OK)
 80079e6:	4621      	mov	r1, r4
	int sensCount = data->sensCounter;
 80079e8:	f830 8003 	ldrh.w	r8, [r0, r3]
	Data *data = GetDataStruct();
 80079ec:	4606      	mov	r6, r0
	if (f_open(&charFile, filename, FA_OPEN_APPEND | FA_WRITE) != FR_OK)
 80079ee:	2232      	movs	r2, #50	; 0x32
 80079f0:	a890      	add	r0, sp, #576	; 0x240
 80079f2:	f7fe fd45 	bl	8006480 <f_open>
 80079f6:	2400      	movs	r4, #0
 80079f8:	b960      	cbnz	r0, 8007a14 <SDWriteChars+0x64>
			sprintf(
 80079fa:	f8df a0f8 	ldr.w	sl, [pc, #248]	; 8007af4 <SDWriteChars+0x144>
				strcat(message, "\n");
 80079fe:	f8df 90f8 	ldr.w	r9, [pc, #248]	; 8007af8 <SDWriteChars+0x148>
 8007a02:	4634      	mov	r4, r6
	if (f_open(&charFile, filename, FA_OPEN_APPEND | FA_WRITE) != FR_OK)
 8007a04:	4605      	mov	r5, r0
 8007a06:	2301      	movs	r3, #1
		for (int i = 0; i < sensCount; i++)
 8007a08:	4545      	cmp	r5, r8
 8007a0a:	db15      	blt.n	8007a38 <SDWriteChars+0x88>
		f_close(&charFile);
 8007a0c:	a890      	add	r0, sp, #576	; 0x240
 8007a0e:	f7ff f803 	bl	8006a18 <f_close>
 8007a12:	e00c      	b.n	8007a2e <SDWriteChars+0x7e>
		ErrorAddLog(
 8007a14:	f001 fb42 	bl	800909c <GetErrorStruct>
 8007a18:	2301      	movs	r3, #1
 8007a1a:	9003      	str	r0, [sp, #12]
 8007a1c:	9300      	str	r3, [sp, #0]
 8007a1e:	9402      	str	r4, [sp, #8]
 8007a20:	9401      	str	r4, [sp, #4]
 8007a22:	2311      	movs	r3, #17
 8007a24:	2218      	movs	r2, #24
 8007a26:	2117      	movs	r1, #23
 8007a28:	2015      	movs	r0, #21
 8007a2a:	f004 fc35 	bl	800c298 <ErrorAddLog>
}
 8007a2e:	2000      	movs	r0, #0
 8007a30:	f20d 4d74 	addw	sp, sp, #1140	; 0x474
 8007a34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			lux = (data->readData.sensData[i].tempHumLux >> 15);
 8007a38:	68a7      	ldr	r7, [r4, #8]
 8007a3a:	ea4f 3bd7 	mov.w	fp, r7, lsr #15
			tempHum = (data->readData.sensData[i].tempHumLux & 0b111111111111111);
 8007a3e:	f3c7 070e 	ubfx	r7, r7, #0, #15
			if (timeBat)
 8007a42:	b14b      	cbz	r3, 8007a58 <SDWriteChars+0xa8>
				sprintf(
 8007a44:	492a      	ldr	r1, [pc, #168]	; (8007af0 <SDWriteChars+0x140>)
 8007a46:	7933      	ldrb	r3, [r6, #4]
 8007a48:	6832      	ldr	r2, [r6, #0]
 8007a4a:	a808      	add	r0, sp, #32
 8007a4c:	f005 fd06 	bl	800d45c <siprintf>
				strcat(message, BatTime);
 8007a50:	a908      	add	r1, sp, #32
 8007a52:	a850      	add	r0, sp, #320	; 0x140
 8007a54:	f005 fd95 	bl	800d582 <strcat>
			sprintf(
 8007a58:	8ae3      	ldrh	r3, [r4, #22]
 8007a5a:	9305      	str	r3, [sp, #20]
 8007a5c:	8aa3      	ldrh	r3, [r4, #20]
 8007a5e:	9304      	str	r3, [sp, #16]
 8007a60:	8a63      	ldrh	r3, [r4, #18]
 8007a62:	9303      	str	r3, [sp, #12]
 8007a64:	8a23      	ldrh	r3, [r4, #16]
 8007a66:	9302      	str	r3, [sp, #8]
 8007a68:	89e3      	ldrh	r3, [r4, #14]
 8007a6a:	9301      	str	r3, [sp, #4]
 8007a6c:	89a3      	ldrh	r3, [r4, #12]
 8007a6e:	9300      	str	r3, [sp, #0]
 8007a70:	463a      	mov	r2, r7
 8007a72:	465b      	mov	r3, fp
 8007a74:	4651      	mov	r1, sl
 8007a76:	a810      	add	r0, sp, #64	; 0x40
 8007a78:	f005 fcf0 	bl	800d45c <siprintf>
			strcat(message, spectra);
 8007a7c:	a910      	add	r1, sp, #64	; 0x40
 8007a7e:	a850      	add	r0, sp, #320	; 0x140
 8007a80:	f005 fd7f 	bl	800d582 <strcat>
			uint16_t totLength = strlen(message);
 8007a84:	a850      	add	r0, sp, #320	; 0x140
 8007a86:	f7f8 fbb5 	bl	80001f4 <strlen>
			if (i != sensCount - 1)
 8007a8a:	f108 33ff 	add.w	r3, r8, #4294967295
 8007a8e:	429d      	cmp	r5, r3
			uint16_t totLength = strlen(message);
 8007a90:	b280      	uxth	r0, r0
			if (i != sensCount - 1)
 8007a92:	d01e      	beq.n	8007ad2 <SDWriteChars+0x122>
				if (totLength > 130)
 8007a94:	2882      	cmp	r0, #130	; 0x82
 8007a96:	d918      	bls.n	8007aca <SDWriteChars+0x11a>
					strcat(message, "\n");
 8007a98:	4649      	mov	r1, r9
 8007a9a:	a850      	add	r0, sp, #320	; 0x140
 8007a9c:	f005 fd71 	bl	800d582 <strcat>
					f_write(&charFile, (char*) message, strlen(message), (void *) &num);
 8007aa0:	a850      	add	r0, sp, #320	; 0x140
 8007aa2:	f7f8 fba7 	bl	80001f4 <strlen>
 8007aa6:	ab07      	add	r3, sp, #28
 8007aa8:	4602      	mov	r2, r0
 8007aaa:	a950      	add	r1, sp, #320	; 0x140
 8007aac:	a890      	add	r0, sp, #576	; 0x240
 8007aae:	f7fe fea6 	bl	80067fe <f_write>
					memset(message, '\0', 256);
 8007ab2:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007ab6:	2100      	movs	r1, #0
 8007ab8:	a850      	add	r0, sp, #320	; 0x140
 8007aba:	f005 f91f 	bl	800ccfc <memset>
					memset(spectra, '\0', 256);
 8007abe:	f44f 7280 	mov.w	r2, #256	; 0x100
 8007ac2:	2100      	movs	r1, #0
 8007ac4:	a810      	add	r0, sp, #64	; 0x40
 8007ac6:	f005 f919 	bl	800ccfc <memset>
		for (int i = 0; i < sensCount; i++)
 8007aca:	3501      	adds	r5, #1
 8007acc:	3410      	adds	r4, #16
 8007ace:	2300      	movs	r3, #0
 8007ad0:	e79a      	b.n	8007a08 <SDWriteChars+0x58>
				strcat(message, "\n");
 8007ad2:	4649      	mov	r1, r9
 8007ad4:	a850      	add	r0, sp, #320	; 0x140
 8007ad6:	f005 fd54 	bl	800d582 <strcat>
				f_write(&charFile, (char*) message, strlen(message), (void *) &num);
 8007ada:	a850      	add	r0, sp, #320	; 0x140
 8007adc:	f7f8 fb8a 	bl	80001f4 <strlen>
 8007ae0:	ab07      	add	r3, sp, #28
 8007ae2:	4602      	mov	r2, r0
 8007ae4:	a950      	add	r1, sp, #320	; 0x140
 8007ae6:	a890      	add	r0, sp, #576	; 0x240
 8007ae8:	f7fe fe89 	bl	80067fe <f_write>
 8007aec:	e7ed      	b.n	8007aca <SDWriteChars+0x11a>
 8007aee:	bf00      	nop
 8007af0:	0800f702 	.word	0x0800f702
 8007af4:	0800f709 	.word	0x0800f709
 8007af8:	0800f700 	.word	0x0800f700

08007afc <EnableSD_Card>:
{
 8007afc:	b530      	push	{r4, r5, lr}
 8007afe:	b087      	sub	sp, #28
	MX_FATFS_Init();
 8007b00:	f000 f9c6 	bl	8007e90 <MX_FATFS_Init>
	HAL_SD_MspInit(&hsd1);
 8007b04:	4816      	ldr	r0, [pc, #88]	; (8007b60 <EnableSD_Card+0x64>)
 8007b06:	f000 fa4b 	bl	8007fa0 <HAL_SD_MspInit>
	DisEnableSDPin(1);
 8007b0a:	2001      	movs	r0, #1
 8007b0c:	f002 f974 	bl	8009df8 <DisEnableSDPin>
	SleepForApproxMs(500);
 8007b10:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8007b14:	f001 fe34 	bl	8009780 <SleepForApproxMs>
	while (SD_Init() != HAL_OK)
 8007b18:	2406      	movs	r4, #6
 8007b1a:	f7ff fc6f 	bl	80073fc <SD_Init>
 8007b1e:	b1e8      	cbz	r0, 8007b5c <EnableSD_Card+0x60>
 8007b20:	3c01      	subs	r4, #1
		if (ucounter >= 5)
 8007b22:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8007b26:	d1f8      	bne.n	8007b1a <EnableSD_Card+0x1e>
			InfoLogAdd(ERRORLEVEL_HIGH,
 8007b28:	f001 fac0 	bl	80090ac <GetTempInfoStruct>
 8007b2c:	2513      	movs	r5, #19
 8007b2e:	2323      	movs	r3, #35	; 0x23
 8007b30:	2227      	movs	r2, #39	; 0x27
 8007b32:	2115      	movs	r1, #21
 8007b34:	9004      	str	r0, [sp, #16]
 8007b36:	9403      	str	r4, [sp, #12]
 8007b38:	2016      	movs	r0, #22
 8007b3a:	9402      	str	r4, [sp, #8]
 8007b3c:	9401      	str	r4, [sp, #4]
 8007b3e:	9500      	str	r5, [sp, #0]
 8007b40:	f004 fbfa 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(
 8007b44:	f001 faaa 	bl	800909c <GetErrorStruct>
 8007b48:	9402      	str	r4, [sp, #8]
 8007b4a:	9003      	str	r0, [sp, #12]
 8007b4c:	9401      	str	r4, [sp, #4]
 8007b4e:	9400      	str	r4, [sp, #0]
 8007b50:	462b      	mov	r3, r5
 8007b52:	2223      	movs	r2, #35	; 0x23
 8007b54:	2127      	movs	r1, #39	; 0x27
 8007b56:	2015      	movs	r0, #21
 8007b58:	f004 fb9e 	bl	800c298 <ErrorAddLog>
}
 8007b5c:	b007      	add	sp, #28
 8007b5e:	bd30      	pop	{r4, r5, pc}
 8007b60:	2000083c 	.word	0x2000083c

08007b64 <SDWriteSensorData>:
{
 8007b64:	b530      	push	{r4, r5, lr}
 8007b66:	b08d      	sub	sp, #52	; 0x34
 8007b68:	4605      	mov	r5, r0
	GetTime(&fileDate);
 8007b6a:	a806      	add	r0, sp, #24
 8007b6c:	f004 ff36 	bl	800c9dc <GetTime>
	sprintf(sensDate, "%d-%02d-%02d.txt", fileDate.Year, fileDate.Month, fileDate.Day);
 8007b70:	f89d 101a 	ldrb.w	r1, [sp, #26]
 8007b74:	f89d 3019 	ldrb.w	r3, [sp, #25]
 8007b78:	f89d 2018 	ldrb.w	r2, [sp, #24]
 8007b7c:	9100      	str	r1, [sp, #0]
 8007b7e:	a808      	add	r0, sp, #32
 8007b80:	4917      	ldr	r1, [pc, #92]	; (8007be0 <SDWriteSensorData+0x7c>)
 8007b82:	f005 fc6b 	bl	800d45c <siprintf>
	if (SD_Init() == HAL_OK)
 8007b86:	f7ff fc39 	bl	80073fc <SD_Init>
 8007b8a:	b9c0      	cbnz	r0, 8007bbe <SDWriteSensorData+0x5a>
		if (SD_getFileName(sensDate, SD_MAX_FILE_SIZE_DATA) == HAL_OK)
 8007b8c:	f645 2108 	movw	r1, #23048	; 0x5a08
 8007b90:	a808      	add	r0, sp, #32
 8007b92:	f7ff fd7f 	bl	8007694 <SD_getFileName>
 8007b96:	b990      	cbnz	r0, 8007bbe <SDWriteSensorData+0x5a>
			if (SDWriteChars(sd_fileName) == HAL_OK)
 8007b98:	4812      	ldr	r0, [pc, #72]	; (8007be4 <SDWriteSensorData+0x80>)
 8007b9a:	f7ff ff09 	bl	80079b0 <SDWriteChars>
 8007b9e:	b970      	cbnz	r0, 8007bbe <SDWriteSensorData+0x5a>
				if (SD_set_timestamp(sd_fileName) == HAL_OK)
 8007ba0:	4810      	ldr	r0, [pc, #64]	; (8007be4 <SDWriteSensorData+0x80>)
 8007ba2:	f7ff fd07 	bl	80075b4 <SD_set_timestamp>
 8007ba6:	4604      	mov	r4, r0
 8007ba8:	b948      	cbnz	r0, 8007bbe <SDWriteSensorData+0x5a>
					printf("Writing to file: %s \r\n", sd_fileName);
 8007baa:	490e      	ldr	r1, [pc, #56]	; (8007be4 <SDWriteSensorData+0x80>)
 8007bac:	480e      	ldr	r0, [pc, #56]	; (8007be8 <SDWriteSensorData+0x84>)
 8007bae:	f005 fbb5 	bl	800d31c <iprintf>
					data->sensCounter = 0;
 8007bb2:	f645 2308 	movw	r3, #23048	; 0x5a08
 8007bb6:	52ec      	strh	r4, [r5, r3]
}
 8007bb8:	4620      	mov	r0, r4
 8007bba:	b00d      	add	sp, #52	; 0x34
 8007bbc:	bd30      	pop	{r4, r5, pc}
	InfoLogAdd(ERRORLEVEL_WARNING,
 8007bbe:	f001 fa75 	bl	80090ac <GetTempInfoStruct>
 8007bc2:	2300      	movs	r3, #0
 8007bc4:	9303      	str	r3, [sp, #12]
 8007bc6:	9302      	str	r3, [sp, #8]
 8007bc8:	9301      	str	r3, [sp, #4]
 8007bca:	2313      	movs	r3, #19
 8007bcc:	9300      	str	r3, [sp, #0]
 8007bce:	2315      	movs	r3, #21
 8007bd0:	9004      	str	r0, [sp, #16]
 8007bd2:	2217      	movs	r2, #23
 8007bd4:	4619      	mov	r1, r3
 8007bd6:	2014      	movs	r0, #20
 8007bd8:	f004 fbae 	bl	800c338 <InfoLogAdd>
	return HAL_ERROR;
 8007bdc:	2401      	movs	r4, #1
 8007bde:	e7eb      	b.n	8007bb8 <SDWriteSensorData+0x54>
 8007be0:	0800f722 	.word	0x0800f722
 8007be4:	2000c0fa 	.word	0x2000c0fa
 8007be8:	0800f733 	.word	0x0800f733

08007bec <SD_Write>:
{
 8007bec:	b084      	sub	sp, #16
 8007bee:	b530      	push	{r4, r5, lr}
 8007bf0:	b087      	sub	sp, #28
 8007bf2:	ac0a      	add	r4, sp, #40	; 0x28
 8007bf4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
	if (f_open(&SDFile, filename, FA_OPEN_APPEND | FA_WRITE) != FR_OK)
 8007bf8:	2232      	movs	r2, #50	; 0x32
 8007bfa:	9996      	ldr	r1, [sp, #600]	; 0x258
 8007bfc:	4817      	ldr	r0, [pc, #92]	; (8007c5c <SD_Write+0x70>)
{
 8007bfe:	9c97      	ldr	r4, [sp, #604]	; 0x25c
 8007c00:	9d98      	ldr	r5, [sp, #608]	; 0x260
	if (f_open(&SDFile, filename, FA_OPEN_APPEND | FA_WRITE) != FR_OK)
 8007c02:	f7fe fc3d 	bl	8006480 <f_open>
 8007c06:	b938      	cbnz	r0, 8007c18 <SD_Write+0x2c>
 8007c08:	4629      	mov	r1, r5
 8007c0a:	4620      	mov	r0, r4
}
 8007c0c:	b007      	add	sp, #28
 8007c0e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8007c12:	b004      	add	sp, #16
 8007c14:	f7ff bbc2 	b.w	800739c <SD_Write.part.4>
		ErrorAddLog(
 8007c18:	f001 fa40 	bl	800909c <GetErrorStruct>
 8007c1c:	2400      	movs	r4, #0
 8007c1e:	2501      	movs	r5, #1
 8007c20:	9003      	str	r0, [sp, #12]
 8007c22:	2311      	movs	r3, #17
 8007c24:	2218      	movs	r2, #24
 8007c26:	2117      	movs	r1, #23
 8007c28:	9402      	str	r4, [sp, #8]
 8007c2a:	9401      	str	r4, [sp, #4]
 8007c2c:	9500      	str	r5, [sp, #0]
 8007c2e:	2015      	movs	r0, #21
 8007c30:	f004 fb32 	bl	800c298 <ErrorAddLog>
		InfoLogAdd(ERRORLEVEL_WARNING,
 8007c34:	f001 fa3a 	bl	80090ac <GetTempInfoStruct>
 8007c38:	2311      	movs	r3, #17
 8007c3a:	9004      	str	r0, [sp, #16]
 8007c3c:	9300      	str	r3, [sp, #0]
 8007c3e:	9403      	str	r4, [sp, #12]
 8007c40:	9402      	str	r4, [sp, #8]
 8007c42:	9501      	str	r5, [sp, #4]
 8007c44:	2318      	movs	r3, #24
 8007c46:	2217      	movs	r2, #23
 8007c48:	2115      	movs	r1, #21
 8007c4a:	2014      	movs	r0, #20
 8007c4c:	f004 fb74 	bl	800c338 <InfoLogAdd>
}
 8007c50:	4620      	mov	r0, r4
 8007c52:	b007      	add	sp, #28
 8007c54:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 8007c58:	b004      	add	sp, #16
 8007c5a:	4770      	bx	lr
 8007c5c:	200003dc 	.word	0x200003dc

08007c60 <SD_WriteInfoLog>:
{
 8007c60:	b5f0      	push	{r4, r5, r6, r7, lr}
 8007c62:	f5ad 7d13 	sub.w	sp, sp, #588	; 0x24c
 8007c66:	4606      	mov	r6, r0
	uint32_t size = InfoGetSize(GetInfoStruct());
 8007c68:	f001 fa1c 	bl	80090a4 <GetInfoStruct>
 8007c6c:	f004 fbb8 	bl	800c3e0 <InfoGetSize>
 8007c70:	4607      	mov	r7, r0
	GetTime(&fileDate);
 8007c72:	a88c      	add	r0, sp, #560	; 0x230
 8007c74:	f004 feb2 	bl	800c9dc <GetTime>
	sprintf(
 8007c78:	f89d 1232 	ldrb.w	r1, [sp, #562]	; 0x232
 8007c7c:	f89d 3231 	ldrb.w	r3, [sp, #561]	; 0x231
 8007c80:	f89d 2230 	ldrb.w	r2, [sp, #560]	; 0x230
 8007c84:	9100      	str	r1, [sp, #0]
 8007c86:	a88e      	add	r0, sp, #568	; 0x238
 8007c88:	4924      	ldr	r1, [pc, #144]	; (8007d1c <SD_WriteInfoLog+0xbc>)
 8007c8a:	f005 fbe7 	bl	800d45c <siprintf>
	if (SD_Init() == HAL_OK)
 8007c8e:	f7ff fbb5 	bl	80073fc <SD_Init>
 8007c92:	b120      	cbz	r0, 8007c9e <SD_WriteInfoLog+0x3e>
	return HAL_ERROR;
 8007c94:	2401      	movs	r4, #1
}
 8007c96:	4620      	mov	r0, r4
 8007c98:	f50d 7d13 	add.w	sp, sp, #588	; 0x24c
 8007c9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		sprintf(sd_fileName, infoDate);
 8007c9e:	4d20      	ldr	r5, [pc, #128]	; (8007d20 <SD_WriteInfoLog+0xc0>)
		if (SD_Write(SDFile, sd_fileName, (uint32_t) &info->infoLog, size) == HAL_OK)
 8007ca0:	4c20      	ldr	r4, [pc, #128]	; (8007d24 <SD_WriteInfoLog+0xc4>)
		sprintf(sd_fileName, infoDate);
 8007ca2:	a98e      	add	r1, sp, #568	; 0x238
 8007ca4:	4628      	mov	r0, r5
 8007ca6:	f005 fbd9 	bl	800d45c <siprintf>
		if (SD_Write(SDFile, sd_fileName, (uint32_t) &info->infoLog, size) == HAL_OK)
 8007caa:	f44f 7208 	mov.w	r2, #544	; 0x220
 8007cae:	f104 0110 	add.w	r1, r4, #16
 8007cb2:	4668      	mov	r0, sp
 8007cb4:	978a      	str	r7, [sp, #552]	; 0x228
 8007cb6:	9689      	str	r6, [sp, #548]	; 0x224
 8007cb8:	9588      	str	r5, [sp, #544]	; 0x220
 8007cba:	f005 f814 	bl	800cce6 <memcpy>
 8007cbe:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8007cc2:	f7ff ff93 	bl	8007bec <SD_Write>
 8007cc6:	2800      	cmp	r0, #0
 8007cc8:	d1e4      	bne.n	8007c94 <SD_WriteInfoLog+0x34>
			if (SD_Verify(SDFile, sd_fileName, (uint32_t) &info->infoLog, size) == HAL_OK)
 8007cca:	f44f 7208 	mov.w	r2, #544	; 0x220
 8007cce:	f104 0110 	add.w	r1, r4, #16
 8007cd2:	4668      	mov	r0, sp
 8007cd4:	978a      	str	r7, [sp, #552]	; 0x228
 8007cd6:	9689      	str	r6, [sp, #548]	; 0x224
 8007cd8:	9588      	str	r5, [sp, #544]	; 0x220
 8007cda:	f005 f804 	bl	800cce6 <memcpy>
 8007cde:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8007ce2:	f7ff fbe9 	bl	80074b8 <SD_Verify>
 8007ce6:	2800      	cmp	r0, #0
 8007ce8:	d1d4      	bne.n	8007c94 <SD_WriteInfoLog+0x34>
				if (SD_set_timestamp(sd_fileName) == HAL_OK)
 8007cea:	4628      	mov	r0, r5
 8007cec:	f7ff fc62 	bl	80075b4 <SD_set_timestamp>
 8007cf0:	4604      	mov	r4, r0
 8007cf2:	2800      	cmp	r0, #0
 8007cf4:	d1ce      	bne.n	8007c94 <SD_WriteInfoLog+0x34>
					printf("Writing to file: %s \r\n", sd_fileName);
 8007cf6:	4629      	mov	r1, r5
 8007cf8:	480b      	ldr	r0, [pc, #44]	; (8007d28 <SD_WriteInfoLog+0xc8>)
 8007cfa:	f005 fb0f 	bl	800d31c <iprintf>
					if (GetErrorFlagsStruct()->errorHourCounter == 2)
 8007cfe:	f001 fa05 	bl	800910c <GetErrorFlagsStruct>
 8007d02:	78c3      	ldrb	r3, [r0, #3]
 8007d04:	2b02      	cmp	r3, #2
 8007d06:	d103      	bne.n	8007d10 <SD_WriteInfoLog+0xb0>
						ArchiveInfoFilesExceptNewest(infoDate);
 8007d08:	a88e      	add	r0, sp, #568	; 0x238
 8007d0a:	f7ff fd6b 	bl	80077e4 <ArchiveInfoFilesExceptNewest>
 8007d0e:	e7c2      	b.n	8007c96 <SD_WriteInfoLog+0x36>
					else if (GetErrorFlagsStruct()->everythingOK == 1)
 8007d10:	f001 f9fc 	bl	800910c <GetErrorFlagsStruct>
 8007d14:	7d43      	ldrb	r3, [r0, #21]
 8007d16:	2b01      	cmp	r3, #1
 8007d18:	d1bd      	bne.n	8007c96 <SD_WriteInfoLog+0x36>
 8007d1a:	e7f5      	b.n	8007d08 <SD_WriteInfoLog+0xa8>
 8007d1c:	0800f75e 	.word	0x0800f75e
 8007d20:	2000c0fa 	.word	0x2000c0fa
 8007d24:	200003dc 	.word	0x200003dc
 8007d28:	0800f733 	.word	0x0800f733

08007d2c <SDwriteErrorLog>:
{
 8007d2c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8007d30:	f5ad 7d12 	sub.w	sp, sp, #584	; 0x248
 8007d34:	4607      	mov	r7, r0
	uint32_t size = ErrorGetSize(GetErrorStruct());
 8007d36:	f001 f9b1 	bl	800909c <GetErrorStruct>
 8007d3a:	f004 fc0f 	bl	800c55c <ErrorGetSize>
 8007d3e:	4680      	mov	r8, r0
	radioFlags *rE = GetErrorFlagsStruct();
 8007d40:	f001 f9e4 	bl	800910c <GetErrorFlagsStruct>
 8007d44:	4606      	mov	r6, r0
	GetTime(&fileDate);
 8007d46:	a88c      	add	r0, sp, #560	; 0x230
 8007d48:	f004 fe48 	bl	800c9dc <GetTime>
	sprintf(
 8007d4c:	f89d 1232 	ldrb.w	r1, [sp, #562]	; 0x232
 8007d50:	f89d 3231 	ldrb.w	r3, [sp, #561]	; 0x231
 8007d54:	f89d 2230 	ldrb.w	r2, [sp, #560]	; 0x230
 8007d58:	9100      	str	r1, [sp, #0]
 8007d5a:	a88e      	add	r0, sp, #568	; 0x238
 8007d5c:	4926      	ldr	r1, [pc, #152]	; (8007df8 <SDwriteErrorLog+0xcc>)
 8007d5e:	f005 fb7d 	bl	800d45c <siprintf>
	if (SD_Init() == HAL_OK)
 8007d62:	f7ff fb4b 	bl	80073fc <SD_Init>
 8007d66:	b128      	cbz	r0, 8007d74 <SDwriteErrorLog+0x48>
	return HAL_ERROR;
 8007d68:	2401      	movs	r4, #1
}
 8007d6a:	4620      	mov	r0, r4
 8007d6c:	f50d 7d12 	add.w	sp, sp, #584	; 0x248
 8007d70:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		sprintf(sd_fileName, errorDate);
 8007d74:	4d21      	ldr	r5, [pc, #132]	; (8007dfc <SDwriteErrorLog+0xd0>)
		if (SD_Write(SDFile, sd_fileName, (uint32_t) &er->errorLog, size) == HAL_OK)
 8007d76:	4c22      	ldr	r4, [pc, #136]	; (8007e00 <SDwriteErrorLog+0xd4>)
		sprintf(sd_fileName, errorDate);
 8007d78:	a98e      	add	r1, sp, #568	; 0x238
 8007d7a:	4628      	mov	r0, r5
 8007d7c:	f005 fb6e 	bl	800d45c <siprintf>
		if (SD_Write(SDFile, sd_fileName, (uint32_t) &er->errorLog, size) == HAL_OK)
 8007d80:	f44f 7208 	mov.w	r2, #544	; 0x220
 8007d84:	f104 0110 	add.w	r1, r4, #16
 8007d88:	4668      	mov	r0, sp
 8007d8a:	f8cd 8228 	str.w	r8, [sp, #552]	; 0x228
 8007d8e:	9789      	str	r7, [sp, #548]	; 0x224
 8007d90:	9588      	str	r5, [sp, #544]	; 0x220
 8007d92:	f004 ffa8 	bl	800cce6 <memcpy>
 8007d96:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8007d9a:	f7ff ff27 	bl	8007bec <SD_Write>
 8007d9e:	2800      	cmp	r0, #0
 8007da0:	d1e2      	bne.n	8007d68 <SDwriteErrorLog+0x3c>
			if (SD_Verify(SDFile, sd_fileName, (uint32_t) &er->errorLog, size) == HAL_OK)
 8007da2:	f44f 7208 	mov.w	r2, #544	; 0x220
 8007da6:	f104 0110 	add.w	r1, r4, #16
 8007daa:	4668      	mov	r0, sp
 8007dac:	f8cd 8228 	str.w	r8, [sp, #552]	; 0x228
 8007db0:	9789      	str	r7, [sp, #548]	; 0x224
 8007db2:	9588      	str	r5, [sp, #544]	; 0x220
 8007db4:	f004 ff97 	bl	800cce6 <memcpy>
 8007db8:	e894 000f 	ldmia.w	r4, {r0, r1, r2, r3}
 8007dbc:	f7ff fb7c 	bl	80074b8 <SD_Verify>
 8007dc0:	2800      	cmp	r0, #0
 8007dc2:	d1d1      	bne.n	8007d68 <SDwriteErrorLog+0x3c>
				if (SD_set_timestamp(sd_fileName) == HAL_OK)
 8007dc4:	4628      	mov	r0, r5
 8007dc6:	f7ff fbf5 	bl	80075b4 <SD_set_timestamp>
 8007dca:	4604      	mov	r4, r0
 8007dcc:	2800      	cmp	r0, #0
 8007dce:	d1cb      	bne.n	8007d68 <SDwriteErrorLog+0x3c>
					printf("Writing to file: %s \r\n", sd_fileName);
 8007dd0:	4629      	mov	r1, r5
 8007dd2:	480c      	ldr	r0, [pc, #48]	; (8007e04 <SDwriteErrorLog+0xd8>)
 8007dd4:	f005 faa2 	bl	800d31c <iprintf>
					GetErrorStruct()->errorCounter = 0;
 8007dd8:	f001 f960 	bl	800909c <GetErrorStruct>
 8007ddc:	f8a0 4258 	strh.w	r4, [r0, #600]	; 0x258
					if (rE->errorDayCounter == 2)
 8007de0:	7933      	ldrb	r3, [r6, #4]
 8007de2:	2b02      	cmp	r3, #2
 8007de4:	d104      	bne.n	8007df0 <SDwriteErrorLog+0xc4>
						ArchivePATHFile(errorDate, ERROR_PATH);
 8007de6:	4908      	ldr	r1, [pc, #32]	; (8007e08 <SDwriteErrorLog+0xdc>)
 8007de8:	a88e      	add	r0, sp, #568	; 0x238
 8007dea:	f7ff fc73 	bl	80076d4 <ArchivePATHFile>
 8007dee:	e7bc      	b.n	8007d6a <SDwriteErrorLog+0x3e>
					else if (rE->everythingOK == 1)
 8007df0:	7d73      	ldrb	r3, [r6, #21]
 8007df2:	2b01      	cmp	r3, #1
 8007df4:	d1b9      	bne.n	8007d6a <SDwriteErrorLog+0x3e>
 8007df6:	e7f6      	b.n	8007de6 <SDwriteErrorLog+0xba>
 8007df8:	0800f782 	.word	0x0800f782
 8007dfc:	2000c0fa 	.word	0x2000c0fa
 8007e00:	200003dc 	.word	0x200003dc
 8007e04:	0800f733 	.word	0x0800f733
 8007e08:	0800f6eb 	.word	0x0800f6eb

08007e0c <BSP_SD_Init>:
/**
  * @brief  Initializes the SD card device.
  * @retval SD status
  */
uint8_t BSP_SD_Init(void)
{
 8007e0c:	b507      	push	{r0, r1, r2, lr}
 * @param  None
 * @retval Returns if SD is detected or not
 */
uint8_t BSP_SD_IsDetected(void)
{
  __IO uint8_t status = SD_PRESENT;
 8007e0e:	2301      	movs	r3, #1
 8007e10:	f88d 3007 	strb.w	r3, [sp, #7]

  /* USER CODE BEGIN 1 */
  /* user code can be inserted here */
  /* USER CODE END 1 */    	

  return status;
 8007e14:	f89d 3007 	ldrb.w	r3, [sp, #7]
  if (BSP_SD_IsDetected() != SD_PRESENT)
 8007e18:	2b01      	cmp	r3, #1
 8007e1a:	d105      	bne.n	8007e28 <BSP_SD_Init+0x1c>
  sd_state = HAL_SD_Init(&hsd1);
 8007e1c:	4803      	ldr	r0, [pc, #12]	; (8007e2c <BSP_SD_Init+0x20>)
 8007e1e:	f7fc fb56 	bl	80044ce <HAL_SD_Init>
}
 8007e22:	b003      	add	sp, #12
 8007e24:	f85d fb04 	ldr.w	pc, [sp], #4
    return MSD_ERROR_SD_NOT_PRESENT;
 8007e28:	2002      	movs	r0, #2
 8007e2a:	e7fa      	b.n	8007e22 <BSP_SD_Init+0x16>
 8007e2c:	2000083c 	.word	0x2000083c

08007e30 <BSP_SD_ReadBlocks>:
{
 8007e30:	b507      	push	{r0, r1, r2, lr}
  if (HAL_SD_ReadBlocks(&hsd1, (uint8_t *)pData, ReadAddr, NumOfBlocks, Timeout) != HAL_OK)
 8007e32:	9300      	str	r3, [sp, #0]
 8007e34:	4613      	mov	r3, r2
 8007e36:	460a      	mov	r2, r1
 8007e38:	4601      	mov	r1, r0
 8007e3a:	4804      	ldr	r0, [pc, #16]	; (8007e4c <BSP_SD_ReadBlocks+0x1c>)
 8007e3c:	f7fb ffb8 	bl	8003db0 <HAL_SD_ReadBlocks>
}
 8007e40:	3000      	adds	r0, #0
 8007e42:	bf18      	it	ne
 8007e44:	2001      	movne	r0, #1
 8007e46:	b003      	add	sp, #12
 8007e48:	f85d fb04 	ldr.w	pc, [sp], #4
 8007e4c:	2000083c 	.word	0x2000083c

08007e50 <BSP_SD_WriteBlocks>:
{
 8007e50:	b507      	push	{r0, r1, r2, lr}
  if (HAL_SD_WriteBlocks(&hsd1, (uint8_t *)pData, WriteAddr, NumOfBlocks, Timeout) != HAL_OK) 
 8007e52:	9300      	str	r3, [sp, #0]
 8007e54:	4613      	mov	r3, r2
 8007e56:	460a      	mov	r2, r1
 8007e58:	4601      	mov	r1, r0
 8007e5a:	4804      	ldr	r0, [pc, #16]	; (8007e6c <BSP_SD_WriteBlocks+0x1c>)
 8007e5c:	f7fc f8b0 	bl	8003fc0 <HAL_SD_WriteBlocks>
}
 8007e60:	3000      	adds	r0, #0
 8007e62:	bf18      	it	ne
 8007e64:	2001      	movne	r0, #1
 8007e66:	b003      	add	sp, #12
 8007e68:	f85d fb04 	ldr.w	pc, [sp], #4
 8007e6c:	2000083c 	.word	0x2000083c

08007e70 <BSP_SD_GetCardState>:
{
 8007e70:	b508      	push	{r3, lr}
  return ((HAL_SD_GetCardState(&hsd1) == HAL_SD_CARD_TRANSFER ) ? SD_TRANSFER_OK : SD_TRANSFER_BUSY);
 8007e72:	4803      	ldr	r0, [pc, #12]	; (8007e80 <BSP_SD_GetCardState+0x10>)
 8007e74:	f7fc fb58 	bl	8004528 <HAL_SD_GetCardState>
}
 8007e78:	3804      	subs	r0, #4
 8007e7a:	bf18      	it	ne
 8007e7c:	2001      	movne	r0, #1
 8007e7e:	bd08      	pop	{r3, pc}
 8007e80:	2000083c 	.word	0x2000083c

08007e84 <BSP_SD_GetCardInfo>:
  HAL_SD_GetCardInfo(&hsd1, CardInfo);
 8007e84:	4601      	mov	r1, r0
 8007e86:	4801      	ldr	r0, [pc, #4]	; (8007e8c <BSP_SD_GetCardInfo+0x8>)
 8007e88:	f7fc bb3c 	b.w	8004504 <HAL_SD_GetCardInfo>
 8007e8c:	2000083c 	.word	0x2000083c

08007e90 <MX_FATFS_Init>:
/* USER CODE BEGIN Variables */

/* USER CODE END Variables */    

void MX_FATFS_Init(void) 
{
 8007e90:	b508      	push	{r3, lr}
  /*## FatFS: Link the SD driver ###########################*/
  retSD = FATFS_LinkDriver(&SD_Driver, SDPath);
 8007e92:	4903      	ldr	r1, [pc, #12]	; (8007ea0 <MX_FATFS_Init+0x10>)
 8007e94:	4803      	ldr	r0, [pc, #12]	; (8007ea4 <MX_FATFS_Init+0x14>)
 8007e96:	f7ff f9a7 	bl	80071e8 <FATFS_LinkDriver>
 8007e9a:	4b03      	ldr	r3, [pc, #12]	; (8007ea8 <MX_FATFS_Init+0x18>)
 8007e9c:	7018      	strb	r0, [r3, #0]
 8007e9e:	bd08      	pop	{r3, pc}
 8007ea0:	200003d5 	.word	0x200003d5
 8007ea4:	0800f794 	.word	0x0800f794
 8007ea8:	200003d4 	.word	0x200003d4

08007eac <get_fattime>:
DWORD get_fattime(void)
{
  /* USER CODE BEGIN get_fattime */
  return 0;
  /* USER CODE END get_fattime */  
}
 8007eac:	2000      	movs	r0, #0
 8007eae:	4770      	bx	lr

08007eb0 <SD_CheckStatus.isra.0>:
/* USER CODE BEGIN beforeFunctionSection */
/* can be used to modify / undefine following code or add new code */
/* USER CODE END beforeFunctionSection */

/* Private functions ---------------------------------------------------------*/
static DSTATUS SD_CheckStatus(BYTE lun)
 8007eb0:	b510      	push	{r4, lr}
{
  Stat = STA_NOINIT;
 8007eb2:	4c06      	ldr	r4, [pc, #24]	; (8007ecc <SD_CheckStatus.isra.0+0x1c>)
 8007eb4:	2301      	movs	r3, #1
 8007eb6:	7023      	strb	r3, [r4, #0]

  if(BSP_SD_GetCardState() == MSD_OK)
 8007eb8:	f7ff ffda 	bl	8007e70 <BSP_SD_GetCardState>
 8007ebc:	4623      	mov	r3, r4
 8007ebe:	b918      	cbnz	r0, 8007ec8 <SD_CheckStatus.isra.0+0x18>
  {
    Stat &= ~STA_NOINIT;
 8007ec0:	7822      	ldrb	r2, [r4, #0]
 8007ec2:	f002 02fe 	and.w	r2, r2, #254	; 0xfe
 8007ec6:	7022      	strb	r2, [r4, #0]
  }

  return Stat;
 8007ec8:	7818      	ldrb	r0, [r3, #0]
}
 8007eca:	bd10      	pop	{r4, pc}
 8007ecc:	20000020 	.word	0x20000020

08007ed0 <SD_initialize>:
  * @brief  Initializes a Drive
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_initialize(BYTE lun)
{
 8007ed0:	b510      	push	{r4, lr}
  Stat = STA_NOINIT;
 8007ed2:	4c05      	ldr	r4, [pc, #20]	; (8007ee8 <SD_initialize+0x18>)
 8007ed4:	2301      	movs	r3, #1
 8007ed6:	7023      	strb	r3, [r4, #0]
#if !defined(DISABLE_SD_INIT)

  if(BSP_SD_Init() == MSD_OK)
 8007ed8:	f7ff ff98 	bl	8007e0c <BSP_SD_Init>
 8007edc:	b910      	cbnz	r0, 8007ee4 <SD_initialize+0x14>
  {
    Stat = SD_CheckStatus(lun);
 8007ede:	f7ff ffe7 	bl	8007eb0 <SD_CheckStatus.isra.0>
 8007ee2:	7020      	strb	r0, [r4, #0]
  }

#else
  Stat = SD_CheckStatus(lun);
#endif
  return Stat;
 8007ee4:	7820      	ldrb	r0, [r4, #0]
}
 8007ee6:	bd10      	pop	{r4, pc}
 8007ee8:	20000020 	.word	0x20000020

08007eec <SD_status>:
  * @param  lun : not used
  * @retval DSTATUS: Operation status
  */
DSTATUS SD_status(BYTE lun)
{
  return SD_CheckStatus(lun);
 8007eec:	f7ff bfe0 	b.w	8007eb0 <SD_CheckStatus.isra.0>

08007ef0 <SD_read>:
  * @param  sector: Sector address (LBA)
  * @param  count: Number of sectors to read (1..128)
  * @retval DRESULT: Operation result
  */
DRESULT SD_read(BYTE lun, BYTE *buff, DWORD sector, UINT count)
{
 8007ef0:	b508      	push	{r3, lr}
 8007ef2:	4608      	mov	r0, r1
 8007ef4:	4611      	mov	r1, r2
 8007ef6:	461a      	mov	r2, r3
  DRESULT res = RES_ERROR;

  if(BSP_SD_ReadBlocks((uint32_t*)buff,
 8007ef8:	f04f 33ff 	mov.w	r3, #4294967295
 8007efc:	f7ff ff98 	bl	8007e30 <BSP_SD_ReadBlocks>
 8007f00:	b920      	cbnz	r0, 8007f0c <SD_read+0x1c>
  if(BSP_SD_WriteBlocks((uint32_t*)buff,
                        (uint32_t)(sector),
                        count, SD_TIMEOUT) == MSD_OK)
  {
	/* wait until the Write operation is finished */
    while(BSP_SD_GetCardState() != MSD_OK)
 8007f02:	f7ff ffb5 	bl	8007e70 <BSP_SD_GetCardState>
 8007f06:	2800      	cmp	r0, #0
 8007f08:	d1fb      	bne.n	8007f02 <SD_read+0x12>
 8007f0a:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
 8007f0c:	2001      	movs	r0, #1
}
 8007f0e:	bd08      	pop	{r3, pc}

08007f10 <SD_ioctl>:
  * @param  *buff: Buffer to send/receive control data
  * @retval DRESULT: Operation result
  */
#if _USE_IOCTL == 1
DRESULT SD_ioctl(BYTE lun, BYTE cmd, void *buff)
{
 8007f10:	b510      	push	{r4, lr}
  DRESULT res = RES_ERROR;
  BSP_SD_CardInfo CardInfo;

  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8007f12:	4b12      	ldr	r3, [pc, #72]	; (8007f5c <SD_ioctl+0x4c>)
 8007f14:	781b      	ldrb	r3, [r3, #0]
 8007f16:	07db      	lsls	r3, r3, #31
{
 8007f18:	b088      	sub	sp, #32
 8007f1a:	4614      	mov	r4, r2
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8007f1c:	d41b      	bmi.n	8007f56 <SD_ioctl+0x46>

  switch (cmd)
 8007f1e:	2903      	cmp	r1, #3
 8007f20:	d803      	bhi.n	8007f2a <SD_ioctl+0x1a>
 8007f22:	e8df f001 	tbb	[pc, r1]
 8007f26:	0510      	.short	0x0510
 8007f28:	120b      	.short	0x120b
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
    res = RES_OK;
    break;

  default:
    res = RES_PARERR;
 8007f2a:	2004      	movs	r0, #4
  }

  return res;
}
 8007f2c:	b008      	add	sp, #32
 8007f2e:	bd10      	pop	{r4, pc}
    BSP_SD_GetCardInfo(&CardInfo);
 8007f30:	4668      	mov	r0, sp
 8007f32:	f7ff ffa7 	bl	8007e84 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockNbr;
 8007f36:	9b06      	ldr	r3, [sp, #24]
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 8007f38:	6023      	str	r3, [r4, #0]
 8007f3a:	e004      	b.n	8007f46 <SD_ioctl+0x36>
    BSP_SD_GetCardInfo(&CardInfo);
 8007f3c:	4668      	mov	r0, sp
 8007f3e:	f7ff ffa1 	bl	8007e84 <BSP_SD_GetCardInfo>
    *(WORD*)buff = CardInfo.LogBlockSize;
 8007f42:	9b07      	ldr	r3, [sp, #28]
 8007f44:	8023      	strh	r3, [r4, #0]
    res = RES_OK;
 8007f46:	2000      	movs	r0, #0
 8007f48:	e7f0      	b.n	8007f2c <SD_ioctl+0x1c>
    BSP_SD_GetCardInfo(&CardInfo);
 8007f4a:	4668      	mov	r0, sp
 8007f4c:	f7ff ff9a 	bl	8007e84 <BSP_SD_GetCardInfo>
    *(DWORD*)buff = CardInfo.LogBlockSize / SD_DEFAULT_BLOCK_SIZE;
 8007f50:	9b07      	ldr	r3, [sp, #28]
 8007f52:	0a5b      	lsrs	r3, r3, #9
 8007f54:	e7f0      	b.n	8007f38 <SD_ioctl+0x28>
  if (Stat & STA_NOINIT) return RES_NOTRDY;
 8007f56:	2003      	movs	r0, #3
 8007f58:	e7e8      	b.n	8007f2c <SD_ioctl+0x1c>
 8007f5a:	bf00      	nop
 8007f5c:	20000020 	.word	0x20000020

08007f60 <SD_write>:
{
 8007f60:	b508      	push	{r3, lr}
 8007f62:	4608      	mov	r0, r1
 8007f64:	4611      	mov	r1, r2
 8007f66:	461a      	mov	r2, r3
  if(BSP_SD_WriteBlocks((uint32_t*)buff,
 8007f68:	f04f 33ff 	mov.w	r3, #4294967295
 8007f6c:	f7ff ff70 	bl	8007e50 <BSP_SD_WriteBlocks>
 8007f70:	b920      	cbnz	r0, 8007f7c <SD_write+0x1c>
    while(BSP_SD_GetCardState() != MSD_OK)
 8007f72:	f7ff ff7d 	bl	8007e70 <BSP_SD_GetCardState>
 8007f76:	2800      	cmp	r0, #0
 8007f78:	d1fb      	bne.n	8007f72 <SD_write+0x12>
 8007f7a:	bd08      	pop	{r3, pc}
  DRESULT res = RES_ERROR;
 8007f7c:	2001      	movs	r0, #1
}
 8007f7e:	bd08      	pop	{r3, pc}

08007f80 <MX_SDMMC1_SD_Init>:
/* SDMMC1 init function */

void MX_SDMMC1_SD_Init(void)
{

  hsd1.Instance = SDMMC1;
 8007f80:	4b05      	ldr	r3, [pc, #20]	; (8007f98 <MX_SDMMC1_SD_Init+0x18>)
 8007f82:	4a06      	ldr	r2, [pc, #24]	; (8007f9c <MX_SDMMC1_SD_Init+0x1c>)
 8007f84:	601a      	str	r2, [r3, #0]
  hsd1.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
 8007f86:	2200      	movs	r2, #0
 8007f88:	605a      	str	r2, [r3, #4]
  hsd1.Init.ClockBypass = SDMMC_CLOCK_BYPASS_DISABLE;
 8007f8a:	609a      	str	r2, [r3, #8]
  hsd1.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
 8007f8c:	60da      	str	r2, [r3, #12]
  hsd1.Init.BusWide = SDMMC_BUS_WIDE_1B;
 8007f8e:	611a      	str	r2, [r3, #16]
  hsd1.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
 8007f90:	615a      	str	r2, [r3, #20]
  hsd1.Init.ClockDiv = 0;
 8007f92:	619a      	str	r2, [r3, #24]
 8007f94:	4770      	bx	lr
 8007f96:	bf00      	nop
 8007f98:	2000083c 	.word	0x2000083c
 8007f9c:	40012800 	.word	0x40012800

08007fa0 <HAL_SD_MspInit>:

}

void HAL_SD_MspInit(SD_HandleTypeDef* sdHandle)
{
 8007fa0:	b5f0      	push	{r4, r5, r6, r7, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(sdHandle->Instance==SDMMC1)
 8007fa2:	6802      	ldr	r2, [r0, #0]
 8007fa4:	4b15      	ldr	r3, [pc, #84]	; (8007ffc <HAL_SD_MspInit+0x5c>)
 8007fa6:	429a      	cmp	r2, r3
{
 8007fa8:	b087      	sub	sp, #28
  if(sdHandle->Instance==SDMMC1)
 8007faa:	d124      	bne.n	8007ff6 <HAL_SD_MspInit+0x56>
  {
  /* USER CODE BEGIN SDMMC1_MspInit 0 */

  /* USER CODE END SDMMC1_MspInit 0 */
    /* SDMMC1 clock enable */
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8007fac:	f503 4368 	add.w	r3, r3, #59392	; 0xe800
    PC8     ------> SDMMC1_D0
    PC12     ------> SDMMC1_CK
    PD2     ------> SDMMC1_CMD 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_12;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007fb0:	2702      	movs	r7, #2
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8007fb2:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007fb4:	4812      	ldr	r0, [pc, #72]	; (8008000 <HAL_SD_MspInit+0x60>)
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8007fb6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8007fba:	661a      	str	r2, [r3, #96]	; 0x60
 8007fbc:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007fbe:	9702      	str	r7, [sp, #8]
    __HAL_RCC_SDMMC1_CLK_ENABLE();
 8007fc0:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8007fc4:	9300      	str	r3, [sp, #0]
 8007fc6:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007fc8:	2600      	movs	r6, #0
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_12;
 8007fca:	f44f 5388 	mov.w	r3, #4352	; 0x1100
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8007fce:	2503      	movs	r5, #3
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 8007fd0:	240c      	movs	r4, #12
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007fd2:	a901      	add	r1, sp, #4
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_12;
 8007fd4:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007fd6:	9603      	str	r6, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8007fd8:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 8007fda:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8007fdc:	f7f9 ff88 	bl	8001ef0 <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8007fe0:	2304      	movs	r3, #4
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007fe2:	eb0d 0103 	add.w	r1, sp, r3
 8007fe6:	4807      	ldr	r0, [pc, #28]	; (8008004 <HAL_SD_MspInit+0x64>)
    GPIO_InitStruct.Pin = GPIO_PIN_2;
 8007fe8:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8007fea:	9702      	str	r7, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8007fec:	9603      	str	r6, [sp, #12]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8007fee:	9504      	str	r5, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF12_SDMMC1;
 8007ff0:	9405      	str	r4, [sp, #20]
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8007ff2:	f7f9 ff7d 	bl	8001ef0 <HAL_GPIO_Init>

  /* USER CODE BEGIN SDMMC1_MspInit 1 */

  /* USER CODE END SDMMC1_MspInit 1 */
  }
}
 8007ff6:	b007      	add	sp, #28
 8007ff8:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8007ffa:	bf00      	nop
 8007ffc:	40012800 	.word	0x40012800
 8008000:	48000800 	.word	0x48000800
 8008004:	48000c00 	.word	0x48000c00

08008008 <SD_DeInitTest>:
  }
} 

/* USER CODE BEGIN 1 */
void SD_DeInitTest(void)
{
 8008008:	b5f0      	push	{r4, r5, r6, r7, lr}

	GPIO_InitTypeDef GPIO_InitStruct;

	RCC->APB2ENR &= ~RCC_APB2ENR_SDMMC1EN;
 800800a:	4a17      	ldr	r2, [pc, #92]	; (8008068 <SD_DeInitTest+0x60>)

	GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800800c:	4d17      	ldr	r5, [pc, #92]	; (800806c <SD_DeInitTest+0x64>)
	RCC->APB2ENR &= ~RCC_APB2ENR_SDMMC1EN;
 800800e:	6e13      	ldr	r3, [r2, #96]	; 0x60
{
 8008010:	b087      	sub	sp, #28
	RCC->APB2ENR &= ~RCC_APB2ENR_SDMMC1EN;
 8008012:	f423 6380 	bic.w	r3, r3, #1024	; 0x400
 8008016:	6613      	str	r3, [r2, #96]	; 0x60
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008018:	2400      	movs	r4, #0
	GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;
 800801a:	f44f 5388 	mov.w	r3, #4352	; 0x1100
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800801e:	2601      	movs	r6, #1
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8008020:	a901      	add	r1, sp, #4
 8008022:	4628      	mov	r0, r5
	GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;
 8008024:	9301      	str	r3, [sp, #4]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8008026:	9602      	str	r6, [sp, #8]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008028:	9403      	str	r4, [sp, #12]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800802a:	f7f9 ff61 	bl	8001ef0 <HAL_GPIO_Init>

	GPIO_InitStruct.Pin = GPIO_PIN_2;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 800802e:	9602      	str	r6, [sp, #8]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8008030:	4e0f      	ldr	r6, [pc, #60]	; (8008070 <SD_DeInitTest+0x68>)
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008032:	9403      	str	r4, [sp, #12]
	GPIO_InitStruct.Pin = GPIO_PIN_2;
 8008034:	2704      	movs	r7, #4
	HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 8008036:	eb0d 0107 	add.w	r1, sp, r7
 800803a:	4630      	mov	r0, r6
	GPIO_InitStruct.Pin = GPIO_PIN_2;
 800803c:	9701      	str	r7, [sp, #4]
	HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 800803e:	f7f9 ff57 	bl	8001ef0 <HAL_GPIO_Init>

	HAL_GPIO_WritePin(GPIOD, GPIO_PIN_2, GPIO_PIN_RESET);
 8008042:	4622      	mov	r2, r4
 8008044:	4639      	mov	r1, r7
 8008046:	4630      	mov	r0, r6
 8008048:	f7fa f892 	bl	8002170 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_8, GPIO_PIN_RESET);
 800804c:	4622      	mov	r2, r4
 800804e:	4628      	mov	r0, r5
 8008050:	f44f 7180 	mov.w	r1, #256	; 0x100
 8008054:	f7fa f88c 	bl	8002170 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOC, GPIO_PIN_12, GPIO_PIN_RESET);
 8008058:	4622      	mov	r2, r4
 800805a:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800805e:	4628      	mov	r0, r5
 8008060:	f7fa f886 	bl	8002170 <HAL_GPIO_WritePin>
}
 8008064:	b007      	add	sp, #28
 8008066:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8008068:	40021000 	.word	0x40021000
 800806c:	48000800 	.word	0x48000800
 8008070:	48000c00 	.word	0x48000c00

08008074 <AS726X_readRegister>:

	return (incoming);
}

uint8_t AS726X_readRegister(uint8_t addr)
{
 8008074:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	uint8_t data_t[2];

	data_t[0] = addr;
 8008076:	ac04      	add	r4, sp, #16

	// first set the register pointer to the register wanted to be read
	// note the & operator which gives us the address of the register_pointer variable
	HAL_I2C_Master_Transmit(&hi2c1, (uint8_t) AS726X_ADDR_Write, (uint8_t *) data_t, 1, 1);
 8008078:	4e0a      	ldr	r6, [pc, #40]	; (80080a4 <AS726X_readRegister+0x30>)
	data_t[0] = addr;
 800807a:	f804 0d04 	strb.w	r0, [r4, #-4]!
	HAL_I2C_Master_Transmit(&hi2c1, (uint8_t) AS726X_ADDR_Write, (uint8_t *) data_t, 1, 1);
 800807e:	2501      	movs	r5, #1
 8008080:	462b      	mov	r3, r5
 8008082:	4622      	mov	r2, r4
 8008084:	9500      	str	r5, [sp, #0]
 8008086:	2192      	movs	r1, #146	; 0x92
 8008088:	4630      	mov	r0, r6
 800808a:	f7fa fa31 	bl	80024f0 <HAL_I2C_Master_Transmit>

	// receive the 2 x 8bit data into the receive buffer
	HAL_I2C_Master_Receive(&hi2c1, (uint8_t) AS726X_ADDR_Read, (uint8_t *) data_t, 1, 1);
 800808e:	9500      	str	r5, [sp, #0]
 8008090:	462b      	mov	r3, r5
 8008092:	4622      	mov	r2, r4
 8008094:	2193      	movs	r1, #147	; 0x93
 8008096:	4630      	mov	r0, r6
 8008098:	f7fa fabe 	bl	8002618 <HAL_I2C_Master_Receive>

	return data_t[0];
}
 800809c:	f89d 000c 	ldrb.w	r0, [sp, #12]
 80080a0:	b004      	add	sp, #16
 80080a2:	bd70      	pop	{r4, r5, r6, pc}
 80080a4:	2000c4bc 	.word	0x2000c4bc

080080a8 <AS726X_writeRegister>:
	AS726X_writeRegister(AS72XX_SLAVE_WRITE_REG, dataToWrite);
}

//Write a value to a spot in the AS726x
void AS726X_writeRegister(uint8_t addr, uint8_t val)
{
 80080a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80080ac:	b086      	sub	sp, #24
	uint8_t data_t[3];
	data_t[0] = addr;
	data_t[1] = val;
	uint32_t timeOutCounter = 0;

	while (HAL_I2C_Master_Transmit(&hi2c1, AS726X_ADDR_Write, (uint8_t *) data_t, 2, 1) != HAL_OK)
 80080ae:	4f12      	ldr	r7, [pc, #72]	; (80080f8 <AS726X_writeRegister+0x50>)
	data_t[0] = addr;
 80080b0:	f88d 0014 	strb.w	r0, [sp, #20]
{
 80080b4:	4605      	mov	r5, r0
 80080b6:	460e      	mov	r6, r1
	data_t[1] = val;
 80080b8:	f88d 1015 	strb.w	r1, [sp, #21]
	while (HAL_I2C_Master_Transmit(&hi2c1, AS726X_ADDR_Write, (uint8_t *) data_t, 2, 1) != HAL_OK)
 80080bc:	2466      	movs	r4, #102	; 0x66
 80080be:	f04f 0801 	mov.w	r8, #1
 80080c2:	f8cd 8000 	str.w	r8, [sp]
 80080c6:	2302      	movs	r3, #2
 80080c8:	aa05      	add	r2, sp, #20
 80080ca:	2192      	movs	r1, #146	; 0x92
 80080cc:	4638      	mov	r0, r7
 80080ce:	f7fa fa0f 	bl	80024f0 <HAL_I2C_Master_Transmit>
 80080d2:	b168      	cbz	r0, 80080f0 <AS726X_writeRegister+0x48>
	{

		if (timeOutCounter > AS72XX_TIMEOUT_TX_END)
 80080d4:	3c01      	subs	r4, #1
 80080d6:	d1f4      	bne.n	80080c2 <AS726X_writeRegister+0x1a>
		{
			ErrorAddLog(LOG_FUNC_AS726X, LOG_SUB_WRITE, LOG_TYPE_WRITE, LOG_STATUS_TIMEOUT, val, addr, 0, GetErrorStruct());
 80080d8:	f000 ffe0 	bl	800909c <GetErrorStruct>
 80080dc:	9402      	str	r4, [sp, #8]
 80080de:	9003      	str	r0, [sp, #12]
 80080e0:	9501      	str	r5, [sp, #4]
 80080e2:	9600      	str	r6, [sp, #0]
 80080e4:	2313      	movs	r3, #19
 80080e6:	2215      	movs	r2, #21
 80080e8:	2117      	movs	r1, #23
 80080ea:	2014      	movs	r0, #20
 80080ec:	f004 f8d4 	bl	800c298 <ErrorAddLog>
			break;
		}
		timeOutCounter++;
	}
}
 80080f0:	b006      	add	sp, #24
 80080f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80080f6:	bf00      	nop
 80080f8:	2000c4bc 	.word	0x2000c4bc

080080fc <AS726X_virtualReadRegister>:
{
 80080fc:	b5f0      	push	{r4, r5, r6, r7, lr}
 80080fe:	4604      	mov	r4, r0
 8008100:	b087      	sub	sp, #28
	status = AS726X_readRegister(AS72XX_SLAVE_STATUS_REG);
 8008102:	2000      	movs	r0, #0
 8008104:	f7ff ffb6 	bl	8008074 <AS726X_readRegister>
	if ((status & AS72XX_SLAVE_RX_VALID) != 0) //There is data to be read
 8008108:	07c1      	lsls	r1, r0, #31
 800810a:	d502      	bpl.n	8008112 <AS726X_virtualReadRegister+0x16>
		uint8_t incoming = AS726X_readRegister(AS72XX_SLAVE_READ_REG); //Read the byte but do nothing with it
 800810c:	2002      	movs	r0, #2
 800810e:	f7ff ffb1 	bl	8008074 <AS726X_readRegister>
{
 8008112:	2564      	movs	r5, #100	; 0x64
		status = AS726X_readRegister(AS72XX_SLAVE_STATUS_REG);
 8008114:	2000      	movs	r0, #0
 8008116:	f7ff ffad 	bl	8008074 <AS726X_readRegister>
		if ((status & AS72XX_SLAVE_TX_VALID) == 0)
 800811a:	0782      	lsls	r2, r0, #30
 800811c:	d51f      	bpl.n	800815e <AS726X_virtualReadRegister+0x62>
		HAL_Delay(1);
 800811e:	2001      	movs	r0, #1
 8008120:	f7f8 febc 	bl	8000e9c <HAL_Delay>
	while (timeOutCounter < AS72XX_TIMEOUT_RX_END)
 8008124:	3d01      	subs	r5, #1
 8008126:	d1f5      	bne.n	8008114 <AS726X_virtualReadRegister+0x18>
		InfoLogAdd(
 8008128:	f000 ffc0 	bl	80090ac <GetTempInfoStruct>
 800812c:	2701      	movs	r7, #1
 800812e:	2314      	movs	r3, #20
 8008130:	2613      	movs	r6, #19
 8008132:	461a      	mov	r2, r3
 8008134:	4619      	mov	r1, r3
 8008136:	9004      	str	r0, [sp, #16]
 8008138:	9503      	str	r5, [sp, #12]
 800813a:	4618      	mov	r0, r3
 800813c:	9702      	str	r7, [sp, #8]
 800813e:	9401      	str	r4, [sp, #4]
 8008140:	9600      	str	r6, [sp, #0]
 8008142:	f004 f8f9 	bl	800c338 <InfoLogAdd>
		ErrorAddLog(LOG_FUNC_AS726X, LOG_SUB_VIR_READ, LOG_TYPE_READ, LOG_STATUS_TIMEOUT, virtualAddr, 1, 0, GetErrorStruct());
 8008146:	f000 ffa9 	bl	800909c <GetErrorStruct>
 800814a:	2214      	movs	r2, #20
 800814c:	9003      	str	r0, [sp, #12]
 800814e:	9502      	str	r5, [sp, #8]
 8008150:	e88d 0090 	stmia.w	sp, {r4, r7}
 8008154:	4633      	mov	r3, r6
 8008156:	4611      	mov	r1, r2
 8008158:	4610      	mov	r0, r2
 800815a:	f004 f89d 	bl	800c298 <ErrorAddLog>
	AS726X_writeRegister(AS72XX_SLAVE_WRITE_REG, virtualAddr);
 800815e:	4621      	mov	r1, r4
 8008160:	2001      	movs	r0, #1
 8008162:	f7ff ffa1 	bl	80080a8 <AS726X_writeRegister>
 8008166:	2564      	movs	r5, #100	; 0x64
		status = AS726X_readRegister(AS72XX_SLAVE_STATUS_REG);
 8008168:	2000      	movs	r0, #0
 800816a:	f7ff ff83 	bl	8008074 <AS726X_readRegister>
		if ((status & AS72XX_SLAVE_RX_VALID) != 0)
 800816e:	07c3      	lsls	r3, r0, #31
 8008170:	d41f      	bmi.n	80081b2 <AS726X_virtualReadRegister+0xb6>
		SleepForApproxMsSpectra(10);
 8008172:	200a      	movs	r0, #10
 8008174:	f001 fb18 	bl	80097a8 <SleepForApproxMsSpectra>
	while (timeOutCounter < AS72XX_TIMEOUT_RX_END)
 8008178:	3d01      	subs	r5, #1
 800817a:	d1f5      	bne.n	8008168 <AS726X_virtualReadRegister+0x6c>
		InfoLogAdd(
 800817c:	f000 ff96 	bl	80090ac <GetTempInfoStruct>
 8008180:	2702      	movs	r7, #2
 8008182:	2314      	movs	r3, #20
 8008184:	2613      	movs	r6, #19
 8008186:	461a      	mov	r2, r3
 8008188:	4619      	mov	r1, r3
 800818a:	9004      	str	r0, [sp, #16]
 800818c:	9503      	str	r5, [sp, #12]
 800818e:	4618      	mov	r0, r3
 8008190:	9702      	str	r7, [sp, #8]
 8008192:	9401      	str	r4, [sp, #4]
 8008194:	9600      	str	r6, [sp, #0]
 8008196:	f004 f8cf 	bl	800c338 <InfoLogAdd>
		ErrorAddLog(LOG_FUNC_AS726X, LOG_SUB_VIR_READ, LOG_TYPE_READ, LOG_STATUS_TIMEOUT, virtualAddr, 2, 0, GetErrorStruct());
 800819a:	f000 ff7f 	bl	800909c <GetErrorStruct>
 800819e:	2214      	movs	r2, #20
 80081a0:	9003      	str	r0, [sp, #12]
 80081a2:	9502      	str	r5, [sp, #8]
 80081a4:	e88d 0090 	stmia.w	sp, {r4, r7}
 80081a8:	4633      	mov	r3, r6
 80081aa:	4611      	mov	r1, r2
 80081ac:	4610      	mov	r0, r2
 80081ae:	f004 f873 	bl	800c298 <ErrorAddLog>
	uint8_t incoming = AS726X_readRegister(AS72XX_SLAVE_READ_REG);
 80081b2:	2002      	movs	r0, #2
}
 80081b4:	b007      	add	sp, #28
 80081b6:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
	uint8_t incoming = AS726X_readRegister(AS72XX_SLAVE_READ_REG);
 80081ba:	f7ff bf5b 	b.w	8008074 <AS726X_readRegister>

080081be <AS726X_Get_HW_No>:
	return AS726X_virtualReadRegister(AS726x_HW_VERSION);
 80081be:	2001      	movs	r0, #1
 80081c0:	f7ff bf9c 	b.w	80080fc <AS726X_virtualReadRegister>

080081c4 <AS726X_virtualWriteRegister>:
{
 80081c4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80081c6:	4605      	mov	r5, r0
 80081c8:	460e      	mov	r6, r1
 80081ca:	2464      	movs	r4, #100	; 0x64
		status = AS726X_readRegister(AS72XX_SLAVE_STATUS_REG);
 80081cc:	2000      	movs	r0, #0
 80081ce:	f7ff ff51 	bl	8008074 <AS726X_readRegister>
		if ((status & AS72XX_SLAVE_TX_VALID) == 0)
 80081d2:	0782      	lsls	r2, r0, #30
 80081d4:	d511      	bpl.n	80081fa <AS726X_virtualWriteRegister+0x36>
		HAL_Delay(POLLING_DELAY);
 80081d6:	2005      	movs	r0, #5
 80081d8:	f7f8 fe60 	bl	8000e9c <HAL_Delay>
	while (timeOutCounter < AS72XX_TIMEOUT_TX_END)
 80081dc:	3c01      	subs	r4, #1
 80081de:	d1f5      	bne.n	80081cc <AS726X_virtualWriteRegister+0x8>
		ErrorAddLog(LOG_FUNC_AS726X, LOG_SUB_VIR_WRITE, LOG_TYPE_WRITE, LOG_STATUS_TIMEOUT, virtualAddr, 1, 0, GetErrorStruct());
 80081e0:	f000 ff5c 	bl	800909c <GetErrorStruct>
 80081e4:	2301      	movs	r3, #1
 80081e6:	9003      	str	r0, [sp, #12]
 80081e8:	9301      	str	r3, [sp, #4]
 80081ea:	9402      	str	r4, [sp, #8]
 80081ec:	9500      	str	r5, [sp, #0]
 80081ee:	2313      	movs	r3, #19
 80081f0:	2215      	movs	r2, #21
 80081f2:	2116      	movs	r1, #22
 80081f4:	2014      	movs	r0, #20
 80081f6:	f004 f84f 	bl	800c298 <ErrorAddLog>
	AS726X_writeRegister(AS72XX_SLAVE_WRITE_REG, (virtualAddr | 0x80));
 80081fa:	f045 0180 	orr.w	r1, r5, #128	; 0x80
 80081fe:	2001      	movs	r0, #1
 8008200:	f7ff ff52 	bl	80080a8 <AS726X_writeRegister>
 8008204:	2464      	movs	r4, #100	; 0x64
		status = AS726X_readRegister(AS72XX_SLAVE_STATUS_REG);
 8008206:	2000      	movs	r0, #0
 8008208:	f7ff ff34 	bl	8008074 <AS726X_readRegister>
		if ((status & AS72XX_SLAVE_TX_VALID) == 0)
 800820c:	0783      	lsls	r3, r0, #30
 800820e:	d511      	bpl.n	8008234 <AS726X_virtualWriteRegister+0x70>
		HAL_Delay(POLLING_DELAY);
 8008210:	2005      	movs	r0, #5
 8008212:	f7f8 fe43 	bl	8000e9c <HAL_Delay>
	while (timeOutCounter < AS72XX_TIMEOUT_TX_END)
 8008216:	3c01      	subs	r4, #1
 8008218:	d1f5      	bne.n	8008206 <AS726X_virtualWriteRegister+0x42>
		ErrorAddLog(LOG_FUNC_AS726X, LOG_SUB_VIR_WRITE, LOG_TYPE_WRITE, LOG_STATUS_TIMEOUT, virtualAddr, 2, 0, GetErrorStruct());
 800821a:	f000 ff3f 	bl	800909c <GetErrorStruct>
 800821e:	2302      	movs	r3, #2
 8008220:	9003      	str	r0, [sp, #12]
 8008222:	9301      	str	r3, [sp, #4]
 8008224:	9402      	str	r4, [sp, #8]
 8008226:	9500      	str	r5, [sp, #0]
 8008228:	2313      	movs	r3, #19
 800822a:	2215      	movs	r2, #21
 800822c:	2116      	movs	r1, #22
 800822e:	2014      	movs	r0, #20
 8008230:	f004 f832 	bl	800c298 <ErrorAddLog>
	AS726X_writeRegister(AS72XX_SLAVE_WRITE_REG, dataToWrite);
 8008234:	4631      	mov	r1, r6
 8008236:	2001      	movs	r0, #1
}
 8008238:	b004      	add	sp, #16
 800823a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	AS726X_writeRegister(AS72XX_SLAVE_WRITE_REG, dataToWrite);
 800823e:	f7ff bf33 	b.w	80080a8 <AS726X_writeRegister>

08008242 <AS726X_setMeasurementMode>:
{
 8008242:	b510      	push	{r4, lr}
 8008244:	4604      	mov	r4, r0
	uint8_t value = AS726X_virtualReadRegister(AS726x_CONTROL_SETUP); //Read
 8008246:	2004      	movs	r0, #4
 8008248:	f7ff ff58 	bl	80080fc <AS726X_virtualReadRegister>
	value |= (mode << 2); //Set BANK bits with user's choice
 800824c:	2c03      	cmp	r4, #3
 800824e:	bf28      	it	cs
 8008250:	2403      	movcs	r4, #3
	value &= 0b11110011; //Clear BANK bits
 8008252:	f020 010c 	bic.w	r1, r0, #12
	value |= (mode << 2); //Set BANK bits with user's choice
 8008256:	ea41 0184 	orr.w	r1, r1, r4, lsl #2
	AS726X_virtualWriteRegister(AS726x_CONTROL_SETUP, value); //Write
 800825a:	b2c9      	uxtb	r1, r1
 800825c:	2004      	movs	r0, #4
}
 800825e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	AS726X_virtualWriteRegister(AS726x_CONTROL_SETUP, value); //Write
 8008262:	f7ff bfaf 	b.w	80081c4 <AS726X_virtualWriteRegister>

08008266 <AS726X_setGain>:
{
 8008266:	b510      	push	{r4, lr}
 8008268:	4604      	mov	r4, r0
	uint8_t value = AS726X_virtualReadRegister(AS726x_CONTROL_SETUP); //Read
 800826a:	2004      	movs	r0, #4
 800826c:	f7ff ff46 	bl	80080fc <AS726X_virtualReadRegister>
	value |= (gain << 4); //Set GAIN bits with user's choice
 8008270:	2c03      	cmp	r4, #3
 8008272:	bf28      	it	cs
 8008274:	2403      	movcs	r4, #3
	value &= 0b11001111; //Clear GAIN bits
 8008276:	f020 0130 	bic.w	r1, r0, #48	; 0x30
	value |= (gain << 4); //Set GAIN bits with user's choice
 800827a:	ea41 1104 	orr.w	r1, r1, r4, lsl #4
	AS726X_virtualWriteRegister(AS726x_CONTROL_SETUP, value); //Write
 800827e:	b2c9      	uxtb	r1, r1
 8008280:	2004      	movs	r0, #4
}
 8008282:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	AS726X_virtualWriteRegister(AS726x_CONTROL_SETUP, value); //Write
 8008286:	f7ff bf9d 	b.w	80081c4 <AS726X_virtualWriteRegister>

0800828a <AS726X_setIntegrationTime>:
	AS726X_virtualWriteRegister(AS726x_INT_T, integrationValue); //Write
 800828a:	4601      	mov	r1, r0
 800828c:	2005      	movs	r0, #5
 800828e:	f7ff bf99 	b.w	80081c4 <AS726X_virtualWriteRegister>

08008292 <AS726X_dataAvailable>:
	sp->red = AS726X_get_Normalized_Value(AS726X_getRed(), gain);
}

//Checks to see if DRDY flag is set in the control setup register
uint8_t AS726X_dataAvailable(void)
{
 8008292:	b508      	push	{r3, lr}
	uint8_t value = AS726X_virtualReadRegister(AS726x_CONTROL_SETUP);
 8008294:	2004      	movs	r0, #4
 8008296:	f7ff ff31 	bl	80080fc <AS726X_virtualReadRegister>
	return (value & (1 << 1)); //Bit 1 is DATA_RDY
}
 800829a:	f000 0002 	and.w	r0, r0, #2
 800829e:	bd08      	pop	{r3, pc}

080082a0 <AS726X_clearDataAvailable>:

//Clears the DRDY flag
//Normally this should clear when data registers are read
uint8_t AS726X_clearDataAvailable(void)
{
 80082a0:	b508      	push	{r3, lr}
	uint8_t value = AS726X_virtualReadRegister(AS726x_CONTROL_SETUP);
 80082a2:	2004      	movs	r0, #4
 80082a4:	f7ff ff2a 	bl	80080fc <AS726X_virtualReadRegister>
	value &= ~(1 << 1); //Set the DATA_RDY bit
	AS726X_virtualWriteRegister(AS726x_CONTROL_SETUP, value);
 80082a8:	f000 01fd 	and.w	r1, r0, #253	; 0xfd
 80082ac:	2004      	movs	r0, #4
 80082ae:	f7ff ff89 	bl	80081c4 <AS726X_virtualWriteRegister>

	return 1;
}
 80082b2:	2001      	movs	r0, #1
 80082b4:	bd08      	pop	{r3, pc}

080082b6 <AS726X_getCalibratedValue>:
	return (AS726X_getCalibratedValue(AS7262_R_CAL));
}

//Given an address, read four bytes and return the floating point calibrated value
float AS726X_getCalibratedValue(uint8_t calAddress)
{
 80082b6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80082b8:	4605      	mov	r5, r0

	uint8_t b0, b1, b2, b3;
	b0 = AS726X_virtualReadRegister(calAddress + 0);
 80082ba:	f7ff ff1f 	bl	80080fc <AS726X_virtualReadRegister>
 80082be:	4607      	mov	r7, r0
	b1 = AS726X_virtualReadRegister(calAddress + 1);
 80082c0:	1c68      	adds	r0, r5, #1
 80082c2:	b2c0      	uxtb	r0, r0
 80082c4:	f7ff ff1a 	bl	80080fc <AS726X_virtualReadRegister>
 80082c8:	4604      	mov	r4, r0
	b2 = AS726X_virtualReadRegister(calAddress + 2);
 80082ca:	1ca8      	adds	r0, r5, #2
 80082cc:	b2c0      	uxtb	r0, r0
 80082ce:	f7ff ff15 	bl	80080fc <AS726X_virtualReadRegister>
 80082d2:	4606      	mov	r6, r0
	b3 = AS726X_virtualReadRegister(calAddress + 3);
 80082d4:	1ce8      	adds	r0, r5, #3
 80082d6:	b2c0      	uxtb	r0, r0
 80082d8:	f7ff ff10 	bl	80080fc <AS726X_virtualReadRegister>

	//Channel calibrated values are stored big-endian
	uint32_t calBytes = 0;
	calBytes |= ((uint32_t) b0 << (8 * 3));
	calBytes |= ((uint32_t) b1 << (8 * 2));
 80082dc:	0424      	lsls	r4, r4, #16
 80082de:	ea44 6407 	orr.w	r4, r4, r7, lsl #24
 80082e2:	4320      	orrs	r0, r4
	calBytes |= ((uint32_t) b2 << (8 * 1));
	calBytes |= ((uint32_t) b3 << (8 * 0));

	return (AS726X_convertBytesToFloat(calBytes));
 80082e4:	ea40 2006 	orr.w	r0, r0, r6, lsl #8
}
 80082e8:	ee00 0a10 	vmov	s0, r0
 80082ec:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080082ee <AS726X_getCalibratedViolet>:
	return (AS726X_getCalibratedValue(AS7262_V_CAL));
 80082ee:	2014      	movs	r0, #20
 80082f0:	f7ff bfe1 	b.w	80082b6 <AS726X_getCalibratedValue>

080082f4 <AS726X_getCalibratedBlue>:
	return (AS726X_getCalibratedValue(AS7262_B_CAL));
 80082f4:	2018      	movs	r0, #24
 80082f6:	f7ff bfde 	b.w	80082b6 <AS726X_getCalibratedValue>

080082fa <AS726X_getCalibratedGreen>:
	return (AS726X_getCalibratedValue(AS7262_G_CAL));
 80082fa:	201c      	movs	r0, #28
 80082fc:	f7ff bfdb 	b.w	80082b6 <AS726X_getCalibratedValue>

08008300 <AS726X_getCalibratedYellow>:
	return (AS726X_getCalibratedValue(AS7262_Y_CAL));
 8008300:	2020      	movs	r0, #32
 8008302:	f7ff bfd8 	b.w	80082b6 <AS726X_getCalibratedValue>

08008306 <AS726X_getCalibratedOrange>:
	return (AS726X_getCalibratedValue(AS7262_O_CAL));
 8008306:	2024      	movs	r0, #36	; 0x24
 8008308:	f7ff bfd5 	b.w	80082b6 <AS726X_getCalibratedValue>

0800830c <AS726X_getCalibratedRed>:
	return (AS726X_getCalibratedValue(AS7262_R_CAL));
 800830c:	2028      	movs	r0, #40	; 0x28
 800830e:	f7ff bfd2 	b.w	80082b6 <AS726X_getCalibratedValue>

08008312 <AS726X_getSpectrum>:
{
 8008312:	b510      	push	{r4, lr}
 8008314:	4604      	mov	r4, r0
	sp->violet = (uint16_t) AS726X_getCalibratedViolet();
 8008316:	f7ff ffea 	bl	80082ee <AS726X_getCalibratedViolet>
 800831a:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800831e:	ee17 3a90 	vmov	r3, s15
 8008322:	8023      	strh	r3, [r4, #0]
	sp->blue = (uint16_t) AS726X_getCalibratedBlue();
 8008324:	f7ff ffe6 	bl	80082f4 <AS726X_getCalibratedBlue>
 8008328:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800832c:	ee17 3a90 	vmov	r3, s15
 8008330:	8063      	strh	r3, [r4, #2]
	sp->green = (uint16_t) AS726X_getCalibratedGreen();
 8008332:	f7ff ffe2 	bl	80082fa <AS726X_getCalibratedGreen>
 8008336:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 800833a:	ee17 3a90 	vmov	r3, s15
 800833e:	80a3      	strh	r3, [r4, #4]
	sp->yellow = (uint16_t) AS726X_getCalibratedYellow();
 8008340:	f7ff ffde 	bl	8008300 <AS726X_getCalibratedYellow>
 8008344:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8008348:	ee17 3a90 	vmov	r3, s15
 800834c:	80e3      	strh	r3, [r4, #6]
	sp->orange = (uint16_t) AS726X_getCalibratedOrange();
 800834e:	f7ff ffda 	bl	8008306 <AS726X_getCalibratedOrange>
 8008352:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8008356:	ee17 3a90 	vmov	r3, s15
 800835a:	8123      	strh	r3, [r4, #8]
	sp->red = (uint16_t) AS726X_getCalibratedRed();
 800835c:	f7ff ffd6 	bl	800830c <AS726X_getCalibratedRed>
 8008360:	eefc 7ac0 	vcvt.u32.f32	s15, s0
 8008364:	ee17 3a90 	vmov	r3, s15
 8008368:	8163      	strh	r3, [r4, #10]
 800836a:	bd10      	pop	{r4, pc}

0800836c <AS726X_disableIndicator>:
/*
 * Disable the onboard indicator LED
 * Read, mask/set, write
 */
void AS726X_disableIndicator(void)
{
 800836c:	b508      	push	{r3, lr}
	uint8_t value = AS726X_virtualReadRegister(AS726x_LED_CONTROL);
 800836e:	2007      	movs	r0, #7
 8008370:	f7ff fec4 	bl	80080fc <AS726X_virtualReadRegister>
	value &= ~(1 << 0); //Clear the bit
	AS726X_virtualWriteRegister(AS726x_LED_CONTROL, value);
}
 8008374:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	AS726X_virtualWriteRegister(AS726x_LED_CONTROL, value);
 8008378:	f000 01fe 	and.w	r1, r0, #254	; 0xfe
 800837c:	2007      	movs	r0, #7
 800837e:	f7ff bf21 	b.w	80081c4 <AS726X_virtualWriteRegister>

08008382 <AS726X_disableBulb>:
/*
 * Disable the onboard 5700k or external incandescent bulb
 * Read, mask/set, write
 */
void AS726X_disableBulb()
{
 8008382:	b508      	push	{r3, lr}
	uint8_t value = AS726X_virtualReadRegister(AS726x_LED_CONTROL);
 8008384:	2007      	movs	r0, #7
 8008386:	f7ff feb9 	bl	80080fc <AS726X_virtualReadRegister>
	value &= ~(1 << 3); //Clear the bit
	AS726X_virtualWriteRegister(AS726x_LED_CONTROL, value);
}
 800838a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	AS726X_virtualWriteRegister(AS726x_LED_CONTROL, value);
 800838e:	f000 01f7 	and.w	r1, r0, #247	; 0xf7
 8008392:	2007      	movs	r0, #7
 8008394:	f7ff bf16 	b.w	80081c4 <AS726X_virtualWriteRegister>

08008398 <AS726X_setBulbCurrent>:
/*
 * Set the current limit of bulb/LED. Current 0: 12.5mA, Current 1: 25mA, Current 2: 50mA, Current 3: 100mA
 * Read, mask/set, write
 */
void AS726X_setBulbCurrent(uint8_t current)
{
 8008398:	b510      	push	{r4, lr}
 800839a:	4604      	mov	r4, r0
	if (current > 0b11)
	{
		current = 0b11; //Limit to two bits
	}
	uint8_t value = AS726X_virtualReadRegister(AS726x_LED_CONTROL); //Read
 800839c:	2007      	movs	r0, #7
 800839e:	f7ff fead 	bl	80080fc <AS726X_virtualReadRegister>
	value &= 0b11001111; //Clear ICL_DRV bits
	value |= (current << 4); //Set ICL_DRV bits with user's choice
 80083a2:	2c03      	cmp	r4, #3
 80083a4:	bf28      	it	cs
 80083a6:	2403      	movcs	r4, #3
	value &= 0b11001111; //Clear ICL_DRV bits
 80083a8:	f020 0130 	bic.w	r1, r0, #48	; 0x30
	value |= (current << 4); //Set ICL_DRV bits with user's choice
 80083ac:	ea41 1104 	orr.w	r1, r1, r4, lsl #4
	AS726X_virtualWriteRegister(AS726x_LED_CONTROL, value); //Write
 80083b0:	b2c9      	uxtb	r1, r1
 80083b2:	2007      	movs	r0, #7
}
 80083b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	AS726X_virtualWriteRegister(AS726x_LED_CONTROL, value); //Write
 80083b8:	f7ff bf04 	b.w	80081c4 <AS726X_virtualWriteRegister>

080083bc <AS726X_begin>:
{
 80083bc:	b530      	push	{r4, r5, lr}
 80083be:	b085      	sub	sp, #20
 80083c0:	4605      	mov	r5, r0
 80083c2:	460c      	mov	r4, r1
	if (AS726X_Get_HW_No() != SENSORTYPE_AS7262 && AS726X_Get_HW_No() != SENSORTYPE_AS7263)	//HW version for AS7262&AS7263
 80083c4:	f7ff fefb 	bl	80081be <AS726X_Get_HW_No>
 80083c8:	283e      	cmp	r0, #62	; 0x3e
 80083ca:	d013      	beq.n	80083f4 <AS726X_begin+0x38>
 80083cc:	f7ff fef7 	bl	80081be <AS726X_Get_HW_No>
 80083d0:	283f      	cmp	r0, #63	; 0x3f
 80083d2:	d00f      	beq.n	80083f4 <AS726X_begin+0x38>
		ErrorAddLog(LOG_FUNC_AS726X, LOG_SUB_INIT, LOG_TYPE_ID, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 80083d4:	f000 fe62 	bl	800909c <GetErrorStruct>
 80083d8:	2300      	movs	r3, #0
 80083da:	9003      	str	r0, [sp, #12]
 80083dc:	9302      	str	r3, [sp, #8]
 80083de:	9301      	str	r3, [sp, #4]
 80083e0:	9300      	str	r3, [sp, #0]
 80083e2:	2014      	movs	r0, #20
 80083e4:	2311      	movs	r3, #17
 80083e6:	2213      	movs	r2, #19
 80083e8:	2127      	movs	r1, #39	; 0x27
 80083ea:	f003 ff55 	bl	800c298 <ErrorAddLog>
 80083ee:	2001      	movs	r0, #1
}
 80083f0:	b005      	add	sp, #20
 80083f2:	bd30      	pop	{r4, r5, pc}
		AS726X_setBulbCurrent(0b00); 		//Set to 12.5mA (minimum)
 80083f4:	2000      	movs	r0, #0
 80083f6:	f7ff ffcf 	bl	8008398 <AS726X_setBulbCurrent>
		AS726X_disableBulb(); 				//Turn off to avoid heating the sensor
 80083fa:	f7ff ffc2 	bl	8008382 <AS726X_disableBulb>
		AS726X_disableIndicator();			//Turn off lights to save power
 80083fe:	f7ff ffb5 	bl	800836c <AS726X_disableIndicator>
		AS726X_setIntegrationTime(AS726X_INTEGRATION_TIME);
 8008402:	20d2      	movs	r0, #210	; 0xd2
 8008404:	f7ff ff41 	bl	800828a <AS726X_setIntegrationTime>
		AS726X_setGain(gain); 						//Set gain
 8008408:	4628      	mov	r0, r5
 800840a:	f7ff ff2c 	bl	8008266 <AS726X_setGain>
		AS726X_setMeasurementMode(measurementMode);  //One-shot reading of VBGYOR
 800840e:	4620      	mov	r0, r4
 8008410:	f7ff ff17 	bl	8008242 <AS726X_setMeasurementMode>
		return HAL_OK;
 8008414:	2000      	movs	r0, #0
 8008416:	e7eb      	b.n	80083f0 <AS726X_begin+0x34>

08008418 <AS726X_takeMeasurements>:
{
 8008418:	b530      	push	{r4, r5, lr}
 800841a:	460c      	mov	r4, r1
 800841c:	b087      	sub	sp, #28
	if (AS726X_begin(gain, AS726X_MODE_ONE_SHOT) != HAL_OK) //Gain and One-shot mode
 800841e:	2103      	movs	r1, #3
 8008420:	f7ff ffcc 	bl	80083bc <AS726X_begin>
 8008424:	b1e0      	cbz	r0, 8008460 <AS726X_takeMeasurements+0x48>
		InfoLogAdd(
 8008426:	f000 fe41 	bl	80090ac <GetTempInfoStruct>
 800842a:	2400      	movs	r4, #0
 800842c:	2114      	movs	r1, #20
 800842e:	2511      	movs	r5, #17
 8008430:	9004      	str	r0, [sp, #16]
 8008432:	2320      	movs	r3, #32
 8008434:	2224      	movs	r2, #36	; 0x24
 8008436:	4608      	mov	r0, r1
 8008438:	9403      	str	r4, [sp, #12]
 800843a:	9402      	str	r4, [sp, #8]
 800843c:	9401      	str	r4, [sp, #4]
 800843e:	9500      	str	r5, [sp, #0]
 8008440:	f003 ff7a 	bl	800c338 <InfoLogAdd>
		ErrorAddLog(LOG_FUNC_AS726X, LOG_SUB_MEASURE, LOG_TYPE_INIT, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 8008444:	f000 fe2a 	bl	800909c <GetErrorStruct>
 8008448:	9402      	str	r4, [sp, #8]
 800844a:	9003      	str	r0, [sp, #12]
 800844c:	9401      	str	r4, [sp, #4]
 800844e:	9400      	str	r4, [sp, #0]
 8008450:	462b      	mov	r3, r5
 8008452:	2220      	movs	r2, #32
 8008454:	2124      	movs	r1, #36	; 0x24
 8008456:	2014      	movs	r0, #20
 8008458:	f003 ff1e 	bl	800c298 <ErrorAddLog>
}
 800845c:	b007      	add	sp, #28
 800845e:	bd30      	pop	{r4, r5, pc}
		AS726X_clearDataAvailable(); //Clear DATA_RDY flag when using Mode 3
 8008460:	f7ff ff1e 	bl	80082a0 <AS726X_clearDataAvailable>
		while (AS726X_dataAvailable() == 0)  //todo can get stuck here?
 8008464:	f7ff ff15 	bl	8008292 <AS726X_dataAvailable>
 8008468:	2800      	cmp	r0, #0
 800846a:	d0fb      	beq.n	8008464 <AS726X_takeMeasurements+0x4c>
		AS726X_getSpectrum(sp);
 800846c:	4620      	mov	r0, r4
}
 800846e:	b007      	add	sp, #28
 8008470:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
		AS726X_getSpectrum(sp);
 8008474:	f7ff bf4d 	b.w	8008312 <AS726X_getSpectrum>

08008478 <HDC1080_writeRegister>:
/*
 * Writes to a certain register. Input: data with register and data, the length of the array, error type message.
 * Return hal_ok if success, else hal_error
 */
uint8_t HDC1080_writeRegister(unsigned char* data, uint8_t len, uint8_t throw)
{
 8008478:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint8_t timeOutCounter = 0;

	while (HAL_I2C_Master_Transmit(&hi2c2, HDC1080_ADDR_WRITE, (uint8_t *) data,
 800847c:	4e13      	ldr	r6, [pc, #76]	; (80084cc <HDC1080_writeRegister+0x54>)
{
 800847e:	b085      	sub	sp, #20
 8008480:	4605      	mov	r5, r0
 8008482:	4691      	mov	r9, r2
	while (HAL_I2C_Master_Transmit(&hi2c2, HDC1080_ADDR_WRITE, (uint8_t *) data,
 8008484:	2466      	movs	r4, #102	; 0x66
 8008486:	460f      	mov	r7, r1
 8008488:	f04f 0801 	mov.w	r8, #1
 800848c:	f8cd 8000 	str.w	r8, [sp]
 8008490:	463b      	mov	r3, r7
 8008492:	462a      	mov	r2, r5
 8008494:	2180      	movs	r1, #128	; 0x80
 8008496:	4630      	mov	r0, r6
 8008498:	f7fa f82a 	bl	80024f0 <HAL_I2C_Master_Transmit>
 800849c:	b190      	cbz	r0, 80084c4 <HDC1080_writeRegister+0x4c>
 800849e:	3c01      	subs	r4, #1
			len, 1) != HAL_OK)
	{
		if (timeOutCounter > HDC1080_TIMEOUT_TX_END)
 80084a0:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 80084a4:	d1f2      	bne.n	800848c <HDC1080_writeRegister+0x14>
		{


			ErrorAddLog(LOG_FUNC_HDC1080, LOG_SUB_WRITE, throw, LOG_STATUS_TIMEOUT, data[0], data[1], 0, GetErrorStruct());
 80084a6:	782e      	ldrb	r6, [r5, #0]
 80084a8:	786d      	ldrb	r5, [r5, #1]
 80084aa:	f000 fdf7 	bl	800909c <GetErrorStruct>
 80084ae:	9402      	str	r4, [sp, #8]
 80084b0:	9003      	str	r0, [sp, #12]
 80084b2:	9501      	str	r5, [sp, #4]
 80084b4:	2018      	movs	r0, #24
 80084b6:	9600      	str	r6, [sp, #0]
 80084b8:	2313      	movs	r3, #19
 80084ba:	464a      	mov	r2, r9
 80084bc:	2117      	movs	r1, #23
 80084be:	f003 feeb 	bl	800c298 <ErrorAddLog>
 80084c2:	2001      	movs	r0, #1
			return HAL_ERROR;
		}
		timeOutCounter++;
	}
	return HAL_OK;
}
 80084c4:	b005      	add	sp, #20
 80084c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80084ca:	bf00      	nop
 80084cc:	2000c508 	.word	0x2000c508

080084d0 <HDC1080_readRegister>:



uint8_t HDC1080_readRegister(unsigned char* data, uint8_t len, uint8_t throw)
{
 80084d0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint8_t timeOutCounter = 0;

	while (HAL_I2C_Master_Transmit(&hi2c2, HDC1080_ADDR_WRITE, (uint8_t *) data,
 80084d4:	f8df 9088 	ldr.w	r9, [pc, #136]	; 8008560 <HDC1080_readRegister+0x90>
{
 80084d8:	b085      	sub	sp, #20
 80084da:	4605      	mov	r5, r0
 80084dc:	460e      	mov	r6, r1
 80084de:	4617      	mov	r7, r2
	while (HAL_I2C_Master_Transmit(&hi2c2, HDC1080_ADDR_WRITE, (uint8_t *) data,
 80084e0:	2466      	movs	r4, #102	; 0x66
 80084e2:	f04f 0801 	mov.w	r8, #1
 80084e6:	f8cd 8000 	str.w	r8, [sp]
 80084ea:	2301      	movs	r3, #1
 80084ec:	462a      	mov	r2, r5
 80084ee:	2180      	movs	r1, #128	; 0x80
 80084f0:	4648      	mov	r0, r9
 80084f2:	f7f9 fffd 	bl	80024f0 <HAL_I2C_Master_Transmit>
 80084f6:	b9e8      	cbnz	r0, 8008534 <HDC1080_readRegister+0x64>
			return HAL_ERROR;
		}
		timeOutCounter++;
	}

	HAL_Delay(20);	// todo dont know if needed
 80084f8:	2014      	movs	r0, #20
 80084fa:	f7f8 fccf 	bl	8000e9c <HAL_Delay>

	timeOutCounter = 0;
	while (HAL_I2C_Master_Receive(&hi2c2, HDC1080_ADDR_READ, (uint8_t *) data,
 80084fe:	f8df 8060 	ldr.w	r8, [pc, #96]	; 8008560 <HDC1080_readRegister+0x90>
	HAL_Delay(20);	// todo dont know if needed
 8008502:	2466      	movs	r4, #102	; 0x66
	while (HAL_I2C_Master_Receive(&hi2c2, HDC1080_ADDR_READ, (uint8_t *) data,
 8008504:	b2b6      	uxth	r6, r6
 8008506:	f04f 0901 	mov.w	r9, #1
 800850a:	f8cd 9000 	str.w	r9, [sp]
 800850e:	4633      	mov	r3, r6
 8008510:	462a      	mov	r2, r5
 8008512:	2181      	movs	r1, #129	; 0x81
 8008514:	4640      	mov	r0, r8
 8008516:	f7fa f87f 	bl	8002618 <HAL_I2C_Master_Receive>
 800851a:	b1f0      	cbz	r0, 800855a <HDC1080_readRegister+0x8a>
 800851c:	3c01      	subs	r4, #1
			len, 1) != HAL_OK)
	{
		if (timeOutCounter > HDC1080_TIMEOUT_RX_END)
 800851e:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8008522:	d1f2      	bne.n	800850a <HDC1080_readRegister+0x3a>
		{
			ErrorAddLog(LOG_FUNC_HDC1080, LOG_SUB_READ, throw, LOG_STATUS_TIMEOUT, data[0], 2, 0, GetErrorStruct());
 8008524:	782d      	ldrb	r5, [r5, #0]
 8008526:	f000 fdb9 	bl	800909c <GetErrorStruct>
 800852a:	2302      	movs	r3, #2
 800852c:	9003      	str	r0, [sp, #12]
 800852e:	9402      	str	r4, [sp, #8]
 8008530:	9301      	str	r3, [sp, #4]
 8008532:	e00a      	b.n	800854a <HDC1080_readRegister+0x7a>
 8008534:	3c01      	subs	r4, #1
		if (timeOutCounter > HDC1080_TIMEOUT_TX_END)
 8008536:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 800853a:	d1d4      	bne.n	80084e6 <HDC1080_readRegister+0x16>
			ErrorAddLog(LOG_FUNC_HDC1080, LOG_SUB_READ, throw, LOG_STATUS_TIMEOUT, data[0], 1, 0, GetErrorStruct());
 800853c:	782d      	ldrb	r5, [r5, #0]
 800853e:	f000 fdad 	bl	800909c <GetErrorStruct>
 8008542:	9402      	str	r4, [sp, #8]
 8008544:	9003      	str	r0, [sp, #12]
 8008546:	f8cd 8004 	str.w	r8, [sp, #4]
			ErrorAddLog(LOG_FUNC_HDC1080, LOG_SUB_READ, throw, LOG_STATUS_TIMEOUT, data[0], 2, 0, GetErrorStruct());
 800854a:	2018      	movs	r0, #24
 800854c:	9500      	str	r5, [sp, #0]
 800854e:	2313      	movs	r3, #19
 8008550:	463a      	mov	r2, r7
 8008552:	2115      	movs	r1, #21
 8008554:	f003 fea0 	bl	800c298 <ErrorAddLog>
			return HAL_ERROR;
 8008558:	2001      	movs	r0, #1
		}
		timeOutCounter++;
	}
	return HAL_OK;
}
 800855a:	b005      	add	sp, #20
 800855c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008560:	2000c508 	.word	0x2000c508

08008564 <HDC1080_Get_Device_ID>:
	}
}


uint16_t HDC1080_Get_Device_ID(void)
{
 8008564:	b507      	push	{r0, r1, r2, lr}
	unsigned char data[2] = { 0 };
 8008566:	2300      	movs	r3, #0
	data[0] = HDC1080_DEV_ID_REG; 					 // address of the register
 8008568:	a802      	add	r0, sp, #8
	unsigned char data[2] = { 0 };
 800856a:	f8ad 3004 	strh.w	r3, [sp, #4]
	data[0] = HDC1080_DEV_ID_REG; 					 // address of the register
 800856e:	23ff      	movs	r3, #255	; 0xff
 8008570:	f800 3d04 	strb.w	r3, [r0, #-4]!

	if (HDC1080_readRegister(data, 2, LOG_TYPE_ID) == HAL_OK)  // data, length, LOG_TYPE error
 8008574:	2213      	movs	r2, #19
 8008576:	2102      	movs	r1, #2
 8008578:	f7ff ffaa 	bl	80084d0 <HDC1080_readRegister>
 800857c:	b940      	cbnz	r0, 8008590 <HDC1080_Get_Device_ID+0x2c>
	{
		return (data[0] << 8) | data[1];
 800857e:	f89d 3004 	ldrb.w	r3, [sp, #4]
 8008582:	f89d 0005 	ldrb.w	r0, [sp, #5]
 8008586:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
	}
	else
	{
		return HDC1080_ERROR_VALUE;
	}
}
 800858a:	b003      	add	sp, #12
 800858c:	f85d fb04 	ldr.w	pc, [sp], #4
		return HDC1080_ERROR_VALUE;
 8008590:	f64d 60ad 	movw	r0, #57005	; 0xdead
 8008594:	e7f9      	b.n	800858a <HDC1080_Get_Device_ID+0x26>

08008596 <HDC1080_Init>:
{
 8008596:	b570      	push	{r4, r5, r6, lr}
 8008598:	b088      	sub	sp, #32
	unsigned char data[4] = { 0 };
 800859a:	2400      	movs	r4, #0
	data[0] = HDC1080_CONF_REG;
 800859c:	2602      	movs	r6, #2
	unsigned char data[4] = { 0 };
 800859e:	9407      	str	r4, [sp, #28]
	data[0] = HDC1080_CONF_REG;
 80085a0:	f88d 601c 	strb.w	r6, [sp, #28]
	if (HDC1080_Get_Device_ID() != HDC1080_DEVICE_ID)
 80085a4:	f7ff ffde 	bl	8008564 <HDC1080_Get_Device_ID>
 80085a8:	f241 0350 	movw	r3, #4176	; 0x1050
 80085ac:	4298      	cmp	r0, r3
 80085ae:	d01b      	beq.n	80085e8 <HDC1080_Init+0x52>
		ErrorAddLog(LOG_FUNC_HDC1080, LOG_SUB_INIT, LOG_TYPE_ID, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 80085b0:	f000 fd74 	bl	800909c <GetErrorStruct>
 80085b4:	2311      	movs	r3, #17
 80085b6:	9003      	str	r0, [sp, #12]
 80085b8:	2213      	movs	r2, #19
 80085ba:	2127      	movs	r1, #39	; 0x27
 80085bc:	2018      	movs	r0, #24
 80085be:	9402      	str	r4, [sp, #8]
 80085c0:	9401      	str	r4, [sp, #4]
 80085c2:	9400      	str	r4, [sp, #0]
 80085c4:	f003 fe68 	bl	800c298 <ErrorAddLog>
		InfoLogAdd(ERRORLEVEL_SEVERE,
 80085c8:	f000 fd70 	bl	80090ac <GetTempInfoStruct>
 80085cc:	2311      	movs	r3, #17
 80085ce:	9300      	str	r3, [sp, #0]
 80085d0:	9004      	str	r0, [sp, #16]
 80085d2:	9403      	str	r4, [sp, #12]
 80085d4:	9402      	str	r4, [sp, #8]
 80085d6:	9401      	str	r4, [sp, #4]
 80085d8:	2313      	movs	r3, #19
			InfoLogAdd(
 80085da:	2227      	movs	r2, #39	; 0x27
 80085dc:	2118      	movs	r1, #24
 80085de:	2015      	movs	r0, #21
 80085e0:	f003 feaa 	bl	800c338 <InfoLogAdd>
}
 80085e4:	b008      	add	sp, #32
 80085e6:	bd70      	pop	{r4, r5, r6, pc}
		if (HDC1080_readRegister(data, 2, LOG_TYPE_SET) != HAL_OK)
 80085e8:	2217      	movs	r2, #23
 80085ea:	4631      	mov	r1, r6
 80085ec:	a807      	add	r0, sp, #28
 80085ee:	f7ff ff6f 	bl	80084d0 <HDC1080_readRegister>
 80085f2:	4605      	mov	r5, r0
 80085f4:	b1a8      	cbz	r0, 8008622 <HDC1080_Init+0x8c>
			ErrorAddLog(LOG_FUNC_HDC1080, LOG_SUB_INIT, LOG_TYPE_READ, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 80085f6:	f000 fd51 	bl	800909c <GetErrorStruct>
 80085fa:	2311      	movs	r3, #17
 80085fc:	9003      	str	r0, [sp, #12]
 80085fe:	2214      	movs	r2, #20
 8008600:	2127      	movs	r1, #39	; 0x27
 8008602:	2018      	movs	r0, #24
 8008604:	9402      	str	r4, [sp, #8]
 8008606:	9401      	str	r4, [sp, #4]
 8008608:	9400      	str	r4, [sp, #0]
 800860a:	f003 fe45 	bl	800c298 <ErrorAddLog>
			InfoLogAdd(
 800860e:	f000 fd4d 	bl	80090ac <GetTempInfoStruct>
 8008612:	2311      	movs	r3, #17
 8008614:	9300      	str	r3, [sp, #0]
 8008616:	9004      	str	r0, [sp, #16]
 8008618:	9403      	str	r4, [sp, #12]
 800861a:	9402      	str	r4, [sp, #8]
 800861c:	9401      	str	r4, [sp, #4]
 800861e:	2314      	movs	r3, #20
 8008620:	e7db      	b.n	80085da <HDC1080_Init+0x44>
			uint16_t confReg = (data[0] << 8) | data[1];
 8008622:	f89d 201c 	ldrb.w	r2, [sp, #28]
 8008626:	f89d 301d 	ldrb.w	r3, [sp, #29]
			data[0] = HDC1080_CONF_REG;
 800862a:	f88d 601c 	strb.w	r6, [sp, #28]
			uint16_t confReg = (data[0] << 8) | data[1];
 800862e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			confReg |= 1 << 13;		//	heater disabled 0 ; enable 1
 8008632:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
			data[1] = (uint8_t) ((confReg >> 8) & 0xFF);  	//	msb
 8008636:	0a1a      	lsrs	r2, r3, #8
 8008638:	f88d 201d 	strb.w	r2, [sp, #29]
			if (HDC1080_writeRegister(data, 3, LOG_TYPE_SET) != HAL_OK)
 800863c:	2103      	movs	r1, #3
 800863e:	2217      	movs	r2, #23
 8008640:	a807      	add	r0, sp, #28
			data[2] = (uint8_t) (confReg & 0xFF);  			//	lsb
 8008642:	f88d 301e 	strb.w	r3, [sp, #30]
			if (HDC1080_writeRegister(data, 3, LOG_TYPE_SET) != HAL_OK)
 8008646:	f7ff ff17 	bl	8008478 <HDC1080_writeRegister>
 800864a:	b1a8      	cbz	r0, 8008678 <HDC1080_Init+0xe2>
				ErrorAddLog(LOG_FUNC_HDC1080, LOG_SUB_INIT, LOG_TYPE_WRITE, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 800864c:	f000 fd26 	bl	800909c <GetErrorStruct>
 8008650:	2311      	movs	r3, #17
 8008652:	9003      	str	r0, [sp, #12]
 8008654:	2215      	movs	r2, #21
 8008656:	2127      	movs	r1, #39	; 0x27
 8008658:	2018      	movs	r0, #24
 800865a:	9502      	str	r5, [sp, #8]
 800865c:	9501      	str	r5, [sp, #4]
 800865e:	9500      	str	r5, [sp, #0]
 8008660:	f003 fe1a 	bl	800c298 <ErrorAddLog>
				InfoLogAdd(
 8008664:	f000 fd22 	bl	80090ac <GetTempInfoStruct>
 8008668:	2311      	movs	r3, #17
 800866a:	9300      	str	r3, [sp, #0]
 800866c:	9004      	str	r0, [sp, #16]
 800866e:	9503      	str	r5, [sp, #12]
 8008670:	9502      	str	r5, [sp, #8]
 8008672:	9501      	str	r5, [sp, #4]
 8008674:	2315      	movs	r3, #21
 8008676:	e7b0      	b.n	80085da <HDC1080_Init+0x44>
				HDC1080_readRegister(data, 2, LOG_TYPE_SET);
 8008678:	2217      	movs	r2, #23
 800867a:	4631      	mov	r1, r6
 800867c:	a807      	add	r0, sp, #28
				data[0] = HDC1080_CONF_REG;
 800867e:	f88d 601c 	strb.w	r6, [sp, #28]
				HDC1080_readRegister(data, 2, LOG_TYPE_SET);
 8008682:	f7ff ff25 	bl	80084d0 <HDC1080_readRegister>
}
 8008686:	e7ad      	b.n	80085e4 <HDC1080_Init+0x4e>

08008688 <HDC1080_Get_Humidity_raw>:
	}
}


uint16_t HDC1080_Get_Humidity_raw(void)
{
 8008688:	b510      	push	{r4, lr}
 800868a:	b088      	sub	sp, #32
	unsigned char data[2] = { 0 };
	data[0] = HDC1080_HUM_REG;
 800868c:	a808      	add	r0, sp, #32
	unsigned char data[2] = { 0 };
 800868e:	2400      	movs	r4, #0
	data[0] = HDC1080_HUM_REG;
 8008690:	2301      	movs	r3, #1
	unsigned char data[2] = { 0 };
 8008692:	f8ad 401c 	strh.w	r4, [sp, #28]
	if (HDC1080_readRegister(data, 2, LOG_TYPE_GET_HUM) == HAL_OK)
 8008696:	221f      	movs	r2, #31
	data[0] = HDC1080_HUM_REG;
 8008698:	f800 3d04 	strb.w	r3, [r0, #-4]!
	if (HDC1080_readRegister(data, 2, LOG_TYPE_GET_HUM) == HAL_OK)
 800869c:	2102      	movs	r1, #2
 800869e:	f7ff ff17 	bl	80084d0 <HDC1080_readRegister>
 80086a2:	b938      	cbnz	r0, 80086b4 <HDC1080_Get_Humidity_raw+0x2c>
	{
		return (data[0] << 8) | data[1];
 80086a4:	f89d 301c 	ldrb.w	r3, [sp, #28]
 80086a8:	f89d 001d 	ldrb.w	r0, [sp, #29]
 80086ac:	ea40 2003 	orr.w	r0, r0, r3, lsl #8
		LOG_TYPE_READ,
		LOG_STATUS_FAIL, 0, 0, 0, GetTempInfoStruct());

		return HDC1080_ERROR_VALUE;
	}
}
 80086b0:	b008      	add	sp, #32
 80086b2:	bd10      	pop	{r4, pc}
		InfoLogAdd(ERRORLEVEL_WARNING,
 80086b4:	f000 fcfa 	bl	80090ac <GetTempInfoStruct>
 80086b8:	2311      	movs	r3, #17
 80086ba:	9300      	str	r3, [sp, #0]
 80086bc:	2314      	movs	r3, #20
 80086be:	9004      	str	r0, [sp, #16]
 80086c0:	9403      	str	r4, [sp, #12]
 80086c2:	4618      	mov	r0, r3
 80086c4:	9402      	str	r4, [sp, #8]
 80086c6:	9401      	str	r4, [sp, #4]
 80086c8:	2239      	movs	r2, #57	; 0x39
 80086ca:	2118      	movs	r1, #24
 80086cc:	f003 fe34 	bl	800c338 <InfoLogAdd>
 80086d0:	f64d 60ad 	movw	r0, #57005	; 0xdead
 80086d4:	e7ec      	b.n	80086b0 <HDC1080_Get_Humidity_raw+0x28>
	...

080086d8 <HDC1080_Get_Humidity>:
/*
 * Calc from datasheet.
 * Gives Relative Humidity in %
 */
uint8_t HDC1080_Get_Humidity(void)
{
 80086d8:	b507      	push	{r0, r1, r2, lr}
	float temp = 100.0 * (float) HDC1080_Get_Humidity_raw() / 65536.0;
 80086da:	f7ff ffd5 	bl	8008688 <HDC1080_Get_Humidity_raw>
 80086de:	ee07 0a90 	vmov	s15, r0
 80086e2:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80086e6:	ee17 0a90 	vmov	r0, s15
 80086ea:	f7f7 ff45 	bl	8000578 <__aeabi_f2d>
 80086ee:	2200      	movs	r2, #0
 80086f0:	4b13      	ldr	r3, [pc, #76]	; (8008740 <HDC1080_Get_Humidity+0x68>)
 80086f2:	f7f7 ff95 	bl	8000620 <__aeabi_dmul>
 80086f6:	2200      	movs	r2, #0
 80086f8:	4b12      	ldr	r3, [pc, #72]	; (8008744 <HDC1080_Get_Humidity+0x6c>)
 80086fa:	f7f7 ff91 	bl	8000620 <__aeabi_dmul>
 80086fe:	f7f8 f9c1 	bl	8000a84 <__aeabi_d2f>

	if (temp > 100)
 8008702:	ed9f 7a11 	vldr	s14, [pc, #68]	; 8008748 <HDC1080_Get_Humidity+0x70>
	float temp = 100.0 * (float) HDC1080_Get_Humidity_raw() / 65536.0;
 8008706:	ee07 0a90 	vmov	s15, r0
	if (temp > 100)
 800870a:	eef4 7ac7 	vcmpe.f32	s15, s14
 800870e:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008712:	dc11      	bgt.n	8008738 <HDC1080_Get_Humidity+0x60>
	{
		temp = 100;
	}
	else if (temp < 0)
	{
		temp = 0;
 8008714:	eef5 7a40 	vcmp.f32	s15, #0.0
 8008718:	ed9f 7a0c 	vldr	s14, [pc, #48]	; 800874c <HDC1080_Get_Humidity+0x74>
 800871c:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
 8008720:	bf48      	it	mi
 8008722:	eef0 7a47 	vmovmi.f32	s15, s14
	}

	return (uint8_t) temp;
 8008726:	eefc 7ae7 	vcvt.u32.f32	s15, s15
 800872a:	edcd 7a01 	vstr	s15, [sp, #4]
}
 800872e:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8008732:	b003      	add	sp, #12
 8008734:	f85d fb04 	ldr.w	pc, [sp], #4
		temp = 100;
 8008738:	eef0 7a47 	vmov.f32	s15, s14
 800873c:	e7f3      	b.n	8008726 <HDC1080_Get_Humidity+0x4e>
 800873e:	bf00      	nop
 8008740:	40590000 	.word	0x40590000
 8008744:	3ef00000 	.word	0x3ef00000
 8008748:	42c80000 	.word	0x42c80000
 800874c:	00000000 	.word	0x00000000

08008750 <MultiSensor_takeMeasurements>:
 * Todo Organize and change name to this file
 *
 */

void MultiSensor_takeMeasurements(SensorData *sd)				// todo try to make this simultaneously to reduce sensor reading time
{
 8008750:	b537      	push	{r0, r1, r2, r4, r5, lr}
	testCounter++;
 8008752:	4a13      	ldr	r2, [pc, #76]	; (80087a0 <MultiSensor_takeMeasurements+0x50>)
 8008754:	8813      	ldrh	r3, [r2, #0]
{
 8008756:	4604      	mov	r4, r0
	testCounter++;
 8008758:	3301      	adds	r3, #1

	float lux;
	VEML7700_GetAutoALSLux(&lux);
 800875a:	a801      	add	r0, sp, #4
	testCounter++;
 800875c:	8013      	strh	r3, [r2, #0]
	VEML7700_GetAutoALSLux(&lux);
 800875e:	f000 fc3b 	bl	8008fd8 <VEML7700_GetAutoALSLux>
	sd->tempHumLux = (((0b11111111 & TMP112_ReadTemp()) << 7) | (0b1111111 & HDC1080_Get_Humidity())
 8008762:	f000 f9c5 	bl	8008af0 <TMP112_ReadTemp>
 8008766:	4605      	mov	r5, r0
 8008768:	f7ff ffb6 	bl	80086d8 <HDC1080_Get_Humidity>
			| ((0b11111111111111111 & (int) lux) << 15));
 800876c:	eddd 7a01 	vldr	s15, [sp, #4]
 8008770:	eefd 7ae7 	vcvt.s32.f32	s15, s15
	sd->tempHumLux = (((0b11111111 & TMP112_ReadTemp()) << 7) | (0b1111111 & HDC1080_Get_Humidity())
 8008774:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 8008778:	ea40 13c5 	orr.w	r3, r0, r5, lsl #7
			| ((0b11111111111111111 & (int) lux) << 15));
 800877c:	ee17 0a90 	vmov	r0, s15
 8008780:	ea43 30c0 	orr.w	r0, r3, r0, lsl #15
	sd->tempHumLux = (((0b11111111 & TMP112_ReadTemp()) << 7) | (0b1111111 & HDC1080_Get_Humidity())
 8008784:	f844 0b04 	str.w	r0, [r4], #4

	HAL_GPIO_WritePin(Temperature_EN_GPIO_Port, Temperature_EN_Pin, GPIO_PIN_RESET);
 8008788:	2200      	movs	r2, #0
 800878a:	2140      	movs	r1, #64	; 0x40
 800878c:	4805      	ldr	r0, [pc, #20]	; (80087a4 <MultiSensor_takeMeasurements+0x54>)
 800878e:	f7f9 fcef 	bl	8002170 <HAL_GPIO_WritePin>

	AS726X_takeMeasurements(AS7262_GAIN_3_7, &(sd->spectrum));
 8008792:	4621      	mov	r1, r4
 8008794:	2001      	movs	r0, #1
 8008796:	f7ff fe3f 	bl	8008418 <AS726X_takeMeasurements>
}
 800879a:	b003      	add	sp, #12
 800879c:	bd30      	pop	{r4, r5, pc}
 800879e:	bf00      	nop
 80087a0:	20000298 	.word	0x20000298
 80087a4:	48000400 	.word	0x48000400

080087a8 <DataStruct_init>:
}


void DataStruct_init(Data *data)
{
	data->sensCounter = 0;
 80087a8:	f645 2208 	movw	r2, #23048	; 0x5a08
 80087ac:	2300      	movs	r3, #0
 80087ae:	5283      	strh	r3, [r0, r2]
	data->dayCounter = 0;
 80087b0:	f645 220a 	movw	r2, #23050	; 0x5a0a
 80087b4:	5483      	strb	r3, [r0, r2]
	data->readData.timeStamp = 0;
 80087b6:	6003      	str	r3, [r0, #0]
	data->readData.batteryLevel = 0;
 80087b8:	7103      	strb	r3, [r0, #4]
	data->readData.foo = 0;
 80087ba:	7143      	strb	r3, [r0, #5]
	data->readData.fooo = 0;
 80087bc:	80c3      	strh	r3, [r0, #6]
 80087be:	4770      	bx	lr

080087c0 <PrintSensorData>:

/*
 * Prints the collected sensorData
 */
void PrintSensorData(Data *data)
{
 80087c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80087c4:	4604      	mov	r4, r0
	printf(
 80087c6:	7902      	ldrb	r2, [r0, #4]
 80087c8:	6801      	ldr	r1, [r0, #0]

	uint16_t i;

	for (i = 0; i < data->sensCounter; i++)
	{
		printf("\t Temp[%lu] Humidity[%lu] \t Lux[%lu] Violet[%u] Blue[%u] Green[%u] Yellow[%u] Orange[%u] Red[%u]  \r\n ", ((data->readData.sensData[i].tempHumLux >> 7) & 0b11111111) / 5,
 80087ca:	f8df 806c 	ldr.w	r8, [pc, #108]	; 8008838 <PrintSensorData+0x78>
	printf(
 80087ce:	4818      	ldr	r0, [pc, #96]	; (8008830 <PrintSensorData+0x70>)
{
 80087d0:	b086      	sub	sp, #24
	for (i = 0; i < data->sensCounter; i++)
 80087d2:	f504 45b4 	add.w	r5, r4, #23040	; 0x5a00
	printf(
 80087d6:	f004 fda1 	bl	800d31c <iprintf>
	for (i = 0; i < data->sensCounter; i++)
 80087da:	3508      	adds	r5, #8
 80087dc:	2300      	movs	r3, #0
		printf("\t Temp[%lu] Humidity[%lu] \t Lux[%lu] Violet[%u] Blue[%u] Green[%u] Yellow[%u] Orange[%u] Red[%u]  \r\n ", ((data->readData.sensData[i].tempHumLux >> 7) & 0b11111111) / 5,
 80087de:	2705      	movs	r7, #5
	for (i = 0; i < data->sensCounter; i++)
 80087e0:	8829      	ldrh	r1, [r5, #0]
 80087e2:	b29a      	uxth	r2, r3
 80087e4:	4291      	cmp	r1, r2
 80087e6:	f103 0601 	add.w	r6, r3, #1
 80087ea:	d805      	bhi.n	80087f8 <PrintSensorData+0x38>
				(data->readData.sensData[i].tempHumLux & 0b1111111), data->readData.sensData[i].tempHumLux >> 15, data->readData.sensData[i].spectrum.violet,
				data->readData.sensData[i].spectrum.blue,
				data->readData.sensData[i].spectrum.green, data->readData.sensData[i].spectrum.yellow, data->readData.sensData[i].spectrum.orange, data->readData.sensData[i].spectrum.red);
	}
	printf("\r\n\r\n");
 80087ec:	4811      	ldr	r0, [pc, #68]	; (8008834 <PrintSensorData+0x74>)
}
 80087ee:	b006      	add	sp, #24
 80087f0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	printf("\r\n\r\n");
 80087f4:	f004 be1a 	b.w	800d42c <puts>
 80087f8:	b29b      	uxth	r3, r3
		printf("\t Temp[%lu] Humidity[%lu] \t Lux[%lu] Violet[%u] Blue[%u] Green[%u] Yellow[%u] Orange[%u] Red[%u]  \r\n ", ((data->readData.sensData[i].tempHumLux >> 7) & 0b11111111) / 5,
 80087fa:	eb04 1303 	add.w	r3, r4, r3, lsl #4
 80087fe:	8ad8      	ldrh	r0, [r3, #22]
 8008800:	689a      	ldr	r2, [r3, #8]
 8008802:	9005      	str	r0, [sp, #20]
 8008804:	8a98      	ldrh	r0, [r3, #20]
 8008806:	9004      	str	r0, [sp, #16]
 8008808:	8a58      	ldrh	r0, [r3, #18]
 800880a:	9003      	str	r0, [sp, #12]
 800880c:	8a18      	ldrh	r0, [r3, #16]
 800880e:	9002      	str	r0, [sp, #8]
 8008810:	89d8      	ldrh	r0, [r3, #14]
 8008812:	9001      	str	r0, [sp, #4]
 8008814:	899b      	ldrh	r3, [r3, #12]
 8008816:	9300      	str	r3, [sp, #0]
 8008818:	f3c2 11c7 	ubfx	r1, r2, #7, #8
 800881c:	0bd3      	lsrs	r3, r2, #15
 800881e:	fbb1 f1f7 	udiv	r1, r1, r7
 8008822:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 8008826:	4640      	mov	r0, r8
 8008828:	f004 fd78 	bl	800d31c <iprintf>
 800882c:	4633      	mov	r3, r6
 800882e:	e7d7      	b.n	80087e0 <PrintSensorData+0x20>
 8008830:	0800f7a8 	.word	0x0800f7a8
 8008834:	0800fe7e 	.word	0x0800fe7e
 8008838:	0800f7c6 	.word	0x0800f7c6

0800883c <TMP112_writeRegister>:
#include "Error.h"
#include "utils.h"


uint8_t TMP112_writeRegister(unsigned char* data, uint8_t len, uint8_t throw)
{
 800883c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint8_t timeOutCounter = 0;

	while (HAL_I2C_Master_Transmit(&hi2c2, TMP112_ADDR_WRITE, (uint8_t *) data,
 8008840:	4d1a      	ldr	r5, [pc, #104]	; (80088ac <TMP112_writeRegister+0x70>)
{
 8008842:	b087      	sub	sp, #28
 8008844:	4606      	mov	r6, r0
 8008846:	4690      	mov	r8, r2
	while (HAL_I2C_Master_Transmit(&hi2c2, TMP112_ADDR_WRITE, (uint8_t *) data,
 8008848:	2434      	movs	r4, #52	; 0x34
 800884a:	460f      	mov	r7, r1
 800884c:	f04f 0901 	mov.w	r9, #1
 8008850:	f8cd 9000 	str.w	r9, [sp]
 8008854:	463b      	mov	r3, r7
 8008856:	4632      	mov	r2, r6
 8008858:	2190      	movs	r1, #144	; 0x90
 800885a:	4628      	mov	r0, r5
 800885c:	f7f9 fe48 	bl	80024f0 <HAL_I2C_Master_Transmit>
 8008860:	b300      	cbz	r0, 80088a4 <TMP112_writeRegister+0x68>
 8008862:	3c01      	subs	r4, #1
			len, 1) != HAL_OK)
	{

		if (timeOutCounter > TMP112_TIMEOUT_TX_END)
 8008864:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8008868:	d1f2      	bne.n	8008850 <TMP112_writeRegister+0x14>
		{
			InfoLogAdd(ERRORLEVEL_SEVERE,
 800886a:	f000 fc1f 	bl	80090ac <GetTempInfoStruct>
 800886e:	2513      	movs	r5, #19
 8008870:	462b      	mov	r3, r5
 8008872:	2217      	movs	r2, #23
 8008874:	2116      	movs	r1, #22
 8008876:	9004      	str	r0, [sp, #16]
 8008878:	9403      	str	r4, [sp, #12]
 800887a:	2015      	movs	r0, #21
 800887c:	9402      	str	r4, [sp, #8]
 800887e:	9401      	str	r4, [sp, #4]
 8008880:	9500      	str	r5, [sp, #0]
 8008882:	f003 fd59 	bl	800c338 <InfoLogAdd>
			LOG_FUNC_TMP112,
			LOG_SUB_WRITE,
			LOG_TYPE_ID,
			LOG_STATUS_TIMEOUT, 0, 0, 0, GetTempInfoStruct());

			ErrorAddLog(LOG_FUNC_TMP112, LOG_SUB_WRITE, throw, LOG_STATUS_TIMEOUT, data[1], data[0], 0, GetErrorStruct());
 8008886:	7877      	ldrb	r7, [r6, #1]
 8008888:	7836      	ldrb	r6, [r6, #0]
 800888a:	f000 fc07 	bl	800909c <GetErrorStruct>
 800888e:	9402      	str	r4, [sp, #8]
 8008890:	9003      	str	r0, [sp, #12]
 8008892:	9601      	str	r6, [sp, #4]
 8008894:	2016      	movs	r0, #22
 8008896:	9700      	str	r7, [sp, #0]
 8008898:	462b      	mov	r3, r5
 800889a:	4642      	mov	r2, r8
 800889c:	2117      	movs	r1, #23
 800889e:	f003 fcfb 	bl	800c298 <ErrorAddLog>
 80088a2:	2001      	movs	r0, #1
		}

		timeOutCounter++;
	}
	return HAL_OK;
}
 80088a4:	b007      	add	sp, #28
 80088a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80088aa:	bf00      	nop
 80088ac:	2000c508 	.word	0x2000c508

080088b0 <TMP112_readRegister>:

uint16_t TMP112_readRegister(unsigned char* data, uint8_t len, uint8_t throw)
{
 80088b0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	uint8_t timeOutCounter = 0;

	while (HAL_I2C_Master_Transmit(&hi2c2, TMP112_ADDR_WRITE, (uint8_t *) data,
 80088b4:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 8008958 <TMP112_readRegister+0xa8>
{
 80088b8:	b087      	sub	sp, #28
 80088ba:	4605      	mov	r5, r0
 80088bc:	460e      	mov	r6, r1
 80088be:	4617      	mov	r7, r2
	while (HAL_I2C_Master_Transmit(&hi2c2, TMP112_ADDR_WRITE, (uint8_t *) data,
 80088c0:	2434      	movs	r4, #52	; 0x34
 80088c2:	f04f 0801 	mov.w	r8, #1
 80088c6:	f8cd 8000 	str.w	r8, [sp]
 80088ca:	2301      	movs	r3, #1
 80088cc:	462a      	mov	r2, r5
 80088ce:	2190      	movs	r1, #144	; 0x90
 80088d0:	4648      	mov	r0, r9
 80088d2:	f7f9 fe0d 	bl	80024f0 <HAL_I2C_Master_Transmit>
 80088d6:	b9d0      	cbnz	r0, 800890e <TMP112_readRegister+0x5e>
		}
		timeOutCounter++;
	}

	timeOutCounter = 0;
	while (HAL_I2C_Master_Receive(&hi2c2, TMP112_ADDR_READ, (uint8_t *) data,
 80088d8:	f8df 807c 	ldr.w	r8, [pc, #124]	; 8008958 <TMP112_readRegister+0xa8>
 80088dc:	2434      	movs	r4, #52	; 0x34
 80088de:	b2b6      	uxth	r6, r6
 80088e0:	f04f 0901 	mov.w	r9, #1
 80088e4:	f8cd 9000 	str.w	r9, [sp]
 80088e8:	4633      	mov	r3, r6
 80088ea:	462a      	mov	r2, r5
 80088ec:	2191      	movs	r1, #145	; 0x91
 80088ee:	4640      	mov	r0, r8
 80088f0:	f7f9 fe92 	bl	8002618 <HAL_I2C_Master_Receive>
 80088f4:	b368      	cbz	r0, 8008952 <TMP112_readRegister+0xa2>
 80088f6:	3c01      	subs	r4, #1
			len, 1) != HAL_OK)
	{
		if (timeOutCounter > TMP112_TIMEOUT_RX_END)
 80088f8:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 80088fc:	d1f2      	bne.n	80088e4 <TMP112_readRegister+0x34>
		{
			InfoLogAdd(ERRORLEVEL_SEVERE,
 80088fe:	782e      	ldrb	r6, [r5, #0]
 8008900:	f000 fbd4 	bl	80090ac <GetTempInfoStruct>
 8008904:	f04f 0802 	mov.w	r8, #2
 8008908:	9004      	str	r0, [sp, #16]
 800890a:	9403      	str	r4, [sp, #12]
 800890c:	e008      	b.n	8008920 <TMP112_readRegister+0x70>
 800890e:	3c01      	subs	r4, #1
		if (timeOutCounter > TMP112_TIMEOUT_TX_END)
 8008910:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8008914:	d1d7      	bne.n	80088c6 <TMP112_readRegister+0x16>
			InfoLogAdd(ERRORLEVEL_SEVERE,
 8008916:	782e      	ldrb	r6, [r5, #0]
 8008918:	f000 fbc8 	bl	80090ac <GetTempInfoStruct>
 800891c:	9403      	str	r4, [sp, #12]
 800891e:	9004      	str	r0, [sp, #16]
			InfoLogAdd(ERRORLEVEL_SEVERE,
 8008920:	2215      	movs	r2, #21
 8008922:	9601      	str	r6, [sp, #4]
 8008924:	2613      	movs	r6, #19
 8008926:	4633      	mov	r3, r6
 8008928:	2116      	movs	r1, #22
 800892a:	4610      	mov	r0, r2
 800892c:	f8cd 8008 	str.w	r8, [sp, #8]
 8008930:	9600      	str	r6, [sp, #0]
 8008932:	f003 fd01 	bl	800c338 <InfoLogAdd>
			LOG_FUNC_TMP112,
			LOG_SUB_READ,
			LOG_TYPE_ID,
			LOG_STATUS_TIMEOUT, data[0], 2, 0, GetTempInfoStruct());

			ErrorAddLog(LOG_FUNC_TMP112, LOG_SUB_READ, throw, LOG_STATUS_TIMEOUT, data[0], 2, 0, GetErrorStruct());
 8008936:	782d      	ldrb	r5, [r5, #0]
 8008938:	f000 fbb0 	bl	800909c <GetErrorStruct>
 800893c:	9402      	str	r4, [sp, #8]
 800893e:	9003      	str	r0, [sp, #12]
 8008940:	e88d 0120 	stmia.w	sp, {r5, r8}
 8008944:	2016      	movs	r0, #22
 8008946:	4633      	mov	r3, r6
 8008948:	463a      	mov	r2, r7
 800894a:	2115      	movs	r1, #21
 800894c:	f003 fca4 	bl	800c298 <ErrorAddLog>
			return HAL_ERROR;
 8008950:	2001      	movs	r0, #1
		}
		timeOutCounter++;
	}
	return HAL_OK;
}
 8008952:	b007      	add	sp, #28
 8008954:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008958:	2000c508 	.word	0x2000c508

0800895c <TMP112_Init>:


void TMP112_Init(void)
{
 800895c:	b507      	push	{r0, r1, r2, lr}
	unsigned char data_t[4] = { 0 };
 800895e:	2300      	movs	r3, #0
 8008960:	9301      	str	r3, [sp, #4]

	/* Set TMP112 into Shutdown mode */
	data_t[0] = TMP112_CONF_REG;
 8008962:	2301      	movs	r3, #1
 8008964:	f88d 3004 	strb.w	r3, [sp, #4]
	data_t[1] = 0x61; //0x61 = SD enable
 8008968:	2361      	movs	r3, #97	; 0x61
 800896a:	f88d 3005 	strb.w	r3, [sp, #5]
	data_t[2] = 0xA0; //Default values of byte 2 in configuration register

	TMP112_writeRegister(data_t, 3, LOG_TYPE_INIT);
 800896e:	2220      	movs	r2, #32
	data_t[2] = 0xA0; //Default values of byte 2 in configuration register
 8008970:	23a0      	movs	r3, #160	; 0xa0
	TMP112_writeRegister(data_t, 3, LOG_TYPE_INIT);
 8008972:	2103      	movs	r1, #3
 8008974:	a801      	add	r0, sp, #4
	data_t[2] = 0xA0; //Default values of byte 2 in configuration register
 8008976:	f88d 3006 	strb.w	r3, [sp, #6]
	TMP112_writeRegister(data_t, 3, LOG_TYPE_INIT);
 800897a:	f7ff ff5f 	bl	800883c <TMP112_writeRegister>
}
 800897e:	b003      	add	sp, #12
 8008980:	f85d fb04 	ldr.w	pc, [sp], #4

08008984 <TMP112_StartOneShot>:

/*
 *  Sets up one short setting
 */
uint8_t TMP112_StartOneShot(void)
{
 8008984:	b507      	push	{r0, r1, r2, lr}
	unsigned char data_t[4] = { 0 };
 8008986:	2300      	movs	r3, #0
 8008988:	9301      	str	r3, [sp, #4]

	/* Set TMP112 into OneShot mode */
	data_t[0] = TMP112_CONF_REG;
 800898a:	2301      	movs	r3, #1
 800898c:	f88d 3004 	strb.w	r3, [sp, #4]
	data_t[1] = 0xE1; //0xE1 = SD enable & OS enable
 8008990:	23e1      	movs	r3, #225	; 0xe1
 8008992:	f88d 3005 	strb.w	r3, [sp, #5]
	data_t[2] = 0xA0; //Default values of byte 2 in configuration register

	/* Send data to sensor */
	return TMP112_writeRegister(data_t, 3, LOG_TYPE_START_ONESHOT);
 8008996:	221b      	movs	r2, #27
	data_t[2] = 0xA0; //Default values of byte 2 in configuration register
 8008998:	23a0      	movs	r3, #160	; 0xa0
	return TMP112_writeRegister(data_t, 3, LOG_TYPE_START_ONESHOT);
 800899a:	2103      	movs	r1, #3
 800899c:	a801      	add	r0, sp, #4
	data_t[2] = 0xA0; //Default values of byte 2 in configuration register
 800899e:	f88d 3006 	strb.w	r3, [sp, #6]
	return TMP112_writeRegister(data_t, 3, LOG_TYPE_START_ONESHOT);
 80089a2:	f7ff ff4b 	bl	800883c <TMP112_writeRegister>
}
 80089a6:	b003      	add	sp, #12
 80089a8:	f85d fb04 	ldr.w	pc, [sp], #4

080089ac <TMP112_WaitForOneShot>:

uint8_t TMP112_WaitForOneShot(void)
{
 80089ac:	b573      	push	{r0, r1, r4, r5, r6, lr}
	unsigned char data[2] = { 0 };
	data[0] = TMP112_CONF_REG;
 80089ae:	ae02      	add	r6, sp, #8
	unsigned char data[2] = { 0 };
 80089b0:	2500      	movs	r5, #0
	data[0] = TMP112_CONF_REG;
 80089b2:	2301      	movs	r3, #1
	unsigned char data[2] = { 0 };
 80089b4:	f8ad 5004 	strh.w	r5, [sp, #4]
	data[0] = TMP112_CONF_REG;
 80089b8:	f806 3d04 	strb.w	r3, [r6, #-4]!
	uint8_t timeOutCounter = 25; // wait total of max 100ms (4*25)
 80089bc:	2419      	movs	r4, #25
	uint8_t ret = 0;

	while ((data[0] & 0x80) == 0 && timeOutCounter--)
 80089be:	f99d 3004 	ldrsb.w	r3, [sp, #4]
 80089c2:	2b00      	cmp	r3, #0
 80089c4:	db03      	blt.n	80089ce <TMP112_WaitForOneShot+0x22>
 80089c6:	3c01      	subs	r4, #1
 80089c8:	b2e4      	uxtb	r4, r4
 80089ca:	2cff      	cmp	r4, #255	; 0xff
 80089cc:	d105      	bne.n	80089da <TMP112_WaitForOneShot+0x2e>
			HAL_Delay(4);
		}
	}

	/* SUCCESS only if everything went OK */
	return (ret == HAL_OK && timeOutCounter > 0) ? HAL_OK : HAL_ERROR;
 80089ce:	b995      	cbnz	r5, 80089f6 <TMP112_WaitForOneShot+0x4a>
 80089d0:	fab4 f084 	clz	r0, r4
 80089d4:	0940      	lsrs	r0, r0, #5
}
 80089d6:	b002      	add	sp, #8
 80089d8:	bd70      	pop	{r4, r5, r6, pc}
		ret = TMP112_readRegister(data, 2, LOG_TYPE_WAIT_ONESHOT);
 80089da:	221c      	movs	r2, #28
 80089dc:	2102      	movs	r1, #2
 80089de:	4630      	mov	r0, r6
 80089e0:	f7ff ff66 	bl	80088b0 <TMP112_readRegister>
		if ((data[0] & 0x80) == 0)
 80089e4:	f99d 3004 	ldrsb.w	r3, [sp, #4]
 80089e8:	2b00      	cmp	r3, #0
		ret = TMP112_readRegister(data, 2, LOG_TYPE_WAIT_ONESHOT);
 80089ea:	b2c5      	uxtb	r5, r0
		if ((data[0] & 0x80) == 0)
 80089ec:	dbe7      	blt.n	80089be <TMP112_WaitForOneShot+0x12>
			HAL_Delay(4);
 80089ee:	2004      	movs	r0, #4
 80089f0:	f7f8 fa54 	bl	8000e9c <HAL_Delay>
 80089f4:	e7e3      	b.n	80089be <TMP112_WaitForOneShot+0x12>
 80089f6:	2001      	movs	r0, #1
 80089f8:	e7ed      	b.n	80089d6 <TMP112_WaitForOneShot+0x2a>

080089fa <TMP112_GetTemperature_raw>:

/*
 * Gets the raw value from the temp register
 */
uint8_t TMP112_GetTemperature_raw(uint16_t *get)
{
 80089fa:	b513      	push	{r0, r1, r4, lr}
 80089fc:	4604      	mov	r4, r0
	unsigned char data[2] = { 0 };
 80089fe:	a802      	add	r0, sp, #8
 8008a00:	2300      	movs	r3, #0
 8008a02:	f820 3d04 	strh.w	r3, [r0, #-4]!

	uint8_t ret = HAL_OK;
	data[0] = TMP112_TEMP_REG;

	ret = TMP112_readRegister(data, 2, LOG_TYPE_GET_TEMP);
 8008a06:	221d      	movs	r2, #29
 8008a08:	2102      	movs	r1, #2
 8008a0a:	f7ff ff51 	bl	80088b0 <TMP112_readRegister>

	/* 12 bit temperature */
	*get = (((data[0] << 8) | data[1]) >> 4);
 8008a0e:	f8bd 3004 	ldrh.w	r3, [sp, #4]
 8008a12:	ba5b      	rev16	r3, r3
 8008a14:	f3c3 130b 	ubfx	r3, r3, #4, #12

	return ret;
}
 8008a18:	b2c0      	uxtb	r0, r0
	*get = (((data[0] << 8) | data[1]) >> 4);
 8008a1a:	8023      	strh	r3, [r4, #0]
}
 8008a1c:	b002      	add	sp, #8
 8008a1e:	bd10      	pop	{r4, pc}

08008a20 <TMP112_ReadTemp_raw>:
/*
 * Reads the raw value from the temp register.
 * Returns a 12 bit two's complement value. range: (-2047) - (2047)
 */
uint16_t TMP112_ReadTemp_raw(void)
{
 8008a20:	b570      	push	{r4, r5, r6, lr}
 8008a22:	b088      	sub	sp, #32
	uint8_t ret = HAL_OK;
	uint16_t temp = 0;
 8008a24:	2500      	movs	r5, #0
 8008a26:	f8ad 501e 	strh.w	r5, [sp, #30]

	/* Set one shot */
	ret = TMP112_StartOneShot();
 8008a2a:	f7ff ffab 	bl	8008984 <TMP112_StartOneShot>
	if (ret != HAL_OK)
 8008a2e:	4604      	mov	r4, r0
 8008a30:	2800      	cmp	r0, #0
 8008a32:	d039      	beq.n	8008aa8 <TMP112_ReadTemp_raw+0x88>
	{
		InfoLogAdd(
 8008a34:	f000 fb3a 	bl	80090ac <GetTempInfoStruct>
 8008a38:	2411      	movs	r4, #17
 8008a3a:	231c      	movs	r3, #28
 8008a3c:	221d      	movs	r2, #29
 8008a3e:	9004      	str	r0, [sp, #16]
 8008a40:	2116      	movs	r1, #22
 8008a42:	2015      	movs	r0, #21
 8008a44:	9503      	str	r5, [sp, #12]
 8008a46:	9502      	str	r5, [sp, #8]
 8008a48:	9501      	str	r5, [sp, #4]
 8008a4a:	9400      	str	r4, [sp, #0]
 8008a4c:	f003 fc74 	bl	800c338 <InfoLogAdd>
				0,
				0,
				0,
				GetTempInfoStruct());
		
		ErrorAddLog(LOG_FUNC_TMP112, LOG_SUB_READTEMP, LOG_TYPE_WAIT_ONESHOT, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 8008a50:	f000 fb24 	bl	800909c <GetErrorStruct>
 8008a54:	9502      	str	r5, [sp, #8]
 8008a56:	9003      	str	r0, [sp, #12]
 8008a58:	9501      	str	r5, [sp, #4]
 8008a5a:	9500      	str	r5, [sp, #0]
 8008a5c:	4623      	mov	r3, r4
 8008a5e:	221c      	movs	r2, #28
					0,
					0,
					0,
					GetTempInfoStruct());
			
			ErrorAddLog(LOG_FUNC_TMP112, LOG_SUB_READTEMP, LOG_TYPE_START_ONESHOT, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 8008a60:	211d      	movs	r1, #29
 8008a62:	2016      	movs	r0, #22
 8008a64:	f003 fc18 	bl	800c298 <ErrorAddLog>
	}

	/* If get temperature fails, send back Invalid temperature representation */
	if (ret != HAL_OK)
	{
		temp = TMP112_INVALID_TEMP;
 8008a68:	2400      	movs	r4, #0
 8008a6a:	f8ad 401e 	strh.w	r4, [sp, #30]

		InfoLogAdd(
 8008a6e:	f000 fb1d 	bl	80090ac <GetTempInfoStruct>
 8008a72:	2511      	movs	r5, #17
 8008a74:	231d      	movs	r3, #29
 8008a76:	461a      	mov	r2, r3
 8008a78:	9004      	str	r0, [sp, #16]
 8008a7a:	2116      	movs	r1, #22
 8008a7c:	9403      	str	r4, [sp, #12]
 8008a7e:	9402      	str	r4, [sp, #8]
 8008a80:	9401      	str	r4, [sp, #4]
 8008a82:	9500      	str	r5, [sp, #0]
 8008a84:	2015      	movs	r0, #21
 8008a86:	f003 fc57 	bl	800c338 <InfoLogAdd>
				0,
				temp,
				0,
				GetTempInfoStruct());
		
		ErrorAddLog(LOG_FUNC_TMP112, LOG_SUB_READTEMP, LOG_TYPE_GET_TEMP, LOG_STATUS_FAIL, temp, 0, 0, GetErrorStruct());
 8008a8a:	f8bd 601e 	ldrh.w	r6, [sp, #30]
 8008a8e:	f000 fb05 	bl	800909c <GetErrorStruct>
 8008a92:	221d      	movs	r2, #29
 8008a94:	9003      	str	r0, [sp, #12]
 8008a96:	9402      	str	r4, [sp, #8]
 8008a98:	9401      	str	r4, [sp, #4]
 8008a9a:	9600      	str	r6, [sp, #0]
 8008a9c:	462b      	mov	r3, r5
 8008a9e:	4611      	mov	r1, r2
 8008aa0:	2016      	movs	r0, #22
 8008aa2:	f003 fbf9 	bl	800c298 <ErrorAddLog>
 8008aa6:	e01f      	b.n	8008ae8 <TMP112_ReadTemp_raw+0xc8>
		ret = TMP112_WaitForOneShot();
 8008aa8:	f7ff ff80 	bl	80089ac <TMP112_WaitForOneShot>
		if (ret != HAL_OK)
 8008aac:	b1b0      	cbz	r0, 8008adc <TMP112_ReadTemp_raw+0xbc>
			InfoLogAdd(
 8008aae:	f000 fafd 	bl	80090ac <GetTempInfoStruct>
 8008ab2:	2511      	movs	r5, #17
 8008ab4:	231b      	movs	r3, #27
 8008ab6:	221d      	movs	r2, #29
 8008ab8:	9004      	str	r0, [sp, #16]
 8008aba:	2116      	movs	r1, #22
 8008abc:	2015      	movs	r0, #21
 8008abe:	9403      	str	r4, [sp, #12]
 8008ac0:	9402      	str	r4, [sp, #8]
 8008ac2:	9401      	str	r4, [sp, #4]
 8008ac4:	9500      	str	r5, [sp, #0]
 8008ac6:	f003 fc37 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(LOG_FUNC_TMP112, LOG_SUB_READTEMP, LOG_TYPE_START_ONESHOT, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 8008aca:	f000 fae7 	bl	800909c <GetErrorStruct>
 8008ace:	9402      	str	r4, [sp, #8]
 8008ad0:	9003      	str	r0, [sp, #12]
 8008ad2:	9401      	str	r4, [sp, #4]
 8008ad4:	9400      	str	r4, [sp, #0]
 8008ad6:	462b      	mov	r3, r5
 8008ad8:	221b      	movs	r2, #27
 8008ada:	e7c1      	b.n	8008a60 <TMP112_ReadTemp_raw+0x40>
			ret = TMP112_GetTemperature_raw(&temp);
 8008adc:	f10d 001e 	add.w	r0, sp, #30
 8008ae0:	f7ff ff8b 	bl	80089fa <TMP112_GetTemperature_raw>
	if (ret != HAL_OK)
 8008ae4:	2800      	cmp	r0, #0
 8008ae6:	d1bf      	bne.n	8008a68 <TMP112_ReadTemp_raw+0x48>
	}
	return temp;
}
 8008ae8:	f8bd 001e 	ldrh.w	r0, [sp, #30]
 8008aec:	b008      	add	sp, #32
 8008aee:	bd70      	pop	{r4, r5, r6, pc}

08008af0 <TMP112_ReadTemp>:
 * Reads and calculates the temperature. Multiplies by 10 means that we get a 1 decimal number.
 * Example: returns 241 means 24,1 celsius.
 * Can use 9 bits -> max value is then 51,1 degrees.
 */
uint8_t TMP112_ReadTemp(void)
{
 8008af0:	b530      	push	{r4, r5, lr}
 8008af2:	b087      	sub	sp, #28

	/* Calculate temp */
	uint16_t raw = TMP112_ReadTemp_raw();
 8008af4:	f7ff ff94 	bl	8008a20 <TMP112_ReadTemp_raw>

	if (raw == TMP112_INVALID_TEMP)
 8008af8:	4604      	mov	r4, r0
 8008afa:	b378      	cbz	r0, 8008b5c <TMP112_ReadTemp+0x6c>
	{
		return TMP112_INVALID_TEMP;
	}

	double tempCalc = (double) (raw & 0xFFF);
 8008afc:	f3c0 000b 	ubfx	r0, r0, #0, #12
 8008b00:	f7f7 fd28 	bl	8000554 <__aeabi_i2d>

	/* Check if number is negative (bit 11 == 1, raw >= 0x800). Can't represent negative values */
	if (BitTst(raw, 11))
 8008b04:	0523      	lsls	r3, r4, #20
 8008b06:	d51d      	bpl.n	8008b44 <TMP112_ReadTemp+0x54>
	{
		InfoLogAdd(
 8008b08:	f000 fad0 	bl	80090ac <GetTempInfoStruct>
 8008b0c:	2500      	movs	r5, #0
 8008b0e:	231d      	movs	r3, #29
 8008b10:	9402      	str	r4, [sp, #8]
 8008b12:	2416      	movs	r4, #22
 8008b14:	461a      	mov	r2, r3
 8008b16:	4621      	mov	r1, r4
 8008b18:	9004      	str	r0, [sp, #16]
 8008b1a:	9503      	str	r5, [sp, #12]
 8008b1c:	2014      	movs	r0, #20
 8008b1e:	9501      	str	r5, [sp, #4]
 8008b20:	9400      	str	r4, [sp, #0]
 8008b22:	f003 fc09 	bl	800c338 <InfoLogAdd>
				0,
				raw,
				0,
				GetTempInfoStruct());
		
		ErrorAddLog(LOG_FUNC_TMP112, LOG_SUB_READTEMP, LOG_TYPE_GET_TEMP, LOG_STATUS_MIN, 0, 0, 0, GetErrorStruct());
 8008b26:	f000 fab9 	bl	800909c <GetErrorStruct>
 8008b2a:	221d      	movs	r2, #29
 8008b2c:	9003      	str	r0, [sp, #12]
 8008b2e:	9502      	str	r5, [sp, #8]
 8008b30:	4620      	mov	r0, r4
 8008b32:	9501      	str	r5, [sp, #4]
 8008b34:	9500      	str	r5, [sp, #0]
 8008b36:	4623      	mov	r3, r4
 8008b38:	4611      	mov	r1, r2
 8008b3a:	f003 fbad 	bl	800c298 <ErrorAddLog>
		return TMP112_INVALID_TEMP;
 8008b3e:	4628      	mov	r0, r5
	{
		temp = TMP112_MAX_TEMP;
	}

	return temp;
}
 8008b40:	b007      	add	sp, #28
 8008b42:	bd30      	pop	{r4, r5, pc}
	uint8_t temp = (uint8_t) (5 * tempCalc / 16.0);
 8008b44:	2200      	movs	r2, #0
 8008b46:	4b06      	ldr	r3, [pc, #24]	; (8008b60 <TMP112_ReadTemp+0x70>)
 8008b48:	f7f7 fd6a 	bl	8000620 <__aeabi_dmul>
 8008b4c:	2200      	movs	r2, #0
 8008b4e:	4b05      	ldr	r3, [pc, #20]	; (8008b64 <TMP112_ReadTemp+0x74>)
 8008b50:	f7f7 fd66 	bl	8000620 <__aeabi_dmul>
 8008b54:	f7f7 ff76 	bl	8000a44 <__aeabi_d2uiz>
 8008b58:	b2c0      	uxtb	r0, r0
	return temp;
 8008b5a:	e7f1      	b.n	8008b40 <TMP112_ReadTemp+0x50>
 8008b5c:	e7f0      	b.n	8008b40 <TMP112_ReadTemp+0x50>
 8008b5e:	bf00      	nop
 8008b60:	40140000 	.word	0x40140000
 8008b64:	3fb00000 	.word	0x3fb00000

08008b68 <VEML7700_ReadData>:
	}
	return HAL_OK;
}

static uint8_t VEML7700_ReadData(uint8_t reg, uint16_t *data)
{
 8008b68:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8008b6c:	b087      	sub	sp, #28
	unsigned char data_r[3] = { 0 };
 8008b6e:	ad05      	add	r5, sp, #20
 8008b70:	2300      	movs	r3, #0
	while (HAL_I2C_Mem_Read(&hi2c2, VEML7700_ADDR_READ, reg, 1, data, len, 10) != HAL_OK)
 8008b72:	4f12      	ldr	r7, [pc, #72]	; (8008bbc <VEML7700_ReadData+0x54>)
	unsigned char data_r[3] = { 0 };
 8008b74:	f8ad 3014 	strh.w	r3, [sp, #20]
{
 8008b78:	460e      	mov	r6, r1
	unsigned char data_r[3] = { 0 };
 8008b7a:	70ab      	strb	r3, [r5, #2]
 8008b7c:	2466      	movs	r4, #102	; 0x66
	while (HAL_I2C_Mem_Read(&hi2c2, VEML7700_ADDR_READ, reg, 1, data, len, 10) != HAL_OK)
 8008b7e:	4680      	mov	r8, r0
 8008b80:	f04f 090a 	mov.w	r9, #10
 8008b84:	2302      	movs	r3, #2
 8008b86:	9301      	str	r3, [sp, #4]
 8008b88:	f8cd 9008 	str.w	r9, [sp, #8]
 8008b8c:	9500      	str	r5, [sp, #0]
 8008b8e:	2301      	movs	r3, #1
 8008b90:	4642      	mov	r2, r8
 8008b92:	2121      	movs	r1, #33	; 0x21
 8008b94:	4638      	mov	r0, r7
 8008b96:	f7f9 fdd3 	bl	8002740 <HAL_I2C_Mem_Read>
 8008b9a:	b938      	cbnz	r0, 8008bac <VEML7700_ReadData+0x44>

	if (VEML7700_readRegister(reg, data_r, 2) == HAL_OK)
	{
		*data = (data_r[0] + data_r[1] * 256);
 8008b9c:	f89d 2015 	ldrb.w	r2, [sp, #21]
 8008ba0:	f89d 3014 	ldrb.w	r3, [sp, #20]
 8008ba4:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 8008ba8:	8033      	strh	r3, [r6, #0]
		return STATUS_OK;
 8008baa:	e004      	b.n	8008bb6 <VEML7700_ReadData+0x4e>
 8008bac:	3c01      	subs	r4, #1
		if (timeOutCounter > VEML7700_TIMEOUT_RX_END)
 8008bae:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8008bb2:	d1e7      	bne.n	8008b84 <VEML7700_ReadData+0x1c>
	}
	return STATUS_ERROR;
 8008bb4:	20ff      	movs	r0, #255	; 0xff
//	}
//
//	*data = (rData[0] | (rData[1] << 8)); //LSB first
//
//	return STATUS_OK;
}
 8008bb6:	b007      	add	sp, #28
 8008bb8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8008bbc:	2000c508 	.word	0x2000c508

08008bc0 <VEML7700_GetALS>:
	return VEML7700_SendData(COMMAND_ALS_WL, thresh);
}

uint8_t VEML7700_GetALS(uint16_t *als)
{
	return VEML7700_ReadData(COMMAND_ALS, als);
 8008bc0:	4601      	mov	r1, r0
 8008bc2:	2004      	movs	r0, #4
 8008bc4:	f7ff bfd0 	b.w	8008b68 <VEML7700_ReadData>

08008bc8 <VEML7700_SendData>:
{
 8008bc8:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char data_t[4] = { 0 };
 8008bca:	2300      	movs	r3, #0
 8008bcc:	9303      	str	r3, [sp, #12]
	while (HAL_I2C_Master_Transmit(&hi2c2, VEML7700_ADDR_WRITE, (uint8_t *) data, len, 10) != HAL_OK)
 8008bce:	4d0d      	ldr	r5, [pc, #52]	; (8008c04 <VEML7700_SendData+0x3c>)
	data_t[1] = (data & 0xff);
 8008bd0:	f88d 100d 	strb.w	r1, [sp, #13]
	data_t[2] = (data >> 8);
 8008bd4:	0a09      	lsrs	r1, r1, #8
	data_t[0] = reg;
 8008bd6:	f88d 000c 	strb.w	r0, [sp, #12]
	data_t[2] = (data >> 8);
 8008bda:	f88d 100e 	strb.w	r1, [sp, #14]
 8008bde:	2466      	movs	r4, #102	; 0x66
	while (HAL_I2C_Master_Transmit(&hi2c2, VEML7700_ADDR_WRITE, (uint8_t *) data, len, 10) != HAL_OK)
 8008be0:	260a      	movs	r6, #10
 8008be2:	9600      	str	r6, [sp, #0]
 8008be4:	2303      	movs	r3, #3
 8008be6:	aa03      	add	r2, sp, #12
 8008be8:	2120      	movs	r1, #32
 8008bea:	4628      	mov	r0, r5
 8008bec:	f7f9 fc80 	bl	80024f0 <HAL_I2C_Master_Transmit>
 8008bf0:	b908      	cbnz	r0, 8008bf6 <VEML7700_SendData+0x2e>
}
 8008bf2:	b004      	add	sp, #16
 8008bf4:	bd70      	pop	{r4, r5, r6, pc}
 8008bf6:	3c01      	subs	r4, #1
		if (timeOutCounter > VEML7700_TIMEOUT_TX_END)
 8008bf8:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
 8008bfc:	d1f1      	bne.n	8008be2 <VEML7700_SendData+0x1a>
	return STATUS_ERROR;
 8008bfe:	20ff      	movs	r0, #255	; 0xff
 8008c00:	e7f7      	b.n	8008bf2 <VEML7700_SendData+0x2a>
 8008c02:	bf00      	nop
 8008c04:	2000c508 	.word	0x2000c508

08008c08 <VEML7700_Initialize>:
{
 8008c08:	b538      	push	{r3, r4, r5, lr}
	register_cache[0] = (((uint16_t) (ALS_GAIN_x2) << ALS_SM_SHIFT)
 8008c0a:	4d0c      	ldr	r5, [pc, #48]	; (8008c3c <VEML7700_Initialize+0x34>)
 8008c0c:	f44f 6200 	mov.w	r2, #2048	; 0x800
 8008c10:	802a      	strh	r2, [r5, #0]
	register_cache[2] = 0xffff;
 8008c12:	f64f 72ff 	movw	r2, #65535	; 0xffff
	register_cache[1] = 0x0000;
 8008c16:	2400      	movs	r4, #0
	register_cache[2] = 0xffff;
 8008c18:	80aa      	strh	r2, [r5, #4]
	register_cache[3] = (((uint16_t) (ALS_POWER_MODE_3) << PSM_SHIFT)
 8008c1a:	2204      	movs	r2, #4
	register_cache[1] = 0x0000;
 8008c1c:	806c      	strh	r4, [r5, #2]
	register_cache[3] = (((uint16_t) (ALS_POWER_MODE_3) << PSM_SHIFT)
 8008c1e:	80ea      	strh	r2, [r5, #6]
		VEML7700_SendData(i, register_cache[i]);
 8008c20:	f835 1014 	ldrh.w	r1, [r5, r4, lsl #1]
 8008c24:	b2e0      	uxtb	r0, r4
 8008c26:	3401      	adds	r4, #1
 8008c28:	f7ff ffce 	bl	8008bc8 <VEML7700_SendData>
	for (uint8_t i = 0; i < 4; i++)
 8008c2c:	2c04      	cmp	r4, #4
 8008c2e:	d1f7      	bne.n	8008c20 <VEML7700_Initialize+0x18>
	HAL_Delay(3);
 8008c30:	2003      	movs	r0, #3
}
 8008c32:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	HAL_Delay(3);
 8008c36:	f7f8 b931 	b.w	8000e9c <HAL_Delay>
 8008c3a:	bf00      	nop
 8008c3c:	200008c0 	.word	0x200008c0

08008c40 <VEML7700_SetGain>:
	uint16_t reg = ((register_cache[COMMAND_ALS_SM] & ~ALS_SM_MASK)
 8008c40:	4b06      	ldr	r3, [pc, #24]	; (8008c5c <VEML7700_SetGain+0x1c>)
 8008c42:	8819      	ldrh	r1, [r3, #0]
			| (((uint16_t) (gain) << ALS_SM_SHIFT) & ALS_SM_MASK));
 8008c44:	02c0      	lsls	r0, r0, #11
 8008c46:	f400 50c0 	and.w	r0, r0, #6144	; 0x1800
	uint16_t reg = ((register_cache[COMMAND_ALS_SM] & ~ALS_SM_MASK)
 8008c4a:	f421 51c0 	bic.w	r1, r1, #6144	; 0x1800
			| (((uint16_t) (gain) << ALS_SM_SHIFT) & ALS_SM_MASK));
 8008c4e:	4301      	orrs	r1, r0
	uint16_t reg = ((register_cache[COMMAND_ALS_SM] & ~ALS_SM_MASK)
 8008c50:	b289      	uxth	r1, r1
	return VEML7700_SendData(COMMAND_ALS_SM, reg);
 8008c52:	2000      	movs	r0, #0
	register_cache[COMMAND_ALS_SM] = reg;
 8008c54:	8019      	strh	r1, [r3, #0]
	return VEML7700_SendData(COMMAND_ALS_SM, reg);
 8008c56:	f7ff bfb7 	b.w	8008bc8 <VEML7700_SendData>
 8008c5a:	bf00      	nop
 8008c5c:	200008c0 	.word	0x200008c0

08008c60 <VEML7700_GetGain>:
	*gain = (als_gain_t) ((register_cache[COMMAND_ALS_SM] & ALS_SM_MASK) >> ALS_SM_SHIFT);
 8008c60:	4b03      	ldr	r3, [pc, #12]	; (8008c70 <VEML7700_GetGain+0x10>)
 8008c62:	881b      	ldrh	r3, [r3, #0]
 8008c64:	f3c3 23c1 	ubfx	r3, r3, #11, #2
 8008c68:	7003      	strb	r3, [r0, #0]
}
 8008c6a:	2000      	movs	r0, #0
 8008c6c:	4770      	bx	lr
 8008c6e:	bf00      	nop
 8008c70:	200008c0 	.word	0x200008c0

08008c74 <VEML7700_SetIntegrationTime>:
	uint16_t reg = ((register_cache[COMMAND_ALS_IT] & ~ALS_IT_MASK)
 8008c74:	4b06      	ldr	r3, [pc, #24]	; (8008c90 <VEML7700_SetIntegrationTime+0x1c>)
 8008c76:	8819      	ldrh	r1, [r3, #0]
			| (((uint16_t) (itime) << ALS_IT_SHIFT) & ALS_IT_MASK));
 8008c78:	0180      	lsls	r0, r0, #6
 8008c7a:	f400 7070 	and.w	r0, r0, #960	; 0x3c0
	uint16_t reg = ((register_cache[COMMAND_ALS_IT] & ~ALS_IT_MASK)
 8008c7e:	f421 7170 	bic.w	r1, r1, #960	; 0x3c0
			| (((uint16_t) (itime) << ALS_IT_SHIFT) & ALS_IT_MASK));
 8008c82:	4301      	orrs	r1, r0
	uint16_t reg = ((register_cache[COMMAND_ALS_IT] & ~ALS_IT_MASK)
 8008c84:	b289      	uxth	r1, r1
	return VEML7700_SendData(COMMAND_ALS_IT, reg);
 8008c86:	2000      	movs	r0, #0
	register_cache[COMMAND_ALS_IT] = reg;
 8008c88:	8019      	strh	r1, [r3, #0]
	return VEML7700_SendData(COMMAND_ALS_IT, reg);
 8008c8a:	f7ff bf9d 	b.w	8008bc8 <VEML7700_SendData>
 8008c8e:	bf00      	nop
 8008c90:	200008c0 	.word	0x200008c0

08008c94 <VEML7700_GetIntegrationTime>:
	*itime = (als_itime_t) ((register_cache[COMMAND_ALS_IT] & ALS_IT_MASK) >> ALS_IT_SHIFT);
 8008c94:	4b03      	ldr	r3, [pc, #12]	; (8008ca4 <VEML7700_GetIntegrationTime+0x10>)
 8008c96:	881b      	ldrh	r3, [r3, #0]
 8008c98:	f3c3 1383 	ubfx	r3, r3, #6, #4
 8008c9c:	7003      	strb	r3, [r0, #0]
}
 8008c9e:	2000      	movs	r0, #0
 8008ca0:	4770      	bx	lr
 8008ca2:	bf00      	nop
 8008ca4:	200008c0 	.word	0x200008c0

08008ca8 <VEML7700_SetPower>:
	uint16_t reg = ((register_cache[COMMAND_ALS_SD] & ~ALS_SD_MASK)
 8008ca8:	4a0a      	ldr	r2, [pc, #40]	; (8008cd4 <VEML7700_SetPower+0x2c>)
 8008caa:	8811      	ldrh	r1, [r2, #0]
{
 8008cac:	b538      	push	{r3, r4, r5, lr}
	uint16_t reg = ((register_cache[COMMAND_ALS_SD] & ~ALS_SD_MASK)
 8008cae:	f021 0301 	bic.w	r3, r1, #1
			| (((uint16_t) (~on) << ALS_SD_SHIFT) & ALS_SD_MASK));
 8008cb2:	43c1      	mvns	r1, r0
 8008cb4:	f001 0101 	and.w	r1, r1, #1
 8008cb8:	4319      	orrs	r1, r3
	uint16_t reg = ((register_cache[COMMAND_ALS_SD] & ~ALS_SD_MASK)
 8008cba:	b289      	uxth	r1, r1
{
 8008cbc:	4604      	mov	r4, r0
	uint8_t status = VEML7700_SendData(COMMAND_ALS_SD, reg);
 8008cbe:	2000      	movs	r0, #0
	register_cache[COMMAND_ALS_SD] = reg;
 8008cc0:	8011      	strh	r1, [r2, #0]
	uint8_t status = VEML7700_SendData(COMMAND_ALS_SD, reg);
 8008cc2:	f7ff ff81 	bl	8008bc8 <VEML7700_SendData>
 8008cc6:	4605      	mov	r5, r0
	if (on)
 8008cc8:	b114      	cbz	r4, 8008cd0 <VEML7700_SetPower+0x28>
		HAL_Delay(3); // minimu 2.5us delay per datasheet
 8008cca:	2003      	movs	r0, #3
 8008ccc:	f7f8 f8e6 	bl	8000e9c <HAL_Delay>
}
 8008cd0:	4628      	mov	r0, r5
 8008cd2:	bd38      	pop	{r3, r4, r5, pc}
 8008cd4:	200008c0 	.word	0x200008c0

08008cd8 <VEML7700_ScaleLux>:

	return status;
}

void VEML7700_ScaleLux(uint16_t raw_counts, float *lux)
{
 8008cd8:	b507      	push	{r0, r1, r2, lr}
 8008cda:	ee07 0a90 	vmov	s15, r0
	als_gain_t gain;
	als_itime_t itime;

	VEML7700_GetGain(&gain);
 8008cde:	f10d 0006 	add.w	r0, sp, #6
 8008ce2:	f7ff ffbd 	bl	8008c60 <VEML7700_GetGain>
	VEML7700_GetIntegrationTime(&itime);
 8008ce6:	f10d 0007 	add.w	r0, sp, #7
 8008cea:	f7ff ffd3 	bl	8008c94 <VEML7700_GetIntegrationTime>
 8008cee:	f89d 3006 	ldrb.w	r3, [sp, #6]
 8008cf2:	f003 0303 	and.w	r3, r3, #3
 8008cf6:	3b01      	subs	r3, #1
 8008cf8:	b2db      	uxtb	r3, r3
 8008cfa:	2b02      	cmp	r3, #2
 8008cfc:	bf9c      	itt	ls
 8008cfe:	4a17      	ldrls	r2, [pc, #92]	; (8008d5c <VEML7700_ScaleLux+0x84>)
 8008d00:	eb02 0383 	addls.w	r3, r2, r3, lsl #2
	default:
		factor1 = 1.f;
		break;
	}

	switch (itime)
 8008d04:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8008d08:	bf94      	ite	ls
 8008d0a:	edd3 6a00 	vldrls	s13, [r3]
	switch (gain & 0x3)
 8008d0e:	eef7 6a00 	vmovhi.f32	s13, #112	; 0x3f800000  1.0
 8008d12:	2a08      	cmp	r2, #8
 8008d14:	bf94      	ite	ls
 8008d16:	4b12      	ldrls	r3, [pc, #72]	; (8008d60 <VEML7700_ScaleLux+0x88>)
	switch (itime)
 8008d18:	ed9f 7a12 	vldrhi	s14, [pc, #72]	; 8008d64 <VEML7700_ScaleLux+0x8c>
	default:
		factor2 = 0.2304f;
		break;
	}

	*lux = raw_counts * factor1 * factor2;
 8008d1c:	eef8 7ae7 	vcvt.f32.s32	s15, s15
 8008d20:	bf9c      	itt	ls
 8008d22:	eb03 0382 	addls.w	r3, r3, r2, lsl #2
 8008d26:	ed93 7a00 	vldrls	s14, [r3]
 8008d2a:	ee67 7aa6 	vmul.f32	s15, s15, s13

	/* Apply correction from App. Note for all readings using Horner's method */
	*lux = *lux * (1.0023f + *lux * (8.1488e-5f + *lux * (-9.3924e-9f + *lux * 6.0135e-13f)));
 8008d2e:	eddf 6a0e 	vldr	s13, [pc, #56]	; 8008d68 <VEML7700_ScaleLux+0x90>
	*lux = raw_counts * factor1 * factor2;
 8008d32:	ee67 7a87 	vmul.f32	s15, s15, s14
	*lux = *lux * (1.0023f + *lux * (8.1488e-5f + *lux * (-9.3924e-9f + *lux * 6.0135e-13f)));
 8008d36:	ed9f 7a0d 	vldr	s14, [pc, #52]	; 8008d6c <VEML7700_ScaleLux+0x94>
 8008d3a:	eea7 7aa6 	vfma.f32	s14, s15, s13
 8008d3e:	eddf 6a0c 	vldr	s13, [pc, #48]	; 8008d70 <VEML7700_ScaleLux+0x98>
 8008d42:	eee7 6a87 	vfma.f32	s13, s15, s14
 8008d46:	ed9f 7a0b 	vldr	s14, [pc, #44]	; 8008d74 <VEML7700_ScaleLux+0x9c>
 8008d4a:	eea7 7aa6 	vfma.f32	s14, s15, s13
 8008d4e:	ee67 7a27 	vmul.f32	s15, s14, s15
 8008d52:	edc1 7a00 	vstr	s15, [r1]
}
 8008d56:	b003      	add	sp, #12
 8008d58:	f85d fb04 	ldr.w	pc, [sp], #4
 8008d5c:	0800f82c 	.word	0x0800f82c
 8008d60:	0800f838 	.word	0x0800f838
 8008d64:	3e6bedfa 	.word	0x3e6bedfa
 8008d68:	2b2943d6 	.word	0x2b2943d6
 8008d6c:	b2215c36 	.word	0xb2215c36
 8008d70:	38aae489 	.word	0x38aae489
 8008d74:	3f804b5e 	.word	0x3f804b5e

08008d78 <VEML7700_SampleDelay>:
//					 auto_itime,
//					 raw_counts);
//}

uint8_t VEML7700_SampleDelay(void)
{
 8008d78:	b513      	push	{r0, r1, r4, lr}
	als_itime_t itime;
	uint8_t status = VEML7700_GetIntegrationTime(&itime);
 8008d7a:	f10d 0007 	add.w	r0, sp, #7
 8008d7e:	f7ff ff89 	bl	8008c94 <VEML7700_GetIntegrationTime>

	switch (itime) {
 8008d82:	f89d 3007 	ldrb.w	r3, [sp, #7]
	uint8_t status = VEML7700_GetIntegrationTime(&itime);
 8008d86:	4604      	mov	r4, r0
	switch (itime) {
 8008d88:	2b0c      	cmp	r3, #12
 8008d8a:	d819      	bhi.n	8008dc0 <VEML7700_SampleDelay+0x48>
 8008d8c:	e8df f003 	tbb	[pc, r3]
 8008d90:	15120f18 	.word	0x15120f18
 8008d94:	18181818 	.word	0x18181818
 8008d98:	1818180d 	.word	0x1818180d
 8008d9c:	07          	.byte	0x07
 8008d9d:	00          	.byte	0x00
	case ALS_INTEGRATION_25ms:
		EXTENDEN_DELAY(25);
 8008d9e:	2032      	movs	r0, #50	; 0x32
	case ALS_INTEGRATION_800ms:
		EXTENDEN_DELAY(800);
		break;

	default:
		EXTENDEN_DELAY(100);
 8008da0:	f7f8 f87c 	bl	8000e9c <HAL_Delay>
		break;
	}

	return status;
}
 8008da4:	4620      	mov	r0, r4
 8008da6:	b002      	add	sp, #8
 8008da8:	bd10      	pop	{r4, pc}
		EXTENDEN_DELAY(50);
 8008daa:	2064      	movs	r0, #100	; 0x64
 8008dac:	e7f8      	b.n	8008da0 <VEML7700_SampleDelay+0x28>
		EXTENDEN_DELAY(200);
 8008dae:	f44f 70c8 	mov.w	r0, #400	; 0x190
 8008db2:	e7f5      	b.n	8008da0 <VEML7700_SampleDelay+0x28>
		EXTENDEN_DELAY(400);
 8008db4:	f44f 7048 	mov.w	r0, #800	; 0x320
 8008db8:	e7f2      	b.n	8008da0 <VEML7700_SampleDelay+0x28>
		EXTENDEN_DELAY(800);
 8008dba:	f44f 60c8 	mov.w	r0, #1600	; 0x640
 8008dbe:	e7ef      	b.n	8008da0 <VEML7700_SampleDelay+0x28>
		EXTENDEN_DELAY(100);
 8008dc0:	20c8      	movs	r0, #200	; 0xc8
 8008dc2:	e7ed      	b.n	8008da0 <VEML7700_SampleDelay+0x28>

08008dc4 <VEML7700_GetAutoXLux>:
{
 8008dc4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8008dc8:	b08f      	sub	sp, #60	; 0x3c
	als_gain_t gains[5] = { ALS_GAIN_d8, ALS_GAIN_d4, ALS_GAIN_x1, ALS_GAIN_x2, 0 };
 8008dca:	2500      	movs	r5, #0
{
 8008dcc:	9109      	str	r1, [sp, #36]	; 0x24
	als_itime_t itimes[7] = { ALS_INTEGRATION_25ms, ALS_INTEGRATION_50ms, ALS_INTEGRATION_100ms,
 8008dce:	210c      	movs	r1, #12
	als_gain_t gains[5] = { ALS_GAIN_d8, ALS_GAIN_d4, ALS_GAIN_x1, ALS_GAIN_x2, 0 };
 8008dd0:	2402      	movs	r4, #2
{
 8008dd2:	4682      	mov	sl, r0
 8008dd4:	9206      	str	r2, [sp, #24]
 8008dd6:	9307      	str	r3, [sp, #28]
	als_gain_t gains[5] = { ALS_GAIN_d8, ALS_GAIN_d4, ALS_GAIN_x1, ALS_GAIN_x2, 0 };
 8008dd8:	2201      	movs	r2, #1
 8008dda:	2303      	movs	r3, #3
	als_itime_t itimes[7] = { ALS_INTEGRATION_25ms, ALS_INTEGRATION_50ms, ALS_INTEGRATION_100ms,
 8008ddc:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
	if (VEML7700_SetPower(0))
 8008de0:	4628      	mov	r0, r5
	als_itime_t itimes[7] = { ALS_INTEGRATION_25ms, ALS_INTEGRATION_50ms, ALS_INTEGRATION_100ms,
 8008de2:	2108      	movs	r1, #8
{
 8008de4:	9e18      	ldr	r6, [sp, #96]	; 0x60
	als_gain_t gains[5] = { ALS_GAIN_d8, ALS_GAIN_d4, ALS_GAIN_x1, ALS_GAIN_x2, 0 };
 8008de6:	f88d 4028 	strb.w	r4, [sp, #40]	; 0x28
 8008dea:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8008dee:	f88d 502a 	strb.w	r5, [sp, #42]	; 0x2a
 8008df2:	f88d 202b 	strb.w	r2, [sp, #43]	; 0x2b
 8008df6:	f88d 502c 	strb.w	r5, [sp, #44]	; 0x2c
	als_itime_t itimes[7] = { ALS_INTEGRATION_25ms, ALS_INTEGRATION_50ms, ALS_INTEGRATION_100ms,
 8008dfa:	f88d 1031 	strb.w	r1, [sp, #49]	; 0x31
 8008dfe:	f88d 5032 	strb.w	r5, [sp, #50]	; 0x32
 8008e02:	f88d 2033 	strb.w	r2, [sp, #51]	; 0x33
 8008e06:	f88d 4034 	strb.w	r4, [sp, #52]	; 0x34
 8008e0a:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
 8008e0e:	f88d 5036 	strb.w	r5, [sp, #54]	; 0x36
	if (VEML7700_SetPower(0))
 8008e12:	f7ff ff49 	bl	8008ca8 <VEML7700_SetPower>
 8008e16:	b148      	cbz	r0, 8008e2c <VEML7700_GetAutoXLux+0x68>
		InfoLogAdd(ERRORLEVEL_SEVERE,
 8008e18:	f000 f948 	bl	80090ac <GetTempInfoStruct>
 8008e1c:	9503      	str	r5, [sp, #12]
 8008e1e:	9004      	str	r0, [sp, #16]
 8008e20:	9502      	str	r5, [sp, #8]
 8008e22:	9501      	str	r5, [sp, #4]
				InfoLogAdd(ERRORLEVEL_SEVERE,
 8008e24:	2211      	movs	r2, #17
 8008e26:	9200      	str	r2, [sp, #0]
 8008e28:	2336      	movs	r3, #54	; 0x36
 8008e2a:	e010      	b.n	8008e4e <VEML7700_GetAutoXLux+0x8a>
 8008e2c:	4607      	mov	r7, r0
		if (VEML7700_SetIntegrationTime(itimes[itime_idx]))
 8008e2e:	ab0c      	add	r3, sp, #48	; 0x30
 8008e30:	fa4f f884 	sxtb.w	r8, r4
 8008e34:	5d18      	ldrb	r0, [r3, r4]
 8008e36:	f7ff ff1d 	bl	8008c74 <VEML7700_SetIntegrationTime>
 8008e3a:	b190      	cbz	r0, 8008e62 <VEML7700_GetAutoXLux+0x9e>
			InfoLogAdd(ERRORLEVEL_SEVERE,
 8008e3c:	f000 f936 	bl	80090ac <GetTempInfoStruct>
 8008e40:	2211      	movs	r2, #17
 8008e42:	9004      	str	r0, [sp, #16]
 8008e44:	9703      	str	r7, [sp, #12]
 8008e46:	9702      	str	r7, [sp, #8]
 8008e48:	9701      	str	r7, [sp, #4]
 8008e4a:	9200      	str	r2, [sp, #0]
 8008e4c:	2331      	movs	r3, #49	; 0x31
 8008e4e:	211d      	movs	r1, #29
 8008e50:	2015      	movs	r0, #21
 8008e52:	f003 fa71 	bl	800c338 <InfoLogAdd>
			return STATUS_ERROR;
 8008e56:	f04f 09ff 	mov.w	r9, #255	; 0xff
}
 8008e5a:	4648      	mov	r0, r9
 8008e5c:	b00f      	add	sp, #60	; 0x3c
 8008e5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8008e62:	4605      	mov	r5, r0
			if (VEML7700_SetGain(gains[gain_idx]))
 8008e64:	ab0a      	add	r3, sp, #40	; 0x28
 8008e66:	f813 b005 	ldrb.w	fp, [r3, r5]
 8008e6a:	4658      	mov	r0, fp
 8008e6c:	f7ff fee8 	bl	8008c40 <VEML7700_SetGain>
 8008e70:	4681      	mov	r9, r0
 8008e72:	b150      	cbz	r0, 8008e8a <VEML7700_GetAutoXLux+0xc6>
				InfoLogAdd(ERRORLEVEL_SEVERE,
 8008e74:	f000 f91a 	bl	80090ac <GetTempInfoStruct>
 8008e78:	2300      	movs	r3, #0
 8008e7a:	2211      	movs	r2, #17
 8008e7c:	9303      	str	r3, [sp, #12]
 8008e7e:	9302      	str	r3, [sp, #8]
 8008e80:	9301      	str	r3, [sp, #4]
 8008e82:	9004      	str	r0, [sp, #16]
 8008e84:	9200      	str	r2, [sp, #0]
 8008e86:	2330      	movs	r3, #48	; 0x30
 8008e88:	e7e1      	b.n	8008e4e <VEML7700_GetAutoXLux+0x8a>
			if (VEML7700_SetPower(1))
 8008e8a:	2001      	movs	r0, #1
 8008e8c:	f7ff ff0c 	bl	8008ca8 <VEML7700_SetPower>
 8008e90:	b168      	cbz	r0, 8008eae <VEML7700_GetAutoXLux+0xea>
				InfoLogAdd(ERRORLEVEL_SEVERE,
 8008e92:	f000 f90b 	bl	80090ac <GetTempInfoStruct>
 8008e96:	f8cd 900c 	str.w	r9, [sp, #12]
 8008e9a:	9004      	str	r0, [sp, #16]
 8008e9c:	f8cd 9008 	str.w	r9, [sp, #8]
 8008ea0:	f8cd 9004 	str.w	r9, [sp, #4]
						InfoLogAdd(ERRORLEVEL_SEVERE,
 8008ea4:	2311      	movs	r3, #17
 8008ea6:	9300      	str	r3, [sp, #0]
 8008ea8:	2212      	movs	r2, #18
 8008eaa:	2336      	movs	r3, #54	; 0x36
 8008eac:	e7cf      	b.n	8008e4e <VEML7700_GetAutoXLux+0x8a>
 8008eae:	9008      	str	r0, [sp, #32]
			VEML7700_SampleDelay();
 8008eb0:	f7ff ff62 	bl	8008d78 <VEML7700_SampleDelay>
			if (counts_func(raw_counts))
 8008eb4:	4630      	mov	r0, r6
 8008eb6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008eb8:	4798      	blx	r3
 8008eba:	9a08      	ldr	r2, [sp, #32]
 8008ebc:	4681      	mov	r9, r0
 8008ebe:	b158      	cbz	r0, 8008ed8 <VEML7700_GetAutoXLux+0x114>
 8008ec0:	9206      	str	r2, [sp, #24]
				InfoLogAdd(ERRORLEVEL_SEVERE,
 8008ec2:	f000 f8f3 	bl	80090ac <GetTempInfoStruct>
 8008ec6:	9a06      	ldr	r2, [sp, #24]
 8008ec8:	9004      	str	r0, [sp, #16]
 8008eca:	9203      	str	r2, [sp, #12]
 8008ecc:	9202      	str	r2, [sp, #8]
 8008ece:	9201      	str	r2, [sp, #4]
						InfoLogAdd(ERRORLEVEL_SEVERE,
 8008ed0:	2211      	movs	r2, #17
 8008ed2:	9200      	str	r2, [sp, #0]
 8008ed4:	2332      	movs	r3, #50	; 0x32
 8008ed6:	e7ba      	b.n	8008e4e <VEML7700_GetAutoXLux+0x8a>
			if (*raw_counts > counts_threshold)
 8008ed8:	8832      	ldrh	r2, [r6, #0]
 8008eda:	2ac8      	cmp	r2, #200	; 0xc8
 8008edc:	d959      	bls.n	8008f92 <VEML7700_GetAutoXLux+0x1ce>
					if (*raw_counts < 10000)
 8008ede:	8830      	ldrh	r0, [r6, #0]
 8008ee0:	f242 730f 	movw	r3, #9999	; 0x270f
 8008ee4:	4298      	cmp	r0, r3
 8008ee6:	d80c      	bhi.n	8008f02 <VEML7700_GetAutoXLux+0x13e>
						VEML7700_ScaleLux(*raw_counts, lux);
 8008ee8:	4651      	mov	r1, sl
 8008eea:	f7ff fef5 	bl	8008cd8 <VEML7700_ScaleLux>
						*auto_gain = gains[gain_idx];
 8008eee:	9b06      	ldr	r3, [sp, #24]
 8008ef0:	f883 b000 	strb.w	fp, [r3]
						*auto_itime = itimes[itime_idx];
 8008ef4:	ab0e      	add	r3, sp, #56	; 0x38
 8008ef6:	4498      	add	r8, r3
 8008ef8:	9b07      	ldr	r3, [sp, #28]
 8008efa:	f818 2c08 	ldrb.w	r2, [r8, #-8]
 8008efe:	701a      	strb	r2, [r3, #0]
						return STATUS_OK;
 8008f00:	e7ab      	b.n	8008e5a <VEML7700_GetAutoXLux+0x96>
					if (VEML7700_SetPower(0))
 8008f02:	2000      	movs	r0, #0
 8008f04:	f7ff fed0 	bl	8008ca8 <VEML7700_SetPower>
 8008f08:	4607      	mov	r7, r0
 8008f0a:	b138      	cbz	r0, 8008f1c <VEML7700_GetAutoXLux+0x158>
						InfoLogAdd(ERRORLEVEL_SEVERE,
 8008f0c:	f000 f8ce 	bl	80090ac <GetTempInfoStruct>
 8008f10:	2300      	movs	r3, #0
 8008f12:	9004      	str	r0, [sp, #16]
 8008f14:	9303      	str	r3, [sp, #12]
 8008f16:	9302      	str	r3, [sp, #8]
 8008f18:	9301      	str	r3, [sp, #4]
 8008f1a:	e783      	b.n	8008e24 <VEML7700_GetAutoXLux+0x60>
 8008f1c:	f108 38ff 	add.w	r8, r8, #4294967295
 8008f20:	fa5f f488 	uxtb.w	r4, r8
					if (VEML7700_SetIntegrationTime(itimes[itime_idx]))
 8008f24:	ab0e      	add	r3, sp, #56	; 0x38
 8008f26:	1919      	adds	r1, r3, r4
 8008f28:	fa4f f884 	sxtb.w	r8, r4
 8008f2c:	f811 3c08 	ldrb.w	r3, [r1, #-8]
 8008f30:	9308      	str	r3, [sp, #32]
 8008f32:	4618      	mov	r0, r3
 8008f34:	f7ff fe9e 	bl	8008c74 <VEML7700_SetIntegrationTime>
 8008f38:	4605      	mov	r5, r0
 8008f3a:	2800      	cmp	r0, #0
 8008f3c:	f47f af7e 	bne.w	8008e3c <VEML7700_GetAutoXLux+0x78>
					if (VEML7700_SetPower(1))
 8008f40:	2001      	movs	r0, #1
 8008f42:	f7ff feb1 	bl	8008ca8 <VEML7700_SetPower>
 8008f46:	4607      	mov	r7, r0
 8008f48:	b130      	cbz	r0, 8008f58 <VEML7700_GetAutoXLux+0x194>
						InfoLogAdd(ERRORLEVEL_SEVERE,
 8008f4a:	f000 f8af 	bl	80090ac <GetTempInfoStruct>
 8008f4e:	9503      	str	r5, [sp, #12]
 8008f50:	9004      	str	r0, [sp, #16]
 8008f52:	9502      	str	r5, [sp, #8]
 8008f54:	9501      	str	r5, [sp, #4]
 8008f56:	e7a5      	b.n	8008ea4 <VEML7700_GetAutoXLux+0xe0>
					VEML7700_SampleDelay();
 8008f58:	f7ff ff0e 	bl	8008d78 <VEML7700_SampleDelay>
					if (counts_func(raw_counts))
 8008f5c:	4630      	mov	r0, r6
 8008f5e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008f60:	4798      	blx	r3
 8008f62:	b130      	cbz	r0, 8008f72 <VEML7700_GetAutoXLux+0x1ae>
						InfoLogAdd(ERRORLEVEL_SEVERE,
 8008f64:	f000 f8a2 	bl	80090ac <GetTempInfoStruct>
 8008f68:	9703      	str	r7, [sp, #12]
 8008f6a:	9004      	str	r0, [sp, #16]
 8008f6c:	9702      	str	r7, [sp, #8]
 8008f6e:	9701      	str	r7, [sp, #4]
 8008f70:	e7ae      	b.n	8008ed0 <VEML7700_GetAutoXLux+0x10c>
				} while (itime_idx > 0);
 8008f72:	2c00      	cmp	r4, #0
 8008f74:	d1b3      	bne.n	8008ede <VEML7700_GetAutoXLux+0x11a>
				VEML7700_ScaleLux(*raw_counts, lux);
 8008f76:	4651      	mov	r1, sl
 8008f78:	8830      	ldrh	r0, [r6, #0]
 8008f7a:	f7ff fead 	bl	8008cd8 <VEML7700_ScaleLux>
				*auto_gain = gains[gain_idx];
 8008f7e:	9b06      	ldr	r3, [sp, #24]
 8008f80:	f883 b000 	strb.w	fp, [r3]
				*auto_itime = itimes[itime_idx];
 8008f84:	9b07      	ldr	r3, [sp, #28]
 8008f86:	461a      	mov	r2, r3
 8008f88:	f89d 3020 	ldrb.w	r3, [sp, #32]
 8008f8c:	7013      	strb	r3, [r2, #0]
				return STATUS_OK;
 8008f8e:	46a1      	mov	r9, r4
 8008f90:	e763      	b.n	8008e5a <VEML7700_GetAutoXLux+0x96>
 8008f92:	9008      	str	r0, [sp, #32]
			if (VEML7700_SetPower(0))
 8008f94:	f7ff fe88 	bl	8008ca8 <VEML7700_SetPower>
 8008f98:	9908      	ldr	r1, [sp, #32]
 8008f9a:	4681      	mov	r9, r0
 8008f9c:	b140      	cbz	r0, 8008fb0 <VEML7700_GetAutoXLux+0x1ec>
 8008f9e:	9106      	str	r1, [sp, #24]
				InfoLogAdd(ERRORLEVEL_SEVERE,
 8008fa0:	f000 f884 	bl	80090ac <GetTempInfoStruct>
 8008fa4:	9906      	ldr	r1, [sp, #24]
 8008fa6:	9004      	str	r0, [sp, #16]
 8008fa8:	9103      	str	r1, [sp, #12]
 8008faa:	9102      	str	r1, [sp, #8]
 8008fac:	9101      	str	r1, [sp, #4]
 8008fae:	e739      	b.n	8008e24 <VEML7700_GetAutoXLux+0x60>
 8008fb0:	3501      	adds	r5, #1
		for (gain_idx = 0; gain_idx < 4; gain_idx++)
 8008fb2:	2d04      	cmp	r5, #4
 8008fb4:	f47f af56 	bne.w	8008e64 <VEML7700_GetAutoXLux+0xa0>
 8008fb8:	3401      	adds	r4, #1
	for (itime_idx = 2; itime_idx < 6; itime_idx++)
 8008fba:	2c06      	cmp	r4, #6
 8008fbc:	f47f af37 	bne.w	8008e2e <VEML7700_GetAutoXLux+0x6a>
	VEML7700_ScaleLux(*raw_counts, lux);
 8008fc0:	4651      	mov	r1, sl
 8008fc2:	8830      	ldrh	r0, [r6, #0]
 8008fc4:	f7ff fe88 	bl	8008cd8 <VEML7700_ScaleLux>
	*auto_gain = gains[gain_idx];
 8008fc8:	9b06      	ldr	r3, [sp, #24]
 8008fca:	f883 9000 	strb.w	r9, [r3]
	*auto_itime = itimes[itime_idx];
 8008fce:	9b07      	ldr	r3, [sp, #28]
 8008fd0:	f883 9000 	strb.w	r9, [r3]
	return STATUS_OK;
 8008fd4:	e741      	b.n	8008e5a <VEML7700_GetAutoXLux+0x96>
	...

08008fd8 <VEML7700_GetAutoALSLux>:
{
 8008fd8:	b530      	push	{r4, r5, lr}
 8008fda:	b085      	sub	sp, #20
	uint8_t status = VEML7700_GetAutoXLux(
 8008fdc:	f10d 030e 	add.w	r3, sp, #14
{
 8008fe0:	4604      	mov	r4, r0
	uint8_t status = VEML7700_GetAutoXLux(
 8008fe2:	9300      	str	r3, [sp, #0]
 8008fe4:	aa03      	add	r2, sp, #12
 8008fe6:	f10d 030d 	add.w	r3, sp, #13
 8008fea:	491d      	ldr	r1, [pc, #116]	; (8009060 <VEML7700_GetAutoALSLux+0x88>)
 8008fec:	f7ff feea 	bl	8008dc4 <VEML7700_GetAutoXLux>
	if (*lux > 120000)
 8008ff0:	eddf 7a1c 	vldr	s15, [pc, #112]	; 8009064 <VEML7700_GetAutoALSLux+0x8c>
 8008ff4:	ed94 7a00 	vldr	s14, [r4]
			(auto_gain == 0) ? "1" : (auto_gain == 1) ? "2" : (auto_gain == 2) ? "1/8" : "1/4",
 8008ff8:	f89d 300c 	ldrb.w	r3, [sp, #12]
	if (*lux > 120000)
 8008ffc:	eeb4 7ae7 	vcmpe.f32	s14, s15
 8009000:	eef1 fa10 	vmrs	APSR_nzcv, fpscr
	uint8_t status = VEML7700_GetAutoXLux(
 8009004:	4605      	mov	r5, r0
		*lux = 120000;
 8009006:	bfc8      	it	gt
 8009008:	edc4 7a00 	vstrgt	s15, [r4]
	printf(
 800900c:	b1e3      	cbz	r3, 8009048 <VEML7700_GetAutoALSLux+0x70>
			(auto_gain == 0) ? "1" : (auto_gain == 1) ? "2" : (auto_gain == 2) ? "1/8" : "1/4",
 800900e:	2b01      	cmp	r3, #1
 8009010:	d01c      	beq.n	800904c <VEML7700_GetAutoALSLux+0x74>
 8009012:	4a15      	ldr	r2, [pc, #84]	; (8009068 <VEML7700_GetAutoALSLux+0x90>)
 8009014:	4915      	ldr	r1, [pc, #84]	; (800906c <VEML7700_GetAutoALSLux+0x94>)
 8009016:	2b02      	cmp	r3, #2
 8009018:	bf18      	it	ne
 800901a:	4611      	movne	r1, r2
			(auto_itime == 0xc) ? "25ms" : (auto_itime == 0x8) ? "50ms" :
 800901c:	f89d 300d 	ldrb.w	r3, [sp, #13]
	printf(
 8009020:	2b0c      	cmp	r3, #12
 8009022:	d015      	beq.n	8009050 <VEML7700_GetAutoALSLux+0x78>
			(auto_itime == 0xc) ? "25ms" : (auto_itime == 0x8) ? "50ms" :
 8009024:	2b08      	cmp	r3, #8
 8009026:	d015      	beq.n	8009054 <VEML7700_GetAutoALSLux+0x7c>
			(auto_itime == 0) ? "100ms" : (auto_itime == 1) ? "200ms" :
 8009028:	b1b3      	cbz	r3, 8009058 <VEML7700_GetAutoALSLux+0x80>
 800902a:	2b01      	cmp	r3, #1
 800902c:	d016      	beq.n	800905c <VEML7700_GetAutoALSLux+0x84>
			(auto_itime == 2) ? "400ms" : "800ms",
 800902e:	4810      	ldr	r0, [pc, #64]	; (8009070 <VEML7700_GetAutoALSLux+0x98>)
 8009030:	4a10      	ldr	r2, [pc, #64]	; (8009074 <VEML7700_GetAutoALSLux+0x9c>)
 8009032:	2b02      	cmp	r3, #2
 8009034:	bf18      	it	ne
 8009036:	4602      	movne	r2, r0
	printf(
 8009038:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 800903c:	480e      	ldr	r0, [pc, #56]	; (8009078 <VEML7700_GetAutoALSLux+0xa0>)
 800903e:	f004 f96d 	bl	800d31c <iprintf>
}
 8009042:	4628      	mov	r0, r5
 8009044:	b005      	add	sp, #20
 8009046:	bd30      	pop	{r4, r5, pc}
	printf(
 8009048:	490c      	ldr	r1, [pc, #48]	; (800907c <VEML7700_GetAutoALSLux+0xa4>)
 800904a:	e7e7      	b.n	800901c <VEML7700_GetAutoALSLux+0x44>
			(auto_gain == 0) ? "1" : (auto_gain == 1) ? "2" : (auto_gain == 2) ? "1/8" : "1/4",
 800904c:	490c      	ldr	r1, [pc, #48]	; (8009080 <VEML7700_GetAutoALSLux+0xa8>)
 800904e:	e7e5      	b.n	800901c <VEML7700_GetAutoALSLux+0x44>
	printf(
 8009050:	4a0c      	ldr	r2, [pc, #48]	; (8009084 <VEML7700_GetAutoALSLux+0xac>)
 8009052:	e7f1      	b.n	8009038 <VEML7700_GetAutoALSLux+0x60>
			(auto_itime == 0xc) ? "25ms" : (auto_itime == 0x8) ? "50ms" :
 8009054:	4a0c      	ldr	r2, [pc, #48]	; (8009088 <VEML7700_GetAutoALSLux+0xb0>)
 8009056:	e7ef      	b.n	8009038 <VEML7700_GetAutoALSLux+0x60>
			(auto_itime == 0) ? "100ms" : (auto_itime == 1) ? "200ms" :
 8009058:	4a0c      	ldr	r2, [pc, #48]	; (800908c <VEML7700_GetAutoALSLux+0xb4>)
 800905a:	e7ed      	b.n	8009038 <VEML7700_GetAutoALSLux+0x60>
 800905c:	4a0c      	ldr	r2, [pc, #48]	; (8009090 <VEML7700_GetAutoALSLux+0xb8>)
 800905e:	e7eb      	b.n	8009038 <VEML7700_GetAutoALSLux+0x60>
 8009060:	08008bc1 	.word	0x08008bc1
 8009064:	47ea6000 	.word	0x47ea6000
 8009068:	0800f85e 	.word	0x0800f85e
 800906c:	0800f862 	.word	0x0800f862
 8009070:	0800f87c 	.word	0x0800f87c
 8009074:	0800f882 	.word	0x0800f882
 8009078:	0800f888 	.word	0x0800f888
 800907c:	0800fca3 	.word	0x0800fca3
 8009080:	0800f85c 	.word	0x0800f85c
 8009084:	0800f86b 	.word	0x0800f86b
 8009088:	0800f866 	.word	0x0800f866
 800908c:	0800f870 	.word	0x0800f870
 8009090:	0800f876 	.word	0x0800f876

08009094 <GetDataStruct>:

/* Fuctions that gets structs */
Data *GetDataStruct(void)
{
	return &data_global;
}
 8009094:	4800      	ldr	r0, [pc, #0]	; (8009098 <GetDataStruct+0x4>)
 8009096:	4770      	bx	lr
 8009098:	200037fc 	.word	0x200037fc

0800909c <GetErrorStruct>:

Error *GetErrorStruct(void)
{
	return &error_global;
}
 800909c:	4800      	ldr	r0, [pc, #0]	; (80090a0 <GetErrorStruct+0x4>)
 800909e:	4770      	bx	lr
 80090a0:	2000c1c4 	.word	0x2000c1c4

080090a4 <GetInfoStruct>:

Info *GetInfoStruct(void)
{
	return &info_global;
}
 80090a4:	4800      	ldr	r0, [pc, #0]	; (80090a8 <GetInfoStruct+0x4>)
 80090a6:	4770      	bx	lr
 80090a8:	20009210 	.word	0x20009210

080090ac <GetTempInfoStruct>:

Info *GetTempInfoStruct(void)
{
	return &tempInfo;
}
 80090ac:	4800      	ldr	r0, [pc, #0]	; (80090b0 <GetTempInfoStruct+0x4>)
 80090ae:	4770      	bx	lr
 80090b0:	2000090c 	.word	0x2000090c

080090b4 <GetTimeStruct>:

Time *GetTimeStruct(TimeStructs retStruct)
{
	if (retStruct == SaraLastConnectedVal)
 80090b4:	b170      	cbz	r0, 80090d4 <GetTimeStruct+0x20>
	{
		return &SaraLastConnected;
	}
	else if (retStruct == mcuClockTimeVal)
 80090b6:	2801      	cmp	r0, #1
 80090b8:	d00e      	beq.n	80090d8 <GetTimeStruct+0x24>
	{
		return &mcuClockTime;
	}
	else if (retStruct == networkStartVal)
 80090ba:	2802      	cmp	r0, #2
 80090bc:	d00e      	beq.n	80090dc <GetTimeStruct+0x28>
	{
		return &networkStart;
	}
	else if (retStruct == networkEndVal)
 80090be:	2803      	cmp	r0, #3
 80090c0:	d00e      	beq.n	80090e0 <GetTimeStruct+0x2c>
	{
		return &networkEnd;
	}
	else if (retStruct == startTimeToSendVal)
 80090c2:	2804      	cmp	r0, #4
 80090c4:	d00e      	beq.n	80090e4 <GetTimeStruct+0x30>
	{
		return &turnOffStart;
	}
	else
	{
		return &turnOffEnd;
 80090c6:	4a08      	ldr	r2, [pc, #32]	; (80090e8 <GetTimeStruct+0x34>)
 80090c8:	4b08      	ldr	r3, [pc, #32]	; (80090ec <GetTimeStruct+0x38>)
 80090ca:	2806      	cmp	r0, #6
 80090cc:	bf0c      	ite	eq
 80090ce:	4618      	moveq	r0, r3
 80090d0:	4610      	movne	r0, r2
 80090d2:	4770      	bx	lr
		return &SaraLastConnected;
 80090d4:	4806      	ldr	r0, [pc, #24]	; (80090f0 <GetTimeStruct+0x3c>)
 80090d6:	4770      	bx	lr
		return &mcuClockTime;
 80090d8:	4806      	ldr	r0, [pc, #24]	; (80090f4 <GetTimeStruct+0x40>)
 80090da:	4770      	bx	lr
		return &networkStart;
 80090dc:	4806      	ldr	r0, [pc, #24]	; (80090f8 <GetTimeStruct+0x44>)
 80090de:	4770      	bx	lr
		return &networkEnd;
 80090e0:	4806      	ldr	r0, [pc, #24]	; (80090fc <GetTimeStruct+0x48>)
 80090e2:	4770      	bx	lr
		return &startTimeToSend;
 80090e4:	4806      	ldr	r0, [pc, #24]	; (8009100 <GetTimeStruct+0x4c>)
	}

}
 80090e6:	4770      	bx	lr
 80090e8:	2000c426 	.word	0x2000c426
 80090ec:	200008c8 	.word	0x200008c8
 80090f0:	2000c107 	.word	0x2000c107
 80090f4:	2000c10d 	.word	0x2000c10d
 80090f8:	20009208 	.word	0x20009208
 80090fc:	200037f0 	.word	0x200037f0
 8009100:	2000c0f4 	.word	0x2000c0f4

08009104 <GetSaraConfigurationStruct>:

SaraConfig *GetSaraConfigurationStruct()
{
	return &SaraConfiguration;
}
 8009104:	4800      	ldr	r0, [pc, #0]	; (8009108 <GetSaraConfigurationStruct+0x4>)
 8009106:	4770      	bx	lr
 8009108:	2000c114 	.word	0x2000c114

0800910c <GetErrorFlagsStruct>:

radioFlags *GetErrorFlagsStruct()
{
	return &radioErrors;
}
 800910c:	4800      	ldr	r0, [pc, #0]	; (8009110 <GetErrorFlagsStruct+0x4>)
 800910e:	4770      	bx	lr
 8009110:	200008ea 	.word	0x200008ea

08009114 <GetErrorTimerStruct>:
	}
	else
	{
		return &endTimer;
	}
}
 8009114:	4b03      	ldr	r3, [pc, #12]	; (8009124 <GetErrorTimerStruct+0x10>)
 8009116:	4a04      	ldr	r2, [pc, #16]	; (8009128 <GetErrorTimerStruct+0x14>)
 8009118:	2800      	cmp	r0, #0
 800911a:	bf0c      	ite	eq
 800911c:	4610      	moveq	r0, r2
 800911e:	4618      	movne	r0, r3
 8009120:	4770      	bx	lr
 8009122:	bf00      	nop
 8009124:	2000c420 	.word	0x2000c420
 8009128:	200008e4 	.word	0x200008e4

0800912c <DisableSD_Card>:

}

/* Turn off SD card for power consumption */
void DisableSD_Card(void)
{
 800912c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800912e:	b087      	sub	sp, #28
	DisEnableSDPin(0);

	/* Reinit GPIO pins */
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStructure.Pull = GPIO_NOPULL;
	GPIO_InitStructure.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
 8009130:	ac06      	add	r4, sp, #24
	DisEnableSDPin(0);
 8009132:	2000      	movs	r0, #0
 8009134:	f000 fe60 	bl	8009df8 <DisEnableSDPin>
	GPIO_InitStructure.Pin = GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11 | GPIO_PIN_12;
 8009138:	f44f 53f8 	mov.w	r3, #7936	; 0x1f00
 800913c:	f844 3d14 	str.w	r3, [r4, #-20]!
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009140:	4f0d      	ldr	r7, [pc, #52]	; (8009178 <DisableSD_Card+0x4c>)
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 8009142:	2503      	movs	r5, #3
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 8009144:	2600      	movs	r6, #0
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009146:	4621      	mov	r1, r4
 8009148:	4638      	mov	r0, r7
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 800914a:	9502      	str	r5, [sp, #8]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 800914c:	9603      	str	r6, [sp, #12]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 800914e:	f7f8 fecf 	bl	8001ef0 <HAL_GPIO_Init>

	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStructure.Pull = GPIO_PULLDOWN;
 8009152:	2302      	movs	r3, #2
 8009154:	9303      	str	r3, [sp, #12]
	GPIO_InitStructure.Pin = GPIO_PIN_7;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009156:	4621      	mov	r1, r4
	GPIO_InitStructure.Pin = GPIO_PIN_7;
 8009158:	2380      	movs	r3, #128	; 0x80
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 800915a:	4638      	mov	r0, r7
	GPIO_InitStructure.Pin = GPIO_PIN_7;
 800915c:	9301      	str	r3, [sp, #4]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 800915e:	9502      	str	r5, [sp, #8]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009160:	f7f8 fec6 	bl	8001ef0 <HAL_GPIO_Init>

	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStructure.Pull = GPIO_NOPULL;
	GPIO_InitStructure.Pin = GPIO_PIN_2;
 8009164:	2304      	movs	r3, #4
	HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 8009166:	4621      	mov	r1, r4
 8009168:	4804      	ldr	r0, [pc, #16]	; (800917c <DisableSD_Card+0x50>)
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 800916a:	9502      	str	r5, [sp, #8]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 800916c:	9603      	str	r6, [sp, #12]
	GPIO_InitStructure.Pin = GPIO_PIN_2;
 800916e:	9301      	str	r3, [sp, #4]
	HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 8009170:	f7f8 febe 	bl	8001ef0 <HAL_GPIO_Init>
}
 8009174:	b007      	add	sp, #28
 8009176:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009178:	48000800 	.word	0x48000800
 800917c:	48000c00 	.word	0x48000c00

08009180 <GPIOSetAnalogSensor>:

/* Set GPIOs to analog except sensor and radio pins */
void GPIOSetAnalogSensor(void)
{
 8009180:	b5f0      	push	{r4, r5, r6, r7, lr}
	GPIO_InitTypeDef GPIO_InitStructure;

	/* Enable GPIOs clock. todo fix this ugly ; ; ; ;  */
	__HAL_RCC_GPIOA_CLK_ENABLE()
 8009182:	4c3e      	ldr	r4, [pc, #248]	; (800927c <GPIOSetAnalogSensor+0xfc>)
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStructure.Pull = GPIO_NOPULL;
	GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10
			| GPIO_PIN_11 | GPIO_PIN_13 | GPIO_PIN_14;

	HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 8009184:	483e      	ldr	r0, [pc, #248]	; (8009280 <GPIOSetAnalogSensor+0x100>)
	__HAL_RCC_GPIOA_CLK_ENABLE()
 8009186:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009188:	f043 0301 	orr.w	r3, r3, #1
 800918c:	64e3      	str	r3, [r4, #76]	; 0x4c
 800918e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
{
 8009190:	b08d      	sub	sp, #52	; 0x34
	__HAL_RCC_GPIOA_CLK_ENABLE()
 8009192:	f003 0301 	and.w	r3, r3, #1
 8009196:	9301      	str	r3, [sp, #4]
 8009198:	9b01      	ldr	r3, [sp, #4]
	__HAL_RCC_GPIOB_CLK_ENABLE()
 800919a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800919c:	f043 0302 	orr.w	r3, r3, #2
 80091a0:	64e3      	str	r3, [r4, #76]	; 0x4c
 80091a2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80091a4:	f003 0302 	and.w	r3, r3, #2
 80091a8:	9302      	str	r3, [sp, #8]
 80091aa:	9b02      	ldr	r3, [sp, #8]
	__HAL_RCC_GPIOC_CLK_ENABLE()
 80091ac:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80091ae:	f043 0304 	orr.w	r3, r3, #4
 80091b2:	64e3      	str	r3, [r4, #76]	; 0x4c
 80091b4:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80091b6:	f003 0304 	and.w	r3, r3, #4
 80091ba:	9303      	str	r3, [sp, #12]
 80091bc:	9b03      	ldr	r3, [sp, #12]
	__HAL_RCC_GPIOD_CLK_ENABLE()
 80091be:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80091c0:	f043 0308 	orr.w	r3, r3, #8
 80091c4:	64e3      	str	r3, [r4, #76]	; 0x4c
 80091c6:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80091c8:	f003 0308 	and.w	r3, r3, #8
 80091cc:	9304      	str	r3, [sp, #16]
 80091ce:	9b04      	ldr	r3, [sp, #16]
	__HAL_RCC_GPIOH_CLK_ENABLE()
 80091d0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80091d2:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80091d6:	64e3      	str	r3, [r4, #76]	; 0x4c
 80091d8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80091da:	f003 0380 	and.w	r3, r3, #128	; 0x80
 80091de:	9305      	str	r3, [sp, #20]
 80091e0:	9b05      	ldr	r3, [sp, #20]
	__HAL_RCC_GPIOE_CLK_ENABLE()
 80091e2:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80091e4:	f043 0310 	orr.w	r3, r3, #16
 80091e8:	64e3      	str	r3, [r4, #76]	; 0x4c
 80091ea:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80091ec:	f003 0310 	and.w	r3, r3, #16
	GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10
 80091f0:	ad0c      	add	r5, sp, #48	; 0x30
	__HAL_RCC_GPIOE_CLK_ENABLE()
 80091f2:	9306      	str	r3, [sp, #24]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 80091f4:	2600      	movs	r6, #0
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 80091f6:	2703      	movs	r7, #3
	__HAL_RCC_GPIOE_CLK_ENABLE()
 80091f8:	9b06      	ldr	r3, [sp, #24]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 80091fa:	9708      	str	r7, [sp, #32]
	GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10
 80091fc:	f646 7381 	movw	r3, #28545	; 0x6f81
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 8009200:	9609      	str	r6, [sp, #36]	; 0x24
	GPIO_InitStructure.Pin = GPIO_PIN_0 | GPIO_PIN_7 | GPIO_PIN_8 | GPIO_PIN_9 | GPIO_PIN_10
 8009202:	f845 3d14 	str.w	r3, [r5, #-20]!
	HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 8009206:	4629      	mov	r1, r5
 8009208:	f7f8 fe72 	bl	8001ef0 <HAL_GPIO_Init>

	/* Turns off SD Card, otherwise strange behavior */
	DisEnableSDPin(0);
 800920c:	4630      	mov	r0, r6
 800920e:	f000 fdf3 	bl	8009df8 <DisEnableSDPin>

	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStructure.Pull = GPIO_NOPULL;
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~GPIO_PIN_7);
 8009212:	f64f 737f 	movw	r3, #65407	; 0xff7f
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009216:	4629      	mov	r1, r5
 8009218:	481a      	ldr	r0, [pc, #104]	; (8009284 <GPIOSetAnalogSensor+0x104>)
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~GPIO_PIN_7);
 800921a:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 800921c:	9708      	str	r7, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 800921e:	9609      	str	r6, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009220:	f7f8 fe66 	bl	8001ef0 <HAL_GPIO_Init>

	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStructure.Pull = GPIO_NOPULL;
	GPIO_InitStructure.Pin = GPIO_PIN_All;
 8009224:	f64f 73ff 	movw	r3, #65535	; 0xffff
	HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 8009228:	4629      	mov	r1, r5
 800922a:	4817      	ldr	r0, [pc, #92]	; (8009288 <GPIOSetAnalogSensor+0x108>)
	GPIO_InitStructure.Pin = GPIO_PIN_All;
 800922c:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 800922e:	9708      	str	r7, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 8009230:	9609      	str	r6, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 8009232:	f7f8 fe5d 	bl	8001ef0 <HAL_GPIO_Init>
	HAL_GPIO_Init(GPIOH, &GPIO_InitStructure);
 8009236:	4629      	mov	r1, r5
 8009238:	4814      	ldr	r0, [pc, #80]	; (800928c <GPIOSetAnalogSensor+0x10c>)
 800923a:	f7f8 fe59 	bl	8001ef0 <HAL_GPIO_Init>
	HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
 800923e:	4629      	mov	r1, r5
 8009240:	4813      	ldr	r0, [pc, #76]	; (8009290 <GPIOSetAnalogSensor+0x110>)
 8009242:	f7f8 fe55 	bl	8001ef0 <HAL_GPIO_Init>

	/* Disable GPIOs clock */
	__HAL_RCC_GPIOA_CLK_DISABLE();
 8009246:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009248:	f023 0301 	bic.w	r3, r3, #1
 800924c:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOB_CLK_DISABLE();
 800924e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009250:	f023 0302 	bic.w	r3, r3, #2
 8009254:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOC_CLK_DISABLE();
 8009256:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009258:	f023 0304 	bic.w	r3, r3, #4
 800925c:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOD_CLK_DISABLE();
 800925e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009260:	f023 0308 	bic.w	r3, r3, #8
 8009264:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOH_CLK_DISABLE();
 8009266:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009268:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 800926c:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOE_CLK_DISABLE();
 800926e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009270:	f023 0310 	bic.w	r3, r3, #16
 8009274:	64e3      	str	r3, [r4, #76]	; 0x4c
}
 8009276:	b00d      	add	sp, #52	; 0x34
 8009278:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800927a:	bf00      	nop
 800927c:	40021000 	.word	0x40021000
 8009280:	48000400 	.word	0x48000400
 8009284:	48000800 	.word	0x48000800
 8009288:	48000c00 	.word	0x48000c00
 800928c:	48001c00 	.word	0x48001c00
 8009290:	48001000 	.word	0x48001000

08009294 <CheckResetCause>:
}

/* Check what the cause of reset is */
void CheckResetCause(void)
{
	if (__HAL_RCC_GET_FLAG(RCC_FLAG_LPWRRST))
 8009294:	4b1c      	ldr	r3, [pc, #112]	; (8009308 <CheckResetCause+0x74>)
 8009296:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800929a:	2a00      	cmp	r2, #0
 800929c:	4a1b      	ldr	r2, [pc, #108]	; (800930c <CheckResetCause+0x78>)
 800929e:	da08      	bge.n	80092b2 <CheckResetCause+0x1e>
	{
		checkResetCause = 1;
 80092a0:	2101      	movs	r1, #1
	{
		checkResetCause = 8;
	}
	else
	{
		checkResetCause = 0;
 80092a2:	7011      	strb	r1, [r2, #0]
	}

	__HAL_RCC_CLEAR_RESET_FLAGS();
 80092a4:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80092a8:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 80092ac:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
 80092b0:	4770      	bx	lr
	else if (__HAL_RCC_GET_FLAG(RCC_FLAG_WWDGRST))
 80092b2:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 80092b6:	0048      	lsls	r0, r1, #1
 80092b8:	d501      	bpl.n	80092be <CheckResetCause+0x2a>
		checkResetCause = 2;
 80092ba:	2102      	movs	r1, #2
 80092bc:	e7f1      	b.n	80092a2 <CheckResetCause+0xe>
	else if (__HAL_RCC_GET_FLAG(RCC_FLAG_IWDGRST))
 80092be:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 80092c2:	0089      	lsls	r1, r1, #2
 80092c4:	d501      	bpl.n	80092ca <CheckResetCause+0x36>
		checkResetCause = 3;
 80092c6:	2103      	movs	r1, #3
 80092c8:	e7eb      	b.n	80092a2 <CheckResetCause+0xe>
	else if (__HAL_RCC_GET_FLAG(RCC_FLAG_SFTRST))
 80092ca:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 80092ce:	00c8      	lsls	r0, r1, #3
 80092d0:	d501      	bpl.n	80092d6 <CheckResetCause+0x42>
		checkResetCause = 4;
 80092d2:	2104      	movs	r1, #4
 80092d4:	e7e5      	b.n	80092a2 <CheckResetCause+0xe>
	else if (__HAL_RCC_GET_FLAG(RCC_FLAG_PINRST))
 80092d6:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 80092da:	0149      	lsls	r1, r1, #5
 80092dc:	d501      	bpl.n	80092e2 <CheckResetCause+0x4e>
		checkResetCause = 5;
 80092de:	2105      	movs	r1, #5
 80092e0:	e7df      	b.n	80092a2 <CheckResetCause+0xe>
	else if (__HAL_RCC_GET_FLAG(RCC_FLAG_BORRST))
 80092e2:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 80092e6:	0108      	lsls	r0, r1, #4
 80092e8:	d501      	bpl.n	80092ee <CheckResetCause+0x5a>
		checkResetCause = 6;
 80092ea:	2106      	movs	r1, #6
 80092ec:	e7d9      	b.n	80092a2 <CheckResetCause+0xe>
	else if (__HAL_RCC_GET_FLAG(RCC_FLAG_FWRST))
 80092ee:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 80092f2:	01c9      	lsls	r1, r1, #7
 80092f4:	d501      	bpl.n	80092fa <CheckResetCause+0x66>
		checkResetCause = 7;
 80092f6:	2107      	movs	r1, #7
 80092f8:	e7d3      	b.n	80092a2 <CheckResetCause+0xe>
	else if (__HAL_RCC_GET_FLAG(RCC_FLAG_OBLRST))
 80092fa:	f8d3 1094 	ldr.w	r1, [r3, #148]	; 0x94
 80092fe:	f011 7100 	ands.w	r1, r1, #33554432	; 0x2000000
		checkResetCause = 8;
 8009302:	bf18      	it	ne
 8009304:	2108      	movne	r1, #8
 8009306:	e7cc      	b.n	80092a2 <CheckResetCause+0xe>
 8009308:	40021000 	.word	0x40021000
 800930c:	2000039b 	.word	0x2000039b

08009310 <SystemClock_Config>:
/**
 * @brief System Clock Configuration
 * @retval None
 */
void SystemClock_Config(void)
{
 8009310:	b500      	push	{lr}
 8009312:	b0b1      	sub	sp, #196	; 0xc4
	RCC_ClkInitTypeDef RCC_ClkInitStruct;
	RCC_PeriphCLKInitTypeDef PeriphClkInit;

	/**Configure LSE Drive Capability 
	 */
	HAL_PWR_EnableBkUpAccess();
 8009314:	f7f9 fc22 	bl	8002b5c <HAL_PWR_EnableBkUpAccess>

	__HAL_RCC_LSEDRIVE_CONFIG(RCC_LSEDRIVE_LOW);
 8009318:	4a3d      	ldr	r2, [pc, #244]	; (8009410 <SystemClock_Config+0x100>)
 800931a:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 800931e:	f023 0318 	bic.w	r3, r3, #24
 8009322:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

	/**Initializes the CPU, AHB and APB busses clocks 
	 */
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_LSE;
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
	RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 8009326:	2201      	movs	r2, #1
	RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE | RCC_OSCILLATORTYPE_LSE;
 8009328:	2305      	movs	r3, #5
 800932a:	9305      	str	r3, [sp, #20]
	RCC_OscInitStruct.LSEState = RCC_LSE_ON;
 800932c:	9207      	str	r2, [sp, #28]
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 800932e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
	RCC_OscInitStruct.PLL.PLLM = 1;
 8009332:	9211      	str	r2, [sp, #68]	; 0x44
	RCC_OscInitStruct.PLL.PLLN = 8;
 8009334:	2208      	movs	r2, #8
	RCC_OscInitStruct.HSEState = RCC_HSE_ON;
 8009336:	9306      	str	r3, [sp, #24]
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8009338:	2103      	movs	r1, #3
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 800933a:	2302      	movs	r3, #2
	RCC_OscInitStruct.PLL.PLLN = 8;
 800933c:	9212      	str	r2, [sp, #72]	; 0x48
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800933e:	a805      	add	r0, sp, #20
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 8009340:	2207      	movs	r2, #7
	RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8009342:	930f      	str	r3, [sp, #60]	; 0x3c
	RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
 8009344:	9110      	str	r1, [sp, #64]	; 0x40
	RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 8009346:	9213      	str	r2, [sp, #76]	; 0x4c
	RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
 8009348:	9314      	str	r3, [sp, #80]	; 0x50
	RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 800934a:	9315      	str	r3, [sp, #84]	; 0x54
	if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 800934c:	f7f9 fd10 	bl	8002d70 <HAL_RCC_OscConfig>
 8009350:	b120      	cbz	r0, 800935c <SystemClock_Config+0x4c>
	{
		_Error_Handler(__FILE__, __LINE__);
 8009352:	f240 2131 	movw	r1, #561	; 0x231
 8009356:	482f      	ldr	r0, [pc, #188]	; (8009414 <SystemClock_Config+0x104>)
 8009358:	f003 fc10 	bl	800cb7c <_Error_Handler>

	/**Initializes the CPU, AHB and APB busses clocks 
	 */
	RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK | RCC_CLOCKTYPE_PCLK1
			| RCC_CLOCKTYPE_PCLK2;
	RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 800935c:	200f      	movs	r0, #15
 800935e:	2303      	movs	r3, #3
 8009360:	e88d 0009 	stmia.w	sp, {r0, r3}
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8009364:	2101      	movs	r1, #1
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8009366:	2300      	movs	r3, #0
	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8009368:	4668      	mov	r0, sp
	RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 800936a:	9302      	str	r3, [sp, #8]
	RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 800936c:	9303      	str	r3, [sp, #12]
	RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 800936e:	9304      	str	r3, [sp, #16]
	if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_1) != HAL_OK)
 8009370:	f7f9 ff5c 	bl	800322c <HAL_RCC_ClockConfig>
 8009374:	b120      	cbz	r0, 8009380 <SystemClock_Config+0x70>
	{
		_Error_Handler(__FILE__, __LINE__);
 8009376:	f240 213f 	movw	r1, #575	; 0x23f
 800937a:	4826      	ldr	r0, [pc, #152]	; (8009414 <SystemClock_Config+0x104>)
 800937c:	f003 fbfe 	bl	800cb7c <_Error_Handler>
	}

	PeriphClkInit.PeriphClockSelection = RCC_PERIPHCLK_RTC | RCC_PERIPHCLK_USART2
 8009380:	4b25      	ldr	r3, [pc, #148]	; (8009418 <SystemClock_Config+0x108>)
 8009382:	9316      	str	r3, [sp, #88]	; 0x58
			| RCC_PERIPHCLK_LPUART1 | RCC_PERIPHCLK_LPTIM1 | RCC_PERIPHCLK_I2C1 | RCC_PERIPHCLK_I2C2
			| RCC_PERIPHCLK_SDMMC1
			| RCC_PERIPHCLK_ADC;
	PeriphClkInit.Usart2ClockSelection = RCC_USART2CLKSOURCE_PCLK1;
 8009384:	2300      	movs	r3, #0
 8009386:	931f      	str	r3, [sp, #124]	; 0x7c
	PeriphClkInit.Lpuart1ClockSelection = RCC_LPUART1CLKSOURCE_PCLK1;
 8009388:	9322      	str	r3, [sp, #136]	; 0x88
	PeriphClkInit.I2c1ClockSelection = RCC_I2C1CLKSOURCE_PCLK1;
 800938a:	9323      	str	r3, [sp, #140]	; 0x8c
	PeriphClkInit.I2c2ClockSelection = RCC_I2C2CLKSOURCE_PCLK1;
 800938c:	9324      	str	r3, [sp, #144]	; 0x90
	PeriphClkInit.Lptim1ClockSelection = RCC_LPTIM1CLKSOURCE_LSE;
 800938e:	f44f 2340 	mov.w	r3, #786432	; 0xc0000
 8009392:	9327      	str	r3, [sp, #156]	; 0x9c
	PeriphClkInit.AdcClockSelection = RCC_ADCCLKSOURCE_PLLSAI1;
 8009394:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8009398:	932d      	str	r3, [sp, #180]	; 0xb4
	PeriphClkInit.RTCClockSelection = RCC_RTCCLKSOURCE_LSE;
 800939a:	f44f 7380 	mov.w	r3, #256	; 0x100
 800939e:	932f      	str	r3, [sp, #188]	; 0xbc
	PeriphClkInit.Sdmmc1ClockSelection = RCC_SDMMC1CLKSOURCE_PLLSAI1;
 80093a0:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 80093a4:	932b      	str	r3, [sp, #172]	; 0xac
	PeriphClkInit.PLLSAI1.PLLSAI1Source = RCC_PLLSOURCE_HSE;
 80093a6:	2303      	movs	r3, #3
 80093a8:	9317      	str	r3, [sp, #92]	; 0x5c
	PeriphClkInit.PLLSAI1.PLLSAI1M = 1;
 80093aa:	2301      	movs	r3, #1
 80093ac:	9318      	str	r3, [sp, #96]	; 0x60
	PeriphClkInit.PLLSAI1.PLLSAI1N = 8;
 80093ae:	2308      	movs	r3, #8
 80093b0:	9319      	str	r3, [sp, #100]	; 0x64
	PeriphClkInit.PLLSAI1.PLLSAI1P = RCC_PLLP_DIV7;
 80093b2:	2307      	movs	r3, #7
 80093b4:	931a      	str	r3, [sp, #104]	; 0x68
	PeriphClkInit.PLLSAI1.PLLSAI1Q = RCC_PLLQ_DIV2;
 80093b6:	2302      	movs	r3, #2
 80093b8:	931b      	str	r3, [sp, #108]	; 0x6c
	PeriphClkInit.PLLSAI1.PLLSAI1R = RCC_PLLR_DIV2;
 80093ba:	931c      	str	r3, [sp, #112]	; 0x70
	PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK | RCC_PLLSAI1_ADC1CLK;
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80093bc:	a816      	add	r0, sp, #88	; 0x58
	PeriphClkInit.PLLSAI1.PLLSAI1ClockOut = RCC_PLLSAI1_48M2CLK | RCC_PLLSAI1_ADC1CLK;
 80093be:	f04f 7388 	mov.w	r3, #17825792	; 0x1100000
 80093c2:	931d      	str	r3, [sp, #116]	; 0x74
	if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 80093c4:	f7fa f876 	bl	80034b4 <HAL_RCCEx_PeriphCLKConfig>
 80093c8:	b120      	cbz	r0, 80093d4 <SystemClock_Config+0xc4>
	{
		_Error_Handler(__FILE__, __LINE__);
 80093ca:	f240 2157 	movw	r1, #599	; 0x257
 80093ce:	4811      	ldr	r0, [pc, #68]	; (8009414 <SystemClock_Config+0x104>)
 80093d0:	f003 fbd4 	bl	800cb7c <_Error_Handler>
	}

	/**Configure the main internal regulator output voltage 
	 */
	if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 80093d4:	f44f 7000 	mov.w	r0, #512	; 0x200
 80093d8:	f7f9 fbd0 	bl	8002b7c <HAL_PWREx_ControlVoltageScaling>
 80093dc:	b120      	cbz	r0, 80093e8 <SystemClock_Config+0xd8>
	{
		_Error_Handler(__FILE__, __LINE__);
 80093de:	f240 215e 	movw	r1, #606	; 0x25e
 80093e2:	480c      	ldr	r0, [pc, #48]	; (8009414 <SystemClock_Config+0x104>)
 80093e4:	f003 fbca 	bl	800cb7c <_Error_Handler>
	}

	/**Configure the Systick interrupt time 
	 */
	HAL_SYSTICK_Config(HAL_RCC_GetHCLKFreq() / 1000);
 80093e8:	f7f9 ffb2 	bl	8003350 <HAL_RCC_GetHCLKFreq>
 80093ec:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80093f0:	fbb0 f0f3 	udiv	r0, r0, r3
 80093f4:	f7f8 faf8 	bl	80019e8 <HAL_SYSTICK_Config>

	/**Configure the Systick 
	 */
	HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);
 80093f8:	2004      	movs	r0, #4
 80093fa:	f7f8 fb0b 	bl	8001a14 <HAL_SYSTICK_CLKSourceConfig>

	/* SysTick_IRQn interrupt configuration */
	HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 80093fe:	2200      	movs	r2, #0
 8009400:	4611      	mov	r1, r2
 8009402:	f04f 30ff 	mov.w	r0, #4294967295
 8009406:	f7f8 faaf 	bl	8001968 <HAL_NVIC_SetPriority>
}
 800940a:	b031      	add	sp, #196	; 0xc4
 800940c:	f85d fb04 	ldr.w	pc, [sp], #4
 8009410:	40021000 	.word	0x40021000
 8009414:	0800f8f6 	.word	0x0800f8f6
 8009418:	000a42e2 	.word	0x000a42e2

0800941c <SystemSleepAndWakeUp>:
{
 800941c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);
 8009420:	4f6d      	ldr	r7, [pc, #436]	; (80095d8 <SystemSleepAndWakeUp+0x1bc>)
	__HAL_RCC_GPIOA_CLK_ENABLE()
 8009422:	4c6e      	ldr	r4, [pc, #440]	; (80095dc <SystemSleepAndWakeUp+0x1c0>)
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009424:	f8df a1cc 	ldr.w	sl, [pc, #460]	; 80095f4 <SystemSleepAndWakeUp+0x1d8>
{
 8009428:	b08c      	sub	sp, #48	; 0x30
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_RESET);
 800942a:	2200      	movs	r2, #0
 800942c:	4638      	mov	r0, r7
 800942e:	2102      	movs	r1, #2
 8009430:	f7f8 fe9e 	bl	8002170 <HAL_GPIO_WritePin>
	__HAL_RCC_GPIOA_CLK_ENABLE()
 8009434:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009436:	f043 0301 	orr.w	r3, r3, #1
 800943a:	64e3      	str	r3, [r4, #76]	; 0x4c
 800943c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800943e:	f003 0301 	and.w	r3, r3, #1
 8009442:	9301      	str	r3, [sp, #4]
 8009444:	9b01      	ldr	r3, [sp, #4]
	__HAL_RCC_GPIOB_CLK_ENABLE()
 8009446:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009448:	f043 0302 	orr.w	r3, r3, #2
 800944c:	64e3      	str	r3, [r4, #76]	; 0x4c
 800944e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009450:	f003 0302 	and.w	r3, r3, #2
 8009454:	9302      	str	r3, [sp, #8]
 8009456:	9b02      	ldr	r3, [sp, #8]
	__HAL_RCC_GPIOC_CLK_ENABLE()
 8009458:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800945a:	f043 0304 	orr.w	r3, r3, #4
 800945e:	64e3      	str	r3, [r4, #76]	; 0x4c
 8009460:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009462:	f003 0304 	and.w	r3, r3, #4
 8009466:	9303      	str	r3, [sp, #12]
 8009468:	9b03      	ldr	r3, [sp, #12]
	__HAL_RCC_GPIOD_CLK_ENABLE()
 800946a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800946c:	f043 0308 	orr.w	r3, r3, #8
 8009470:	64e3      	str	r3, [r4, #76]	; 0x4c
 8009472:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009474:	f003 0308 	and.w	r3, r3, #8
 8009478:	9304      	str	r3, [sp, #16]
 800947a:	9b04      	ldr	r3, [sp, #16]
	__HAL_RCC_GPIOH_CLK_ENABLE()
 800947c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800947e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8009482:	64e3      	str	r3, [r4, #76]	; 0x4c
 8009484:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009486:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800948a:	9305      	str	r3, [sp, #20]
 800948c:	9b05      	ldr	r3, [sp, #20]
	__HAL_RCC_GPIOE_CLK_ENABLE()
 800948e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009490:	f043 0310 	orr.w	r3, r3, #16
 8009494:	64e3      	str	r3, [r4, #76]	; 0x4c
 8009496:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009498:	f003 0310 	and.w	r3, r3, #16
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~GPIO_PIN_1) & (~GPIO_PIN_2) & (~GPIO_PIN_3)
 800949c:	ad0c      	add	r5, sp, #48	; 0x30
	__HAL_RCC_GPIOE_CLK_ENABLE()
 800949e:	9306      	str	r3, [sp, #24]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 80094a0:	2603      	movs	r6, #3
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 80094a2:	f04f 0900 	mov.w	r9, #0
	__HAL_RCC_GPIOE_CLK_ENABLE()
 80094a6:	9b06      	ldr	r3, [sp, #24]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 80094a8:	9608      	str	r6, [sp, #32]
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~GPIO_PIN_1) & (~GPIO_PIN_2) & (~GPIO_PIN_3)
 80094aa:	f64f 7331 	movw	r3, #65329	; 0xff31
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 80094ae:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~GPIO_PIN_1) & (~GPIO_PIN_2) & (~GPIO_PIN_3)
 80094b2:	f845 3d14 	str.w	r3, [r5, #-20]!
	HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 80094b6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80094ba:	4629      	mov	r1, r5
 80094bc:	f7f8 fd18 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStructure.Pull = GPIO_PULLDOWN;
 80094c0:	f04f 0802 	mov.w	r8, #2
	GPIO_InitStructure.Pin = Radio_EN_Pin | (GPIO_PIN_2) | (GPIO_PIN_3) | Sara_Power_On_Pin
 80094c4:	23ce      	movs	r3, #206	; 0xce
	HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 80094c6:	4629      	mov	r1, r5
 80094c8:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStructure.Pin = Radio_EN_Pin | (GPIO_PIN_2) | (GPIO_PIN_3) | Sara_Power_On_Pin
 80094cc:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 80094ce:	9608      	str	r6, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_PULLDOWN;
 80094d0:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 80094d4:	f7f8 fd0c 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~Spectrum_EN_Pin) & (~Temperature_EN_Pin);
 80094d8:	f64f 739f 	movw	r3, #65439	; 0xff9f
	HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 80094dc:	4629      	mov	r1, r5
 80094de:	4638      	mov	r0, r7
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~Spectrum_EN_Pin) & (~Temperature_EN_Pin);
 80094e0:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 80094e2:	9608      	str	r6, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 80094e4:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 80094e8:	f7f8 fd02 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStructure.Pin = Spectrum_EN_Pin | Temperature_EN_Pin;
 80094ec:	2360      	movs	r3, #96	; 0x60
	HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 80094ee:	4629      	mov	r1, r5
 80094f0:	4638      	mov	r0, r7
	GPIO_InitStructure.Pin = Spectrum_EN_Pin | Temperature_EN_Pin;
 80094f2:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 80094f4:	9608      	str	r6, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_PULLDOWN;
 80094f6:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOB, &GPIO_InitStructure);
 80094fa:	f7f8 fcf9 	bl	8001ef0 <HAL_GPIO_Init>
	DisEnableSDPin(0);
 80094fe:	4648      	mov	r0, r9
 8009500:	f000 fc7a 	bl	8009df8 <DisEnableSDPin>
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~GPIO_PIN_7) & (~VBAT_Sense_EN_Pin);
 8009504:	f64f 737b 	movw	r3, #65403	; 0xff7b
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009508:	4629      	mov	r1, r5
 800950a:	4650      	mov	r0, sl
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~GPIO_PIN_7) & (~VBAT_Sense_EN_Pin);
 800950c:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 800950e:	9608      	str	r6, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 8009510:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009514:	f7f8 fcec 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStructure.Pin = GPIO_PIN_7 | VBAT_Sense_EN_Pin;
 8009518:	2384      	movs	r3, #132	; 0x84
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 800951a:	4629      	mov	r1, r5
 800951c:	4650      	mov	r0, sl
	GPIO_InitStructure.Pin = GPIO_PIN_7 | VBAT_Sense_EN_Pin;
 800951e:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 8009520:	9608      	str	r6, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_PULLDOWN;
 8009522:	f8cd 8024 	str.w	r8, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009526:	f7f8 fce3 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStructure.Pin = GPIO_PIN_All;
 800952a:	f64f 73ff 	movw	r3, #65535	; 0xffff
	HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 800952e:	4629      	mov	r1, r5
 8009530:	482b      	ldr	r0, [pc, #172]	; (80095e0 <SystemSleepAndWakeUp+0x1c4>)
	GPIO_InitStructure.Pin = GPIO_PIN_All;
 8009532:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 8009534:	9608      	str	r6, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 8009536:	f8cd 9024 	str.w	r9, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 800953a:	f7f8 fcd9 	bl	8001ef0 <HAL_GPIO_Init>
	HAL_GPIO_Init(GPIOH, &GPIO_InitStructure);
 800953e:	4629      	mov	r1, r5
 8009540:	4828      	ldr	r0, [pc, #160]	; (80095e4 <SystemSleepAndWakeUp+0x1c8>)
 8009542:	f7f8 fcd5 	bl	8001ef0 <HAL_GPIO_Init>
	HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
 8009546:	4629      	mov	r1, r5
 8009548:	4827      	ldr	r0, [pc, #156]	; (80095e8 <SystemSleepAndWakeUp+0x1cc>)
 800954a:	f7f8 fcd1 	bl	8001ef0 <HAL_GPIO_Init>
	__HAL_RCC_GPIOA_CLK_DISABLE();
 800954e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009550:	f023 0301 	bic.w	r3, r3, #1
 8009554:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOB_CLK_DISABLE();
 8009556:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009558:	f023 0302 	bic.w	r3, r3, #2
 800955c:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOC_CLK_DISABLE();
 800955e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009560:	f023 0304 	bic.w	r3, r3, #4
 8009564:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOD_CLK_DISABLE();
 8009566:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009568:	f023 0308 	bic.w	r3, r3, #8
 800956c:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOH_CLK_DISABLE();
 800956e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009570:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009574:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOE_CLK_DISABLE();
 8009576:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009578:	f023 0310 	bic.w	r3, r3, #16
 800957c:	64e3      	str	r3, [r4, #76]	; 0x4c
	HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
 800957e:	4c1b      	ldr	r4, [pc, #108]	; (80095ec <SystemSleepAndWakeUp+0x1d0>)
	MX_I2C1_DeInit();
 8009580:	f000 fd42 	bl	800a008 <MX_I2C1_DeInit>
	MX_I2C2_DeInit();
 8009584:	f000 fd46 	bl	800a014 <MX_I2C2_DeInit>
	MX_LPUART1_UART_DeInit();
 8009588:	f001 f894 	bl	800a6b4 <MX_LPUART1_UART_DeInit>
	MX_ADC_DeInit();
 800958c:	f7fd ff00 	bl	8007390 <MX_ADC_DeInit>
	HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
 8009590:	4620      	mov	r0, r4
 8009592:	f7fa fbd2 	bl	8003d3a <HAL_RTCEx_DeactivateWakeUpTimer>
	HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 8009596:	2001      	movs	r0, #1
 8009598:	f7f9 fb24 	bl	8002be4 <HAL_PWREx_EnterSTOP2Mode>
	__HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&hrtc, RTC_FLAG_WUTF);
 800959c:	6822      	ldr	r2, [r4, #0]
 800959e:	68d3      	ldr	r3, [r2, #12]
 80095a0:	b2db      	uxtb	r3, r3
 80095a2:	f463 6390 	orn	r3, r3, #1152	; 0x480
 80095a6:	60d3      	str	r3, [r2, #12]
	__HAL_RTC_CLEAR_FLAG(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
 80095a8:	4b11      	ldr	r3, [pc, #68]	; (80095f0 <SystemSleepAndWakeUp+0x1d4>)
 80095aa:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 80095ae:	615a      	str	r2, [r3, #20]
	HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
 80095b0:	4620      	mov	r0, r4
 80095b2:	f7fa fbc2 	bl	8003d3a <HAL_RTCEx_DeactivateWakeUpTimer>
	SystemClock_Config();
 80095b6:	f7ff feab 	bl	8009310 <SystemClock_Config>
	MX_GPIO_Init();
 80095ba:	f000 f9cb 	bl	8009954 <MX_GPIO_Init>
	MX_LPUART1_UART_Init();
 80095be:	f000 ffb1 	bl	800a524 <MX_LPUART1_UART_Init>
	MX_USART2_UART_Init();
 80095c2:	f000 ffcf 	bl	800a564 <MX_USART2_UART_Init>
	HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, GPIO_PIN_SET);
 80095c6:	2201      	movs	r2, #1
 80095c8:	4641      	mov	r1, r8
 80095ca:	4638      	mov	r0, r7
 80095cc:	f7f8 fdd0 	bl	8002170 <HAL_GPIO_WritePin>
}
 80095d0:	b00c      	add	sp, #48	; 0x30
 80095d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80095d6:	bf00      	nop
 80095d8:	48000400 	.word	0x48000400
 80095dc:	40021000 	.word	0x40021000
 80095e0:	48000c00 	.word	0x48000c00
 80095e4:	48001c00 	.word	0x48001c00
 80095e8:	48001000 	.word	0x48001000
 80095ec:	2000c59c 	.word	0x2000c59c
 80095f0:	40010400 	.word	0x40010400
 80095f4:	48000800 	.word	0x48000800

080095f8 <EnterStopRadioNetwork>:
{
 80095f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	printf("Radio searching for network... \t going to sleep, leaving radio on\r\n");
 80095fc:	4857      	ldr	r0, [pc, #348]	; (800975c <EnterStopRadioNetwork+0x164>)
	__HAL_RCC_GPIOA_CLK_ENABLE()
 80095fe:	4c58      	ldr	r4, [pc, #352]	; (8009760 <EnterStopRadioNetwork+0x168>)
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 8009600:	f8df 8178 	ldr.w	r8, [pc, #376]	; 800977c <EnterStopRadioNetwork+0x184>
{
 8009604:	b08c      	sub	sp, #48	; 0x30
	printf("Radio searching for network... \t going to sleep, leaving radio on\r\n");
 8009606:	f003 ff11 	bl	800d42c <puts>
	RTC_SetAlarmB(1);
 800960a:	2001      	movs	r0, #1
 800960c:	f000 feb6 	bl	800a37c <RTC_SetAlarmB>
	__HAL_RCC_GPIOA_CLK_ENABLE()
 8009610:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009612:	f043 0301 	orr.w	r3, r3, #1
 8009616:	64e3      	str	r3, [r4, #76]	; 0x4c
 8009618:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800961a:	f003 0301 	and.w	r3, r3, #1
 800961e:	9301      	str	r3, [sp, #4]
 8009620:	9b01      	ldr	r3, [sp, #4]
	__HAL_RCC_GPIOB_CLK_ENABLE()
 8009622:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009624:	f043 0302 	orr.w	r3, r3, #2
 8009628:	64e3      	str	r3, [r4, #76]	; 0x4c
 800962a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800962c:	f003 0302 	and.w	r3, r3, #2
 8009630:	9302      	str	r3, [sp, #8]
 8009632:	9b02      	ldr	r3, [sp, #8]
	__HAL_RCC_GPIOC_CLK_ENABLE()
 8009634:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009636:	f043 0304 	orr.w	r3, r3, #4
 800963a:	64e3      	str	r3, [r4, #76]	; 0x4c
 800963c:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800963e:	f003 0304 	and.w	r3, r3, #4
 8009642:	9303      	str	r3, [sp, #12]
 8009644:	9b03      	ldr	r3, [sp, #12]
	__HAL_RCC_GPIOD_CLK_ENABLE()
 8009646:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009648:	f043 0308 	orr.w	r3, r3, #8
 800964c:	64e3      	str	r3, [r4, #76]	; 0x4c
 800964e:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009650:	f003 0308 	and.w	r3, r3, #8
 8009654:	9304      	str	r3, [sp, #16]
 8009656:	9b04      	ldr	r3, [sp, #16]
	__HAL_RCC_GPIOH_CLK_ENABLE()
 8009658:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800965a:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800965e:	64e3      	str	r3, [r4, #76]	; 0x4c
 8009660:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009662:	f003 0380 	and.w	r3, r3, #128	; 0x80
 8009666:	9305      	str	r3, [sp, #20]
 8009668:	9b05      	ldr	r3, [sp, #20]
	__HAL_RCC_GPIOE_CLK_ENABLE()
 800966a:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800966c:	f043 0310 	orr.w	r3, r3, #16
 8009670:	64e3      	str	r3, [r4, #76]	; 0x4c
 8009672:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
	GPIO_InitStructure.Pin = GPIO_PIN_8 & GPIO_PIN_9 & GPIO_PIN_10 & GPIO_PIN_11 & GPIO_PIN_12
 8009674:	ad0c      	add	r5, sp, #48	; 0x30
	__HAL_RCC_GPIOE_CLK_ENABLE()
 8009676:	f003 0310 	and.w	r3, r3, #16
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 800967a:	2600      	movs	r6, #0
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 800967c:	2703      	movs	r7, #3
	__HAL_RCC_GPIOE_CLK_ENABLE()
 800967e:	9306      	str	r3, [sp, #24]
 8009680:	9b06      	ldr	r3, [sp, #24]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 8009682:	9708      	str	r7, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 8009684:	9609      	str	r6, [sp, #36]	; 0x24
	GPIO_InitStructure.Pin = GPIO_PIN_8 & GPIO_PIN_9 & GPIO_PIN_10 & GPIO_PIN_11 & GPIO_PIN_12
 8009686:	f845 6d14 	str.w	r6, [r5, #-20]!
	HAL_GPIO_Init(GPIOA, &GPIO_InitStructure);
 800968a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800968e:	4629      	mov	r1, r5
 8009690:	f7f8 fc2e 	bl	8001ef0 <HAL_GPIO_Init>
	DisEnableSDPin(0);
 8009694:	4630      	mov	r0, r6
 8009696:	f000 fbaf 	bl	8009df8 <DisEnableSDPin>
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~GPIO_PIN_7);
 800969a:	f64f 737f 	movw	r3, #65407	; 0xff7f
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 800969e:	4629      	mov	r1, r5
 80096a0:	4640      	mov	r0, r8
	GPIO_InitStructure.Pin = GPIO_PIN_All & (~GPIO_PIN_7);
 80096a2:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 80096a4:	9708      	str	r7, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 80096a6:	9609      	str	r6, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 80096a8:	f7f8 fc22 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStructure.Pull = GPIO_PULLDOWN;
 80096ac:	2302      	movs	r3, #2
 80096ae:	9309      	str	r3, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 80096b0:	4629      	mov	r1, r5
	GPIO_InitStructure.Pin = GPIO_PIN_7;
 80096b2:	2380      	movs	r3, #128	; 0x80
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 80096b4:	4640      	mov	r0, r8
	GPIO_InitStructure.Pin = GPIO_PIN_7;
 80096b6:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 80096b8:	9708      	str	r7, [sp, #32]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStructure);
 80096ba:	f7f8 fc19 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStructure.Pin = GPIO_PIN_All;
 80096be:	f64f 73ff 	movw	r3, #65535	; 0xffff
	HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 80096c2:	4629      	mov	r1, r5
 80096c4:	4827      	ldr	r0, [pc, #156]	; (8009764 <EnterStopRadioNetwork+0x16c>)
	GPIO_InitStructure.Pin = GPIO_PIN_All;
 80096c6:	9307      	str	r3, [sp, #28]
	GPIO_InitStructure.Mode = GPIO_MODE_ANALOG;
 80096c8:	9708      	str	r7, [sp, #32]
	GPIO_InitStructure.Pull = GPIO_NOPULL;
 80096ca:	9609      	str	r6, [sp, #36]	; 0x24
	HAL_GPIO_Init(GPIOD, &GPIO_InitStructure);
 80096cc:	f7f8 fc10 	bl	8001ef0 <HAL_GPIO_Init>
	HAL_GPIO_Init(GPIOH, &GPIO_InitStructure);
 80096d0:	4629      	mov	r1, r5
 80096d2:	4825      	ldr	r0, [pc, #148]	; (8009768 <EnterStopRadioNetwork+0x170>)
 80096d4:	f7f8 fc0c 	bl	8001ef0 <HAL_GPIO_Init>
	HAL_GPIO_Init(GPIOE, &GPIO_InitStructure);
 80096d8:	4629      	mov	r1, r5
 80096da:	4824      	ldr	r0, [pc, #144]	; (800976c <EnterStopRadioNetwork+0x174>)
 80096dc:	f7f8 fc08 	bl	8001ef0 <HAL_GPIO_Init>
	__HAL_RCC_GPIOA_CLK_DISABLE();
 80096e0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80096e2:	f023 0301 	bic.w	r3, r3, #1
 80096e6:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOB_CLK_DISABLE();
 80096e8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80096ea:	f023 0302 	bic.w	r3, r3, #2
 80096ee:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOC_CLK_DISABLE();
 80096f0:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80096f2:	f023 0304 	bic.w	r3, r3, #4
 80096f6:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOD_CLK_DISABLE();
 80096f8:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 80096fa:	f023 0308 	bic.w	r3, r3, #8
 80096fe:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOH_CLK_DISABLE();
 8009700:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 8009702:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 8009706:	64e3      	str	r3, [r4, #76]	; 0x4c
	__HAL_RCC_GPIOE_CLK_DISABLE();
 8009708:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800970a:	f023 0310 	bic.w	r3, r3, #16
 800970e:	64e3      	str	r3, [r4, #76]	; 0x4c
	HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
 8009710:	4c17      	ldr	r4, [pc, #92]	; (8009770 <EnterStopRadioNetwork+0x178>)
	MX_LPUART1_UART_DeInit();
 8009712:	f000 ffcf 	bl	800a6b4 <MX_LPUART1_UART_DeInit>
	HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
 8009716:	4620      	mov	r0, r4
 8009718:	f7fa fb0f 	bl	8003d3a <HAL_RTCEx_DeactivateWakeUpTimer>
	HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 800971c:	2001      	movs	r0, #1
 800971e:	f7f9 fa61 	bl	8002be4 <HAL_PWREx_EnterSTOP2Mode>
	__HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&hrtc, RTC_FLAG_WUTF);
 8009722:	6822      	ldr	r2, [r4, #0]
 8009724:	68d3      	ldr	r3, [r2, #12]
 8009726:	b2db      	uxtb	r3, r3
 8009728:	f463 6390 	orn	r3, r3, #1152	; 0x480
 800972c:	60d3      	str	r3, [r2, #12]
	__HAL_RTC_CLEAR_FLAG(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
 800972e:	4b11      	ldr	r3, [pc, #68]	; (8009774 <EnterStopRadioNetwork+0x17c>)
 8009730:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 8009734:	615a      	str	r2, [r3, #20]
	HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
 8009736:	4620      	mov	r0, r4
 8009738:	f7fa faff 	bl	8003d3a <HAL_RTCEx_DeactivateWakeUpTimer>
	SystemClock_Config();
 800973c:	f7ff fde8 	bl	8009310 <SystemClock_Config>
	GPIOInitRadio();
 8009740:	f000 f9c4 	bl	8009acc <GPIOInitRadio>
	MX_LPUART1_UART_Init();
 8009744:	f000 feee 	bl	800a524 <MX_LPUART1_UART_Init>
	MX_USART2_UART_Init();
 8009748:	f000 ff0c 	bl	800a564 <MX_USART2_UART_Init>
	MX_LPTIM1_Init();
 800974c:	f000 fcc2 	bl	800a0d4 <MX_LPTIM1_Init>
	printf("Start\r\n");
 8009750:	4809      	ldr	r0, [pc, #36]	; (8009778 <EnterStopRadioNetwork+0x180>)
 8009752:	f003 fe6b 	bl	800d42c <puts>
}
 8009756:	b00c      	add	sp, #48	; 0x30
 8009758:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800975c:	0800f8ac 	.word	0x0800f8ac
 8009760:	40021000 	.word	0x40021000
 8009764:	48000c00 	.word	0x48000c00
 8009768:	48001c00 	.word	0x48001c00
 800976c:	48001000 	.word	0x48001000
 8009770:	2000c59c 	.word	0x2000c59c
 8009774:	40010400 	.word	0x40010400
 8009778:	0800f8ef 	.word	0x0800f8ef
 800977c:	48000800 	.word	0x48000800

08009780 <SleepForApproxMs>:
{
 8009780:	b510      	push	{r4, lr}
	HAL_LPTIM_TimeOut_Start_IT(&hlptim1, period, sleepTime);
 8009782:	4c08      	ldr	r4, [pc, #32]	; (80097a4 <SleepForApproxMs+0x24>)
 8009784:	0142      	lsls	r2, r0, #5
 8009786:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800978a:	4620      	mov	r0, r4
 800978c:	f7f9 f958 	bl	8002a40 <HAL_LPTIM_TimeOut_Start_IT>
	HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 8009790:	2001      	movs	r0, #1
 8009792:	f7f9 fa27 	bl	8002be4 <HAL_PWREx_EnterSTOP2Mode>
	SystemClock_Config();
 8009796:	f7ff fdbb 	bl	8009310 <SystemClock_Config>
	HAL_LPTIM_TimeOut_Stop_IT(&hlptim1);
 800979a:	4620      	mov	r0, r4
}
 800979c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	HAL_LPTIM_TimeOut_Stop_IT(&hlptim1);
 80097a0:	f7f9 b96a 	b.w	8002a78 <HAL_LPTIM_TimeOut_Stop_IT>
 80097a4:	2000c564 	.word	0x2000c564

080097a8 <SleepForApproxMsSpectra>:
 80097a8:	f7ff bfea 	b.w	8009780 <SleepForApproxMs>

080097ac <InitAll>:
{
 80097ac:	b508      	push	{r3, lr}
	HAL_Init();
 80097ae:	f7f7 fb55 	bl	8000e5c <HAL_Init>
	SystemClock_Config();
 80097b2:	f7ff fdad 	bl	8009310 <SystemClock_Config>
	CheckResetCause();
 80097b6:	f7ff fd6d 	bl	8009294 <CheckResetCause>
	MX_GPIO_Init();
 80097ba:	f000 f8cb 	bl	8009954 <MX_GPIO_Init>
	MX_CRC_Init();
 80097be:	f000 f899 	bl	80098f4 <MX_CRC_Init>
	MX_I2C2_Init();
 80097c2:	f000 fb83 	bl	8009ecc <MX_I2C2_Init>
	MX_RTC_Init();
 80097c6:	f000 fcc3 	bl	800a150 <MX_RTC_Init>
	MX_LPUART1_UART_Init();
 80097ca:	f000 feab 	bl	800a524 <MX_LPUART1_UART_Init>
	MX_USART2_UART_Init();
 80097ce:	f000 fec9 	bl	800a564 <MX_USART2_UART_Init>
	MX_I2C1_Init();
 80097d2:	f000 fb47 	bl	8009e64 <MX_I2C1_Init>
	MX_ADC1_Init();
 80097d6:	f000 f819 	bl	800980c <MX_ADC1_Init>
	MX_LPTIM1_Init();
 80097da:	f000 fc7b 	bl	800a0d4 <MX_LPTIM1_Init>
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_ClearFlag_ORE(USART_TypeDef *USARTx)
{
  WRITE_REG(USARTx->ICR, USART_ICR_ORECF);
 80097de:	4b09      	ldr	r3, [pc, #36]	; (8009804 <InitAll+0x58>)
 80097e0:	2208      	movs	r2, #8
 80097e2:	621a      	str	r2, [r3, #32]
  * @param  USARTx USART Instance
  * @retval None
  */
__STATIC_INLINE void LL_USART_EnableIT_RXNE(USART_TypeDef *USARTx)
{
  SET_BIT(USARTx->CR1, USART_CR1_RXNEIE);
 80097e4:	681a      	ldr	r2, [r3, #0]
 80097e6:	f042 0220 	orr.w	r2, r2, #32
 80097ea:	601a      	str	r2, [r3, #0]
	MX_FATFS_Init();
 80097ec:	f7fe fb50 	bl	8007e90 <MX_FATFS_Init>
	MX_SDMMC1_SD_Init();
 80097f0:	f7fe fbc6 	bl	8007f80 <MX_SDMMC1_SD_Init>
	HAL_SD_MspInit(&hsd1);
 80097f4:	4804      	ldr	r0, [pc, #16]	; (8009808 <InitAll+0x5c>)
 80097f6:	f7fe fbd3 	bl	8007fa0 <HAL_SD_MspInit>
}
 80097fa:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	MX_IWDG_Init();
 80097fe:	f000 bc0f 	b.w	800a020 <MX_IWDG_Init>
 8009802:	bf00      	nop
 8009804:	40004400 	.word	0x40004400
 8009808:	2000083c 	.word	0x2000083c

0800980c <MX_ADC1_Init>:

ADC_HandleTypeDef hadc1;

/* ADC1 init function */
void MX_ADC1_Init(void)
{
 800980c:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
  ADC_ChannelConfTypeDef sConfig;

    /**Common config 
    */
  hadc1.Instance = ADC1;
 800980e:	4819      	ldr	r0, [pc, #100]	; (8009874 <MX_ADC1_Init+0x68>)
 8009810:	4b19      	ldr	r3, [pc, #100]	; (8009878 <MX_ADC1_Init+0x6c>)
 8009812:	6003      	str	r3, [r0, #0]
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8009814:	2204      	movs	r2, #4
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 8009816:	2300      	movs	r3, #0
  hadc1.Init.EOCSelection = ADC_EOC_SINGLE_CONV;
 8009818:	6142      	str	r2, [r0, #20]
  hadc1.Init.LowPowerAutoWait = DISABLE;
	hadc1.Init.ContinuousConvMode = DISABLE;
  hadc1.Init.NbrOfConversion = 1;
 800981a:	2201      	movs	r2, #1
  hadc1.Init.ClockPrescaler = ADC_CLOCK_ASYNC_DIV1;
 800981c:	6043      	str	r3, [r0, #4]
  hadc1.Init.Resolution = ADC_RESOLUTION_12B;
 800981e:	6083      	str	r3, [r0, #8]
  hadc1.Init.DataAlign = ADC_DATAALIGN_RIGHT;
 8009820:	60c3      	str	r3, [r0, #12]
  hadc1.Init.ScanConvMode = ADC_SCAN_DISABLE;
 8009822:	6103      	str	r3, [r0, #16]
  hadc1.Init.LowPowerAutoWait = DISABLE;
 8009824:	6183      	str	r3, [r0, #24]
	hadc1.Init.ContinuousConvMode = DISABLE;
 8009826:	61c3      	str	r3, [r0, #28]
  hadc1.Init.NbrOfConversion = 1;
 8009828:	6202      	str	r2, [r0, #32]
  hadc1.Init.DiscontinuousConvMode = DISABLE;
 800982a:	6243      	str	r3, [r0, #36]	; 0x24
  hadc1.Init.NbrOfDiscConversion = 1;
 800982c:	6282      	str	r2, [r0, #40]	; 0x28
  hadc1.Init.ExternalTrigConv = ADC_SOFTWARE_START;
 800982e:	62c3      	str	r3, [r0, #44]	; 0x2c
  hadc1.Init.ExternalTrigConvEdge = ADC_EXTERNALTRIGCONVEDGE_NONE;
 8009830:	6303      	str	r3, [r0, #48]	; 0x30
  hadc1.Init.DMAContinuousRequests = DISABLE;
 8009832:	6343      	str	r3, [r0, #52]	; 0x34
  hadc1.Init.Overrun = ADC_OVR_DATA_PRESERVED;
 8009834:	6383      	str	r3, [r0, #56]	; 0x38
  hadc1.Init.OversamplingMode = DISABLE;
 8009836:	63c3      	str	r3, [r0, #60]	; 0x3c
  if (HAL_ADC_Init(&hadc1) != HAL_OK)
 8009838:	f7f7 fb66 	bl	8000f08 <HAL_ADC_Init>
 800983c:	b118      	cbz	r0, 8009846 <MX_ADC1_Init+0x3a>
  {
    _Error_Handler(__FILE__, __LINE__);
 800983e:	2156      	movs	r1, #86	; 0x56
 8009840:	480e      	ldr	r0, [pc, #56]	; (800987c <MX_ADC1_Init+0x70>)
 8009842:	f003 f99b 	bl	800cb7c <_Error_Handler>
  }

    /**Configure Regular Channel 
    */
	sConfig.Channel = ADC_CHANNEL_4;
  sConfig.Rank = ADC_REGULAR_RANK_1;
 8009846:	4a0e      	ldr	r2, [pc, #56]	; (8009880 <MX_ADC1_Init+0x74>)
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
  sConfig.Offset = 0;
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8009848:	480a      	ldr	r0, [pc, #40]	; (8009874 <MX_ADC1_Init+0x68>)
  sConfig.Rank = ADC_REGULAR_RANK_1;
 800984a:	2306      	movs	r3, #6
 800984c:	e88d 000c 	stmia.w	sp, {r2, r3}
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8009850:	227f      	movs	r2, #127	; 0x7f
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
 8009852:	2300      	movs	r3, #0
  sConfig.SingleDiff = ADC_SINGLE_ENDED;
 8009854:	9203      	str	r2, [sp, #12]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8009856:	4669      	mov	r1, sp
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 8009858:	2204      	movs	r2, #4
  sConfig.SamplingTime = ADC_SAMPLETIME_2CYCLES_5;
 800985a:	9302      	str	r3, [sp, #8]
  sConfig.OffsetNumber = ADC_OFFSET_NONE;
 800985c:	9204      	str	r2, [sp, #16]
  sConfig.Offset = 0;
 800985e:	9305      	str	r3, [sp, #20]
  if (HAL_ADC_ConfigChannel(&hadc1, &sConfig) != HAL_OK)
 8009860:	f7f7 fc72 	bl	8001148 <HAL_ADC_ConfigChannel>
 8009864:	b118      	cbz	r0, 800986e <MX_ADC1_Init+0x62>
  {
    _Error_Handler(__FILE__, __LINE__);
 8009866:	2163      	movs	r1, #99	; 0x63
 8009868:	4804      	ldr	r0, [pc, #16]	; (800987c <MX_ADC1_Init+0x70>)
 800986a:	f003 f987 	bl	800cb7c <_Error_Handler>
  }

}
 800986e:	b007      	add	sp, #28
 8009870:	f85d fb04 	ldr.w	pc, [sp], #4
 8009874:	2000c42c 	.word	0x2000c42c
 8009878:	50040000 	.word	0x50040000
 800987c:	0800f911 	.word	0x0800f911
 8009880:	10c00010 	.word	0x10c00010

08009884 <HAL_ADC_MspInit>:

void HAL_ADC_MspInit(ADC_HandleTypeDef* adcHandle)
{
 8009884:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(adcHandle->Instance==ADC1)
 8009886:	6802      	ldr	r2, [r0, #0]
 8009888:	4b0e      	ldr	r3, [pc, #56]	; (80098c4 <HAL_ADC_MspInit+0x40>)
 800988a:	429a      	cmp	r2, r3
 800988c:	d116      	bne.n	80098bc <HAL_ADC_MspInit+0x38>
  {
  /* USER CODE BEGIN ADC1_MspInit 0 */

  /* USER CODE END ADC1_MspInit 0 */
    /* ADC1 clock enable */
    __HAL_RCC_ADC_CLK_ENABLE();
 800988e:	f103 4370 	add.w	r3, r3, #4026531840	; 0xf0000000
 8009892:	f5a3 33f8 	sub.w	r3, r3, #126976	; 0x1f000
//    HAL_GPIO_Init(VINT_Sense_GPIO_Port, &GPIO_InitStruct);

    GPIO_InitStruct.Pin = VBAT_Sense_Pin;
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(VBAT_Sense_GPIO_Port, &GPIO_InitStruct);
 8009896:	a901      	add	r1, sp, #4
    __HAL_RCC_ADC_CLK_ENABLE();
 8009898:	6cda      	ldr	r2, [r3, #76]	; 0x4c
    HAL_GPIO_Init(VBAT_Sense_GPIO_Port, &GPIO_InitStruct);
 800989a:	480b      	ldr	r0, [pc, #44]	; (80098c8 <HAL_ADC_MspInit+0x44>)
    __HAL_RCC_ADC_CLK_ENABLE();
 800989c:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 80098a0:	64da      	str	r2, [r3, #76]	; 0x4c
 80098a2:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80098a4:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 80098a8:	9300      	str	r3, [sp, #0]
 80098aa:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Pin = VBAT_Sense_Pin;
 80098ac:	2308      	movs	r3, #8
 80098ae:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Mode = GPIO_MODE_ANALOG_ADC_CONTROL;
 80098b0:	230b      	movs	r3, #11
 80098b2:	9302      	str	r3, [sp, #8]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 80098b4:	2300      	movs	r3, #0
 80098b6:	9303      	str	r3, [sp, #12]
    HAL_GPIO_Init(VBAT_Sense_GPIO_Port, &GPIO_InitStruct);
 80098b8:	f7f8 fb1a 	bl	8001ef0 <HAL_GPIO_Init>

  /* USER CODE BEGIN ADC1_MspInit 1 */

  /* USER CODE END ADC1_MspInit 1 */
  }
}
 80098bc:	b007      	add	sp, #28
 80098be:	f85d fb04 	ldr.w	pc, [sp], #4
 80098c2:	bf00      	nop
 80098c4:	50040000 	.word	0x50040000
 80098c8:	48000800 	.word	0x48000800

080098cc <HAL_ADC_MspDeInit>:

void HAL_ADC_MspDeInit(ADC_HandleTypeDef* adcHandle)
{

  if(adcHandle->Instance==ADC1)
 80098cc:	6802      	ldr	r2, [r0, #0]
 80098ce:	4b06      	ldr	r3, [pc, #24]	; (80098e8 <HAL_ADC_MspDeInit+0x1c>)
 80098d0:	429a      	cmp	r2, r3
 80098d2:	d108      	bne.n	80098e6 <HAL_ADC_MspDeInit+0x1a>
  {
  /* USER CODE BEGIN ADC1_MspDeInit 0 */

  /* USER CODE END ADC1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_ADC_CLK_DISABLE();
 80098d4:	4a05      	ldr	r2, [pc, #20]	; (80098ec <HAL_ADC_MspDeInit+0x20>)
    PC4     ------> ADC1_IN13
    PB0     ------> ADC1_IN15 
    */
//    HAL_GPIO_DeInit(VINT_Sense_GPIO_Port, VINT_Sense_Pin);

    HAL_GPIO_DeInit(VBAT_Sense_GPIO_Port, VBAT_Sense_Pin);
 80098d6:	4806      	ldr	r0, [pc, #24]	; (80098f0 <HAL_ADC_MspDeInit+0x24>)
    __HAL_RCC_ADC_CLK_DISABLE();
 80098d8:	6cd3      	ldr	r3, [r2, #76]	; 0x4c
 80098da:	f423 5300 	bic.w	r3, r3, #8192	; 0x2000
 80098de:	64d3      	str	r3, [r2, #76]	; 0x4c
    HAL_GPIO_DeInit(VBAT_Sense_GPIO_Port, VBAT_Sense_Pin);
 80098e0:	2108      	movs	r1, #8
 80098e2:	f7f8 bbc7 	b.w	8002074 <HAL_GPIO_DeInit>
 80098e6:	4770      	bx	lr
 80098e8:	50040000 	.word	0x50040000
 80098ec:	40021000 	.word	0x40021000
 80098f0:	48000800 	.word	0x48000800

080098f4 <MX_CRC_Init>:

/* CRC init function */
void MX_CRC_Init(void)
{

  hcrc.Instance = CRC;
 80098f4:	480a      	ldr	r0, [pc, #40]	; (8009920 <MX_CRC_Init+0x2c>)
{
 80098f6:	b508      	push	{r3, lr}
  hcrc.Instance = CRC;
 80098f8:	4b0a      	ldr	r3, [pc, #40]	; (8009924 <MX_CRC_Init+0x30>)
 80098fa:	6003      	str	r3, [r0, #0]
  hcrc.Init.DefaultPolynomialUse = DEFAULT_POLYNOMIAL_ENABLE;
 80098fc:	2300      	movs	r3, #0
 80098fe:	7103      	strb	r3, [r0, #4]
  hcrc.Init.DefaultInitValueUse = DEFAULT_INIT_VALUE_ENABLE;
 8009900:	7143      	strb	r3, [r0, #5]
  hcrc.Init.InputDataInversionMode = CRC_INPUTDATA_INVERSION_NONE;
 8009902:	6143      	str	r3, [r0, #20]
  hcrc.Init.OutputDataInversionMode = CRC_OUTPUTDATA_INVERSION_DISABLE;
 8009904:	6183      	str	r3, [r0, #24]
  hcrc.InputDataFormat = CRC_INPUTDATA_FORMAT_BYTES;
 8009906:	2301      	movs	r3, #1
 8009908:	6203      	str	r3, [r0, #32]
  if (HAL_CRC_Init(&hcrc) != HAL_OK)
 800990a:	f7f8 f8db 	bl	8001ac4 <HAL_CRC_Init>
 800990e:	b128      	cbz	r0, 800991c <MX_CRC_Init+0x28>
  {
    _Error_Handler(__FILE__, __LINE__);
 8009910:	2147      	movs	r1, #71	; 0x47
 8009912:	4805      	ldr	r0, [pc, #20]	; (8009928 <MX_CRC_Init+0x34>)
  }

}
 8009914:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
 8009918:	f003 b930 	b.w	800cb7c <_Error_Handler>
 800991c:	bd08      	pop	{r3, pc}
 800991e:	bf00      	nop
 8009920:	2000c498 	.word	0x2000c498
 8009924:	40023000 	.word	0x40023000
 8009928:	0800f927 	.word	0x0800f927

0800992c <HAL_CRC_MspInit>:

void HAL_CRC_MspInit(CRC_HandleTypeDef* crcHandle)
{

  if(crcHandle->Instance==CRC)
 800992c:	6802      	ldr	r2, [r0, #0]
 800992e:	4b08      	ldr	r3, [pc, #32]	; (8009950 <HAL_CRC_MspInit+0x24>)
 8009930:	429a      	cmp	r2, r3
{
 8009932:	b082      	sub	sp, #8
  if(crcHandle->Instance==CRC)
 8009934:	d10a      	bne.n	800994c <HAL_CRC_MspInit+0x20>
  {
  /* USER CODE BEGIN CRC_MspInit 0 */

  /* USER CODE END CRC_MspInit 0 */
    /* CRC clock enable */
    __HAL_RCC_CRC_CLK_ENABLE();
 8009936:	f5a3 5300 	sub.w	r3, r3, #8192	; 0x2000
 800993a:	6c9a      	ldr	r2, [r3, #72]	; 0x48
 800993c:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009940:	649a      	str	r2, [r3, #72]	; 0x48
 8009942:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 8009944:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8009948:	9301      	str	r3, [sp, #4]
 800994a:	9b01      	ldr	r3, [sp, #4]
  /* USER CODE BEGIN CRC_MspInit 1 */

  /* USER CODE END CRC_MspInit 1 */
  }
}
 800994c:	b002      	add	sp, #8
 800994e:	4770      	bx	lr
 8009950:	40023000 	.word	0x40023000

08009954 <MX_GPIO_Init>:
{

  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8009954:	4b59      	ldr	r3, [pc, #356]	; (8009abc <MX_GPIO_Init+0x168>)
{
 8009956:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800995a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  __HAL_RCC_GPIOA_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();

  /*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(
 800995c:	4d58      	ldr	r5, [pc, #352]	; (8009ac0 <MX_GPIO_Init+0x16c>)
			USART2_CTS_Pin | USART2_CK_Pin | Radio_EN_Pin
                          |Sara_Power_On_Pin|Sara_Reset_Pin|DebugPin9_Pin|DebugPin11_Pin 
                          |DebugPin13_Pin, GPIO_PIN_RESET);

  /*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(
 800995e:	4f59      	ldr	r7, [pc, #356]	; (8009ac4 <MX_GPIO_Init+0x170>)
  __HAL_RCC_GPIOC_CLK_ENABLE();
 8009960:	f042 0204 	orr.w	r2, r2, #4
 8009964:	64da      	str	r2, [r3, #76]	; 0x4c
 8009966:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 8009968:	b08a      	sub	sp, #40	; 0x28
  __HAL_RCC_GPIOC_CLK_ENABLE();
 800996a:	f002 0204 	and.w	r2, r2, #4
 800996e:	9200      	str	r2, [sp, #0]
 8009970:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_GPIOH_CLK_ENABLE();
 8009972:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009974:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8009978:	64da      	str	r2, [r3, #76]	; 0x4c
 800997a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800997c:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8009980:	9201      	str	r2, [sp, #4]
 8009982:	9a01      	ldr	r2, [sp, #4]
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8009984:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009986:	f042 0201 	orr.w	r2, r2, #1
 800998a:	64da      	str	r2, [r3, #76]	; 0x4c
 800998c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800998e:	f002 0201 	and.w	r2, r2, #1
 8009992:	9202      	str	r2, [sp, #8]
 8009994:	9a02      	ldr	r2, [sp, #8]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8009996:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009998:	f042 0202 	orr.w	r2, r2, #2
 800999c:	64da      	str	r2, [r3, #76]	; 0x4c
 800999e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80099a0:	f002 0202 	and.w	r2, r2, #2
 80099a4:	9203      	str	r2, [sp, #12]
 80099a6:	9a03      	ldr	r2, [sp, #12]
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80099a8:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 80099aa:	f042 0208 	orr.w	r2, r2, #8
 80099ae:	64da      	str	r2, [r3, #76]	; 0x4c
 80099b0:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80099b2:	f003 0308 	and.w	r3, r3, #8
 80099b6:	9304      	str	r3, [sp, #16]
	HAL_GPIO_WritePin(
 80099b8:	4628      	mov	r0, r5
 80099ba:	2200      	movs	r2, #0
 80099bc:	21e4      	movs	r1, #228	; 0xe4
  __HAL_RCC_GPIOD_CLK_ENABLE();
 80099be:	9b04      	ldr	r3, [sp, #16]
	HAL_GPIO_WritePin(
 80099c0:	f7f8 fbd6 	bl	8002170 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(
 80099c4:	2200      	movs	r2, #0
 80099c6:	f248 51d3 	movw	r1, #34259	; 0x85d3
 80099ca:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80099ce:	f7f8 fbcf 	bl	8002170 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(
 80099d2:	2200      	movs	r2, #0
 80099d4:	4638      	mov	r0, r7
 80099d6:	21f6      	movs	r1, #246	; 0xf6
 80099d8:	f7f8 fbca 	bl	8002170 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PCPin PCPin PCPin PCPin 
                           PCPin PCPin */
	GPIO_InitStruct.Pin = Heartbeat_Pin | DebugPin12_Pin | DebugPin16_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80099dc:	2400      	movs	r4, #0
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80099de:	2601      	movs	r6, #1
	GPIO_InitStruct.Pin = Heartbeat_Pin | DebugPin12_Pin | DebugPin16_Pin;
 80099e0:	2364      	movs	r3, #100	; 0x64
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80099e2:	a905      	add	r1, sp, #20
 80099e4:	4628      	mov	r0, r5
	GPIO_InitStruct.Pin = Heartbeat_Pin | DebugPin12_Pin | DebugPin16_Pin;
 80099e6:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80099e8:	9606      	str	r6, [sp, #24]

	GPIO_InitStruct.Pin = SD_Power_EN_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 80099ea:	f04f 0802 	mov.w	r8, #2
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 80099ee:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 80099f0:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80099f2:	f7f8 fa7d 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = SD_Power_EN_Pin;
 80099f6:	2380      	movs	r3, #128	; 0x80
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 80099f8:	a905      	add	r1, sp, #20
 80099fa:	4628      	mov	r0, r5
	GPIO_InitStruct.Pin = SD_Power_EN_Pin;
 80099fc:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 80099fe:	9606      	str	r6, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8009a00:	f8cd 801c 	str.w	r8, [sp, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009a04:	9408      	str	r4, [sp, #32]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009a06:	f7f8 fa73 	bl	8001ef0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PAPin PAPin PAPin PAPin
                           PAPin PAPin PAPin PAPin 
                           PAPin */
	GPIO_InitStruct.Pin = USART2_CTS_Pin | USART2_CK_Pin | Radio_EN_Pin
 8009a0a:	f248 53d3 	movw	r3, #34259	; 0x85d3
                          |Sara_Power_On_Pin|Sara_Reset_Pin|DebugPin9_Pin|DebugPin11_Pin 
                          |DebugPin13_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009a0e:	a905      	add	r1, sp, #20
 8009a10:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Pin = USART2_CTS_Pin | USART2_CK_Pin | Radio_EN_Pin
 8009a14:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009a16:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009a18:	9407      	str	r4, [sp, #28]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009a1a:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009a1c:	f7f8 fa68 	bl	8001ef0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin PBPin */
	GPIO_InitStruct.Pin = INT1_MCU_Pin | INT2_MCU_Pin;
 8009a20:	f44f 5340 	mov.w	r3, #12288	; 0x3000
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009a24:	a905      	add	r1, sp, #20
 8009a26:	4638      	mov	r0, r7
	GPIO_InitStruct.Pin = INT1_MCU_Pin | INT2_MCU_Pin;
 8009a28:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009a2a:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009a2c:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009a2e:	f7f8 fa5f 	bl	8001ef0 <HAL_GPIO_Init>

	GPIO_InitStruct.Pin = VINT_Sense_Pin;
 8009a32:	2310      	movs	r3, #16
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009a34:	a905      	add	r1, sp, #20
 8009a36:	4628      	mov	r0, r5
	GPIO_InitStruct.Pin = VINT_Sense_Pin;
 8009a38:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009a3a:	9406      	str	r4, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8009a3c:	f8cd 801c 	str.w	r8, [sp, #28]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009a40:	f7f8 fa56 	bl	8001ef0 <HAL_GPIO_Init>

  /*Configure GPIO pins : PBPin PBPin PBPin PBPin
                           PBPin PBPin PBPin */
	GPIO_InitStruct.Pin = VBAT_Sense_EN_Pin | PCB_Ver_Sense_Pin
 8009a44:	23f6      	movs	r3, #246	; 0xf6
                          | DebugPin19_Pin
			| DebugPin22_Pin;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009a46:	a905      	add	r1, sp, #20
 8009a48:	4638      	mov	r0, r7
	GPIO_InitStruct.Pin = VBAT_Sense_EN_Pin | PCB_Ver_Sense_Pin
 8009a4a:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009a4c:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009a4e:	9407      	str	r4, [sp, #28]

  /*Configure GPIO pins : PC9 PC10 PC11 */
  GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009a50:	2603      	movs	r6, #3
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009a52:	9408      	str	r4, [sp, #32]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009a54:	f7f8 fa4c 	bl	8001ef0 <HAL_GPIO_Init>
  GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
 8009a58:	f44f 6360 	mov.w	r3, #3584	; 0xe00
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009a5c:	a905      	add	r1, sp, #20
 8009a5e:	4628      	mov	r0, r5
  GPIO_InitStruct.Pin = GPIO_PIN_9|GPIO_PIN_10|GPIO_PIN_11;
 8009a60:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009a62:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009a64:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009a66:	f7f8 fa43 	bl	8001ef0 <HAL_GPIO_Init>

  /*Configure GPIO pin : PtPin */
	GPIO_InitStruct.Pin = VBUS_Detect_Pin | Charge_Detect_Pin;
 8009a6a:	f44f 4302 	mov.w	r3, #33280	; 0x8200
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(VBUS_Detect_GPIO_Port, &GPIO_InitStruct);
 8009a6e:	a905      	add	r1, sp, #20
 8009a70:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Pin = VBUS_Detect_Pin | Charge_Detect_Pin;
 8009a74:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009a76:	9406      	str	r4, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009a78:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(VBUS_Detect_GPIO_Port, &GPIO_InitStruct);
 8009a7a:	f7f8 fa39 	bl	8001ef0 <HAL_GPIO_Init>

  /*Configure GPIO pin : PA11 */
  GPIO_InitStruct.Pin = GPIO_PIN_11;
 8009a7e:	f44f 6300 	mov.w	r3, #2048	; 0x800
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009a82:	a905      	add	r1, sp, #20
 8009a84:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  GPIO_InitStruct.Pin = GPIO_PIN_11;
 8009a88:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009a8a:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009a8c:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009a8e:	f7f8 fa2f 	bl	8001ef0 <HAL_GPIO_Init>

  /*Configure GPIO pin : PA12 */
  GPIO_InitStruct.Pin = GPIO_PIN_12;
 8009a92:	f44f 5380 	mov.w	r3, #4096	; 0x1000
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009a96:	a905      	add	r1, sp, #20
 8009a98:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  GPIO_InitStruct.Pin = GPIO_PIN_12;
 8009a9c:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009a9e:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009aa0:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009aa2:	f7f8 fa25 	bl	8001ef0 <HAL_GPIO_Init>

  /*Configure GPIO pin : PH3 */
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 8009aa6:	2308      	movs	r3, #8
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8009aa8:	a905      	add	r1, sp, #20
 8009aaa:	4807      	ldr	r0, [pc, #28]	; (8009ac8 <MX_GPIO_Init+0x174>)
  GPIO_InitStruct.Pin = GPIO_PIN_3;
 8009aac:	9305      	str	r3, [sp, #20]
  GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009aae:	9606      	str	r6, [sp, #24]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009ab0:	9407      	str	r4, [sp, #28]
  HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8009ab2:	f7f8 fa1d 	bl	8001ef0 <HAL_GPIO_Init>

}
 8009ab6:	b00a      	add	sp, #40	; 0x28
 8009ab8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009abc:	40021000 	.word	0x40021000
 8009ac0:	48000800 	.word	0x48000800
 8009ac4:	48000400 	.word	0x48000400
 8009ac8:	48001c00 	.word	0x48001c00

08009acc <GPIOInitRadio>:
void GPIOInitRadio(void)
{
	GPIO_InitTypeDef GPIO_InitStruct;

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE()
 8009acc:	4b52      	ldr	r3, [pc, #328]	; (8009c18 <GPIOInitRadio+0x14c>)
{
 8009ace:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	__HAL_RCC_GPIOC_CLK_ENABLE()
 8009ad2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
	;
	__HAL_RCC_GPIOD_CLK_ENABLE()
	;

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC,
 8009ad4:	4f51      	ldr	r7, [pc, #324]	; (8009c1c <GPIOInitRadio+0x150>)

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, DebugPin9_Pin | DebugPin11_Pin | DebugPin13_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOB,
 8009ad6:	4d52      	ldr	r5, [pc, #328]	; (8009c20 <GPIOInitRadio+0x154>)
	__HAL_RCC_GPIOC_CLK_ENABLE()
 8009ad8:	f042 0204 	orr.w	r2, r2, #4
 8009adc:	64da      	str	r2, [r3, #76]	; 0x4c
 8009ade:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 8009ae0:	b08a      	sub	sp, #40	; 0x28
	__HAL_RCC_GPIOC_CLK_ENABLE()
 8009ae2:	f002 0204 	and.w	r2, r2, #4
 8009ae6:	9200      	str	r2, [sp, #0]
 8009ae8:	9a00      	ldr	r2, [sp, #0]
	__HAL_RCC_GPIOH_CLK_ENABLE()
 8009aea:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009aec:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8009af0:	64da      	str	r2, [r3, #76]	; 0x4c
 8009af2:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009af4:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8009af8:	9201      	str	r2, [sp, #4]
 8009afa:	9a01      	ldr	r2, [sp, #4]
	__HAL_RCC_GPIOA_CLK_ENABLE()
 8009afc:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009afe:	f042 0201 	orr.w	r2, r2, #1
 8009b02:	64da      	str	r2, [r3, #76]	; 0x4c
 8009b04:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009b06:	f002 0201 	and.w	r2, r2, #1
 8009b0a:	9202      	str	r2, [sp, #8]
 8009b0c:	9a02      	ldr	r2, [sp, #8]
	__HAL_RCC_GPIOB_CLK_ENABLE()
 8009b0e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009b10:	f042 0202 	orr.w	r2, r2, #2
 8009b14:	64da      	str	r2, [r3, #76]	; 0x4c
 8009b16:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009b18:	f002 0202 	and.w	r2, r2, #2
 8009b1c:	9203      	str	r2, [sp, #12]
 8009b1e:	9a03      	ldr	r2, [sp, #12]
	__HAL_RCC_GPIOD_CLK_ENABLE()
 8009b20:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009b22:	f042 0208 	orr.w	r2, r2, #8
 8009b26:	64da      	str	r2, [r3, #76]	; 0x4c
 8009b28:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8009b2a:	f003 0308 	and.w	r3, r3, #8
 8009b2e:	9304      	str	r3, [sp, #16]
	HAL_GPIO_WritePin(GPIOC,
 8009b30:	4638      	mov	r0, r7
 8009b32:	2200      	movs	r2, #0
 8009b34:	21e4      	movs	r1, #228	; 0xe4
	__HAL_RCC_GPIOD_CLK_ENABLE()
 8009b36:	9b04      	ldr	r3, [sp, #16]
	HAL_GPIO_WritePin(GPIOC,
 8009b38:	f7f8 fb1a 	bl	8002170 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOA, DebugPin9_Pin | DebugPin11_Pin | DebugPin13_Pin, GPIO_PIN_RESET);
 8009b3c:	2200      	movs	r2, #0
 8009b3e:	f44f 4105 	mov.w	r1, #34048	; 0x8500
 8009b42:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8009b46:	f7f8 fb13 	bl	8002170 <HAL_GPIO_WritePin>
	HAL_GPIO_WritePin(GPIOB,
 8009b4a:	2200      	movs	r2, #0
 8009b4c:	4628      	mov	r0, r5
 8009b4e:	21f0      	movs	r1, #240	; 0xf0
 8009b50:	f7f8 fb0e 	bl	8002170 <HAL_GPIO_WritePin>
	 PCPin PCPin */
	GPIO_InitStruct.Pin = Heartbeat_Pin | DebugPin12_Pin | DebugPin16_Pin

			| SD_Power_EN_Pin | VBAT_Sense_EN_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009b54:	2400      	movs	r4, #0
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009b56:	2601      	movs	r6, #1
	GPIO_InitStruct.Pin = Heartbeat_Pin | DebugPin12_Pin | DebugPin16_Pin
 8009b58:	23e4      	movs	r3, #228	; 0xe4
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009b5a:	a905      	add	r1, sp, #20
 8009b5c:	4638      	mov	r0, r7
	GPIO_InitStruct.Pin = Heartbeat_Pin | DebugPin12_Pin | DebugPin16_Pin
 8009b5e:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009b60:	9606      	str	r6, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009b62:	9407      	str	r4, [sp, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009b64:	9408      	str	r4, [sp, #32]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009b66:	f7f8 f9c3 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pins : PAPin PAPin PAPin PAPin
	 PAPin PAPin PAPin PAPin
	 PAPin */
	GPIO_InitStruct.Pin = DebugPin9_Pin | DebugPin11_Pin | DebugPin13_Pin;
 8009b6a:	f44f 4305 	mov.w	r3, #34048	; 0x8500
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009b6e:	a905      	add	r1, sp, #20
 8009b70:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Pin = DebugPin9_Pin | DebugPin11_Pin | DebugPin13_Pin;
 8009b74:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009b76:	9606      	str	r6, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009b78:	9407      	str	r4, [sp, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009b7a:	9408      	str	r4, [sp, #32]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009b7c:	f7f8 f9b8 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pins : PBPin PBPin PBPin */
	GPIO_InitStruct.Pin = INT1_MCU_Pin | INT2_MCU_Pin;
 8009b80:	f44f 5340 	mov.w	r3, #12288	; 0x3000
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009b84:	a905      	add	r1, sp, #20
 8009b86:	4628      	mov	r0, r5
	GPIO_InitStruct.Pin = INT1_MCU_Pin | INT2_MCU_Pin;
 8009b88:	9305      	str	r3, [sp, #20]

	GPIO_InitStruct.Pin = VINT_Sense_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8009b8a:	f04f 0802 	mov.w	r8, #2
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009b8e:	9406      	str	r4, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009b90:	9407      	str	r4, [sp, #28]
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009b92:	f7f8 f9ad 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = VINT_Sense_Pin;
 8009b96:	2310      	movs	r3, #16
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009b98:	a905      	add	r1, sp, #20
 8009b9a:	4638      	mov	r0, r7
	GPIO_InitStruct.Pin = VINT_Sense_Pin;
 8009b9c:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009b9e:	9406      	str	r4, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8009ba0:	f8cd 801c 	str.w	r8, [sp, #28]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009ba4:	f7f8 f9a4 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pins : PBPin PBPin PBPin PBPin
	 PBPin PBPin PBPin */
	GPIO_InitStruct.Pin = Temperature_EN_Pin | Spectrum_EN_Pin | DebugPin17_Pin
 8009ba8:	23f0      	movs	r3, #240	; 0xf0
			| DebugPin19_Pin
			| DebugPin22_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009baa:	a905      	add	r1, sp, #20
 8009bac:	4628      	mov	r0, r5
	GPIO_InitStruct.Pin = Temperature_EN_Pin | Spectrum_EN_Pin | DebugPin17_Pin
 8009bae:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009bb0:	9606      	str	r6, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009bb2:	9407      	str	r4, [sp, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009bb4:	9408      	str	r4, [sp, #32]
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009bb6:	f7f8 f99b 	bl	8001ef0 <HAL_GPIO_Init>
//	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
//	GPIO_InitStruct.Pull = GPIO_NOPULL;
//	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

	/*Configure GPIO pin : PtPin */
	GPIO_InitStruct.Pin = VBUS_Detect_Pin;
 8009bba:	f44f 7300 	mov.w	r3, #512	; 0x200
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(VBUS_Detect_GPIO_Port, &GPIO_InitStruct);
 8009bbe:	a905      	add	r1, sp, #20
 8009bc0:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Pin = VBUS_Detect_Pin;
 8009bc4:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009bc6:	9406      	str	r4, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009bc8:	9407      	str	r4, [sp, #28]
	HAL_GPIO_Init(VBUS_Detect_GPIO_Port, &GPIO_InitStruct);
 8009bca:	f7f8 f991 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pin : PA11 */
	GPIO_InitStruct.Pin = GPIO_PIN_11;
 8009bce:	f44f 6300 	mov.w	r3, #2048	; 0x800
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009bd2:	2503      	movs	r5, #3
	GPIO_InitStruct.Pin = GPIO_PIN_11;
 8009bd4:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Alternate = GPIO_AF10_USB_FS;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009bd6:	a905      	add	r1, sp, #20
	GPIO_InitStruct.Alternate = GPIO_AF10_USB_FS;
 8009bd8:	230a      	movs	r3, #10
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009bda:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Alternate = GPIO_AF10_USB_FS;
 8009bde:	9309      	str	r3, [sp, #36]	; 0x24
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009be0:	f8cd 8018 	str.w	r8, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009be4:	9407      	str	r4, [sp, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009be6:	9508      	str	r5, [sp, #32]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009be8:	f7f8 f982 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pin : PA12 */
	GPIO_InitStruct.Pin = GPIO_PIN_12;
 8009bec:	f44f 5380 	mov.w	r3, #4096	; 0x1000
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009bf0:	a905      	add	r1, sp, #20
 8009bf2:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Pin = GPIO_PIN_12;
 8009bf6:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009bf8:	9506      	str	r5, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009bfa:	9407      	str	r4, [sp, #28]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009bfc:	f7f8 f978 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pin : PH3 */
	GPIO_InitStruct.Pin = GPIO_PIN_3;
 8009c00:	2308      	movs	r3, #8
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8009c02:	a905      	add	r1, sp, #20
 8009c04:	4807      	ldr	r0, [pc, #28]	; (8009c24 <GPIOInitRadio+0x158>)
	GPIO_InitStruct.Pin = GPIO_PIN_3;
 8009c06:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009c08:	9506      	str	r5, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009c0a:	9407      	str	r4, [sp, #28]
	HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8009c0c:	f7f8 f970 	bl	8001ef0 <HAL_GPIO_Init>


}
 8009c10:	b00a      	add	sp, #40	; 0x28
 8009c12:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8009c16:	bf00      	nop
 8009c18:	40021000 	.word	0x40021000
 8009c1c:	48000800 	.word	0x48000800
 8009c20:	48000400 	.word	0x48000400
 8009c24:	48001c00 	.word	0x48001c00

08009c28 <GPIOInitSensor>:
void GPIOInitSensor(void)
{
	GPIO_InitTypeDef GPIO_InitStruct;

	/* GPIO Ports Clock Enable */
	__HAL_RCC_GPIOC_CLK_ENABLE()
 8009c28:	4b4c      	ldr	r3, [pc, #304]	; (8009d5c <GPIOInitSensor+0x134>)
{
 8009c2a:	b5f0      	push	{r4, r5, r6, r7, lr}
	__HAL_RCC_GPIOC_CLK_ENABLE()
 8009c2c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
	;
	__HAL_RCC_GPIOD_CLK_ENABLE()
	;

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOC,
 8009c2e:	4e4c      	ldr	r6, [pc, #304]	; (8009d60 <GPIOInitSensor+0x138>)
	__HAL_RCC_GPIOC_CLK_ENABLE()
 8009c30:	f042 0204 	orr.w	r2, r2, #4
 8009c34:	64da      	str	r2, [r3, #76]	; 0x4c
 8009c36:	6cda      	ldr	r2, [r3, #76]	; 0x4c
{
 8009c38:	b08b      	sub	sp, #44	; 0x2c
	__HAL_RCC_GPIOC_CLK_ENABLE()
 8009c3a:	f002 0204 	and.w	r2, r2, #4
 8009c3e:	9200      	str	r2, [sp, #0]
 8009c40:	9a00      	ldr	r2, [sp, #0]
	__HAL_RCC_GPIOH_CLK_ENABLE()
 8009c42:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009c44:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8009c48:	64da      	str	r2, [r3, #76]	; 0x4c
 8009c4a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009c4c:	f002 0280 	and.w	r2, r2, #128	; 0x80
 8009c50:	9201      	str	r2, [sp, #4]
 8009c52:	9a01      	ldr	r2, [sp, #4]
	__HAL_RCC_GPIOA_CLK_ENABLE()
 8009c54:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009c56:	f042 0201 	orr.w	r2, r2, #1
 8009c5a:	64da      	str	r2, [r3, #76]	; 0x4c
 8009c5c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009c5e:	f002 0201 	and.w	r2, r2, #1
 8009c62:	9202      	str	r2, [sp, #8]
 8009c64:	9a02      	ldr	r2, [sp, #8]
	__HAL_RCC_GPIOB_CLK_ENABLE()
 8009c66:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009c68:	f042 0202 	orr.w	r2, r2, #2
 8009c6c:	64da      	str	r2, [r3, #76]	; 0x4c
 8009c6e:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009c70:	f002 0202 	and.w	r2, r2, #2
 8009c74:	9203      	str	r2, [sp, #12]
 8009c76:	9a03      	ldr	r2, [sp, #12]
	__HAL_RCC_GPIOD_CLK_ENABLE()
 8009c78:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009c7a:	f042 0208 	orr.w	r2, r2, #8
 8009c7e:	64da      	str	r2, [r3, #76]	; 0x4c
 8009c80:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8009c82:	f003 0308 	and.w	r3, r3, #8
 8009c86:	9304      	str	r3, [sp, #16]
	HAL_GPIO_WritePin(GPIOC,
 8009c88:	4630      	mov	r0, r6
 8009c8a:	2200      	movs	r2, #0
 8009c8c:	21a4      	movs	r1, #164	; 0xa4
	__HAL_RCC_GPIOD_CLK_ENABLE()
 8009c8e:	9b04      	ldr	r3, [sp, #16]
	HAL_GPIO_WritePin(GPIOC,
 8009c90:	f7f8 fa6e 	bl	8002170 <HAL_GPIO_WritePin>
	VBAT_Sense_EN_Pin | DebugPin12_Pin | DebugPin16_Pin

	| SD_Power_EN_Pin, GPIO_PIN_RESET);

	/*Configure GPIO pin Output Level */
	HAL_GPIO_WritePin(GPIOA, DebugPin9_Pin | DebugPin11_Pin | DebugPin13_Pin, GPIO_PIN_RESET);
 8009c94:	2200      	movs	r2, #0
 8009c96:	f44f 4105 	mov.w	r1, #34048	; 0x8500
 8009c9a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8009c9e:	f7f8 fa67 	bl	8002170 <HAL_GPIO_WritePin>
	 PCPin PCPin */
	GPIO_InitStruct.Pin = DebugPin12_Pin | DebugPin16_Pin

	| SD_Power_EN_Pin | VBAT_Sense_EN_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009ca2:	2400      	movs	r4, #0
	GPIO_InitStruct.Pin = DebugPin12_Pin | DebugPin16_Pin
 8009ca4:	23a4      	movs	r3, #164	; 0xa4
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009ca6:	2501      	movs	r5, #1
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009ca8:	a905      	add	r1, sp, #20
 8009caa:	4630      	mov	r0, r6
	GPIO_InitStruct.Pin = DebugPin12_Pin | DebugPin16_Pin
 8009cac:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009cae:	9506      	str	r5, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009cb0:	9407      	str	r4, [sp, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009cb2:	9408      	str	r4, [sp, #32]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009cb4:	f7f8 f91c 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pins : PAPin PAPin PAPin PAPin
	 PAPin PAPin PAPin PAPin
	 PAPin */
	GPIO_InitStruct.Pin = DebugPin9_Pin | DebugPin11_Pin | DebugPin13_Pin;
 8009cb8:	f44f 4305 	mov.w	r3, #34048	; 0x8500
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009cbc:	a905      	add	r1, sp, #20
 8009cbe:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Pin = DebugPin9_Pin | DebugPin11_Pin | DebugPin13_Pin;
 8009cc2:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009cc4:	9506      	str	r5, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009cc6:	9407      	str	r4, [sp, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009cc8:	9408      	str	r4, [sp, #32]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009cca:	f7f8 f911 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pins : PBPin PBPin PBPin */
	GPIO_InitStruct.Pin = INT1_MCU_Pin | INT2_MCU_Pin;
 8009cce:	f44f 5340 	mov.w	r3, #12288	; 0x3000
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009cd2:	a905      	add	r1, sp, #20
 8009cd4:	4823      	ldr	r0, [pc, #140]	; (8009d64 <GPIOInitSensor+0x13c>)
	GPIO_InitStruct.Pin = INT1_MCU_Pin | INT2_MCU_Pin;
 8009cd6:	9305      	str	r3, [sp, #20]

	GPIO_InitStruct.Pin = VINT_Sense_Pin;
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8009cd8:	2702      	movs	r7, #2
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009cda:	9406      	str	r4, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009cdc:	9407      	str	r4, [sp, #28]
	HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009cde:	f7f8 f907 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = VINT_Sense_Pin;
 8009ce2:	2310      	movs	r3, #16
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009ce4:	a905      	add	r1, sp, #20
 8009ce6:	4630      	mov	r0, r6
	/*Configure GPIO pins : PBPin PBPin PBPin PBPin
	 PBPin PBPin PBPin */

	/*Configure GPIO pins : PC9 PC10 PC11 */
	GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009ce8:	2503      	movs	r5, #3
	GPIO_InitStruct.Pin = VINT_Sense_Pin;
 8009cea:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009cec:	9406      	str	r4, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_PULLDOWN;
 8009cee:	9707      	str	r7, [sp, #28]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009cf0:	f7f8 f8fe 	bl	8001ef0 <HAL_GPIO_Init>
	GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;
 8009cf4:	f44f 6360 	mov.w	r3, #3584	; 0xe00
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009cf8:	a905      	add	r1, sp, #20
 8009cfa:	4630      	mov	r0, r6
	GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;
 8009cfc:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009cfe:	9506      	str	r5, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009d00:	9407      	str	r4, [sp, #28]
	HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009d02:	f7f8 f8f5 	bl	8001ef0 <HAL_GPIO_Init>
	/*Configure GPIO pin : PtPin */
	GPIO_InitStruct.Pin = VBUS_Detect_Pin;
 8009d06:	f44f 7300 	mov.w	r3, #512	; 0x200
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(VBUS_Detect_GPIO_Port, &GPIO_InitStruct);
 8009d0a:	a905      	add	r1, sp, #20
 8009d0c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Pin = VBUS_Detect_Pin;
 8009d10:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8009d12:	9406      	str	r4, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009d14:	9407      	str	r4, [sp, #28]
	HAL_GPIO_Init(VBUS_Detect_GPIO_Port, &GPIO_InitStruct);
 8009d16:	f7f8 f8eb 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pin : PA11 */
	GPIO_InitStruct.Pin = GPIO_PIN_11;
 8009d1a:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8009d1e:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
	GPIO_InitStruct.Alternate = GPIO_AF10_USB_FS;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009d20:	a905      	add	r1, sp, #20
	GPIO_InitStruct.Alternate = GPIO_AF10_USB_FS;
 8009d22:	230a      	movs	r3, #10
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009d24:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Alternate = GPIO_AF10_USB_FS;
 8009d28:	9309      	str	r3, [sp, #36]	; 0x24
	GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8009d2a:	9706      	str	r7, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009d2c:	9407      	str	r4, [sp, #28]
	GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009d2e:	9508      	str	r5, [sp, #32]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009d30:	f7f8 f8de 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pin : PA12 */
	GPIO_InitStruct.Pin = GPIO_PIN_12;
 8009d34:	f44f 5380 	mov.w	r3, #4096	; 0x1000
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009d38:	a905      	add	r1, sp, #20
 8009d3a:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
	GPIO_InitStruct.Pin = GPIO_PIN_12;
 8009d3e:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009d40:	9506      	str	r5, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009d42:	9407      	str	r4, [sp, #28]
	HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8009d44:	f7f8 f8d4 	bl	8001ef0 <HAL_GPIO_Init>

	/*Configure GPIO pin : PH3 */
	GPIO_InitStruct.Pin = GPIO_PIN_3;
 8009d48:	2308      	movs	r3, #8
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
	GPIO_InitStruct.Pull = GPIO_NOPULL;
	HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8009d4a:	a905      	add	r1, sp, #20
 8009d4c:	4806      	ldr	r0, [pc, #24]	; (8009d68 <GPIOInitSensor+0x140>)
	GPIO_InitStruct.Pin = GPIO_PIN_3;
 8009d4e:	9305      	str	r3, [sp, #20]
	GPIO_InitStruct.Mode = GPIO_MODE_ANALOG;
 8009d50:	9506      	str	r5, [sp, #24]
	GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009d52:	9407      	str	r4, [sp, #28]
	HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
 8009d54:	f7f8 f8cc 	bl	8001ef0 <HAL_GPIO_Init>
}
 8009d58:	b00b      	add	sp, #44	; 0x2c
 8009d5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8009d5c:	40021000 	.word	0x40021000
 8009d60:	48000800 	.word	0x48000800
 8009d64:	48000400 	.word	0x48000400
 8009d68:	48001c00 	.word	0x48001c00

08009d6c <DisEnableSensorPins>:


/* bool = 1 will enable pins, bool = 0 will disable */
void DisEnableSensorPins(uint8_t bool)
{
 8009d6c:	b510      	push	{r4, lr}
	if (bool)
 8009d6e:	4604      	mov	r4, r0
 8009d70:	b198      	cbz	r0, 8009d9a <DisEnableSensorPins+0x2e>
	{
		HAL_GPIO_WritePin(Temperature_EN_GPIO_Port, Temperature_EN_Pin,
 8009d72:	2201      	movs	r2, #1
 8009d74:	2140      	movs	r1, #64	; 0x40
 8009d76:	480f      	ldr	r0, [pc, #60]	; (8009db4 <DisEnableSensorPins+0x48>)
 8009d78:	f7f8 f9fa 	bl	8002170 <HAL_GPIO_WritePin>
				GPIO_PIN_SET);

		HAL_GPIO_WritePin(Spectrum_EN_GPIO_Port, Spectrum_EN_Pin, GPIO_PIN_SET);
 8009d7c:	2201      	movs	r2, #1
 8009d7e:	2120      	movs	r1, #32
 8009d80:	480c      	ldr	r0, [pc, #48]	; (8009db4 <DisEnableSensorPins+0x48>)
 8009d82:	f7f8 f9f5 	bl	8002170 <HAL_GPIO_WritePin>

		HAL_GPIO_WritePin(VBAT_Sense_EN_GPIO_Port, VBAT_Sense_EN_Pin,
 8009d86:	2201      	movs	r2, #1
				GPIO_PIN_RESET);

		HAL_GPIO_WritePin(Spectrum_EN_GPIO_Port, Spectrum_EN_Pin,
				GPIO_PIN_RESET);

		HAL_GPIO_WritePin(VBAT_Sense_EN_GPIO_Port, VBAT_Sense_EN_Pin,
 8009d88:	480b      	ldr	r0, [pc, #44]	; (8009db8 <DisEnableSensorPins+0x4c>)
 8009d8a:	2104      	movs	r1, #4
 8009d8c:	f7f8 f9f0 	bl	8002170 <HAL_GPIO_WritePin>
				GPIO_PIN_RESET);

		HAL_Delay(10);
 8009d90:	200a      	movs	r0, #10
	}
}
 8009d92:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		HAL_Delay(10);
 8009d96:	f7f7 b881 	b.w	8000e9c <HAL_Delay>
		HAL_GPIO_WritePin(Temperature_EN_GPIO_Port, Temperature_EN_Pin,
 8009d9a:	4602      	mov	r2, r0
 8009d9c:	2140      	movs	r1, #64	; 0x40
 8009d9e:	4805      	ldr	r0, [pc, #20]	; (8009db4 <DisEnableSensorPins+0x48>)
 8009da0:	f7f8 f9e6 	bl	8002170 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(Spectrum_EN_GPIO_Port, Spectrum_EN_Pin,
 8009da4:	4622      	mov	r2, r4
 8009da6:	2120      	movs	r1, #32
 8009da8:	4802      	ldr	r0, [pc, #8]	; (8009db4 <DisEnableSensorPins+0x48>)
 8009daa:	f7f8 f9e1 	bl	8002170 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(VBAT_Sense_EN_GPIO_Port, VBAT_Sense_EN_Pin,
 8009dae:	4622      	mov	r2, r4
 8009db0:	e7ea      	b.n	8009d88 <DisEnableSensorPins+0x1c>
 8009db2:	bf00      	nop
 8009db4:	48000400 	.word	0x48000400
 8009db8:	48000800 	.word	0x48000800

08009dbc <DisEnableBatteryPin>:

void DisEnableBatteryPin(uint8_t bool)
{
 8009dbc:	b508      	push	{r3, lr}
	if (bool)
 8009dbe:	4602      	mov	r2, r0
 8009dc0:	b100      	cbz	r0, 8009dc4 <DisEnableBatteryPin+0x8>
	{
		HAL_GPIO_WritePin(Spectrum_EN_GPIO_Port, Spectrum_EN_Pin, GPIO_PIN_SET);
 8009dc2:	2201      	movs	r2, #1

		HAL_Delay(10);
	}
	else
	{
		HAL_GPIO_WritePin(Spectrum_EN_GPIO_Port, Spectrum_EN_Pin, GPIO_PIN_RESET);
 8009dc4:	4804      	ldr	r0, [pc, #16]	; (8009dd8 <DisEnableBatteryPin+0x1c>)
 8009dc6:	2120      	movs	r1, #32
 8009dc8:	f7f8 f9d2 	bl	8002170 <HAL_GPIO_WritePin>

		HAL_Delay(10);
 8009dcc:	200a      	movs	r0, #10
	}
}
 8009dce:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		HAL_Delay(10);
 8009dd2:	f7f7 b863 	b.w	8000e9c <HAL_Delay>
 8009dd6:	bf00      	nop
 8009dd8:	48000400 	.word	0x48000400

08009ddc <DisEnableRadioPin>:

void DisEnableRadioPin(uint8_t bool)
{
 8009ddc:	b508      	push	{r3, lr}
	if (bool)
 8009dde:	4602      	mov	r2, r0
 8009de0:	b100      	cbz	r0, 8009de4 <DisEnableRadioPin+0x8>
	{
		HAL_GPIO_WritePin(Radio_EN_GPIO_Port, Radio_EN_Pin, GPIO_PIN_SET);
 8009de2:	2201      	movs	r2, #1

		HAL_Delay(10);
	}
	else
	{
		HAL_GPIO_WritePin(Radio_EN_GPIO_Port, Radio_EN_Pin, GPIO_PIN_RESET);
 8009de4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8009de8:	2102      	movs	r1, #2
 8009dea:	f7f8 f9c1 	bl	8002170 <HAL_GPIO_WritePin>

		HAL_Delay(10);
 8009dee:	200a      	movs	r0, #10
	}
}
 8009df0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		HAL_Delay(10);
 8009df4:	f7f7 b852 	b.w	8000e9c <HAL_Delay>

08009df8 <DisEnableSDPin>:

void DisEnableSDPin(uint8_t bool)
{
 8009df8:	b530      	push	{r4, r5, lr}
	if (bool)
 8009dfa:	4602      	mov	r2, r0
{
 8009dfc:	b087      	sub	sp, #28
	if (bool)
 8009dfe:	b1a8      	cbz	r0, 8009e2c <DisEnableSDPin+0x34>
	{
		GPIO_InitTypeDef GPIO_InitStruct;

		/* GPIO Ports Clock Enable */
		__HAL_RCC_GPIOC_CLK_ENABLE()
 8009e00:	4b0f      	ldr	r3, [pc, #60]	; (8009e40 <DisEnableSDPin+0x48>)

		GPIO_InitStruct.Pin = SD_Power_EN_Pin;
		GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
		GPIO_InitStruct.Pull = GPIO_NOPULL;
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
		HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009e02:	4810      	ldr	r0, [pc, #64]	; (8009e44 <DisEnableSDPin+0x4c>)
		__HAL_RCC_GPIOC_CLK_ENABLE()
 8009e04:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8009e06:	f042 0204 	orr.w	r2, r2, #4
 8009e0a:	64da      	str	r2, [r3, #76]	; 0x4c
 8009e0c:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8009e0e:	f003 0304 	and.w	r3, r3, #4
 8009e12:	9300      	str	r3, [sp, #0]
 8009e14:	9b00      	ldr	r3, [sp, #0]
		GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009e16:	2501      	movs	r5, #1
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009e18:	2300      	movs	r3, #0
		GPIO_InitStruct.Pin = SD_Power_EN_Pin;
 8009e1a:	2480      	movs	r4, #128	; 0x80
		HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009e1c:	a901      	add	r1, sp, #4
		GPIO_InitStruct.Pin = SD_Power_EN_Pin;
 8009e1e:	9401      	str	r4, [sp, #4]
		GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8009e20:	9502      	str	r5, [sp, #8]
		GPIO_InitStruct.Pull = GPIO_NOPULL;
 8009e22:	9303      	str	r3, [sp, #12]
		GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8009e24:	9304      	str	r3, [sp, #16]
		HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 8009e26:	f7f8 f863 	bl	8001ef0 <HAL_GPIO_Init>

		HAL_GPIO_WritePin(SD_Power_EN_GPIO_Port, SD_Power_EN_Pin, GPIO_PIN_SET);
 8009e2a:	462a      	mov	r2, r5

		HAL_Delay(10);
	}
	else
	{
		HAL_GPIO_WritePin(SD_Power_EN_GPIO_Port, SD_Power_EN_Pin,
 8009e2c:	2180      	movs	r1, #128	; 0x80
 8009e2e:	4805      	ldr	r0, [pc, #20]	; (8009e44 <DisEnableSDPin+0x4c>)
 8009e30:	f7f8 f99e 	bl	8002170 <HAL_GPIO_WritePin>
				GPIO_PIN_RESET);

		HAL_Delay(10);
 8009e34:	200a      	movs	r0, #10
 8009e36:	f7f7 f831 	bl	8000e9c <HAL_Delay>
	}
}
 8009e3a:	b007      	add	sp, #28
 8009e3c:	bd30      	pop	{r4, r5, pc}
 8009e3e:	bf00      	nop
 8009e40:	40021000 	.word	0x40021000
 8009e44:	48000800 	.word	0x48000800

08009e48 <DisEnableSaraPin>:

void DisEnableSaraPin(uint8_t bool)
{
 8009e48:	b508      	push	{r3, lr}
	if (bool)
 8009e4a:	4602      	mov	r2, r0
 8009e4c:	b100      	cbz	r0, 8009e50 <DisEnableSaraPin+0x8>
	{
		HAL_GPIO_WritePin(Sara_Power_On_GPIO_Port, Sara_Power_On_Pin, GPIO_PIN_SET);
 8009e4e:	2201      	movs	r2, #1

		HAL_Delay(10);
	}
	else
	{
		HAL_GPIO_WritePin(Sara_Power_On_GPIO_Port, Sara_Power_On_Pin, GPIO_PIN_RESET);
 8009e50:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8009e54:	2140      	movs	r1, #64	; 0x40
 8009e56:	f7f8 f98b 	bl	8002170 <HAL_GPIO_WritePin>

		HAL_Delay(10);
 8009e5a:	200a      	movs	r0, #10
	}
}
 8009e5c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		HAL_Delay(10);
 8009e60:	f7f7 b81c 	b.w	8000e9c <HAL_Delay>

08009e64 <MX_I2C1_Init>:
I2C_HandleTypeDef hi2c1;
I2C_HandleTypeDef hi2c2;

/* I2C1 init function */
void MX_I2C1_Init(void)
{
 8009e64:	b508      	push	{r3, lr}

  hi2c1.Instance = I2C1;
 8009e66:	4815      	ldr	r0, [pc, #84]	; (8009ebc <MX_I2C1_Init+0x58>)
  hi2c1.Init.Timing = 0x00300F38;
 8009e68:	4b15      	ldr	r3, [pc, #84]	; (8009ec0 <MX_I2C1_Init+0x5c>)
 8009e6a:	4916      	ldr	r1, [pc, #88]	; (8009ec4 <MX_I2C1_Init+0x60>)
  hi2c1.Init.OwnAddress1 = 0;
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8009e6c:	2201      	movs	r2, #1
  hi2c1.Init.Timing = 0x00300F38;
 8009e6e:	e880 000a 	stmia.w	r0, {r1, r3}
  hi2c1.Init.OwnAddress1 = 0;
 8009e72:	2300      	movs	r3, #0
 8009e74:	6083      	str	r3, [r0, #8]
  hi2c1.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8009e76:	60c2      	str	r2, [r0, #12]
  hi2c1.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8009e78:	6103      	str	r3, [r0, #16]
  hi2c1.Init.OwnAddress2 = 0;
 8009e7a:	6143      	str	r3, [r0, #20]
  hi2c1.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8009e7c:	6183      	str	r3, [r0, #24]
  hi2c1.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8009e7e:	61c3      	str	r3, [r0, #28]
  hi2c1.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8009e80:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c1) != HAL_OK)
 8009e82:	f7f8 facb 	bl	800241c <HAL_I2C_Init>
 8009e86:	b118      	cbz	r0, 8009e90 <MX_I2C1_Init+0x2c>
  {
    _Error_Handler(__FILE__, __LINE__);
 8009e88:	214d      	movs	r1, #77	; 0x4d
 8009e8a:	480f      	ldr	r0, [pc, #60]	; (8009ec8 <MX_I2C1_Init+0x64>)
 8009e8c:	f002 fe76 	bl	800cb7c <_Error_Handler>
  }

    /**Configure Analogue filter 
    */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c1, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8009e90:	2100      	movs	r1, #0
 8009e92:	480a      	ldr	r0, [pc, #40]	; (8009ebc <MX_I2C1_Init+0x58>)
 8009e94:	f7f8 fd10 	bl	80028b8 <HAL_I2CEx_ConfigAnalogFilter>
 8009e98:	b118      	cbz	r0, 8009ea2 <MX_I2C1_Init+0x3e>
  {
    _Error_Handler(__FILE__, __LINE__);
 8009e9a:	2154      	movs	r1, #84	; 0x54
 8009e9c:	480a      	ldr	r0, [pc, #40]	; (8009ec8 <MX_I2C1_Init+0x64>)
 8009e9e:	f002 fe6d 	bl	800cb7c <_Error_Handler>
  }

    /**Configure Digital filter 
    */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c1, 0) != HAL_OK)
 8009ea2:	2100      	movs	r1, #0
 8009ea4:	4805      	ldr	r0, [pc, #20]	; (8009ebc <MX_I2C1_Init+0x58>)
 8009ea6:	f7f8 fd2d 	bl	8002904 <HAL_I2CEx_ConfigDigitalFilter>
 8009eaa:	b128      	cbz	r0, 8009eb8 <MX_I2C1_Init+0x54>
  {
    _Error_Handler(__FILE__, __LINE__);
 8009eac:	215b      	movs	r1, #91	; 0x5b
 8009eae:	4806      	ldr	r0, [pc, #24]	; (8009ec8 <MX_I2C1_Init+0x64>)
  }

}
 8009eb0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
 8009eb4:	f002 be62 	b.w	800cb7c <_Error_Handler>
 8009eb8:	bd08      	pop	{r3, pc}
 8009eba:	bf00      	nop
 8009ebc:	2000c4bc 	.word	0x2000c4bc
 8009ec0:	00300f38 	.word	0x00300f38
 8009ec4:	40005400 	.word	0x40005400
 8009ec8:	0800f93d 	.word	0x0800f93d

08009ecc <MX_I2C2_Init>:
/* I2C2 init function */
void MX_I2C2_Init(void)
{
 8009ecc:	b508      	push	{r3, lr}

  hi2c2.Instance = I2C2;
 8009ece:	4815      	ldr	r0, [pc, #84]	; (8009f24 <MX_I2C2_Init+0x58>)
  hi2c2.Init.Timing = 0x00300F38;
 8009ed0:	4b15      	ldr	r3, [pc, #84]	; (8009f28 <MX_I2C2_Init+0x5c>)
 8009ed2:	4916      	ldr	r1, [pc, #88]	; (8009f2c <MX_I2C2_Init+0x60>)
  hi2c2.Init.OwnAddress1 = 0;
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8009ed4:	2201      	movs	r2, #1
  hi2c2.Init.Timing = 0x00300F38;
 8009ed6:	e880 000a 	stmia.w	r0, {r1, r3}
  hi2c2.Init.OwnAddress1 = 0;
 8009eda:	2300      	movs	r3, #0
 8009edc:	6083      	str	r3, [r0, #8]
  hi2c2.Init.AddressingMode = I2C_ADDRESSINGMODE_7BIT;
 8009ede:	60c2      	str	r2, [r0, #12]
  hi2c2.Init.DualAddressMode = I2C_DUALADDRESS_DISABLE;
 8009ee0:	6103      	str	r3, [r0, #16]
  hi2c2.Init.OwnAddress2 = 0;
 8009ee2:	6143      	str	r3, [r0, #20]
  hi2c2.Init.OwnAddress2Masks = I2C_OA2_NOMASK;
 8009ee4:	6183      	str	r3, [r0, #24]
  hi2c2.Init.GeneralCallMode = I2C_GENERALCALL_DISABLE;
 8009ee6:	61c3      	str	r3, [r0, #28]
  hi2c2.Init.NoStretchMode = I2C_NOSTRETCH_DISABLE;
 8009ee8:	6203      	str	r3, [r0, #32]
  if (HAL_I2C_Init(&hi2c2) != HAL_OK)
 8009eea:	f7f8 fa97 	bl	800241c <HAL_I2C_Init>
 8009eee:	b118      	cbz	r0, 8009ef8 <MX_I2C2_Init+0x2c>
  {
    _Error_Handler(__FILE__, __LINE__);
 8009ef0:	216e      	movs	r1, #110	; 0x6e
 8009ef2:	480f      	ldr	r0, [pc, #60]	; (8009f30 <MX_I2C2_Init+0x64>)
 8009ef4:	f002 fe42 	bl	800cb7c <_Error_Handler>
  }

    /**Configure Analogue filter 
    */
  if (HAL_I2CEx_ConfigAnalogFilter(&hi2c2, I2C_ANALOGFILTER_ENABLE) != HAL_OK)
 8009ef8:	2100      	movs	r1, #0
 8009efa:	480a      	ldr	r0, [pc, #40]	; (8009f24 <MX_I2C2_Init+0x58>)
 8009efc:	f7f8 fcdc 	bl	80028b8 <HAL_I2CEx_ConfigAnalogFilter>
 8009f00:	b118      	cbz	r0, 8009f0a <MX_I2C2_Init+0x3e>
  {
    _Error_Handler(__FILE__, __LINE__);
 8009f02:	2175      	movs	r1, #117	; 0x75
 8009f04:	480a      	ldr	r0, [pc, #40]	; (8009f30 <MX_I2C2_Init+0x64>)
 8009f06:	f002 fe39 	bl	800cb7c <_Error_Handler>
  }

    /**Configure Digital filter 
    */
  if (HAL_I2CEx_ConfigDigitalFilter(&hi2c2, 0) != HAL_OK)
 8009f0a:	2100      	movs	r1, #0
 8009f0c:	4805      	ldr	r0, [pc, #20]	; (8009f24 <MX_I2C2_Init+0x58>)
 8009f0e:	f7f8 fcf9 	bl	8002904 <HAL_I2CEx_ConfigDigitalFilter>
 8009f12:	b128      	cbz	r0, 8009f20 <MX_I2C2_Init+0x54>
  {
    _Error_Handler(__FILE__, __LINE__);
 8009f14:	217c      	movs	r1, #124	; 0x7c
 8009f16:	4806      	ldr	r0, [pc, #24]	; (8009f30 <MX_I2C2_Init+0x64>)
  }

}
 8009f18:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
 8009f1c:	f002 be2e 	b.w	800cb7c <_Error_Handler>
 8009f20:	bd08      	pop	{r3, pc}
 8009f22:	bf00      	nop
 8009f24:	2000c508 	.word	0x2000c508
 8009f28:	00300f38 	.word	0x00300f38
 8009f2c:	40005800 	.word	0x40005800
 8009f30:	0800f93d 	.word	0x0800f93d

08009f34 <HAL_I2C_MspInit>:

void HAL_I2C_MspInit(I2C_HandleTypeDef* i2cHandle)
{
 8009f34:	b500      	push	{lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(i2cHandle->Instance==I2C1)
 8009f36:	6803      	ldr	r3, [r0, #0]
 8009f38:	4a1e      	ldr	r2, [pc, #120]	; (8009fb4 <HAL_I2C_MspInit+0x80>)
 8009f3a:	4293      	cmp	r3, r2
{
 8009f3c:	b089      	sub	sp, #36	; 0x24
  if(i2cHandle->Instance==I2C1)
 8009f3e:	d11b      	bne.n	8009f78 <HAL_I2C_MspInit+0x44>
  
    /**I2C1 GPIO Configuration    
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA 
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
 8009f40:	f44f 7340 	mov.w	r3, #768	; 0x300
 8009f44:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8009f46:	2312      	movs	r3, #18
 8009f48:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8009f4a:	2301      	movs	r3, #1
 8009f4c:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009f4e:	2303      	movs	r3, #3
 8009f50:	9306      	str	r3, [sp, #24]
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009f52:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8009f54:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009f56:	4818      	ldr	r0, [pc, #96]	; (8009fb8 <HAL_I2C_MspInit+0x84>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C1;
 8009f58:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009f5a:	f7f7 ffc9 	bl	8001ef0 <HAL_GPIO_Init>

    /* I2C1 clock enable */
    __HAL_RCC_I2C1_CLK_ENABLE();
 8009f5e:	4b17      	ldr	r3, [pc, #92]	; (8009fbc <HAL_I2C_MspInit+0x88>)
 8009f60:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8009f62:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 8009f66:	659a      	str	r2, [r3, #88]	; 0x58
 8009f68:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009f6a:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8009f6e:	9301      	str	r3, [sp, #4]
 8009f70:	9b01      	ldr	r3, [sp, #4]
    __HAL_RCC_I2C2_CLK_ENABLE();
  /* USER CODE BEGIN I2C2_MspInit 1 */

  /* USER CODE END I2C2_MspInit 1 */
  }
}
 8009f72:	b009      	add	sp, #36	; 0x24
 8009f74:	f85d fb04 	ldr.w	pc, [sp], #4
  else if(i2cHandle->Instance==I2C2)
 8009f78:	4a11      	ldr	r2, [pc, #68]	; (8009fc0 <HAL_I2C_MspInit+0x8c>)
 8009f7a:	4293      	cmp	r3, r2
 8009f7c:	d1f9      	bne.n	8009f72 <HAL_I2C_MspInit+0x3e>
    GPIO_InitStruct.Pin = GPIO_PIN_10|GPIO_PIN_11;
 8009f7e:	f44f 6340 	mov.w	r3, #3072	; 0xc00
 8009f82:	9303      	str	r3, [sp, #12]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_OD;
 8009f84:	2312      	movs	r3, #18
 8009f86:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Pull = GPIO_PULLUP;
 8009f88:	2301      	movs	r3, #1
 8009f8a:	9305      	str	r3, [sp, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 8009f8c:	2303      	movs	r3, #3
 8009f8e:	9306      	str	r3, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009f90:	a903      	add	r1, sp, #12
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 8009f92:	2304      	movs	r3, #4
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009f94:	4808      	ldr	r0, [pc, #32]	; (8009fb8 <HAL_I2C_MspInit+0x84>)
    GPIO_InitStruct.Alternate = GPIO_AF4_I2C2;
 8009f96:	9307      	str	r3, [sp, #28]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8009f98:	f7f7 ffaa 	bl	8001ef0 <HAL_GPIO_Init>
    __HAL_RCC_I2C2_CLK_ENABLE();
 8009f9c:	4b07      	ldr	r3, [pc, #28]	; (8009fbc <HAL_I2C_MspInit+0x88>)
 8009f9e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8009fa0:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8009fa4:	659a      	str	r2, [r3, #88]	; 0x58
 8009fa6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8009fa8:	f403 0380 	and.w	r3, r3, #4194304	; 0x400000
 8009fac:	9302      	str	r3, [sp, #8]
 8009fae:	9b02      	ldr	r3, [sp, #8]
}
 8009fb0:	e7df      	b.n	8009f72 <HAL_I2C_MspInit+0x3e>
 8009fb2:	bf00      	nop
 8009fb4:	40005400 	.word	0x40005400
 8009fb8:	48000400 	.word	0x48000400
 8009fbc:	40021000 	.word	0x40021000
 8009fc0:	40005800 	.word	0x40005800

08009fc4 <HAL_I2C_MspDeInit>:

void HAL_I2C_MspDeInit(I2C_HandleTypeDef* i2cHandle)
{

  if(i2cHandle->Instance==I2C1)
 8009fc4:	6803      	ldr	r3, [r0, #0]
 8009fc6:	4a0d      	ldr	r2, [pc, #52]	; (8009ffc <HAL_I2C_MspDeInit+0x38>)
 8009fc8:	4293      	cmp	r3, r2
 8009fca:	d10a      	bne.n	8009fe2 <HAL_I2C_MspDeInit+0x1e>
  {
  /* USER CODE BEGIN I2C1_MspDeInit 0 */

  /* USER CODE END I2C1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_I2C1_CLK_DISABLE();
 8009fcc:	f502 32de 	add.w	r2, r2, #113664	; 0x1bc00
  
    /**I2C1 GPIO Configuration    
    PB8     ------> I2C1_SCL
    PB9     ------> I2C1_SDA 
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_8|GPIO_PIN_9);
 8009fd0:	f44f 7140 	mov.w	r1, #768	; 0x300
    __HAL_RCC_I2C1_CLK_DISABLE();
 8009fd4:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8009fd6:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8009fda:	6593      	str	r3, [r2, #88]	; 0x58
  
    /**I2C2 GPIO Configuration    
    PB10     ------> I2C2_SCL
    PB11     ------> I2C2_SDA 
    */
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
 8009fdc:	4808      	ldr	r0, [pc, #32]	; (800a000 <HAL_I2C_MspDeInit+0x3c>)
 8009fde:	f7f8 b849 	b.w	8002074 <HAL_GPIO_DeInit>
  else if(i2cHandle->Instance==I2C2)
 8009fe2:	4a08      	ldr	r2, [pc, #32]	; (800a004 <HAL_I2C_MspDeInit+0x40>)
 8009fe4:	4293      	cmp	r3, r2
 8009fe6:	d108      	bne.n	8009ffa <HAL_I2C_MspDeInit+0x36>
    __HAL_RCC_I2C2_CLK_DISABLE();
 8009fe8:	f502 32dc 	add.w	r2, r2, #112640	; 0x1b800
    HAL_GPIO_DeInit(GPIOB, GPIO_PIN_10|GPIO_PIN_11);
 8009fec:	f44f 6140 	mov.w	r1, #3072	; 0xc00
    __HAL_RCC_I2C2_CLK_DISABLE();
 8009ff0:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8009ff2:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8009ff6:	6593      	str	r3, [r2, #88]	; 0x58
 8009ff8:	e7f0      	b.n	8009fdc <HAL_I2C_MspDeInit+0x18>
 8009ffa:	4770      	bx	lr
 8009ffc:	40005400 	.word	0x40005400
 800a000:	48000400 	.word	0x48000400
 800a004:	40005800 	.word	0x40005800

0800a008 <MX_I2C1_DeInit>:

/* USER CODE BEGIN 1 */

void MX_I2C1_DeInit(void)
{
	HAL_I2C_DeInit(&hi2c1);
 800a008:	4801      	ldr	r0, [pc, #4]	; (800a010 <MX_I2C1_DeInit+0x8>)
 800a00a:	f7f8 ba57 	b.w	80024bc <HAL_I2C_DeInit>
 800a00e:	bf00      	nop
 800a010:	2000c4bc 	.word	0x2000c4bc

0800a014 <MX_I2C2_DeInit>:
}

void MX_I2C2_DeInit(void)
{
	HAL_I2C_DeInit(&hi2c2);
 800a014:	4801      	ldr	r0, [pc, #4]	; (800a01c <MX_I2C2_DeInit+0x8>)
 800a016:	f7f8 ba51 	b.w	80024bc <HAL_I2C_DeInit>
 800a01a:	bf00      	nop
 800a01c:	2000c508 	.word	0x2000c508

0800a020 <MX_IWDG_Init>:
{

	/* Calculate the timeout of the Watchdog:
	 * Prescaler * Window / 32.768 = 32 sec
	 *  */
  hiwdg.Instance = IWDG;
 800a020:	4809      	ldr	r0, [pc, #36]	; (800a048 <MX_IWDG_Init+0x28>)
	hiwdg.Init.Prescaler = IWDG_PRESCALER_256;
 800a022:	4a0a      	ldr	r2, [pc, #40]	; (800a04c <MX_IWDG_Init+0x2c>)
{
 800a024:	b508      	push	{r3, lr}
	hiwdg.Init.Prescaler = IWDG_PRESCALER_256;
 800a026:	2306      	movs	r3, #6
 800a028:	e880 000c 	stmia.w	r0, {r2, r3}
	hiwdg.Init.Window = 4095;
 800a02c:	f640 73ff 	movw	r3, #4095	; 0xfff
 800a030:	60c3      	str	r3, [r0, #12]
	hiwdg.Init.Reload = 4095;
 800a032:	6083      	str	r3, [r0, #8]
  if (HAL_IWDG_Init(&hiwdg) != HAL_OK)
 800a034:	f7f8 fc8b 	bl	800294e <HAL_IWDG_Init>
 800a038:	b128      	cbz	r0, 800a046 <MX_IWDG_Init+0x26>
  {
    Error_Handler();
 800a03a:	2148      	movs	r1, #72	; 0x48
 800a03c:	4804      	ldr	r0, [pc, #16]	; (800a050 <MX_IWDG_Init+0x30>)
  }

}
 800a03e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    Error_Handler();
 800a042:	f002 bd9b 	b.w	800cb7c <_Error_Handler>
 800a046:	bd08      	pop	{r3, pc}
 800a048:	2000c554 	.word	0x2000c554
 800a04c:	40003000 	.word	0x40003000
 800a050:	0800f953 	.word	0x0800f953

0800a054 <ResetIWDG>:

/* USER CODE BEGIN 1 */
void ResetIWDG(void)
{
	IWDG->KR = 0x0000AAAA;
 800a054:	4b02      	ldr	r3, [pc, #8]	; (800a060 <ResetIWDG+0xc>)
 800a056:	f64a 22aa 	movw	r2, #43690	; 0xaaaa
 800a05a:	601a      	str	r2, [r3, #0]
 800a05c:	4770      	bx	lr
 800a05e:	bf00      	nop
 800a060:	40003000 	.word	0x40003000

0800a064 <Program_IWDG_Freeze_Shutdown>:
}

void Program_IWDG_Freeze_Shutdown(void)
{
 800a064:	b500      	push	{lr}
 800a066:	b08b      	sub	sp, #44	; 0x2c
	FLASH_OBProgramInitTypeDef myFlashOB_Program;
	myFlashOB_Program.OptionType = OPTIONBYTE_USER;
 800a068:	2304      	movs	r3, #4
 800a06a:	9300      	str	r3, [sp, #0]
	myFlashOB_Program.USERType = OB_USER_IWDG_STOP;
 800a06c:	2310      	movs	r3, #16
 800a06e:	9305      	str	r3, [sp, #20]
	myFlashOB_Program.USERConfig = 0;
 800a070:	2300      	movs	r3, #0
 800a072:	9306      	str	r3, [sp, #24]
	myFlashOB_Program.RDPLevel = 0xAA;

	printf("----------** FLASH Program **----------\r\n");
 800a074:	4811      	ldr	r0, [pc, #68]	; (800a0bc <Program_IWDG_Freeze_Shutdown+0x58>)
	myFlashOB_Program.RDPLevel = 0xAA;
 800a076:	23aa      	movs	r3, #170	; 0xaa
 800a078:	9304      	str	r3, [sp, #16]
	printf("----------** FLASH Program **----------\r\n");
 800a07a:	f003 f9d7 	bl	800d42c <puts>

	if (HAL_FLASH_Unlock() == HAL_OK)
 800a07e:	f7f7 fda7 	bl	8001bd0 <HAL_FLASH_Unlock>
 800a082:	b910      	cbnz	r0, 800a08a <Program_IWDG_Freeze_Shutdown+0x26>
	{
		printf("FLASH Unlocked\r\n");
 800a084:	480e      	ldr	r0, [pc, #56]	; (800a0c0 <Program_IWDG_Freeze_Shutdown+0x5c>)
 800a086:	f003 f9d1 	bl	800d42c <puts>
	}

	if (HAL_FLASH_OB_Unlock() == HAL_OK)
 800a08a:	f7f7 fdbd 	bl	8001c08 <HAL_FLASH_OB_Unlock>
 800a08e:	b910      	cbnz	r0, 800a096 <Program_IWDG_Freeze_Shutdown+0x32>
	{
		printf("OB_Bits unlocked\r\n");
 800a090:	480c      	ldr	r0, [pc, #48]	; (800a0c4 <Program_IWDG_Freeze_Shutdown+0x60>)
 800a092:	f003 f9cb 	bl	800d42c <puts>
	}

	if (HAL_FLASHEx_OBProgram(&myFlashOB_Program) == HAL_OK)
 800a096:	4668      	mov	r0, sp
 800a098:	f7f7 fe06 	bl	8001ca8 <HAL_FLASHEx_OBProgram>
 800a09c:	b910      	cbnz	r0, 800a0a4 <Program_IWDG_Freeze_Shutdown+0x40>
	{
		printf("OB_Bit programmed\r\n");
 800a09e:	480a      	ldr	r0, [pc, #40]	; (800a0c8 <Program_IWDG_Freeze_Shutdown+0x64>)
 800a0a0:	f003 f9c4 	bl	800d42c <puts>
	}

	HAL_FLASH_Lock();
 800a0a4:	f7f7 fda6 	bl	8001bf4 <HAL_FLASH_Lock>

	printf("FLASH Locked\r\n");
 800a0a8:	4808      	ldr	r0, [pc, #32]	; (800a0cc <Program_IWDG_Freeze_Shutdown+0x68>)
 800a0aa:	f003 f9bf 	bl	800d42c <puts>
	printf("-------------------------\r\n");
 800a0ae:	4808      	ldr	r0, [pc, #32]	; (800a0d0 <Program_IWDG_Freeze_Shutdown+0x6c>)
 800a0b0:	f003 f9bc 	bl	800d42c <puts>
}
 800a0b4:	b00b      	add	sp, #44	; 0x2c
 800a0b6:	f85d fb04 	ldr.w	pc, [sp], #4
 800a0ba:	bf00      	nop
 800a0bc:	0800f96a 	.word	0x0800f96a
 800a0c0:	0800f993 	.word	0x0800f993
 800a0c4:	0800f9a3 	.word	0x0800f9a3
 800a0c8:	0800f9b5 	.word	0x0800f9b5
 800a0cc:	0800f9c8 	.word	0x0800f9c8
 800a0d0:	0800f9d6 	.word	0x0800f9d6

0800a0d4 <MX_LPTIM1_Init>:

/* LPTIM1 init function */
void MX_LPTIM1_Init(void)
{

  hlptim1.Instance = LPTIM1;
 800a0d4:	480c      	ldr	r0, [pc, #48]	; (800a108 <MX_LPTIM1_Init+0x34>)
{
 800a0d6:	b508      	push	{r3, lr}
  hlptim1.Instance = LPTIM1;
 800a0d8:	4b0c      	ldr	r3, [pc, #48]	; (800a10c <MX_LPTIM1_Init+0x38>)
 800a0da:	6003      	str	r3, [r0, #0]
  hlptim1.Init.Clock.Source = LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC;
  hlptim1.Init.Clock.Prescaler = LPTIM_PRESCALER_DIV1;
  hlptim1.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE;
 800a0dc:	f64f 72ff 	movw	r2, #65535	; 0xffff
  hlptim1.Init.Clock.Source = LPTIM_CLOCKSOURCE_APBCLOCK_LPOSC;
 800a0e0:	2300      	movs	r3, #0
 800a0e2:	6043      	str	r3, [r0, #4]
  hlptim1.Init.Clock.Prescaler = LPTIM_PRESCALER_DIV1;
 800a0e4:	6083      	str	r3, [r0, #8]
  hlptim1.Init.Trigger.Source = LPTIM_TRIGSOURCE_SOFTWARE;
 800a0e6:	6142      	str	r2, [r0, #20]
  hlptim1.Init.OutputPolarity = LPTIM_OUTPUTPOLARITY_HIGH;
 800a0e8:	6203      	str	r3, [r0, #32]
  hlptim1.Init.UpdateMode = LPTIM_UPDATE_IMMEDIATE;
 800a0ea:	6243      	str	r3, [r0, #36]	; 0x24
  hlptim1.Init.CounterSource = LPTIM_COUNTERSOURCE_INTERNAL;
 800a0ec:	6283      	str	r3, [r0, #40]	; 0x28
  hlptim1.Init.Input1Source = LPTIM_INPUT1SOURCE_GPIO;
 800a0ee:	62c3      	str	r3, [r0, #44]	; 0x2c
  hlptim1.Init.Input2Source = LPTIM_INPUT2SOURCE_GPIO;
 800a0f0:	6303      	str	r3, [r0, #48]	; 0x30
  if (HAL_LPTIM_Init(&hlptim1) != HAL_OK)
 800a0f2:	f7f8 fc53 	bl	800299c <HAL_LPTIM_Init>
 800a0f6:	b128      	cbz	r0, 800a104 <MX_LPTIM1_Init+0x30>
  {
    _Error_Handler(__FILE__, __LINE__);
 800a0f8:	214a      	movs	r1, #74	; 0x4a
 800a0fa:	4805      	ldr	r0, [pc, #20]	; (800a110 <MX_LPTIM1_Init+0x3c>)
  }

}
 800a0fc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
 800a100:	f002 bd3c 	b.w	800cb7c <_Error_Handler>
 800a104:	bd08      	pop	{r3, pc}
 800a106:	bf00      	nop
 800a108:	2000c564 	.word	0x2000c564
 800a10c:	40007c00 	.word	0x40007c00
 800a110:	0800f9f1 	.word	0x0800f9f1

0800a114 <HAL_LPTIM_MspInit>:

void HAL_LPTIM_MspInit(LPTIM_HandleTypeDef* lptimHandle)
{
 800a114:	b507      	push	{r0, r1, r2, lr}

  if(lptimHandle->Instance==LPTIM1)
 800a116:	4b0d      	ldr	r3, [pc, #52]	; (800a14c <HAL_LPTIM_MspInit+0x38>)
 800a118:	6802      	ldr	r2, [r0, #0]
 800a11a:	429a      	cmp	r2, r3
 800a11c:	d112      	bne.n	800a144 <HAL_LPTIM_MspInit+0x30>
  {
  /* USER CODE BEGIN LPTIM1_MspInit 0 */
		GPIO_InitTypeDef GPIO_InitStruct;
  /* USER CODE END LPTIM1_MspInit 0 */
    /* LPTIM1 clock enable */
    __HAL_RCC_LPTIM1_CLK_ENABLE();
 800a11e:	f503 33ca 	add.w	r3, r3, #103424	; 0x19400

    /* LPTIM1 interrupt Init */
    HAL_NVIC_SetPriority(LPTIM1_IRQn, 0, 0);
 800a122:	2041      	movs	r0, #65	; 0x41
    __HAL_RCC_LPTIM1_CLK_ENABLE();
 800a124:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800a126:	f042 4200 	orr.w	r2, r2, #2147483648	; 0x80000000
 800a12a:	659a      	str	r2, [r3, #88]	; 0x58
 800a12c:	6d9b      	ldr	r3, [r3, #88]	; 0x58
    HAL_NVIC_SetPriority(LPTIM1_IRQn, 0, 0);
 800a12e:	2200      	movs	r2, #0
    __HAL_RCC_LPTIM1_CLK_ENABLE();
 800a130:	f003 4300 	and.w	r3, r3, #2147483648	; 0x80000000
 800a134:	9301      	str	r3, [sp, #4]
    HAL_NVIC_SetPriority(LPTIM1_IRQn, 0, 0);
 800a136:	4611      	mov	r1, r2
    __HAL_RCC_LPTIM1_CLK_ENABLE();
 800a138:	9b01      	ldr	r3, [sp, #4]
    HAL_NVIC_SetPriority(LPTIM1_IRQn, 0, 0);
 800a13a:	f7f7 fc15 	bl	8001968 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(LPTIM1_IRQn);
 800a13e:	2041      	movs	r0, #65	; 0x41
 800a140:	f7f7 fc46 	bl	80019d0 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN LPTIM1_MspInit 1 */

  /* USER CODE END LPTIM1_MspInit 1 */
  }
}
 800a144:	b003      	add	sp, #12
 800a146:	f85d fb04 	ldr.w	pc, [sp], #4
 800a14a:	bf00      	nop
 800a14c:	40007c00 	.word	0x40007c00

0800a150 <MX_RTC_Init>:

RTC_HandleTypeDef hrtc;

/* RTC init function */
void MX_RTC_Init(void)
{
 800a150:	b510      	push	{r4, lr}
  RTC_AlarmTypeDef sAlarm;
	RTC_AlarmTypeDef sAlarmB;

    /**Initialize RTC Only 
    */
  hrtc.Instance = RTC;
 800a152:	483d      	ldr	r0, [pc, #244]	; (800a248 <MX_RTC_Init+0xf8>)
 800a154:	4b3d      	ldr	r3, [pc, #244]	; (800a24c <MX_RTC_Init+0xfc>)
 800a156:	6003      	str	r3, [r0, #0]
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
  hrtc.Init.AsynchPrediv = 127;
 800a158:	227f      	movs	r2, #127	; 0x7f
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 800a15a:	2300      	movs	r3, #0
{
 800a15c:	b09a      	sub	sp, #104	; 0x68
  hrtc.Init.AsynchPrediv = 127;
 800a15e:	6082      	str	r2, [r0, #8]
  hrtc.Init.SynchPrediv = 255;
 800a160:	22ff      	movs	r2, #255	; 0xff
  hrtc.Init.HourFormat = RTC_HOURFORMAT_24;
 800a162:	6043      	str	r3, [r0, #4]
  hrtc.Init.SynchPrediv = 255;
 800a164:	60c2      	str	r2, [r0, #12]
  hrtc.Init.OutPut = RTC_OUTPUT_DISABLE;
 800a166:	6103      	str	r3, [r0, #16]
  hrtc.Init.OutPutRemap = RTC_OUTPUT_REMAP_NONE;
 800a168:	6143      	str	r3, [r0, #20]
  hrtc.Init.OutPutPolarity = RTC_OUTPUT_POLARITY_HIGH;
 800a16a:	6183      	str	r3, [r0, #24]
  hrtc.Init.OutPutType = RTC_OUTPUT_TYPE_OPENDRAIN;
 800a16c:	61c3      	str	r3, [r0, #28]
  if (HAL_RTC_Init(&hrtc) != HAL_OK)
 800a16e:	f7f9 fb97 	bl	80038a0 <HAL_RTC_Init>
 800a172:	b118      	cbz	r0, 800a17c <MX_RTC_Init+0x2c>
  {
    _Error_Handler(__FILE__, __LINE__);
 800a174:	2150      	movs	r1, #80	; 0x50
 800a176:	4836      	ldr	r0, [pc, #216]	; (800a250 <MX_RTC_Init+0x100>)
 800a178:	f002 fd00 	bl	800cb7c <_Error_Handler>

  /* USER CODE END RTC_Init 2 */

    /**Initialize RTC and set the Time and Date 
    */
  sTime.Hours = 13;
 800a17c:	230d      	movs	r3, #13
  sTime.Minutes = 37;
  sTime.Seconds = 0;
 800a17e:	2200      	movs	r2, #0
  sTime.Hours = 13;
 800a180:	f88d 3004 	strb.w	r3, [sp, #4]
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN) != HAL_OK)
 800a184:	a901      	add	r1, sp, #4
  sTime.Minutes = 37;
 800a186:	2325      	movs	r3, #37	; 0x25
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN) != HAL_OK)
 800a188:	482f      	ldr	r0, [pc, #188]	; (800a248 <MX_RTC_Init+0xf8>)
  sTime.Minutes = 37;
 800a18a:	f88d 3005 	strb.w	r3, [sp, #5]
  sTime.Seconds = 0;
 800a18e:	f88d 2006 	strb.w	r2, [sp, #6]
  sTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 800a192:	9204      	str	r2, [sp, #16]
  sTime.StoreOperation = RTC_STOREOPERATION_RESET;
 800a194:	9205      	str	r2, [sp, #20]
  if (HAL_RTC_SetTime(&hrtc, &sTime, RTC_FORMAT_BIN) != HAL_OK)
 800a196:	f7f9 fbe3 	bl	8003960 <HAL_RTC_SetTime>
 800a19a:	b118      	cbz	r0, 800a1a4 <MX_RTC_Init+0x54>
  {
    _Error_Handler(__FILE__, __LINE__);
 800a19c:	215f      	movs	r1, #95	; 0x5f
 800a19e:	482c      	ldr	r0, [pc, #176]	; (800a250 <MX_RTC_Init+0x100>)
 800a1a0:	f002 fcec 	bl	800cb7c <_Error_Handler>
  }
  /* USER CODE BEGIN RTC_Init 3 */

  /* USER CODE END RTC_Init 3 */

  sDate.WeekDay = RTC_WEEKDAY_MONDAY;
 800a1a4:	2301      	movs	r3, #1
 800a1a6:	f88d 3000 	strb.w	r3, [sp]
  sDate.Month = RTC_MONTH_FEBRUARY;
 800a1aa:	2302      	movs	r3, #2
 800a1ac:	f88d 3001 	strb.w	r3, [sp, #1]
	sDate.Date = 13;
 800a1b0:	230d      	movs	r3, #13
 800a1b2:	f88d 3002 	strb.w	r3, [sp, #2]
  sDate.Year = 19;

  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN) != HAL_OK)
 800a1b6:	2200      	movs	r2, #0
  sDate.Year = 19;
 800a1b8:	2313      	movs	r3, #19
  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN) != HAL_OK)
 800a1ba:	4669      	mov	r1, sp
 800a1bc:	4822      	ldr	r0, [pc, #136]	; (800a248 <MX_RTC_Init+0xf8>)
  sDate.Year = 19;
 800a1be:	f88d 3003 	strb.w	r3, [sp, #3]
  if (HAL_RTC_SetDate(&hrtc, &sDate, RTC_FORMAT_BIN) != HAL_OK)
 800a1c2:	f7f9 fc46 	bl	8003a52 <HAL_RTC_SetDate>
 800a1c6:	b118      	cbz	r0, 800a1d0 <MX_RTC_Init+0x80>
  {
    _Error_Handler(__FILE__, __LINE__);
 800a1c8:	216c      	movs	r1, #108	; 0x6c
 800a1ca:	4821      	ldr	r0, [pc, #132]	; (800a250 <MX_RTC_Init+0x100>)
 800a1cc:	f002 fcd6 	bl	800cb7c <_Error_Handler>

  /* USER CODE END RTC_Init 4 */

    /**Enable the Alarm A 
    */
  sAlarm.AlarmTime.Hours = 0;
 800a1d0:	2400      	movs	r4, #0
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
  sAlarm.AlarmDateWeekDay = 1;
 800a1d2:	2301      	movs	r3, #1
 800a1d4:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
  sAlarm.Alarm = RTC_ALARM_A;
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN) != HAL_OK)
 800a1d8:	4622      	mov	r2, r4
  sAlarm.Alarm = RTC_ALARM_A;
 800a1da:	f44f 7380 	mov.w	r3, #256	; 0x100
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN) != HAL_OK)
 800a1de:	a906      	add	r1, sp, #24
 800a1e0:	4819      	ldr	r0, [pc, #100]	; (800a248 <MX_RTC_Init+0xf8>)
  sAlarm.AlarmTime.Hours = 0;
 800a1e2:	f88d 4018 	strb.w	r4, [sp, #24]
  sAlarm.AlarmTime.Minutes = 0;
 800a1e6:	f88d 4019 	strb.w	r4, [sp, #25]
  sAlarm.AlarmTime.Seconds = 0;
 800a1ea:	f88d 401a 	strb.w	r4, [sp, #26]
  sAlarm.AlarmTime.SubSeconds = 0;
 800a1ee:	9407      	str	r4, [sp, #28]
  sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 800a1f0:	9409      	str	r4, [sp, #36]	; 0x24
  sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 800a1f2:	940a      	str	r4, [sp, #40]	; 0x28
  sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 800a1f4:	940b      	str	r4, [sp, #44]	; 0x2c
  sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 800a1f6:	940c      	str	r4, [sp, #48]	; 0x30
  sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 800a1f8:	940d      	str	r4, [sp, #52]	; 0x34
  sAlarm.Alarm = RTC_ALARM_A;
 800a1fa:	930f      	str	r3, [sp, #60]	; 0x3c
  if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN) != HAL_OK)
 800a1fc:	f7f9 fc92 	bl	8003b24 <HAL_RTC_SetAlarm_IT>
 800a200:	b118      	cbz	r0, 800a20a <MX_RTC_Init+0xba>
  {
    _Error_Handler(__FILE__, __LINE__);
 800a202:	2181      	movs	r1, #129	; 0x81
 800a204:	4812      	ldr	r0, [pc, #72]	; (800a250 <MX_RTC_Init+0x100>)
 800a206:	f002 fcb9 	bl	800cb7c <_Error_Handler>
	sAlarmB.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
	sAlarmB.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
	sAlarmB.AlarmMask = RTC_ALARMMASK_NONE;
	sAlarmB.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
	sAlarmB.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
	sAlarmB.AlarmDateWeekDay = 1;
 800a20a:	2301      	movs	r3, #1
 800a20c:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
	sAlarmB.Alarm = RTC_ALARM_A;
	if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarmB, RTC_FORMAT_BIN) != HAL_OK)
 800a210:	2200      	movs	r2, #0
	sAlarmB.Alarm = RTC_ALARM_A;
 800a212:	f44f 7380 	mov.w	r3, #256	; 0x100
	if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarmB, RTC_FORMAT_BIN) != HAL_OK)
 800a216:	a910      	add	r1, sp, #64	; 0x40
 800a218:	480b      	ldr	r0, [pc, #44]	; (800a248 <MX_RTC_Init+0xf8>)
	sAlarmB.AlarmTime.Hours = 0;
 800a21a:	f88d 4040 	strb.w	r4, [sp, #64]	; 0x40
	sAlarmB.AlarmTime.Minutes = 0;
 800a21e:	f88d 4041 	strb.w	r4, [sp, #65]	; 0x41
	sAlarmB.AlarmTime.Seconds = 0;
 800a222:	f88d 4042 	strb.w	r4, [sp, #66]	; 0x42
	sAlarmB.AlarmTime.SubSeconds = 0;
 800a226:	9411      	str	r4, [sp, #68]	; 0x44
	sAlarmB.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 800a228:	9413      	str	r4, [sp, #76]	; 0x4c
	sAlarmB.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 800a22a:	9414      	str	r4, [sp, #80]	; 0x50
	sAlarmB.AlarmMask = RTC_ALARMMASK_NONE;
 800a22c:	9415      	str	r4, [sp, #84]	; 0x54
	sAlarmB.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 800a22e:	9416      	str	r4, [sp, #88]	; 0x58
	sAlarmB.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 800a230:	9417      	str	r4, [sp, #92]	; 0x5c
	sAlarmB.Alarm = RTC_ALARM_A;
 800a232:	9319      	str	r3, [sp, #100]	; 0x64
	if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarmB, RTC_FORMAT_BIN) != HAL_OK)
 800a234:	f7f9 fc76 	bl	8003b24 <HAL_RTC_SetAlarm_IT>
 800a238:	b118      	cbz	r0, 800a242 <MX_RTC_Init+0xf2>
	{
		_Error_Handler(__FILE__, __LINE__);
 800a23a:	2191      	movs	r1, #145	; 0x91
 800a23c:	4804      	ldr	r0, [pc, #16]	; (800a250 <MX_RTC_Init+0x100>)
 800a23e:	f002 fc9d 	bl	800cb7c <_Error_Handler>
	}
  /* USER CODE BEGIN RTC_Init 5 */

  /* USER CODE END RTC_Init 5 */

}
 800a242:	b01a      	add	sp, #104	; 0x68
 800a244:	bd10      	pop	{r4, pc}
 800a246:	bf00      	nop
 800a248:	2000c59c 	.word	0x2000c59c
 800a24c:	40002800 	.word	0x40002800
 800a250:	0800fa09 	.word	0x0800fa09

0800a254 <HAL_RTC_MspInit>:

void HAL_RTC_MspInit(RTC_HandleTypeDef* rtcHandle)
{
 800a254:	b508      	push	{r3, lr}

  if(rtcHandle->Instance==RTC)
 800a256:	6802      	ldr	r2, [r0, #0]
 800a258:	4b0a      	ldr	r3, [pc, #40]	; (800a284 <HAL_RTC_MspInit+0x30>)
 800a25a:	429a      	cmp	r2, r3
 800a25c:	d110      	bne.n	800a280 <HAL_RTC_MspInit+0x2c>
  {
  /* USER CODE BEGIN RTC_MspInit 0 */

  /* USER CODE END RTC_MspInit 0 */
    /* RTC clock enable */
    __HAL_RCC_RTC_ENABLE();
 800a25e:	4a0a      	ldr	r2, [pc, #40]	; (800a288 <HAL_RTC_MspInit+0x34>)
 800a260:	f8d2 3090 	ldr.w	r3, [r2, #144]	; 0x90
 800a264:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 800a268:	f8c2 3090 	str.w	r3, [r2, #144]	; 0x90

    /* RTC interrupt Init */
    HAL_NVIC_SetPriority(RTC_Alarm_IRQn, 0, 0);
 800a26c:	2200      	movs	r2, #0
 800a26e:	2029      	movs	r0, #41	; 0x29
 800a270:	4611      	mov	r1, r2
 800a272:	f7f7 fb79 	bl	8001968 <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 800a276:	2029      	movs	r0, #41	; 0x29
  /* USER CODE BEGIN RTC_MspInit 1 */

  /* USER CODE END RTC_MspInit 1 */
  }
}
 800a278:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    HAL_NVIC_EnableIRQ(RTC_Alarm_IRQn);
 800a27c:	f7f7 bba8 	b.w	80019d0 <HAL_NVIC_EnableIRQ>
 800a280:	bd08      	pop	{r3, pc}
 800a282:	bf00      	nop
 800a284:	40002800 	.word	0x40002800
 800a288:	40021000 	.word	0x40021000

0800a28c <RTC_Get_DateTime_Comp>:
  }
} 

/* USER CODE BEGIN 1 */
uint32_t RTC_Get_DateTime_Comp()   //ANFR
{
 800a28c:	b510      	push	{r4, lr}
	RTC_DateTypeDef sD;
	RTC_TimeTypeDef tS;

	uint32_t dateTime = 0;

	HAL_RTC_GetTime(&hrtc, &tS, RTC_FORMAT_BIN);
 800a28e:	4c17      	ldr	r4, [pc, #92]	; (800a2ec <RTC_Get_DateTime_Comp+0x60>)
{
 800a290:	b086      	sub	sp, #24
	HAL_RTC_GetTime(&hrtc, &tS, RTC_FORMAT_BIN);
 800a292:	a901      	add	r1, sp, #4
 800a294:	2200      	movs	r2, #0
 800a296:	4620      	mov	r0, r4
 800a298:	f7f9 fd07 	bl	8003caa <HAL_RTC_GetTime>
	HAL_RTC_GetDate(&hrtc, &sD, RTC_FORMAT_BIN);
 800a29c:	2200      	movs	r2, #0
 800a29e:	4669      	mov	r1, sp
 800a2a0:	4620      	mov	r0, r4
 800a2a2:	f7f9 fd2a 	bl	8003cfa <HAL_RTC_GetDate>
	dateTime = (uint32_t) (0b111111 & sD.Year) << 26;
	dateTime |= (uint32_t) (0b1111 & sD.Month) << 22;
	dateTime |= (uint32_t) (0b11111 & sD.Date) << 17;
	dateTime |= (uint32_t) (0b11111 & tS.Hours) << 12;
	dateTime |= (uint32_t) (0b111111 & tS.Minutes) << 6;
	dateTime |= (uint32_t) (0b111111 & tS.Seconds);
 800a2a6:	f89d 3006 	ldrb.w	r3, [sp, #6]
	dateTime = (uint32_t) (0b111111 & sD.Year) << 26;
 800a2aa:	f89d 0003 	ldrb.w	r0, [sp, #3]
	dateTime |= (uint32_t) (0b111111 & tS.Seconds);
 800a2ae:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a2b2:	ea43 6380 	orr.w	r3, r3, r0, lsl #26
	dateTime |= (uint32_t) (0b1111 & sD.Month) << 22;
 800a2b6:	f89d 0001 	ldrb.w	r0, [sp, #1]
 800a2ba:	0580      	lsls	r0, r0, #22
 800a2bc:	f000 7070 	and.w	r0, r0, #62914560	; 0x3c00000
 800a2c0:	4303      	orrs	r3, r0
	dateTime |= (uint32_t) (0b11111 & sD.Date) << 17;
 800a2c2:	f89d 0002 	ldrb.w	r0, [sp, #2]
 800a2c6:	0440      	lsls	r0, r0, #17
 800a2c8:	f400 1078 	and.w	r0, r0, #4063232	; 0x3e0000
 800a2cc:	4303      	orrs	r3, r0
	dateTime |= (uint32_t) (0b11111 & tS.Hours) << 12;
 800a2ce:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800a2d2:	0300      	lsls	r0, r0, #12
 800a2d4:	f400 30f8 	and.w	r0, r0, #126976	; 0x1f000
 800a2d8:	4303      	orrs	r3, r0
	dateTime |= (uint32_t) (0b111111 & tS.Minutes) << 6;
 800a2da:	f89d 0005 	ldrb.w	r0, [sp, #5]
 800a2de:	0180      	lsls	r0, r0, #6
 800a2e0:	f400 607c 	and.w	r0, r0, #4032	; 0xfc0

	return dateTime;
}
 800a2e4:	4318      	orrs	r0, r3
 800a2e6:	b006      	add	sp, #24
 800a2e8:	bd10      	pop	{r4, pc}
 800a2ea:	bf00      	nop
 800a2ec:	2000c59c 	.word	0x2000c59c

0800a2f0 <RTC_SetAlarm>:

void RTC_SetAlarm(uint32_t seconds)  // todo
{
 800a2f0:	b530      	push	{r4, r5, lr}
	RTC_AlarmTypeDef sAlarm;
	struct tm time;
	RTC_DateTypeDef ds;
	RTC_TimeTypeDef ts;

	HAL_RTC_GetTime(&hrtc, &ts, RTC_FORMAT_BIN);
 800a2f2:	4c21      	ldr	r4, [pc, #132]	; (800a378 <RTC_SetAlarm+0x88>)
{
 800a2f4:	b09b      	sub	sp, #108	; 0x6c
 800a2f6:	4605      	mov	r5, r0
	HAL_RTC_GetTime(&hrtc, &ts, RTC_FORMAT_BIN);
 800a2f8:	a902      	add	r1, sp, #8
 800a2fa:	2200      	movs	r2, #0
 800a2fc:	4620      	mov	r0, r4
 800a2fe:	f7f9 fcd4 	bl	8003caa <HAL_RTC_GetTime>
	HAL_RTC_GetDate(&hrtc, &ds, RTC_FORMAT_BIN);
 800a302:	a901      	add	r1, sp, #4
 800a304:	2200      	movs	r2, #0
 800a306:	4620      	mov	r0, r4
 800a308:	f7f9 fcf7 	bl	8003cfa <HAL_RTC_GetDate>

	time.tm_year = ds.Year + 100;
	time.tm_mon = ds.Month - 1;
	time.tm_mday = ds.Date;
 800a30c:	f89d 3006 	ldrb.w	r3, [sp, #6]
	time.tm_year = ds.Year + 100;
 800a310:	f89d 2007 	ldrb.w	r2, [sp, #7]
	time.tm_mday = ds.Date;
 800a314:	930a      	str	r3, [sp, #40]	; 0x28
	time.tm_hour = ts.Hours;
 800a316:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800a31a:	9309      	str	r3, [sp, #36]	; 0x24
	time.tm_min = ts.Minutes;
 800a31c:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800a320:	9308      	str	r3, [sp, #32]
	time.tm_year = ds.Year + 100;
 800a322:	3264      	adds	r2, #100	; 0x64
	time.tm_sec = ts.Seconds + seconds;
 800a324:	f89d 300a 	ldrb.w	r3, [sp, #10]
	time.tm_year = ds.Year + 100;
 800a328:	920c      	str	r2, [sp, #48]	; 0x30
	time.tm_sec = ts.Seconds + seconds;
 800a32a:	a81a      	add	r0, sp, #104	; 0x68
	time.tm_mon = ds.Month - 1;
 800a32c:	f89d 2005 	ldrb.w	r2, [sp, #5]
	time.tm_sec = ts.Seconds + seconds;
 800a330:	442b      	add	r3, r5
	time.tm_mon = ds.Month - 1;
 800a332:	3a01      	subs	r2, #1
	time.tm_sec = ts.Seconds + seconds;
 800a334:	f840 3d4c 	str.w	r3, [r0, #-76]!
	time.tm_mon = ds.Month - 1;
 800a338:	920b      	str	r2, [sp, #44]	; 0x2c

	mktime(&time);
 800a33a:	f002 fdc7 	bl	800cecc <mktime>

	/*
	 *	The date, month and year doesn't matter. The alarm should go off every day no matter what day it is...
	 */
	sAlarm.AlarmTime.Hours = time.tm_hour;
 800a33e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a340:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	sAlarm.AlarmTime.Minutes = time.tm_min;
 800a344:	9b08      	ldr	r3, [sp, #32]
 800a346:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
	sAlarm.AlarmTime.Seconds = time.tm_sec;
 800a34a:	9b07      	ldr	r3, [sp, #28]
 800a34c:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
	sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
	sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
	sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
	sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
	sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
	sAlarm.AlarmDateWeekDay = time.tm_mday;
 800a350:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a352:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
	sAlarm.AlarmTime.SubSeconds = 0;
 800a356:	2200      	movs	r2, #0
	sAlarm.Alarm = RTC_ALARM_A;
 800a358:	f44f 7380 	mov.w	r3, #256	; 0x100

	if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN) != HAL_OK)
 800a35c:	a910      	add	r1, sp, #64	; 0x40
 800a35e:	4620      	mov	r0, r4
	sAlarm.AlarmTime.SubSeconds = 0;
 800a360:	9211      	str	r2, [sp, #68]	; 0x44
	sAlarm.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 800a362:	9213      	str	r2, [sp, #76]	; 0x4c
	sAlarm.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 800a364:	9214      	str	r2, [sp, #80]	; 0x50
	sAlarm.AlarmMask = RTC_ALARMMASK_NONE;
 800a366:	9215      	str	r2, [sp, #84]	; 0x54
	sAlarm.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 800a368:	9216      	str	r2, [sp, #88]	; 0x58
	sAlarm.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 800a36a:	9217      	str	r2, [sp, #92]	; 0x5c
	sAlarm.Alarm = RTC_ALARM_A;
 800a36c:	9319      	str	r3, [sp, #100]	; 0x64
	if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarm, RTC_FORMAT_BIN) != HAL_OK)
 800a36e:	f7f9 fbd9 	bl	8003b24 <HAL_RTC_SetAlarm_IT>
	{
		//printf("fel \r\n");
	}
}
 800a372:	b01b      	add	sp, #108	; 0x6c
 800a374:	bd30      	pop	{r4, r5, pc}
 800a376:	bf00      	nop
 800a378:	2000c59c 	.word	0x2000c59c

0800a37c <RTC_SetAlarmB>:

void RTC_SetAlarmB(uint32_t seconds)  // todo
{
 800a37c:	b530      	push	{r4, r5, lr}
	RTC_AlarmTypeDef sAlarmB;
	struct tm time;
	RTC_DateTypeDef ds;
	RTC_TimeTypeDef ts;

	HAL_RTC_GetTime(&hrtc, &ts, RTC_FORMAT_BIN);
 800a37e:	4c21      	ldr	r4, [pc, #132]	; (800a404 <RTC_SetAlarmB+0x88>)
{
 800a380:	b09b      	sub	sp, #108	; 0x6c
 800a382:	4605      	mov	r5, r0
	HAL_RTC_GetTime(&hrtc, &ts, RTC_FORMAT_BIN);
 800a384:	a902      	add	r1, sp, #8
 800a386:	2200      	movs	r2, #0
 800a388:	4620      	mov	r0, r4
 800a38a:	f7f9 fc8e 	bl	8003caa <HAL_RTC_GetTime>
	HAL_RTC_GetDate(&hrtc, &ds, RTC_FORMAT_BIN);
 800a38e:	a901      	add	r1, sp, #4
 800a390:	2200      	movs	r2, #0
 800a392:	4620      	mov	r0, r4
 800a394:	f7f9 fcb1 	bl	8003cfa <HAL_RTC_GetDate>

	time.tm_year = ds.Year + 100;
	time.tm_mon = ds.Month - 1;
	time.tm_mday = ds.Date;
 800a398:	f89d 3006 	ldrb.w	r3, [sp, #6]
	time.tm_year = ds.Year + 100;
 800a39c:	f89d 2007 	ldrb.w	r2, [sp, #7]
	time.tm_mday = ds.Date;
 800a3a0:	930a      	str	r3, [sp, #40]	; 0x28
	time.tm_hour = ts.Hours;
 800a3a2:	f89d 3008 	ldrb.w	r3, [sp, #8]
 800a3a6:	9309      	str	r3, [sp, #36]	; 0x24
	time.tm_min = ts.Minutes;
 800a3a8:	f89d 3009 	ldrb.w	r3, [sp, #9]
 800a3ac:	9308      	str	r3, [sp, #32]
	time.tm_year = ds.Year + 100;
 800a3ae:	3264      	adds	r2, #100	; 0x64
	time.tm_sec = ts.Seconds + seconds;
 800a3b0:	f89d 300a 	ldrb.w	r3, [sp, #10]
	time.tm_year = ds.Year + 100;
 800a3b4:	920c      	str	r2, [sp, #48]	; 0x30
	time.tm_sec = ts.Seconds + seconds;
 800a3b6:	a81a      	add	r0, sp, #104	; 0x68
	time.tm_mon = ds.Month - 1;
 800a3b8:	f89d 2005 	ldrb.w	r2, [sp, #5]
	time.tm_sec = ts.Seconds + seconds;
 800a3bc:	442b      	add	r3, r5
	time.tm_mon = ds.Month - 1;
 800a3be:	3a01      	subs	r2, #1
	time.tm_sec = ts.Seconds + seconds;
 800a3c0:	f840 3d4c 	str.w	r3, [r0, #-76]!
	time.tm_mon = ds.Month - 1;
 800a3c4:	920b      	str	r2, [sp, #44]	; 0x2c

	mktime(&time);
 800a3c6:	f002 fd81 	bl	800cecc <mktime>

	/*
	 *	The date, month and year doesn't matter. The alarm should go off every day no matter what day it is...
	 */
	sAlarmB.AlarmTime.Hours = time.tm_hour;
 800a3ca:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800a3cc:	f88d 3040 	strb.w	r3, [sp, #64]	; 0x40
	sAlarmB.AlarmTime.Minutes = time.tm_min;
 800a3d0:	9b08      	ldr	r3, [sp, #32]
 800a3d2:	f88d 3041 	strb.w	r3, [sp, #65]	; 0x41
	sAlarmB.AlarmTime.Seconds = time.tm_sec;
 800a3d6:	9b07      	ldr	r3, [sp, #28]
 800a3d8:	f88d 3042 	strb.w	r3, [sp, #66]	; 0x42
	sAlarmB.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
	sAlarmB.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
	sAlarmB.AlarmMask = RTC_ALARMMASK_NONE;
	sAlarmB.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
	sAlarmB.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
	sAlarmB.AlarmDateWeekDay = time.tm_mday;
 800a3dc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800a3de:	f88d 3060 	strb.w	r3, [sp, #96]	; 0x60
	sAlarmB.AlarmTime.SubSeconds = 0;
 800a3e2:	2200      	movs	r2, #0
	sAlarmB.Alarm = RTC_ALARM_B;
 800a3e4:	f44f 7300 	mov.w	r3, #512	; 0x200

	if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarmB, RTC_FORMAT_BIN) != HAL_OK)
 800a3e8:	a910      	add	r1, sp, #64	; 0x40
 800a3ea:	4620      	mov	r0, r4
	sAlarmB.AlarmTime.SubSeconds = 0;
 800a3ec:	9211      	str	r2, [sp, #68]	; 0x44
	sAlarmB.AlarmTime.DayLightSaving = RTC_DAYLIGHTSAVING_NONE;
 800a3ee:	9213      	str	r2, [sp, #76]	; 0x4c
	sAlarmB.AlarmTime.StoreOperation = RTC_STOREOPERATION_RESET;
 800a3f0:	9214      	str	r2, [sp, #80]	; 0x50
	sAlarmB.AlarmMask = RTC_ALARMMASK_NONE;
 800a3f2:	9215      	str	r2, [sp, #84]	; 0x54
	sAlarmB.AlarmSubSecondMask = RTC_ALARMSUBSECONDMASK_ALL;
 800a3f4:	9216      	str	r2, [sp, #88]	; 0x58
	sAlarmB.AlarmDateWeekDaySel = RTC_ALARMDATEWEEKDAYSEL_DATE;
 800a3f6:	9217      	str	r2, [sp, #92]	; 0x5c
	sAlarmB.Alarm = RTC_ALARM_B;
 800a3f8:	9319      	str	r3, [sp, #100]	; 0x64
	if (HAL_RTC_SetAlarm_IT(&hrtc, &sAlarmB, RTC_FORMAT_BIN) != HAL_OK)
 800a3fa:	f7f9 fb93 	bl	8003b24 <HAL_RTC_SetAlarm_IT>
	{
		//printf("fel \r\n");
	}
}
 800a3fe:	b01b      	add	sp, #108	; 0x6c
 800a400:	bd30      	pop	{r4, r5, pc}
 800a402:	bf00      	nop
 800a404:	2000c59c 	.word	0x2000c59c

0800a408 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a408:	4b21      	ldr	r3, [pc, #132]	; (800a490 <HAL_MspInit+0x88>)
{
 800a40a:	b507      	push	{r0, r1, r2, lr}
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 800a40c:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800a40e:	f042 0201 	orr.w	r2, r2, #1
 800a412:	661a      	str	r2, [r3, #96]	; 0x60
 800a414:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 800a416:	f002 0201 	and.w	r2, r2, #1
 800a41a:	9200      	str	r2, [sp, #0]
 800a41c:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 800a41e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800a420:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800a424:	659a      	str	r2, [r3, #88]	; 0x58
 800a426:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800a428:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 800a42c:	9301      	str	r3, [sp, #4]

  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800a42e:	2003      	movs	r0, #3
  __HAL_RCC_PWR_CLK_ENABLE();
 800a430:	9b01      	ldr	r3, [sp, #4]
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800a432:	f7f7 fa87 	bl	8001944 <HAL_NVIC_SetPriorityGrouping>

  /* System interrupt init*/
  /* MemoryManagement_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(MemoryManagement_IRQn, 0, 0);
 800a436:	2200      	movs	r2, #0
 800a438:	4611      	mov	r1, r2
 800a43a:	f06f 000b 	mvn.w	r0, #11
 800a43e:	f7f7 fa93 	bl	8001968 <HAL_NVIC_SetPriority>
  /* BusFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(BusFault_IRQn, 0, 0);
 800a442:	2200      	movs	r2, #0
 800a444:	4611      	mov	r1, r2
 800a446:	f06f 000a 	mvn.w	r0, #10
 800a44a:	f7f7 fa8d 	bl	8001968 <HAL_NVIC_SetPriority>
  /* UsageFault_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(UsageFault_IRQn, 0, 0);
 800a44e:	2200      	movs	r2, #0
 800a450:	4611      	mov	r1, r2
 800a452:	f06f 0009 	mvn.w	r0, #9
 800a456:	f7f7 fa87 	bl	8001968 <HAL_NVIC_SetPriority>
  /* SVCall_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SVCall_IRQn, 0, 0);
 800a45a:	2200      	movs	r2, #0
 800a45c:	4611      	mov	r1, r2
 800a45e:	f06f 0004 	mvn.w	r0, #4
 800a462:	f7f7 fa81 	bl	8001968 <HAL_NVIC_SetPriority>
  /* DebugMonitor_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(DebugMonitor_IRQn, 0, 0);
 800a466:	2200      	movs	r2, #0
 800a468:	4611      	mov	r1, r2
 800a46a:	f06f 0003 	mvn.w	r0, #3
 800a46e:	f7f7 fa7b 	bl	8001968 <HAL_NVIC_SetPriority>
  /* PendSV_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(PendSV_IRQn, 0, 0);
 800a472:	2200      	movs	r2, #0
 800a474:	4611      	mov	r1, r2
 800a476:	f06f 0001 	mvn.w	r0, #1
 800a47a:	f7f7 fa75 	bl	8001968 <HAL_NVIC_SetPriority>
  /* SysTick_IRQn interrupt configuration */
  HAL_NVIC_SetPriority(SysTick_IRQn, 0, 0);
 800a47e:	2200      	movs	r2, #0
 800a480:	4611      	mov	r1, r2
 800a482:	f04f 30ff 	mov.w	r0, #4294967295
 800a486:	f7f7 fa6f 	bl	8001968 <HAL_NVIC_SetPriority>

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 800a48a:	b003      	add	sp, #12
 800a48c:	f85d fb04 	ldr.w	pc, [sp], #4
 800a490:	40021000 	.word	0x40021000

0800a494 <SysTick_Handler>:

/**
* @brief This function handles System tick timer.
*/
void SysTick_Handler(void)
{
 800a494:	b508      	push	{r3, lr}
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 800a496:	f7f6 fcf3 	bl	8000e80 <HAL_IncTick>
  HAL_SYSTICK_IRQHandler();
  /* USER CODE BEGIN SysTick_IRQn 1 */


  /* USER CODE END SysTick_IRQn 1 */
}
 800a49a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_SYSTICK_IRQHandler();
 800a49e:	f7f7 bac6 	b.w	8001a2e <HAL_SYSTICK_IRQHandler>

0800a4a2 <USART2_IRQHandler>:
* @brief This function handles USART2 global interrupt.
*/
void USART2_IRQHandler(void)
{
  /* USER CODE BEGIN USART2_IRQn 0 */
	USART2_Callback();
 800a4a2:	f001 ba45 	b.w	800b930 <USART2_Callback>
	...

0800a4a8 <RTC_Alarm_IRQHandler>:
void RTC_Alarm_IRQHandler(void)
{
  /* USER CODE BEGIN RTC_Alarm_IRQn 0 */

  /* USER CODE END RTC_Alarm_IRQn 0 */
  HAL_RTC_AlarmIRQHandler(&hrtc);
 800a4a8:	4801      	ldr	r0, [pc, #4]	; (800a4b0 <RTC_Alarm_IRQHandler+0x8>)
 800a4aa:	f7f9 b98f 	b.w	80037cc <HAL_RTC_AlarmIRQHandler>
 800a4ae:	bf00      	nop
 800a4b0:	2000c59c 	.word	0x2000c59c

0800a4b4 <LPTIM1_IRQHandler>:
	/* USER CODE BEGIN LPTIM1_IRQn 0 */
//	HAL_GPIO_WritePin(HeartBeat_GPIO_Port, HeartBeat_Pin, GPIO_PIN_SET);
//	HAL_GPIO_TogglePin(HeartBeat_GPIO_Port, HeartBeat_Pin);
//	HAL_GPIO_TogglePin(GPIOB, GPIO_PIN_2);
	/* USER CODE END LPTIM1_IRQn 0 */
	HAL_LPTIM_IRQHandler(&hlptim1);
 800a4b4:	4801      	ldr	r0, [pc, #4]	; (800a4bc <LPTIM1_IRQHandler+0x8>)
 800a4b6:	f7f8 bafb 	b.w	8002ab0 <HAL_LPTIM_IRQHandler>
 800a4ba:	bf00      	nop
 800a4bc:	2000c564 	.word	0x2000c564

0800a4c0 <HAL_RTC_AlarmAEventCallback>:

	/* USER CODE END LPTIM1_IRQn 1 */
}

void HAL_RTC_AlarmAEventCallback(RTC_HandleTypeDef *hrtc)
{
 800a4c0:	b508      	push	{r3, lr}
	SaraConfig *sC = GetSaraConfigurationStruct();
 800a4c2:	f7fe fe1f 	bl	8009104 <GetSaraConfigurationStruct>
	RTC_SetAlarm(sC->updateFrequency);
 800a4c6:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 800a4ca:	f7ff ff11 	bl	800a2f0 <RTC_SetAlarm>
	SetSensorState(SENSOR_AWAKE);
 800a4ce:	2001      	movs	r0, #1
}
 800a4d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	SetSensorState(SENSOR_AWAKE);
 800a4d4:	f000 b926 	b.w	800a724 <SetSensorState>

0800a4d8 <HAL_RTCEx_AlarmBEventCallback>:

void HAL_RTCEx_AlarmBEventCallback(RTC_HandleTypeDef *hrtc)
{
 800a4d8:	4770      	bx	lr
	...

0800a4dc <SystemInit>:

void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
  #if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
    SCB->CPACR |= ((3UL << 10*2)|(3UL << 11*2));  /* set CP10 and CP11 Full Access */
 800a4dc:	490f      	ldr	r1, [pc, #60]	; (800a51c <SystemInit+0x40>)
 800a4de:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 800a4e2:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 800a4e6:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
  #endif

  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 800a4ea:	4b0d      	ldr	r3, [pc, #52]	; (800a520 <SystemInit+0x44>)
 800a4ec:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000U;
 800a4ee:	2000      	movs	r0, #0
  RCC->CR |= RCC_CR_MSION;
 800a4f0:	f042 0201 	orr.w	r2, r2, #1
 800a4f4:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000U;
 800a4f6:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= 0xEAF6FFFFU;
 800a4f8:	681a      	ldr	r2, [r3, #0]
 800a4fa:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 800a4fe:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 800a502:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000U;
 800a504:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800a508:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= 0xFFFBFFFFU;
 800a50a:	681a      	ldr	r2, [r3, #0]
 800a50c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800a510:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000U;
 800a512:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 800a514:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 800a518:	608b      	str	r3, [r1, #8]
 800a51a:	4770      	bx	lr
 800a51c:	e000ed00 	.word	0xe000ed00
 800a520:	40021000 	.word	0x40021000

0800a524 <MX_LPUART1_UART_Init>:
UART_HandleTypeDef hlpuart1;

/* LPUART1 init function */

void MX_LPUART1_UART_Init(void)
{
 800a524:	b508      	push	{r3, lr}

  hlpuart1.Instance = LPUART1;
 800a526:	480c      	ldr	r0, [pc, #48]	; (800a558 <MX_LPUART1_UART_Init+0x34>)
  hlpuart1.Init.BaudRate = 115200;
 800a528:	4b0c      	ldr	r3, [pc, #48]	; (800a55c <MX_LPUART1_UART_Init+0x38>)
 800a52a:	f44f 3ee1 	mov.w	lr, #115200	; 0x1c200
 800a52e:	e880 4008 	stmia.w	r0, {r3, lr}
  hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
  hlpuart1.Init.StopBits = UART_STOPBITS_1;
  hlpuart1.Init.Parity = UART_PARITY_NONE;
  hlpuart1.Init.Mode = UART_MODE_TX_RX;
 800a532:	220c      	movs	r2, #12
  hlpuart1.Init.WordLength = UART_WORDLENGTH_8B;
 800a534:	2300      	movs	r3, #0
 800a536:	6083      	str	r3, [r0, #8]
  hlpuart1.Init.StopBits = UART_STOPBITS_1;
 800a538:	60c3      	str	r3, [r0, #12]
  hlpuart1.Init.Parity = UART_PARITY_NONE;
 800a53a:	6103      	str	r3, [r0, #16]
  hlpuart1.Init.Mode = UART_MODE_TX_RX;
 800a53c:	6142      	str	r2, [r0, #20]
  hlpuart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 800a53e:	6183      	str	r3, [r0, #24]
  hlpuart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 800a540:	6203      	str	r3, [r0, #32]
  hlpuart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 800a542:	6243      	str	r3, [r0, #36]	; 0x24
  if (HAL_UART_Init(&hlpuart1) != HAL_OK)
 800a544:	f7fa faae 	bl	8004aa4 <HAL_UART_Init>
 800a548:	b128      	cbz	r0, 800a556 <MX_LPUART1_UART_Init+0x32>
  {
    _Error_Handler(__FILE__, __LINE__);
 800a54a:	214d      	movs	r1, #77	; 0x4d
 800a54c:	4804      	ldr	r0, [pc, #16]	; (800a560 <MX_LPUART1_UART_Init+0x3c>)
  }

}
 800a54e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    _Error_Handler(__FILE__, __LINE__);
 800a552:	f002 bb13 	b.w	800cb7c <_Error_Handler>
 800a556:	bd08      	pop	{r3, pc}
 800a558:	2000c5c0 	.word	0x2000c5c0
 800a55c:	40008000 	.word	0x40008000
 800a560:	0800fa68 	.word	0x0800fa68

0800a564 <MX_USART2_UART_Init>:
  * @retval None
*/
__STATIC_INLINE void LL_APB1_GRP1_EnableClock(uint32_t Periphs)
{
  __IO uint32_t tmpreg;
  SET_BIT(RCC->APB1ENR1, Periphs);
 800a564:	4b1f      	ldr	r3, [pc, #124]	; (800a5e4 <MX_USART2_UART_Init+0x80>)
/* USART2 init function */

void MX_USART2_UART_Init(void)
{
 800a566:	b530      	push	{r4, r5, lr}
 800a568:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800a56a:	f442 3200 	orr.w	r2, r2, #131072	; 0x20000
 800a56e:	659a      	str	r2, [r3, #88]	; 0x58
  /* Delay after an RCC peripheral clock enabling */
  tmpreg = READ_BIT(RCC->APB1ENR1, Periphs);
 800a570:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 800a572:	b08f      	sub	sp, #60	; 0x3c
 800a574:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800a578:	9300      	str	r3, [sp, #0]
  (void)tmpreg;
 800a57a:	9b00      	ldr	r3, [sp, #0]
  /**USART2 GPIO Configuration  
  PA2   ------> USART2_TX
  PA3   ------> USART2_RX 
  */
  GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_3;
  GPIO_InitStruct.Mode = LL_GPIO_MODE_ALTERNATE;
 800a57c:	2302      	movs	r3, #2
 800a57e:	9302      	str	r3, [sp, #8]
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 800a580:	2303      	movs	r3, #3
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 800a582:	2400      	movs	r4, #0
  GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_3;
 800a584:	250c      	movs	r5, #12
  GPIO_InitStruct.Speed = LL_GPIO_SPEED_FREQ_VERY_HIGH;
 800a586:	9303      	str	r3, [sp, #12]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a588:	a901      	add	r1, sp, #4
  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
 800a58a:	2307      	movs	r3, #7
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a58c:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
  GPIO_InitStruct.OutputType = LL_GPIO_OUTPUT_PUSHPULL;
 800a590:	9404      	str	r4, [sp, #16]
  GPIO_InitStruct.Pull = LL_GPIO_PULL_NO;
 800a592:	9405      	str	r4, [sp, #20]
  GPIO_InitStruct.Alternate = LL_GPIO_AF_7;
 800a594:	9306      	str	r3, [sp, #24]
  GPIO_InitStruct.Pin = LL_GPIO_PIN_2|LL_GPIO_PIN_3;
 800a596:	9501      	str	r5, [sp, #4]
  LL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 800a598:	f7fa fab6 	bl	8004b08 <LL_GPIO_Init>
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800a59c:	4b12      	ldr	r3, [pc, #72]	; (800a5e8 <MX_USART2_UART_Init+0x84>)
 800a59e:	68db      	ldr	r3, [r3, #12]
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800a5a0:	4b12      	ldr	r3, [pc, #72]	; (800a5ec <MX_USART2_UART_Init+0x88>)
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800a5a2:	2240      	movs	r2, #64	; 0x40
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800a5a4:	f883 4326 	strb.w	r4, [r3, #806]	; 0x326
  NVIC->ISER[(((uint32_t)(int32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)(int32_t)IRQn) & 0x1FUL));
 800a5a8:	605a      	str	r2, [r3, #4]
  /* USART2 interrupt Init */
  NVIC_SetPriority(USART2_IRQn, NVIC_EncodePriority(NVIC_GetPriorityGrouping(),0, 0));
  NVIC_EnableIRQ(USART2_IRQn);

  USART_InitStruct.BaudRate = 115200;
  USART_InitStruct.DataWidth = LL_USART_DATAWIDTH_8B;
 800a5aa:	9408      	str	r4, [sp, #32]
  USART_InitStruct.StopBits = LL_USART_STOPBITS_1;
 800a5ac:	9409      	str	r4, [sp, #36]	; 0x24
  USART_InitStruct.Parity = LL_USART_PARITY_NONE;
 800a5ae:	940a      	str	r4, [sp, #40]	; 0x28
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
  USART_InitStruct.HardwareFlowControl = LL_USART_HWCONTROL_NONE;
 800a5b0:	940c      	str	r4, [sp, #48]	; 0x30
  USART_InitStruct.OverSampling = LL_USART_OVERSAMPLING_16;
 800a5b2:	940d      	str	r4, [sp, #52]	; 0x34
  LL_USART_Init(USART2, &USART_InitStruct);
 800a5b4:	4c0e      	ldr	r4, [pc, #56]	; (800a5f0 <MX_USART2_UART_Init+0x8c>)
  USART_InitStruct.TransferDirection = LL_USART_DIRECTION_TX_RX;
 800a5b6:	950b      	str	r5, [sp, #44]	; 0x2c
  USART_InitStruct.BaudRate = 115200;
 800a5b8:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
  LL_USART_Init(USART2, &USART_InitStruct);
 800a5bc:	a907      	add	r1, sp, #28
 800a5be:	4620      	mov	r0, r4
  USART_InitStruct.BaudRate = 115200;
 800a5c0:	9307      	str	r3, [sp, #28]
  LL_USART_Init(USART2, &USART_InitStruct);
 800a5c2:	f7fa ff91 	bl	80054e8 <LL_USART_Init>
  CLEAR_BIT(USARTx->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 800a5c6:	6863      	ldr	r3, [r4, #4]
 800a5c8:	f423 4390 	bic.w	r3, r3, #18432	; 0x4800
 800a5cc:	6063      	str	r3, [r4, #4]
  CLEAR_BIT(USARTx->CR3, (USART_CR3_SCEN | USART_CR3_IREN | USART_CR3_HDSEL));
 800a5ce:	68a3      	ldr	r3, [r4, #8]
 800a5d0:	f023 032a 	bic.w	r3, r3, #42	; 0x2a
 800a5d4:	60a3      	str	r3, [r4, #8]
  SET_BIT(USARTx->CR1, USART_CR1_UE);
 800a5d6:	6823      	ldr	r3, [r4, #0]
 800a5d8:	f043 0301 	orr.w	r3, r3, #1
 800a5dc:	6023      	str	r3, [r4, #0]

  LL_USART_ConfigAsyncMode(USART2);

  LL_USART_Enable(USART2);

}
 800a5de:	b00f      	add	sp, #60	; 0x3c
 800a5e0:	bd30      	pop	{r4, r5, pc}
 800a5e2:	bf00      	nop
 800a5e4:	40021000 	.word	0x40021000
 800a5e8:	e000ed00 	.word	0xe000ed00
 800a5ec:	e000e100 	.word	0xe000e100
 800a5f0:	40004400 	.word	0x40004400

0800a5f4 <HAL_UART_MspInit>:

void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
 800a5f4:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}

  GPIO_InitTypeDef GPIO_InitStruct;
  if(uartHandle->Instance==LPUART1)
 800a5f6:	6802      	ldr	r2, [r0, #0]
 800a5f8:	4b0e      	ldr	r3, [pc, #56]	; (800a634 <HAL_UART_MspInit+0x40>)
 800a5fa:	429a      	cmp	r2, r3
 800a5fc:	d117      	bne.n	800a62e <HAL_UART_MspInit+0x3a>
  {
  /* USER CODE BEGIN LPUART1_MspInit 0 */

  /* USER CODE END LPUART1_MspInit 0 */
    /* LPUART1 clock enable */
    __HAL_RCC_LPUART1_CLK_ENABLE();
 800a5fe:	f503 33c8 	add.w	r3, r3, #102400	; 0x19000
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF8_LPUART1;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a602:	a901      	add	r1, sp, #4
    __HAL_RCC_LPUART1_CLK_ENABLE();
 800a604:	6dda      	ldr	r2, [r3, #92]	; 0x5c
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a606:	480c      	ldr	r0, [pc, #48]	; (800a638 <HAL_UART_MspInit+0x44>)
    __HAL_RCC_LPUART1_CLK_ENABLE();
 800a608:	f042 0201 	orr.w	r2, r2, #1
 800a60c:	65da      	str	r2, [r3, #92]	; 0x5c
 800a60e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 800a610:	f003 0301 	and.w	r3, r3, #1
 800a614:	9300      	str	r3, [sp, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a616:	2202      	movs	r2, #2
    __HAL_RCC_LPUART1_CLK_ENABLE();
 800a618:	9b00      	ldr	r3, [sp, #0]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 800a61a:	9202      	str	r2, [sp, #8]
    GPIO_InitStruct.Pin = GPIO_PIN_0|GPIO_PIN_1;
 800a61c:	2303      	movs	r3, #3
 800a61e:	9301      	str	r3, [sp, #4]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a620:	2200      	movs	r2, #0
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 800a622:	9304      	str	r3, [sp, #16]
    GPIO_InitStruct.Alternate = GPIO_AF8_LPUART1;
 800a624:	2308      	movs	r3, #8
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 800a626:	9203      	str	r2, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF8_LPUART1;
 800a628:	9305      	str	r3, [sp, #20]
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 800a62a:	f7f7 fc61 	bl	8001ef0 <HAL_GPIO_Init>

  /* USER CODE BEGIN LPUART1_MspInit 1 */

  /* USER CODE END LPUART1_MspInit 1 */
  }
}
 800a62e:	b007      	add	sp, #28
 800a630:	f85d fb04 	ldr.w	pc, [sp], #4
 800a634:	40008000 	.word	0x40008000
 800a638:	48000800 	.word	0x48000800

0800a63c <HAL_UART_MspDeInit>:

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{

  if(uartHandle->Instance==LPUART1)
 800a63c:	6802      	ldr	r2, [r0, #0]
 800a63e:	4b06      	ldr	r3, [pc, #24]	; (800a658 <HAL_UART_MspDeInit+0x1c>)
 800a640:	429a      	cmp	r2, r3
 800a642:	d108      	bne.n	800a656 <HAL_UART_MspDeInit+0x1a>
  {
  /* USER CODE BEGIN LPUART1_MspDeInit 0 */

  /* USER CODE END LPUART1_MspDeInit 0 */
    /* Peripheral clock disable */
    __HAL_RCC_LPUART1_CLK_DISABLE();
 800a644:	4a05      	ldr	r2, [pc, #20]	; (800a65c <HAL_UART_MspDeInit+0x20>)
  
    /**LPUART1 GPIO Configuration    
    PC0     ------> LPUART1_RX
    PC1     ------> LPUART1_TX 
    */
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_0|GPIO_PIN_1);
 800a646:	4806      	ldr	r0, [pc, #24]	; (800a660 <HAL_UART_MspDeInit+0x24>)
    __HAL_RCC_LPUART1_CLK_DISABLE();
 800a648:	6dd3      	ldr	r3, [r2, #92]	; 0x5c
 800a64a:	f023 0301 	bic.w	r3, r3, #1
 800a64e:	65d3      	str	r3, [r2, #92]	; 0x5c
    HAL_GPIO_DeInit(GPIOC, GPIO_PIN_0|GPIO_PIN_1);
 800a650:	2103      	movs	r1, #3
 800a652:	f7f7 bd0f 	b.w	8002074 <HAL_GPIO_DeInit>
 800a656:	4770      	bx	lr
 800a658:	40008000 	.word	0x40008000
 800a65c:	40021000 	.word	0x40021000
 800a660:	48000800 	.word	0x48000800

0800a664 <_write>:
} 

/* USER CODE BEGIN 1 */
int _write(int file, char *data, int len)
{
	if ((file != STDOUT_FILENO) && (file != STDERR_FILENO))
 800a664:	3801      	subs	r0, #1
 800a666:	2801      	cmp	r0, #1
{
 800a668:	b510      	push	{r4, lr}
 800a66a:	4614      	mov	r4, r2
	if ((file != STDOUT_FILENO) && (file != STDERR_FILENO))
 800a66c:	d907      	bls.n	800a67e <_write+0x1a>
	{
		errno = EBADF;
 800a66e:	f002 faf1 	bl	800cc54 <__errno>
 800a672:	2309      	movs	r3, #9
 800a674:	6003      	str	r3, [r0, #0]
		return -1;
 800a676:	f04f 34ff 	mov.w	r4, #4294967295
	// arbitrary timeout 1000
	HAL_StatusTypeDef status = HAL_UART_Transmit(&hlpuart1, (uint8_t*) data, len, 1000);

	// return # of bytes written - as best we can tell
	return (status == HAL_OK ? len : 0);
}
 800a67a:	4620      	mov	r0, r4
 800a67c:	bd10      	pop	{r4, pc}
	HAL_StatusTypeDef status = HAL_UART_Transmit(&hlpuart1, (uint8_t*) data, len, 1000);
 800a67e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 800a682:	b292      	uxth	r2, r2
 800a684:	4803      	ldr	r0, [pc, #12]	; (800a694 <_write+0x30>)
 800a686:	f7fa f984 	bl	8004992 <HAL_UART_Transmit>
	return (status == HAL_OK ? len : 0);
 800a68a:	2800      	cmp	r0, #0
 800a68c:	bf18      	it	ne
 800a68e:	2400      	movne	r4, #0
 800a690:	e7f3      	b.n	800a67a <_write+0x16>
 800a692:	bf00      	nop
 800a694:	2000c5c0 	.word	0x2000c5c0

0800a698 <debugPrint>:

/* Print to computer (HAL) without the need of \r\n */
void debugPrint(UART_HandleTypeDef *huart, char _out[])
{
 800a698:	b570      	push	{r4, r5, r6, lr}
 800a69a:	4605      	mov	r5, r0
	HAL_UART_Transmit(huart, (uint8_t*) _out, strlen(_out), 10);
 800a69c:	4608      	mov	r0, r1
{
 800a69e:	460c      	mov	r4, r1
	HAL_UART_Transmit(huart, (uint8_t*) _out, strlen(_out), 10);
 800a6a0:	f7f5 fda8 	bl	80001f4 <strlen>
 800a6a4:	4621      	mov	r1, r4
 800a6a6:	b282      	uxth	r2, r0
 800a6a8:	230a      	movs	r3, #10
 800a6aa:	4628      	mov	r0, r5
}
 800a6ac:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	HAL_UART_Transmit(huart, (uint8_t*) _out, strlen(_out), 10);
 800a6b0:	f7fa b96f 	b.w	8004992 <HAL_UART_Transmit>

0800a6b4 <MX_LPUART1_UART_DeInit>:

void MX_LPUART1_UART_DeInit(void)
{
	HAL_UART_DeInit(&hlpuart1);
 800a6b4:	4801      	ldr	r0, [pc, #4]	; (800a6bc <MX_LPUART1_UART_DeInit+0x8>)
 800a6b6:	f7f9 bf4b 	b.w	8004550 <HAL_UART_DeInit>
 800a6ba:	bf00      	nop
 800a6bc:	2000c5c0 	.word	0x2000c5c0

0800a6c0 <StartTurnOffCounter>:
	return radioState = rState;
}

/* Sometimes the Sara module gets an error while turning off and gets stuck in while-loop, this is the startTimer for breaking */
static void StartTurnOffCounter(void)
{
 800a6c0:	b508      	push	{r3, lr}
	GetTime(GetTimeStruct(turnOffStartVal));
 800a6c2:	2006      	movs	r0, #6
 800a6c4:	f7fe fcf6 	bl	80090b4 <GetTimeStruct>
}
 800a6c8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	GetTime(GetTimeStruct(turnOffStartVal));
 800a6cc:	f002 b986 	b.w	800c9dc <GetTime>

0800a6d0 <CompareTurnOffTimers>:

/* Checks if Sara module has tried to turn off for more than X sec */
static uint8_t CompareTurnOffTimers(void)
{
 800a6d0:	b510      	push	{r4, lr}
	/* Gets what time it is now */
	GetTime(GetTimeStruct(turnOffEndVal));
 800a6d2:	2007      	movs	r0, #7
 800a6d4:	f7fe fcee 	bl	80090b4 <GetTimeStruct>
 800a6d8:	f002 f980 	bl	800c9dc <GetTime>

	/* Compares to startTimer and checks if the diff is more than X sec */
	if (abs(
			RTC_GetElapsedSeconds(
 800a6dc:	2006      	movs	r0, #6
 800a6de:	f7fe fce9 	bl	80090b4 <GetTimeStruct>
 800a6e2:	4604      	mov	r4, r0
 800a6e4:	2007      	movs	r0, #7
 800a6e6:	f7fe fce5 	bl	80090b4 <GetTimeStruct>
 800a6ea:	4601      	mov	r1, r0
 800a6ec:	4620      	mov	r0, r4
 800a6ee:	f002 f92f 	bl	800c950 <RTC_GetElapsedSeconds>
	if (abs(
 800a6f2:	2800      	cmp	r0, #0
 800a6f4:	bfb8      	it	lt
 800a6f6:	4240      	neglt	r0, r0
					GetTimeStruct(turnOffEndVal))) > POWEROFF_TIMEOUT)
	{
		return true;
	}
	return false;
}
 800a6f8:	2805      	cmp	r0, #5
 800a6fa:	bfd4      	ite	le
 800a6fc:	2000      	movle	r0, #0
 800a6fe:	2001      	movgt	r0, #1
 800a700:	bd10      	pop	{r4, pc}

0800a702 <ResetRadio>:

/* If the radio has tried turning off for more than X sec, reset and turn off */
static uint8_t ResetRadio(void)
{
 800a702:	b508      	push	{r3, lr}
	/* Reboot the Sara module */
	if (StartUpSara())
 800a704:	f001 f9d6 	bl	800bab4 <StartUpSara>
 800a708:	b908      	cbnz	r0, 800a70e <ResetRadio+0xc>
			{
				return true;
			}
		}
	}
	return false;
 800a70a:	2000      	movs	r0, #0
 800a70c:	bd08      	pop	{r3, pc}
		if (SaraInitAtCommands())
 800a70e:	f001 fa37 	bl	800bb80 <SaraInitAtCommands>
 800a712:	2800      	cmp	r0, #0
 800a714:	d0f9      	beq.n	800a70a <ResetRadio+0x8>
			if (SaraPowerDown())
 800a716:	f001 fa07 	bl	800bb28 <SaraPowerDown>
	return false;
 800a71a:	3000      	adds	r0, #0
 800a71c:	bf18      	it	ne
 800a71e:	2001      	movne	r0, #1
}
 800a720:	bd08      	pop	{r3, pc}
	...

0800a724 <SetSensorState>:
	return sensorState = sState;
 800a724:	4b01      	ldr	r3, [pc, #4]	; (800a72c <SetSensorState+0x8>)
 800a726:	7018      	strb	r0, [r3, #0]
}
 800a728:	4770      	bx	lr
 800a72a:	bf00      	nop
 800a72c:	2000029a 	.word	0x2000029a

0800a730 <SetRadioState>:
	return radioState = rState;
 800a730:	4b01      	ldr	r3, [pc, #4]	; (800a738 <SetRadioState+0x8>)
 800a732:	7018      	strb	r0, [r3, #0]
}
 800a734:	4770      	bx	lr
 800a736:	bf00      	nop
 800a738:	20000028 	.word	0x20000028

0800a73c <RadioResetState>:

/* Reset Radio state to idle */
void RadioResetState(Error *er, Data *data)
{
 800a73c:	b5f0      	push	{r4, r5, r6, r7, lr}
 800a73e:	b085      	sub	sp, #20
 800a740:	4605      	mov	r5, r0
	/* Resets Watchdog, safety measure due to the radio can take long time in certain scenarios */
	ResetIWDG();
 800a742:	f7ff fc87 	bl	800a054 <ResetIWDG>

	/* Want to have todays data fail */
	CopyTempToInfo();
 800a746:	f001 fe51 	bl	800c3ec <CopyTempToInfo>

	/* Start counter that evaluates how long it takes to turn off */
	StartTurnOffCounter();
 800a74a:	f7ff ffb9 	bl	800a6c0 <StartTurnOffCounter>

	/* Raise error radio flag and start timer */
	ErrorTimerHourly(GetErrorTimerStruct(startTimerEnum), GetErrorFlagsStruct());
 800a74e:	2000      	movs	r0, #0
 800a750:	f7fe fce0 	bl	8009114 <GetErrorTimerStruct>
 800a754:	4604      	mov	r4, r0
 800a756:	f7fe fcd9 	bl	800910c <GetErrorFlagsStruct>
 800a75a:	4601      	mov	r1, r0
 800a75c:	4620      	mov	r0, r4
 800a75e:	f001 ff03 	bl	800c568 <ErrorTimerHourly>

	/* Shut down Sara module */
	while (!SaraPowerDown())
 800a762:	f001 f9e1 	bl	800bb28 <SaraPowerDown>
 800a766:	b938      	cbnz	r0, 800a778 <RadioResetState+0x3c>
	{
		/* Compare the turn off counter with the start value */
		if (CompareTurnOffTimers())
 800a768:	f7ff ffb2 	bl	800a6d0 <CompareTurnOffTimers>
 800a76c:	2800      	cmp	r0, #0
 800a76e:	d0f8      	beq.n	800a762 <RadioResetState+0x26>
		{
			/* Hard reset of the radio */
			if (ResetRadio())
 800a770:	f7ff ffc7 	bl	800a702 <ResetRadio>
 800a774:	2800      	cmp	r0, #0
 800a776:	d0f4      	beq.n	800a762 <RadioResetState+0x26>
				break;
			}
		}
	}

	radioFlags *rE = GetErrorFlagsStruct();
 800a778:	f7fe fcc8 	bl	800910c <GetErrorFlagsStruct>
 800a77c:	4607      	mov	r7, r0

	Info *info = GetInfoStruct();
 800a77e:	f7fe fc91 	bl	80090a4 <GetInfoStruct>

	/* Resets potential parameters */
	rE->alreadyConnected = 0;
 800a782:	2400      	movs	r4, #0
 800a784:	76bc      	strb	r4, [r7, #26]
	rE->trySubscribeAgain = 0;
 800a786:	773c      	strb	r4, [r7, #28]
	Info *info = GetInfoStruct();
 800a788:	4606      	mov	r6, r0

	/* Enable SD card so that one can write to SD */
	EnableSD_Card();
 800a78a:	f7fd f9b7 	bl	8007afc <EnableSD_Card>

	/* If any errors have occured */
	if (er->errorCounter > 0)
 800a78e:	f8b5 3258 	ldrh.w	r3, [r5, #600]	; 0x258
 800a792:	b12b      	cbz	r3, 800a7a0 <RadioResetState+0x64>
	{
		/* Try to write to SD card */
		if (SDwriteErrorLog(er) == HAL_OK)
 800a794:	4628      	mov	r0, r5
 800a796:	f7fd fac9 	bl	8007d2c <SDwriteErrorLog>
 800a79a:	b9c0      	cbnz	r0, 800a7ce <RadioResetState+0x92>
		{
			/* If successful, reset counter */
			er->errorCounter = 0;
 800a79c:	f8a5 0258 	strh.w	r0, [r5, #600]	; 0x258
			LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
		}
	}

	/* If there is any Info in the InfoLog (which there will be in case of failure) */
	if (info->infoCounter > 0)
 800a7a0:	f642 63e0 	movw	r3, #12000	; 0x2ee0
 800a7a4:	5af3      	ldrh	r3, [r6, r3]
 800a7a6:	b15b      	cbz	r3, 800a7c0 <RadioResetState+0x84>
	{
		/* Write to SD card */
		if (SD_WriteInfoLog(info) == HAL_OK)
 800a7a8:	4630      	mov	r0, r6
 800a7aa:	f7fd fa59 	bl	8007c60 <SD_WriteInfoLog>
 800a7ae:	b938      	cbnz	r0, 800a7c0 <RadioResetState+0x84>
		{
			/* Reset all InfoStructs */
			ResetInfoStruct(GetInfoStruct());
 800a7b0:	f7fe fc78 	bl	80090a4 <GetInfoStruct>
 800a7b4:	f001 fda9 	bl	800c30a <ResetInfoStruct>
			ResetInfoStruct(GetTempInfoStruct());
 800a7b8:	f7fe fc78 	bl	80090ac <GetTempInfoStruct>
 800a7bc:	f001 fda5 	bl	800c30a <ResetInfoStruct>
		}
	}

	/* Turn off SD card */
	DisableSD_Card();
 800a7c0:	f7fe fcb4 	bl	800912c <DisableSD_Card>
	return radioState = rState;
 800a7c4:	4b08      	ldr	r3, [pc, #32]	; (800a7e8 <RadioResetState+0xac>)
 800a7c6:	2200      	movs	r2, #0
 800a7c8:	701a      	strb	r2, [r3, #0]

	/* Reset stage of Sara */
	SetRadioState(RADIO_IDLE);
}
 800a7ca:	b005      	add	sp, #20
 800a7cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
			ErrorAddLog(LOG_FUNC_MAIN, LOG_SUB_WRITE_ERROR,
 800a7ce:	f7fe fc65 	bl	800909c <GetErrorStruct>
 800a7d2:	9402      	str	r4, [sp, #8]
 800a7d4:	9003      	str	r0, [sp, #12]
 800a7d6:	9401      	str	r4, [sp, #4]
 800a7d8:	9400      	str	r4, [sp, #0]
 800a7da:	2311      	movs	r3, #17
 800a7dc:	2215      	movs	r2, #21
 800a7de:	2120      	movs	r1, #32
 800a7e0:	201a      	movs	r0, #26
 800a7e2:	f001 fd59 	bl	800c298 <ErrorAddLog>
 800a7e6:	e7db      	b.n	800a7a0 <RadioResetState+0x64>
 800a7e8:	20000028 	.word	0x20000028

0800a7ec <RadioFirstRunFinished>:

/* First run of the Radio is finished */
void RadioFirstRunFinished(void)
{
 800a7ec:	b538      	push	{r3, r4, r5, lr}
	SaraConfig *sC = GetSaraConfigurationStruct();
 800a7ee:	f7fe fc89 	bl	8009104 <GetSaraConfigurationStruct>
 800a7f2:	4605      	mov	r5, r0

	radioFlags *rE = GetErrorFlagsStruct();
 800a7f4:	f7fe fc8a 	bl	800910c <GetErrorFlagsStruct>
 800a7f8:	4604      	mov	r4, r0

	/* Set alarm for wakeup */
	RTC_SetAlarm(sC->updateFrequency);
 800a7fa:	f8d5 0080 	ldr.w	r0, [r5, #128]	; 0x80
 800a7fe:	f7ff fd77 	bl	800a2f0 <RTC_SetAlarm>
	return radioState = rState;
 800a802:	4b06      	ldr	r3, [pc, #24]	; (800a81c <RadioFirstRunFinished+0x30>)

	/* Initialize sensors */
	SetSensorState(SENSOR_AWAKE);

	/* Debug message */
	debugPrint(&hlpuart1, "f");
 800a804:	4906      	ldr	r1, [pc, #24]	; (800a820 <RadioFirstRunFinished+0x34>)
 800a806:	4807      	ldr	r0, [pc, #28]	; (800a824 <RadioFirstRunFinished+0x38>)
	return radioState = rState;
 800a808:	220e      	movs	r2, #14
 800a80a:	701a      	strb	r2, [r3, #0]
	return sensorState = sState;
 800a80c:	4b06      	ldr	r3, [pc, #24]	; (800a828 <RadioFirstRunFinished+0x3c>)
 800a80e:	2201      	movs	r2, #1
 800a810:	701a      	strb	r2, [r3, #0]
	debugPrint(&hlpuart1, "f");
 800a812:	f7ff ff41 	bl	800a698 <debugPrint>

	/* First run finished */
	rE->firstRun = 0;
 800a816:	2300      	movs	r3, #0
 800a818:	74e3      	strb	r3, [r4, #19]
 800a81a:	bd38      	pop	{r3, r4, r5, pc}
 800a81c:	20000028 	.word	0x20000028
 800a820:	0801008d 	.word	0x0801008d
 800a824:	2000c5c0 	.word	0x2000c5c0
 800a828:	2000029a 	.word	0x2000029a

0800a82c <RadioStateMachine>:
	}
}

/* RadioStateMachine, now contains some debugPrints that should be removed in the end //TODO */
void RadioStateMachine(Data *data, Error *er)
{
 800a82c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return radioState;
 800a830:	f8df 82f4 	ldr.w	r8, [pc, #756]	; 800ab28 <RadioStateMachine+0x2fc>
 800a834:	f898 4000 	ldrb.w	r4, [r8]
{
 800a838:	b0c6      	sub	sp, #280	; 0x118
 800a83a:	4607      	mov	r7, r0
 800a83c:	460e      	mov	r6, r1
 800a83e:	4645      	mov	r5, r8
	/* Get current radio state */
	RadioStates rS = GetRadioState();

	/* Idle stage, do nothing */
	if (rS == RADIO_IDLE)
 800a840:	b9cc      	cbnz	r4, 800a876 <RadioStateMachine+0x4a>
	printf("IDLESTATE\r\n");
 800a842:	48b3      	ldr	r0, [pc, #716]	; (800ab10 <RadioStateMachine+0x2e4>)
 800a844:	f002 fdf2 	bl	800d42c <puts>
	TimeToSend(GetTimeStruct(SaraLastConnectedVal), &endTimeToSend, data);
 800a848:	4620      	mov	r0, r4
 800a84a:	f7fe fc33 	bl	80090b4 <GetTimeStruct>
 800a84e:	463a      	mov	r2, r7
 800a850:	a906      	add	r1, sp, #24
 800a852:	f002 f8eb 	bl	800ca2c <TimeToSend>
	InfoLogAdd(
 800a856:	f7fe fc29 	bl	80090ac <GetTempInfoStruct>
 800a85a:	2311      	movs	r3, #17
 800a85c:	9004      	str	r0, [sp, #16]
 800a85e:	2012      	movs	r0, #18
 800a860:	9403      	str	r4, [sp, #12]
 800a862:	9402      	str	r4, [sp, #8]
 800a864:	9401      	str	r4, [sp, #4]
 800a866:	9000      	str	r0, [sp, #0]
 800a868:	461a      	mov	r2, r3
	InfoLogAdd(ERRORLEVEL_INFO,
 800a86a:	211b      	movs	r1, #27
 800a86c:	f001 fd64 	bl	800c338 <InfoLogAdd>
	/* Check state of V_INT Pin */
	else if (rS == RADIO_CHECKPOWER)
	{
		RadioCheckpowerState();
	}
}
 800a870:	b046      	add	sp, #280	; 0x118
 800a872:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (rS == RADIO_AWAKE)
 800a876:	2c01      	cmp	r4, #1
 800a878:	d119      	bne.n	800a8ae <RadioStateMachine+0x82>
	MX_USART2_UART_Init();
 800a87a:	f7ff fe73 	bl	800a564 <MX_USART2_UART_Init>
	MX_LPTIM1_Init();
 800a87e:	f7ff fc29 	bl	800a0d4 <MX_LPTIM1_Init>
	EnableSD_Card();
 800a882:	f7fd f93b 	bl	8007afc <EnableSD_Card>
	SDWriteSensorData(data);
 800a886:	4638      	mov	r0, r7
 800a888:	f7fd f96c 	bl	8007b64 <SDWriteSensorData>
	DisableSD_Card();
 800a88c:	f7fe fc4e 	bl	800912c <DisableSD_Card>
	return radioState = rState;
 800a890:	2302      	movs	r3, #2
 800a892:	f888 3000 	strb.w	r3, [r8]
	InfoLogAdd(ERRORLEVEL_INFO,
 800a896:	f7fe fc09 	bl	80090ac <GetTempInfoStruct>
 800a89a:	2300      	movs	r3, #0
 800a89c:	9004      	str	r0, [sp, #16]
 800a89e:	2012      	movs	r0, #18
 800a8a0:	9303      	str	r3, [sp, #12]
 800a8a2:	9302      	str	r3, [sp, #8]
 800a8a4:	9301      	str	r3, [sp, #4]
 800a8a6:	9000      	str	r0, [sp, #0]
 800a8a8:	2311      	movs	r3, #17
 800a8aa:	2238      	movs	r2, #56	; 0x38
 800a8ac:	e7dd      	b.n	800a86a <RadioStateMachine+0x3e>
	else if (rS == RADIO_STARTUP)
 800a8ae:	2c02      	cmp	r4, #2
 800a8b0:	d15f      	bne.n	800a972 <RadioStateMachine+0x146>
		RadioStartupState(data, er, GetErrorFlagsStruct());
 800a8b2:	f7fe fc2b 	bl	800910c <GetErrorFlagsStruct>
 800a8b6:	4605      	mov	r5, r0
	if (StartUpSara())
 800a8b8:	f001 f8fc 	bl	800bab4 <StartUpSara>
 800a8bc:	4604      	mov	r4, r0
 800a8be:	b198      	cbz	r0, 800a8e8 <RadioStateMachine+0xbc>
	return radioState = rState;
 800a8c0:	2303      	movs	r3, #3
		rE->startUpError = 0;
 800a8c2:	2400      	movs	r4, #0
		debugPrint(&hlpuart1, "."); //TODO
 800a8c4:	4993      	ldr	r1, [pc, #588]	; (800ab14 <RadioStateMachine+0x2e8>)
 800a8c6:	4894      	ldr	r0, [pc, #592]	; (800ab18 <RadioStateMachine+0x2ec>)
	return radioState = rState;
 800a8c8:	f888 3000 	strb.w	r3, [r8]
		debugPrint(&hlpuart1, "."); //TODO
 800a8cc:	f7ff fee4 	bl	800a698 <debugPrint>
		rE->startUpError = 0;
 800a8d0:	736c      	strb	r4, [r5, #13]
		InfoLogAdd(ERRORLEVEL_INFO,
 800a8d2:	f7fe fbeb 	bl	80090ac <GetTempInfoStruct>
 800a8d6:	9004      	str	r0, [sp, #16]
 800a8d8:	2012      	movs	r0, #18
 800a8da:	9403      	str	r4, [sp, #12]
 800a8dc:	9402      	str	r4, [sp, #8]
 800a8de:	9401      	str	r4, [sp, #4]
 800a8e0:	9000      	str	r0, [sp, #0]
 800a8e2:	2316      	movs	r3, #22
 800a8e4:	2227      	movs	r2, #39	; 0x27
 800a8e6:	e7c0      	b.n	800a86a <RadioStateMachine+0x3e>
		rE->startUpError++;
 800a8e8:	7b6b      	ldrb	r3, [r5, #13]
 800a8ea:	3301      	adds	r3, #1
 800a8ec:	736b      	strb	r3, [r5, #13]
		InfoLogAdd(ERRORLEVEL_INFO,
 800a8ee:	f7fe fbdd 	bl	80090ac <GetTempInfoStruct>
 800a8f2:	f04f 0811 	mov.w	r8, #17
 800a8f6:	9004      	str	r0, [sp, #16]
 800a8f8:	2316      	movs	r3, #22
 800a8fa:	9403      	str	r4, [sp, #12]
 800a8fc:	9402      	str	r4, [sp, #8]
 800a8fe:	9401      	str	r4, [sp, #4]
 800a900:	f8cd 8000 	str.w	r8, [sp]
 800a904:	2227      	movs	r2, #39	; 0x27
 800a906:	211b      	movs	r1, #27
 800a908:	2012      	movs	r0, #18
 800a90a:	f001 fd15 	bl	800c338 <InfoLogAdd>
		if (rE->startUpError == MAX_FAILED_ATTEMPTS)
 800a90e:	7b6b      	ldrb	r3, [r5, #13]
 800a910:	2b03      	cmp	r3, #3
 800a912:	d1ad      	bne.n	800a870 <RadioStateMachine+0x44>
			InfoLogAdd(ERRORLEVEL_HIGH,
 800a914:	f7fe fbca 	bl	80090ac <GetTempInfoStruct>
 800a918:	2316      	movs	r3, #22
 800a91a:	2227      	movs	r2, #39	; 0x27
 800a91c:	211b      	movs	r1, #27
 800a91e:	9004      	str	r0, [sp, #16]
 800a920:	9403      	str	r4, [sp, #12]
 800a922:	4618      	mov	r0, r3
 800a924:	9402      	str	r4, [sp, #8]
 800a926:	9401      	str	r4, [sp, #4]
 800a928:	f8cd 8000 	str.w	r8, [sp]
 800a92c:	f001 fd04 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(
 800a930:	f7fe fbb4 	bl	800909c <GetErrorStruct>
 800a934:	4643      	mov	r3, r8
 800a936:	9003      	str	r0, [sp, #12]
 800a938:	9402      	str	r4, [sp, #8]
 800a93a:	9401      	str	r4, [sp, #4]
 800a93c:	9400      	str	r4, [sp, #0]
 800a93e:	2216      	movs	r2, #22
 800a940:	2127      	movs	r1, #39	; 0x27
 800a942:	201b      	movs	r0, #27
 800a944:	f001 fca8 	bl	800c298 <ErrorAddLog>
			if (rE->firstRun == 0)
 800a948:	7ceb      	ldrb	r3, [r5, #19]
 800a94a:	b953      	cbnz	r3, 800a962 <RadioStateMachine+0x136>
				RadioResetState(er, data);
 800a94c:	4639      	mov	r1, r7
 800a94e:	4630      	mov	r0, r6
 800a950:	f7ff fef4 	bl	800a73c <RadioResetState>
			rE->startUpError = 0;
 800a954:	2300      	movs	r3, #0
 800a956:	736b      	strb	r3, [r5, #13]
			debugPrint(&hlpuart1, "2"); //TODO
 800a958:	4970      	ldr	r1, [pc, #448]	; (800ab1c <RadioStateMachine+0x2f0>)
 800a95a:	486f      	ldr	r0, [pc, #444]	; (800ab18 <RadioStateMachine+0x2ec>)
 800a95c:	f7ff fe9c 	bl	800a698 <debugPrint>
 800a960:	e786      	b.n	800a870 <RadioStateMachine+0x44>
				InitTimeStruct(GetTimeStruct(SaraLastConnectedVal));
 800a962:	4620      	mov	r0, r4
 800a964:	f7fe fba6 	bl	80090b4 <GetTimeStruct>
 800a968:	f001 fae2 	bl	800bf30 <InitTimeStruct>
				RadioFirstRunFinished();
 800a96c:	f7ff ff3e 	bl	800a7ec <RadioFirstRunFinished>
 800a970:	e7f0      	b.n	800a954 <RadioStateMachine+0x128>
	else if (rS == RADIO_INIT)
 800a972:	2c03      	cmp	r4, #3
 800a974:	d164      	bne.n	800aa40 <RadioStateMachine+0x214>
		RadioInitState(data, er, GetErrorFlagsStruct());
 800a976:	f7fe fbc9 	bl	800910c <GetErrorFlagsStruct>
 800a97a:	4605      	mov	r5, r0
	if (SaraInitAtCommands())
 800a97c:	f001 f900 	bl	800bb80 <SaraInitAtCommands>
 800a980:	4604      	mov	r4, r0
 800a982:	b1d8      	cbz	r0, 800a9bc <RadioStateMachine+0x190>
		rE->AtInit = 0;
 800a984:	2400      	movs	r4, #0
		debugPrint(&hlpuart1, "."); //TODO
 800a986:	4963      	ldr	r1, [pc, #396]	; (800ab14 <RadioStateMachine+0x2e8>)
 800a988:	4863      	ldr	r0, [pc, #396]	; (800ab18 <RadioStateMachine+0x2ec>)
 800a98a:	f7ff fe85 	bl	800a698 <debugPrint>
	return radioState = rState;
 800a98e:	2304      	movs	r3, #4
		rE->AtInit = 0;
 800a990:	73ac      	strb	r4, [r5, #14]
	return radioState = rState;
 800a992:	f888 3000 	strb.w	r3, [r8]
		InfoLogAdd(ERRORLEVEL_INFO,
 800a996:	f7fe fb89 	bl	80090ac <GetTempInfoStruct>
 800a99a:	9004      	str	r0, [sp, #16]
 800a99c:	2012      	movs	r0, #18
 800a99e:	9000      	str	r0, [sp, #0]
 800a9a0:	2320      	movs	r3, #32
 800a9a2:	2227      	movs	r2, #39	; 0x27
 800a9a4:	211b      	movs	r1, #27
 800a9a6:	9403      	str	r4, [sp, #12]
 800a9a8:	9402      	str	r4, [sp, #8]
 800a9aa:	9401      	str	r4, [sp, #4]
 800a9ac:	f001 fcc4 	bl	800c338 <InfoLogAdd>
		GetTime(GetTimeStruct(networkStartVal));
 800a9b0:	2002      	movs	r0, #2
 800a9b2:	f7fe fb7f 	bl	80090b4 <GetTimeStruct>
 800a9b6:	f002 f811 	bl	800c9dc <GetTime>
 800a9ba:	e759      	b.n	800a870 <RadioStateMachine+0x44>
		rE->AtInit++;
 800a9bc:	7bab      	ldrb	r3, [r5, #14]
 800a9be:	3301      	adds	r3, #1
 800a9c0:	73ab      	strb	r3, [r5, #14]
		InfoLogAdd(ERRORLEVEL_INFO,
 800a9c2:	f7fe fb73 	bl	80090ac <GetTempInfoStruct>
 800a9c6:	f04f 0811 	mov.w	r8, #17
 800a9ca:	9004      	str	r0, [sp, #16]
 800a9cc:	2320      	movs	r3, #32
 800a9ce:	9403      	str	r4, [sp, #12]
 800a9d0:	9402      	str	r4, [sp, #8]
 800a9d2:	9401      	str	r4, [sp, #4]
 800a9d4:	f8cd 8000 	str.w	r8, [sp]
 800a9d8:	2227      	movs	r2, #39	; 0x27
 800a9da:	211b      	movs	r1, #27
 800a9dc:	2012      	movs	r0, #18
 800a9de:	f001 fcab 	bl	800c338 <InfoLogAdd>
		if (rE->AtInit == MAX_FAILED_ATTEMPTS)
 800a9e2:	7bab      	ldrb	r3, [r5, #14]
 800a9e4:	2b03      	cmp	r3, #3
 800a9e6:	f47f af43 	bne.w	800a870 <RadioStateMachine+0x44>
			InfoLogAdd(ERRORLEVEL_HIGH,
 800a9ea:	f7fe fb5f 	bl	80090ac <GetTempInfoStruct>
 800a9ee:	2320      	movs	r3, #32
 800a9f0:	9004      	str	r0, [sp, #16]
 800a9f2:	9403      	str	r4, [sp, #12]
 800a9f4:	9402      	str	r4, [sp, #8]
 800a9f6:	9401      	str	r4, [sp, #4]
 800a9f8:	f8cd 8000 	str.w	r8, [sp]
 800a9fc:	2227      	movs	r2, #39	; 0x27
 800a9fe:	211b      	movs	r1, #27
 800aa00:	2016      	movs	r0, #22
 800aa02:	f001 fc99 	bl	800c338 <InfoLogAdd>
			if (rE->firstRun == 0)
 800aa06:	7ceb      	ldrb	r3, [r5, #19]
 800aa08:	b993      	cbnz	r3, 800aa30 <RadioStateMachine+0x204>
				RadioResetState(er, data);
 800aa0a:	4639      	mov	r1, r7
 800aa0c:	4630      	mov	r0, r6
 800aa0e:	f7ff fe95 	bl	800a73c <RadioResetState>
			ErrorAddLog(
 800aa12:	f7fe fb43 	bl	800909c <GetErrorStruct>
 800aa16:	2400      	movs	r4, #0
 800aa18:	9003      	str	r0, [sp, #12]
 800aa1a:	9402      	str	r4, [sp, #8]
 800aa1c:	9401      	str	r4, [sp, #4]
 800aa1e:	9400      	str	r4, [sp, #0]
 800aa20:	2311      	movs	r3, #17
 800aa22:	2220      	movs	r2, #32
 800aa24:	2127      	movs	r1, #39	; 0x27
 800aa26:	201b      	movs	r0, #27
 800aa28:	f001 fc36 	bl	800c298 <ErrorAddLog>
			rE->AtInit = 0;
 800aa2c:	73ac      	strb	r4, [r5, #14]
 800aa2e:	e793      	b.n	800a958 <RadioStateMachine+0x12c>
				InitTimeStruct(GetTimeStruct(SaraLastConnectedVal));
 800aa30:	4620      	mov	r0, r4
 800aa32:	f7fe fb3f 	bl	80090b4 <GetTimeStruct>
 800aa36:	f001 fa7b 	bl	800bf30 <InitTimeStruct>
				RadioFirstRunFinished();
 800aa3a:	f7ff fed7 	bl	800a7ec <RadioFirstRunFinished>
 800aa3e:	e7e8      	b.n	800aa12 <RadioStateMachine+0x1e6>
	else if (rS == RADIO_NETWORK)
 800aa40:	2c04      	cmp	r4, #4
 800aa42:	d173      	bne.n	800ab2c <RadioStateMachine+0x300>
		RadioNetworkState(data, er, GetErrorFlagsStruct());
 800aa44:	f7fe fb62 	bl	800910c <GetErrorFlagsStruct>
	if (SaraCheckCommand("AT+CEREG?\r\n", "+CEREG: 0,1OK", LOW_TIMEOUT))
 800aa48:	220a      	movs	r2, #10
		RadioNetworkState(data, er, GetErrorFlagsStruct());
 800aa4a:	4681      	mov	r9, r0
	if (SaraCheckCommand("AT+CEREG?\r\n", "+CEREG: 0,1OK", LOW_TIMEOUT))
 800aa4c:	4934      	ldr	r1, [pc, #208]	; (800ab20 <RadioStateMachine+0x2f4>)
 800aa4e:	4835      	ldr	r0, [pc, #212]	; (800ab24 <RadioStateMachine+0x2f8>)
 800aa50:	f001 f802 	bl	800ba58 <SaraCheckCommand>
 800aa54:	4604      	mov	r4, r0
 800aa56:	b1a8      	cbz	r0, 800aa84 <RadioStateMachine+0x258>
		debugPrint(&hlpuart1, "."); //TODO
 800aa58:	492e      	ldr	r1, [pc, #184]	; (800ab14 <RadioStateMachine+0x2e8>)
 800aa5a:	482f      	ldr	r0, [pc, #188]	; (800ab18 <RadioStateMachine+0x2ec>)
 800aa5c:	f7ff fe1c 	bl	800a698 <debugPrint>
		InfoLogAdd(ERRORLEVEL_INFO,
 800aa60:	f7fe fb24 	bl	80090ac <GetTempInfoStruct>
 800aa64:	2300      	movs	r3, #0
 800aa66:	9004      	str	r0, [sp, #16]
 800aa68:	2012      	movs	r0, #18
 800aa6a:	9303      	str	r3, [sp, #12]
 800aa6c:	9302      	str	r3, [sp, #8]
 800aa6e:	9301      	str	r3, [sp, #4]
 800aa70:	9000      	str	r0, [sp, #0]
 800aa72:	2326      	movs	r3, #38	; 0x26
 800aa74:	2229      	movs	r2, #41	; 0x29
 800aa76:	211b      	movs	r1, #27
 800aa78:	f001 fc5e 	bl	800c338 <InfoLogAdd>
	return radioState = rState;
 800aa7c:	2305      	movs	r3, #5
 800aa7e:	f888 3000 	strb.w	r3, [r8]
 800aa82:	e6f5      	b.n	800a870 <RadioStateMachine+0x44>
		GetTime(GetTimeStruct(networkEndVal));
 800aa84:	2003      	movs	r0, #3
 800aa86:	f7fe fb15 	bl	80090b4 <GetTimeStruct>
 800aa8a:	f001 ffa7 	bl	800c9dc <GetTime>
				RTC_GetElapsedSeconds(
 800aa8e:	2002      	movs	r0, #2
 800aa90:	f7fe fb10 	bl	80090b4 <GetTimeStruct>
 800aa94:	4605      	mov	r5, r0
 800aa96:	2003      	movs	r0, #3
 800aa98:	f7fe fb0c 	bl	80090b4 <GetTimeStruct>
 800aa9c:	4601      	mov	r1, r0
 800aa9e:	4628      	mov	r0, r5
 800aaa0:	f001 ff56 	bl	800c950 <RTC_GetElapsedSeconds>
		if (abs(
 800aaa4:	2800      	cmp	r0, #0
 800aaa6:	bfb8      	it	lt
 800aaa8:	4240      	neglt	r0, r0
 800aaaa:	f5b0 7f96 	cmp.w	r0, #300	; 0x12c
 800aaae:	f77f aedf 	ble.w	800a870 <RadioStateMachine+0x44>
			InfoLogAdd(ERRORLEVEL_HIGH,
 800aab2:	f7fe fafb 	bl	80090ac <GetTempInfoStruct>
 800aab6:	2511      	movs	r5, #17
 800aab8:	2326      	movs	r3, #38	; 0x26
 800aaba:	2229      	movs	r2, #41	; 0x29
 800aabc:	211b      	movs	r1, #27
 800aabe:	9004      	str	r0, [sp, #16]
 800aac0:	9403      	str	r4, [sp, #12]
 800aac2:	2016      	movs	r0, #22
 800aac4:	9402      	str	r4, [sp, #8]
 800aac6:	9401      	str	r4, [sp, #4]
 800aac8:	9500      	str	r5, [sp, #0]
 800aaca:	f001 fc35 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(
 800aace:	f7fe fae5 	bl	800909c <GetErrorStruct>
 800aad2:	462b      	mov	r3, r5
 800aad4:	9003      	str	r0, [sp, #12]
 800aad6:	2217      	movs	r2, #23
 800aad8:	2129      	movs	r1, #41	; 0x29
 800aada:	201b      	movs	r0, #27
 800aadc:	9402      	str	r4, [sp, #8]
 800aade:	9401      	str	r4, [sp, #4]
 800aae0:	9400      	str	r4, [sp, #0]
 800aae2:	f001 fbd9 	bl	800c298 <ErrorAddLog>
			debugPrint(&hlpuart1, "2"); //TODO
 800aae6:	490d      	ldr	r1, [pc, #52]	; (800ab1c <RadioStateMachine+0x2f0>)
 800aae8:	480b      	ldr	r0, [pc, #44]	; (800ab18 <RadioStateMachine+0x2ec>)
 800aaea:	f7ff fdd5 	bl	800a698 <debugPrint>
			if (rE->firstRun == 0)
 800aaee:	f899 3013 	ldrb.w	r3, [r9, #19]
 800aaf2:	b923      	cbnz	r3, 800aafe <RadioStateMachine+0x2d2>
			RadioResetState(er, data);
 800aaf4:	4639      	mov	r1, r7
 800aaf6:	4630      	mov	r0, r6
 800aaf8:	f7ff fe20 	bl	800a73c <RadioResetState>
 800aafc:	e6b8      	b.n	800a870 <RadioStateMachine+0x44>
				InitTimeStruct(GetTimeStruct(SaraLastConnectedVal));
 800aafe:	4620      	mov	r0, r4
 800ab00:	f7fe fad8 	bl	80090b4 <GetTimeStruct>
 800ab04:	f001 fa14 	bl	800bf30 <InitTimeStruct>
			RadioFirstRunFinished();
 800ab08:	f7ff fe70 	bl	800a7ec <RadioFirstRunFinished>
 800ab0c:	e6b0      	b.n	800a870 <RadioStateMachine+0x44>
 800ab0e:	bf00      	nop
 800ab10:	0800fa80 	.word	0x0800fa80
 800ab14:	0800fa8b 	.word	0x0800fa8b
 800ab18:	2000c5c0 	.word	0x2000c5c0
 800ab1c:	0800f85c 	.word	0x0800f85c
 800ab20:	0800fa8d 	.word	0x0800fa8d
 800ab24:	0800fa9b 	.word	0x0800fa9b
 800ab28:	20000028 	.word	0x20000028
	else if (rS == RADIO_RSSI)
 800ab2c:	2c05      	cmp	r4, #5
 800ab2e:	d15e      	bne.n	800abee <RadioStateMachine+0x3c2>
		RadioRssiState(data, er, GetErrorFlagsStruct());
 800ab30:	f7fe faec 	bl	800910c <GetErrorFlagsStruct>
 800ab34:	4681      	mov	r9, r0
	if (SaraGetSignalStrength())
 800ab36:	f001 f8fb 	bl	800bd30 <SaraGetSignalStrength>
 800ab3a:	4605      	mov	r5, r0
 800ab3c:	b1d8      	cbz	r0, 800ab76 <RadioStateMachine+0x34a>
		if (SaraGetRSSI())
 800ab3e:	f001 f961 	bl	800be04 <SaraGetRSSI>
 800ab42:	2800      	cmp	r0, #0
 800ab44:	f43f ae94 	beq.w	800a870 <RadioStateMachine+0x44>
			InfoLogAdd(ERRORLEVEL_INFO,
 800ab48:	f7fe fab0 	bl	80090ac <GetTempInfoStruct>
 800ab4c:	2500      	movs	r5, #0
 800ab4e:	9004      	str	r0, [sp, #16]
 800ab50:	2012      	movs	r0, #18
 800ab52:	9000      	str	r0, [sp, #0]
 800ab54:	2319      	movs	r3, #25
 800ab56:	2231      	movs	r2, #49	; 0x31
 800ab58:	211b      	movs	r1, #27
 800ab5a:	9503      	str	r5, [sp, #12]
 800ab5c:	9502      	str	r5, [sp, #8]
 800ab5e:	9501      	str	r5, [sp, #4]
 800ab60:	f001 fbea 	bl	800c338 <InfoLogAdd>
			debugPrint(&hlpuart1, "."); //TODO
 800ab64:	49a8      	ldr	r1, [pc, #672]	; (800ae08 <RadioStateMachine+0x5dc>)
 800ab66:	48a9      	ldr	r0, [pc, #676]	; (800ae0c <RadioStateMachine+0x5e0>)
 800ab68:	f7ff fd96 	bl	800a698 <debugPrint>
	return radioState = rState;
 800ab6c:	f888 4000 	strb.w	r4, [r8]
			rE->testCounterGetSignal = 0;
 800ab70:	f889 5005 	strb.w	r5, [r9, #5]
 800ab74:	e67c      	b.n	800a870 <RadioStateMachine+0x44>
		InfoLogAdd(ERRORLEVEL_INFO,
 800ab76:	f7fe fa99 	bl	80090ac <GetTempInfoStruct>
 800ab7a:	2411      	movs	r4, #17
 800ab7c:	9004      	str	r0, [sp, #16]
 800ab7e:	2319      	movs	r3, #25
 800ab80:	2231      	movs	r2, #49	; 0x31
 800ab82:	211b      	movs	r1, #27
 800ab84:	2012      	movs	r0, #18
 800ab86:	9503      	str	r5, [sp, #12]
 800ab88:	9502      	str	r5, [sp, #8]
 800ab8a:	9501      	str	r5, [sp, #4]
 800ab8c:	9400      	str	r4, [sp, #0]
 800ab8e:	f001 fbd3 	bl	800c338 <InfoLogAdd>
		rE->testCounterGetSignal++;
 800ab92:	f899 3005 	ldrb.w	r3, [r9, #5]
 800ab96:	3301      	adds	r3, #1
 800ab98:	f889 3005 	strb.w	r3, [r9, #5]
		HAL_Delay(500);
 800ab9c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800aba0:	f7f6 f97c 	bl	8000e9c <HAL_Delay>
		if (rE->testCounterGetSignal == MAX_FAILED_ATTEMPTS_GET_SIGNAL)
 800aba4:	f899 3005 	ldrb.w	r3, [r9, #5]
 800aba8:	2b0f      	cmp	r3, #15
 800abaa:	f47f ae61 	bne.w	800a870 <RadioStateMachine+0x44>
			InfoLogAdd(ERRORLEVEL_HIGH,
 800abae:	f7fe fa7d 	bl	80090ac <GetTempInfoStruct>
 800abb2:	2319      	movs	r3, #25
 800abb4:	9004      	str	r0, [sp, #16]
 800abb6:	2231      	movs	r2, #49	; 0x31
 800abb8:	211b      	movs	r1, #27
 800abba:	9503      	str	r5, [sp, #12]
 800abbc:	9502      	str	r5, [sp, #8]
 800abbe:	e88d 0030 	stmia.w	sp, {r4, r5}
 800abc2:	2016      	movs	r0, #22
 800abc4:	f001 fbb8 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(
 800abc8:	f7fe fa68 	bl	800909c <GetErrorStruct>
 800abcc:	9502      	str	r5, [sp, #8]
 800abce:	9003      	str	r0, [sp, #12]
 800abd0:	9501      	str	r5, [sp, #4]
 800abd2:	9500      	str	r5, [sp, #0]
 800abd4:	4623      	mov	r3, r4
 800abd6:	2217      	movs	r2, #23
 800abd8:	2131      	movs	r1, #49	; 0x31
 800abda:	201b      	movs	r0, #27
 800abdc:	f001 fb5c 	bl	800c298 <ErrorAddLog>
			rE->testCounterGetSignal = 0;
 800abe0:	f889 5005 	strb.w	r5, [r9, #5]
			debugPrint(&hlpuart1, "2"); //TODO
 800abe4:	498a      	ldr	r1, [pc, #552]	; (800ae10 <RadioStateMachine+0x5e4>)
 800abe6:	4889      	ldr	r0, [pc, #548]	; (800ae0c <RadioStateMachine+0x5e0>)
 800abe8:	f7ff fd56 	bl	800a698 <debugPrint>
 800abec:	e782      	b.n	800aaf4 <RadioStateMachine+0x2c8>
	else if (rS == RADIO_CLOCK)
 800abee:	2c06      	cmp	r4, #6
 800abf0:	d17b      	bne.n	800acea <RadioStateMachine+0x4be>
		RadioClockState(data, er, GetErrorFlagsStruct());
 800abf2:	f7fe fa8b 	bl	800910c <GetErrorFlagsStruct>
	char timeBuffer[64] = { 0 };
 800abf6:	2240      	movs	r2, #64	; 0x40
 800abf8:	2100      	movs	r1, #0
		RadioClockState(data, er, GetErrorFlagsStruct());
 800abfa:	4604      	mov	r4, r0
	char timeBuffer[64] = { 0 };
 800abfc:	a806      	add	r0, sp, #24
 800abfe:	f002 f87d 	bl	800ccfc <memset>
	SARA_getRealTimeClock(timeBuffer);
 800ac02:	a806      	add	r0, sp, #24
 800ac04:	f000 ffd4 	bl	800bbb0 <SARA_getRealTimeClock>
	if (SaraCompareRealTimeClock(
 800ac08:	2000      	movs	r0, #0
 800ac0a:	f7fe fa53 	bl	80090b4 <GetTimeStruct>
 800ac0e:	4605      	mov	r5, r0
 800ac10:	2001      	movs	r0, #1
 800ac12:	f7fe fa4f 	bl	80090b4 <GetTimeStruct>
 800ac16:	4629      	mov	r1, r5
 800ac18:	4602      	mov	r2, r0
 800ac1a:	a806      	add	r0, sp, #24
 800ac1c:	f001 f826 	bl	800bc6c <SaraCompareRealTimeClock>
 800ac20:	4605      	mov	r5, r0
 800ac22:	b1c8      	cbz	r0, 800ac58 <RadioStateMachine+0x42c>
		InfoLogAdd(ERRORLEVEL_INFO,
 800ac24:	f7fe fa42 	bl	80090ac <GetTempInfoStruct>
 800ac28:	2500      	movs	r5, #0
 800ac2a:	9004      	str	r0, [sp, #16]
 800ac2c:	2012      	movs	r0, #18
 800ac2e:	9000      	str	r0, [sp, #0]
 800ac30:	2317      	movs	r3, #23
 800ac32:	2232      	movs	r2, #50	; 0x32
 800ac34:	211b      	movs	r1, #27
 800ac36:	9503      	str	r5, [sp, #12]
 800ac38:	9502      	str	r5, [sp, #8]
 800ac3a:	9501      	str	r5, [sp, #4]
 800ac3c:	f001 fb7c 	bl	800c338 <InfoLogAdd>
	return radioState = rState;
 800ac40:	2307      	movs	r3, #7
		printf("."); //
 800ac42:	202e      	movs	r0, #46	; 0x2e
	return radioState = rState;
 800ac44:	f888 3000 	strb.w	r3, [r8]
		printf("."); //
 800ac48:	f002 fb80 	bl	800d34c <putchar>
		if (rE->firstRun == 1)  //TODO THIS IS FIRST TIMER
 800ac4c:	7ce3      	ldrb	r3, [r4, #19]
		rE->testCounterTime = 0;
 800ac4e:	71e5      	strb	r5, [r4, #7]
		if (rE->firstRun == 1)  //TODO THIS IS FIRST TIMER
 800ac50:	2b01      	cmp	r3, #1
 800ac52:	f47f ae0d 	bne.w	800a870 <RadioStateMachine+0x44>
 800ac56:	e757      	b.n	800ab08 <RadioStateMachine+0x2dc>
		HAL_Delay(200);
 800ac58:	20c8      	movs	r0, #200	; 0xc8
 800ac5a:	f7f6 f91f 	bl	8000e9c <HAL_Delay>
		rE->testCounterTime++;
 800ac5e:	79e3      	ldrb	r3, [r4, #7]
 800ac60:	3301      	adds	r3, #1
 800ac62:	71e3      	strb	r3, [r4, #7]
		InfoLogAdd(ERRORLEVEL_INFO,
 800ac64:	f7fe fa22 	bl	80090ac <GetTempInfoStruct>
 800ac68:	f04f 0811 	mov.w	r8, #17
 800ac6c:	9004      	str	r0, [sp, #16]
 800ac6e:	2317      	movs	r3, #23
 800ac70:	9503      	str	r5, [sp, #12]
 800ac72:	9502      	str	r5, [sp, #8]
 800ac74:	9501      	str	r5, [sp, #4]
 800ac76:	f8cd 8000 	str.w	r8, [sp]
 800ac7a:	2232      	movs	r2, #50	; 0x32
 800ac7c:	211b      	movs	r1, #27
 800ac7e:	2012      	movs	r0, #18
 800ac80:	f001 fb5a 	bl	800c338 <InfoLogAdd>
		if (rE->testCounterTime == MAX_FAILED_ATTEMPTS)
 800ac84:	79e3      	ldrb	r3, [r4, #7]
 800ac86:	2b03      	cmp	r3, #3
 800ac88:	f47f adf2 	bne.w	800a870 <RadioStateMachine+0x44>
			InfoLogAdd(ERRORLEVEL_HIGH,
 800ac8c:	f7fe fa0e 	bl	80090ac <GetTempInfoStruct>
 800ac90:	2317      	movs	r3, #23
 800ac92:	9004      	str	r0, [sp, #16]
 800ac94:	9503      	str	r5, [sp, #12]
 800ac96:	9502      	str	r5, [sp, #8]
 800ac98:	9501      	str	r5, [sp, #4]
 800ac9a:	f8cd 8000 	str.w	r8, [sp]
 800ac9e:	2232      	movs	r2, #50	; 0x32
 800aca0:	211b      	movs	r1, #27
 800aca2:	2016      	movs	r0, #22
 800aca4:	f001 fb48 	bl	800c338 <InfoLogAdd>
			if (rE->firstRun == 0)
 800aca8:	7ce3      	ldrb	r3, [r4, #19]
 800acaa:	b9b3      	cbnz	r3, 800acda <RadioStateMachine+0x4ae>
				RadioResetState(er, data);
 800acac:	4639      	mov	r1, r7
 800acae:	4630      	mov	r0, r6
 800acb0:	f7ff fd44 	bl	800a73c <RadioResetState>
			ErrorAddLog(
 800acb4:	f7fe f9f2 	bl	800909c <GetErrorStruct>
 800acb8:	2500      	movs	r5, #0
 800acba:	9003      	str	r0, [sp, #12]
 800acbc:	2311      	movs	r3, #17
 800acbe:	2225      	movs	r2, #37	; 0x25
 800acc0:	2132      	movs	r1, #50	; 0x32
 800acc2:	201b      	movs	r0, #27
 800acc4:	9502      	str	r5, [sp, #8]
 800acc6:	9501      	str	r5, [sp, #4]
 800acc8:	9500      	str	r5, [sp, #0]
 800acca:	f001 fae5 	bl	800c298 <ErrorAddLog>
			debugPrint(&hlpuart1, "2"); //TODO
 800acce:	4950      	ldr	r1, [pc, #320]	; (800ae10 <RadioStateMachine+0x5e4>)
 800acd0:	484e      	ldr	r0, [pc, #312]	; (800ae0c <RadioStateMachine+0x5e0>)
 800acd2:	f7ff fce1 	bl	800a698 <debugPrint>
			rE->testCounterTime = 0;
 800acd6:	71e5      	strb	r5, [r4, #7]
 800acd8:	e5ca      	b.n	800a870 <RadioStateMachine+0x44>
				InitTimeStruct(GetTimeStruct(SaraLastConnectedVal));
 800acda:	2000      	movs	r0, #0
 800acdc:	f7fe f9ea 	bl	80090b4 <GetTimeStruct>
 800ace0:	f001 f926 	bl	800bf30 <InitTimeStruct>
				RadioFirstRunFinished();
 800ace4:	f7ff fd82 	bl	800a7ec <RadioFirstRunFinished>
 800ace8:	e7e4      	b.n	800acb4 <RadioStateMachine+0x488>
	else if (rS == RADIO_SETSERVER)
 800acea:	2c07      	cmp	r4, #7
 800acec:	d158      	bne.n	800ada0 <RadioStateMachine+0x574>
		RadioSetServerState(data, er, GetErrorFlagsStruct(), GetSaraConfigurationStruct());
 800acee:	f7fe fa0d 	bl	800910c <GetErrorFlagsStruct>
 800acf2:	4605      	mov	r5, r0
 800acf4:	f7fe fa06 	bl	8009104 <GetSaraConfigurationStruct>
	if (MqttSetHttp(sC->webPage))
 800acf8:	3085      	adds	r0, #133	; 0x85
 800acfa:	f000 fce9 	bl	800b6d0 <MqttSetHttp>
 800acfe:	4604      	mov	r4, r0
 800ad00:	b1b0      	cbz	r0, 800ad30 <RadioStateMachine+0x504>
		InfoLogAdd(ERRORLEVEL_INFO,
 800ad02:	f7fe f9d3 	bl	80090ac <GetTempInfoStruct>
 800ad06:	2400      	movs	r4, #0
 800ad08:	9004      	str	r0, [sp, #16]
 800ad0a:	2012      	movs	r0, #18
 800ad0c:	2317      	movs	r3, #23
 800ad0e:	9000      	str	r0, [sp, #0]
 800ad10:	2233      	movs	r2, #51	; 0x33
 800ad12:	211b      	movs	r1, #27
 800ad14:	9403      	str	r4, [sp, #12]
 800ad16:	9402      	str	r4, [sp, #8]
 800ad18:	9401      	str	r4, [sp, #4]
 800ad1a:	f001 fb0d 	bl	800c338 <InfoLogAdd>
		debugPrint(&hlpuart1, "."); //TODO
 800ad1e:	493a      	ldr	r1, [pc, #232]	; (800ae08 <RadioStateMachine+0x5dc>)
 800ad20:	483a      	ldr	r0, [pc, #232]	; (800ae0c <RadioStateMachine+0x5e0>)
 800ad22:	f7ff fcb9 	bl	800a698 <debugPrint>
	return radioState = rState;
 800ad26:	2308      	movs	r3, #8
 800ad28:	f888 3000 	strb.w	r3, [r8]
		rE->setServerError = 0;
 800ad2c:	73ec      	strb	r4, [r5, #15]
 800ad2e:	e59f      	b.n	800a870 <RadioStateMachine+0x44>
		rE->setServerError++;
 800ad30:	7beb      	ldrb	r3, [r5, #15]
 800ad32:	3301      	adds	r3, #1
 800ad34:	73eb      	strb	r3, [r5, #15]
		InfoLogAdd(ERRORLEVEL_INFO,
 800ad36:	f7fe f9b9 	bl	80090ac <GetTempInfoStruct>
 800ad3a:	2311      	movs	r3, #17
 800ad3c:	9004      	str	r0, [sp, #16]
 800ad3e:	9300      	str	r3, [sp, #0]
 800ad40:	9403      	str	r4, [sp, #12]
 800ad42:	2317      	movs	r3, #23
 800ad44:	9402      	str	r4, [sp, #8]
 800ad46:	9401      	str	r4, [sp, #4]
 800ad48:	2233      	movs	r2, #51	; 0x33
 800ad4a:	211b      	movs	r1, #27
 800ad4c:	2012      	movs	r0, #18
 800ad4e:	f001 faf3 	bl	800c338 <InfoLogAdd>
		if (rE->setServerError == MAX_FAILED_ATTEMPTS)
 800ad52:	7beb      	ldrb	r3, [r5, #15]
 800ad54:	2b03      	cmp	r3, #3
 800ad56:	f47f ad8b 	bne.w	800a870 <RadioStateMachine+0x44>
			InfoLogAdd(ERRORLEVEL_HIGH,
 800ad5a:	f7fe f9a7 	bl	80090ac <GetTempInfoStruct>
 800ad5e:	2400      	movs	r4, #0
 800ad60:	f04f 0811 	mov.w	r8, #17
 800ad64:	2317      	movs	r3, #23
 800ad66:	2233      	movs	r2, #51	; 0x33
 800ad68:	211b      	movs	r1, #27
 800ad6a:	9004      	str	r0, [sp, #16]
 800ad6c:	9403      	str	r4, [sp, #12]
 800ad6e:	2016      	movs	r0, #22
 800ad70:	9402      	str	r4, [sp, #8]
 800ad72:	9401      	str	r4, [sp, #4]
 800ad74:	f8cd 8000 	str.w	r8, [sp]
 800ad78:	f001 fade 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(
 800ad7c:	f7fe f98e 	bl	800909c <GetErrorStruct>
 800ad80:	4643      	mov	r3, r8
 800ad82:	9003      	str	r0, [sp, #12]
 800ad84:	2217      	movs	r2, #23
 800ad86:	2133      	movs	r1, #51	; 0x33
 800ad88:	201b      	movs	r0, #27
 800ad8a:	9402      	str	r4, [sp, #8]
 800ad8c:	9401      	str	r4, [sp, #4]
 800ad8e:	9400      	str	r4, [sp, #0]
 800ad90:	f001 fa82 	bl	800c298 <ErrorAddLog>
			debugPrint(&hlpuart1, "2"); //TODO
 800ad94:	491e      	ldr	r1, [pc, #120]	; (800ae10 <RadioStateMachine+0x5e4>)
 800ad96:	481d      	ldr	r0, [pc, #116]	; (800ae0c <RadioStateMachine+0x5e0>)
 800ad98:	f7ff fc7e 	bl	800a698 <debugPrint>
			rE->setServerError = 0;
 800ad9c:	73ec      	strb	r4, [r5, #15]
 800ad9e:	e6a9      	b.n	800aaf4 <RadioStateMachine+0x2c8>
	else if (rS == RADIO_CONNECT)
 800ada0:	2c08      	cmp	r4, #8
 800ada2:	d170      	bne.n	800ae86 <RadioStateMachine+0x65a>
		RadioConnectState(data, er, GetErrorFlagsStruct());
 800ada4:	f7fe f9b2 	bl	800910c <GetErrorFlagsStruct>
 800ada8:	4680      	mov	r8, r0
	if (MqttConnect())
 800adaa:	f000 fc87 	bl	800b6bc <MqttConnect>
 800adae:	b388      	cbz	r0, 800ae14 <RadioStateMachine+0x5e8>
		InfoLogAdd(ERRORLEVEL_INFO,
 800adb0:	f7fe f97c 	bl	80090ac <GetTempInfoStruct>
 800adb4:	2400      	movs	r4, #0
 800adb6:	9004      	str	r0, [sp, #16]
 800adb8:	2012      	movs	r0, #18
 800adba:	2326      	movs	r3, #38	; 0x26
 800adbc:	2233      	movs	r2, #51	; 0x33
 800adbe:	9000      	str	r0, [sp, #0]
 800adc0:	211b      	movs	r1, #27
 800adc2:	9403      	str	r4, [sp, #12]
 800adc4:	9402      	str	r4, [sp, #8]
 800adc6:	9401      	str	r4, [sp, #4]
 800adc8:	f001 fab6 	bl	800c338 <InfoLogAdd>
		debugPrint(&hlpuart1, "."); //TODO
 800adcc:	490e      	ldr	r1, [pc, #56]	; (800ae08 <RadioStateMachine+0x5dc>)
 800adce:	480f      	ldr	r0, [pc, #60]	; (800ae0c <RadioStateMachine+0x5e0>)
 800add0:	f7ff fc62 	bl	800a698 <debugPrint>
		uint8_t rxBuff[256] = { 0 };
 800add4:	f44f 7280 	mov.w	r2, #256	; 0x100
 800add8:	4621      	mov	r1, r4
 800adda:	a806      	add	r0, sp, #24
 800addc:	f001 ff8e 	bl	800ccfc <memset>
		SaraWaitForResponse(rxBuff, 256, 200);
 800ade0:	22c8      	movs	r2, #200	; 0xc8
 800ade2:	f44f 7180 	mov.w	r1, #256	; 0x100
 800ade6:	a806      	add	r0, sp, #24
 800ade8:	f000 fdbe 	bl	800b968 <SaraWaitForResponse>
	return radioState = rState;
 800adec:	2309      	movs	r3, #9
 800adee:	702b      	strb	r3, [r5, #0]
		if (rE->trySubscribeAgain == 1)
 800adf0:	f898 301c 	ldrb.w	r3, [r8, #28]
		rE->testCounterConnectServer = 0;
 800adf4:	f888 4006 	strb.w	r4, [r8, #6]
		if (rE->trySubscribeAgain == 1)
 800adf8:	2b01      	cmp	r3, #1
 800adfa:	f47f ad39 	bne.w	800a870 <RadioStateMachine+0x44>
	return radioState = rState;
 800adfe:	230a      	movs	r3, #10
 800ae00:	702b      	strb	r3, [r5, #0]
			rE->trySubscribeAgain = 0;
 800ae02:	f888 401c 	strb.w	r4, [r8, #28]
 800ae06:	e533      	b.n	800a870 <RadioStateMachine+0x44>
 800ae08:	0800fa8b 	.word	0x0800fa8b
 800ae0c:	2000c5c0 	.word	0x2000c5c0
 800ae10:	0800f85c 	.word	0x0800f85c
		rE->testCounterConnectServer++;
 800ae14:	f898 3006 	ldrb.w	r3, [r8, #6]
 800ae18:	3301      	adds	r3, #1
 800ae1a:	f888 3006 	strb.w	r3, [r8, #6]
		InfoLogAdd(ERRORLEVEL_INFO,
 800ae1e:	f7fe f945 	bl	80090ac <GetTempInfoStruct>
 800ae22:	2400      	movs	r4, #0
 800ae24:	2511      	movs	r5, #17
 800ae26:	9004      	str	r0, [sp, #16]
 800ae28:	2326      	movs	r3, #38	; 0x26
 800ae2a:	9403      	str	r4, [sp, #12]
 800ae2c:	9402      	str	r4, [sp, #8]
 800ae2e:	9401      	str	r4, [sp, #4]
 800ae30:	9500      	str	r5, [sp, #0]
 800ae32:	2233      	movs	r2, #51	; 0x33
 800ae34:	211b      	movs	r1, #27
 800ae36:	2012      	movs	r0, #18
 800ae38:	f001 fa7e 	bl	800c338 <InfoLogAdd>
		if (rE->testCounterConnectServer == MAX_FAILED_ATTEMPTS)
 800ae3c:	f898 3006 	ldrb.w	r3, [r8, #6]
 800ae40:	2b03      	cmp	r3, #3
 800ae42:	f47f ad15 	bne.w	800a870 <RadioStateMachine+0x44>
			InfoLogAdd(ERRORLEVEL_HIGH,
 800ae46:	f7fe f931 	bl	80090ac <GetTempInfoStruct>
 800ae4a:	2326      	movs	r3, #38	; 0x26
 800ae4c:	2233      	movs	r2, #51	; 0x33
 800ae4e:	211b      	movs	r1, #27
 800ae50:	9004      	str	r0, [sp, #16]
 800ae52:	9403      	str	r4, [sp, #12]
 800ae54:	2016      	movs	r0, #22
 800ae56:	9402      	str	r4, [sp, #8]
 800ae58:	9401      	str	r4, [sp, #4]
 800ae5a:	9500      	str	r5, [sp, #0]
 800ae5c:	f001 fa6c 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(
 800ae60:	f7fe f91c 	bl	800909c <GetErrorStruct>
 800ae64:	462b      	mov	r3, r5
 800ae66:	9003      	str	r0, [sp, #12]
 800ae68:	2226      	movs	r2, #38	; 0x26
 800ae6a:	2133      	movs	r1, #51	; 0x33
 800ae6c:	201b      	movs	r0, #27
 800ae6e:	9402      	str	r4, [sp, #8]
 800ae70:	9401      	str	r4, [sp, #4]
 800ae72:	9400      	str	r4, [sp, #0]
 800ae74:	f001 fa10 	bl	800c298 <ErrorAddLog>
			debugPrint(&hlpuart1, "2"); //TODO
 800ae78:	49b1      	ldr	r1, [pc, #708]	; (800b140 <RadioStateMachine+0x914>)
 800ae7a:	48b2      	ldr	r0, [pc, #712]	; (800b144 <RadioStateMachine+0x918>)
 800ae7c:	f7ff fc0c 	bl	800a698 <debugPrint>
			rE->testCounterConnectServer = 0;
 800ae80:	f888 4006 	strb.w	r4, [r8, #6]
 800ae84:	e636      	b.n	800aaf4 <RadioStateMachine+0x2c8>
	else if (rS == RADIO_PUSHDATA)
 800ae86:	2c09      	cmp	r4, #9
 800ae88:	d166      	bne.n	800af58 <RadioStateMachine+0x72c>
		RadioPushdataState(data, er, GetErrorFlagsStruct());
 800ae8a:	f7fe f93f 	bl	800910c <GetErrorFlagsStruct>
 800ae8e:	4680      	mov	r8, r0
	EnableSD_Card();
 800ae90:	f7fc fe34 	bl	8007afc <EnableSD_Card>
	if (SD_Init() == HAL_OK)
 800ae94:	f7fc fab2 	bl	80073fc <SD_Init>
 800ae98:	4604      	mov	r4, r0
 800ae9a:	bb28      	cbnz	r0, 800aee8 <RadioStateMachine+0x6bc>
		if (FindFile())
 800ae9c:	f7fc fc4c 	bl	8007738 <FindFile>
 800aea0:	2800      	cmp	r0, #0
 800aea2:	f43f ace5 	beq.w	800a870 <RadioStateMachine+0x44>
			FindAndSendFile();
 800aea6:	f7fc fd5d 	bl	8007964 <FindAndSendFile>
			DisableSD_Card();
 800aeaa:	f7fe f93f 	bl	800912c <DisableSD_Card>
			InfoLogAdd(ERRORLEVEL_INFO,
 800aeae:	f7fe f8fd 	bl	80090ac <GetTempInfoStruct>
 800aeb2:	9004      	str	r0, [sp, #16]
 800aeb4:	2012      	movs	r0, #18
 800aeb6:	2315      	movs	r3, #21
 800aeb8:	9000      	str	r0, [sp, #0]
 800aeba:	2233      	movs	r2, #51	; 0x33
 800aebc:	211b      	movs	r1, #27
 800aebe:	9403      	str	r4, [sp, #12]
 800aec0:	9402      	str	r4, [sp, #8]
 800aec2:	9401      	str	r4, [sp, #4]
 800aec4:	f001 fa38 	bl	800c338 <InfoLogAdd>
			debugPrint(&hlpuart1, "###"); //TODO
 800aec8:	499f      	ldr	r1, [pc, #636]	; (800b148 <RadioStateMachine+0x91c>)
 800aeca:	489e      	ldr	r0, [pc, #632]	; (800b144 <RadioStateMachine+0x918>)
 800aecc:	f7ff fbe4 	bl	800a698 <debugPrint>
	return radioState = rState;
 800aed0:	230a      	movs	r3, #10
 800aed2:	702b      	strb	r3, [r5, #0]
			if (rE->alreadyConnected == 1)
 800aed4:	f898 301a 	ldrb.w	r3, [r8, #26]
			rE->publishError = 0;
 800aed8:	f888 4008 	strb.w	r4, [r8, #8]
			if (rE->alreadyConnected == 1)
 800aedc:	2b01      	cmp	r3, #1
 800aede:	f47f acc7 	bne.w	800a870 <RadioStateMachine+0x44>
	return radioState = rState;
 800aee2:	230b      	movs	r3, #11
 800aee4:	702b      	strb	r3, [r5, #0]
 800aee6:	e4c3      	b.n	800a870 <RadioStateMachine+0x44>
		InfoLogAdd(ERRORLEVEL_INFO,
 800aee8:	f7fe f8e0 	bl	80090ac <GetTempInfoStruct>
 800aeec:	2400      	movs	r4, #0
 800aeee:	2511      	movs	r5, #17
 800aef0:	9004      	str	r0, [sp, #16]
 800aef2:	2315      	movs	r3, #21
 800aef4:	9403      	str	r4, [sp, #12]
 800aef6:	9402      	str	r4, [sp, #8]
 800aef8:	9401      	str	r4, [sp, #4]
 800aefa:	9500      	str	r5, [sp, #0]
 800aefc:	2233      	movs	r2, #51	; 0x33
 800aefe:	211b      	movs	r1, #27
 800af00:	2012      	movs	r0, #18
 800af02:	f001 fa19 	bl	800c338 <InfoLogAdd>
		rE->publishError++;
 800af06:	f898 3008 	ldrb.w	r3, [r8, #8]
 800af0a:	3301      	adds	r3, #1
 800af0c:	b2db      	uxtb	r3, r3
		if (rE->publishError == MAX_FAILED_ATTEMPTS)
 800af0e:	2b03      	cmp	r3, #3
		rE->publishError++;
 800af10:	f888 3008 	strb.w	r3, [r8, #8]
		if (rE->publishError == MAX_FAILED_ATTEMPTS)
 800af14:	f47f acac 	bne.w	800a870 <RadioStateMachine+0x44>
			InfoLogAdd(ERRORLEVEL_HIGH,
 800af18:	f7fe f8c8 	bl	80090ac <GetTempInfoStruct>
 800af1c:	2315      	movs	r3, #21
 800af1e:	2233      	movs	r2, #51	; 0x33
 800af20:	211b      	movs	r1, #27
 800af22:	9004      	str	r0, [sp, #16]
 800af24:	9403      	str	r4, [sp, #12]
 800af26:	2016      	movs	r0, #22
 800af28:	9402      	str	r4, [sp, #8]
 800af2a:	9401      	str	r4, [sp, #4]
 800af2c:	9500      	str	r5, [sp, #0]
 800af2e:	f001 fa03 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(
 800af32:	f7fe f8b3 	bl	800909c <GetErrorStruct>
 800af36:	462b      	mov	r3, r5
 800af38:	9003      	str	r0, [sp, #12]
 800af3a:	2215      	movs	r2, #21
 800af3c:	2133      	movs	r1, #51	; 0x33
 800af3e:	201b      	movs	r0, #27
 800af40:	9402      	str	r4, [sp, #8]
 800af42:	9401      	str	r4, [sp, #4]
 800af44:	9400      	str	r4, [sp, #0]
 800af46:	f001 f9a7 	bl	800c298 <ErrorAddLog>
			debugPrint(&hlpuart1, "2"); //TODO
 800af4a:	497d      	ldr	r1, [pc, #500]	; (800b140 <RadioStateMachine+0x914>)
 800af4c:	487d      	ldr	r0, [pc, #500]	; (800b144 <RadioStateMachine+0x918>)
 800af4e:	f7ff fba3 	bl	800a698 <debugPrint>
			rE->publishError = 0;
 800af52:	f888 4008 	strb.w	r4, [r8, #8]
 800af56:	e5cd      	b.n	800aaf4 <RadioStateMachine+0x2c8>
	else if (rS == RADIO_SUBSCRIBE)
 800af58:	2c0a      	cmp	r4, #10
 800af5a:	f040 8085 	bne.w	800b068 <RadioStateMachine+0x83c>
		RadioSubscribeState(data, er, GetErrorFlagsStruct(), GetSaraConfigurationStruct());
 800af5e:	f7fe f8d5 	bl	800910c <GetErrorFlagsStruct>
 800af62:	4681      	mov	r9, r0
 800af64:	f7fe f8ce 	bl	8009104 <GetSaraConfigurationStruct>
	if (MqttSubscribe(sC->connectSubTopic, 0))
 800af68:	f100 0850 	add.w	r8, r0, #80	; 0x50
 800af6c:	2100      	movs	r1, #0
 800af6e:	4640      	mov	r0, r8
 800af70:	f000 fbe8 	bl	800b744 <MqttSubscribe>
 800af74:	b318      	cbz	r0, 800afbe <RadioStateMachine+0x792>
		uint8_t rxBuff[256] = { 0 };
 800af76:	f44f 7280 	mov.w	r2, #256	; 0x100
 800af7a:	2100      	movs	r1, #0
 800af7c:	a806      	add	r0, sp, #24
 800af7e:	f001 febd 	bl	800ccfc <memset>
		SaraWaitForResponse(rxBuff, 256, 2);
 800af82:	2202      	movs	r2, #2
 800af84:	f44f 7180 	mov.w	r1, #256	; 0x100
 800af88:	a806      	add	r0, sp, #24
 800af8a:	f000 fced 	bl	800b968 <SaraWaitForResponse>
		InfoLogAdd(ERRORLEVEL_INFO,
 800af8e:	f7fe f88d 	bl	80090ac <GetTempInfoStruct>
 800af92:	2400      	movs	r4, #0
 800af94:	9004      	str	r0, [sp, #16]
 800af96:	2012      	movs	r0, #18
 800af98:	2327      	movs	r3, #39	; 0x27
 800af9a:	9403      	str	r4, [sp, #12]
 800af9c:	9402      	str	r4, [sp, #8]
 800af9e:	9401      	str	r4, [sp, #4]
 800afa0:	9000      	str	r0, [sp, #0]
 800afa2:	2233      	movs	r2, #51	; 0x33
 800afa4:	211b      	movs	r1, #27
 800afa6:	f001 f9c7 	bl	800c338 <InfoLogAdd>
		rE->alreadyConnected = 1;
 800afaa:	2301      	movs	r3, #1
 800afac:	f889 301a 	strb.w	r3, [r9, #26]
	return radioState = rState;
 800afb0:	230b      	movs	r3, #11
 800afb2:	702b      	strb	r3, [r5, #0]
		rE->subscribeError = 0;
 800afb4:	f889 4009 	strb.w	r4, [r9, #9]
		rE->subscribeErrorCounter = 0;
 800afb8:	f889 401d 	strb.w	r4, [r9, #29]
 800afbc:	e458      	b.n	800a870 <RadioStateMachine+0x44>
	else if (MqttUnSubscribe(sC->connectSubTopic))
 800afbe:	4640      	mov	r0, r8
 800afc0:	f000 fbe6 	bl	800b790 <MqttUnSubscribe>
 800afc4:	4680      	mov	r8, r0
 800afc6:	b108      	cbz	r0, 800afcc <RadioStateMachine+0x7a0>
	return radioState = rState;
 800afc8:	702c      	strb	r4, [r5, #0]
}
 800afca:	e451      	b.n	800a870 <RadioStateMachine+0x44>
		InfoLogAdd(ERRORLEVEL_INFO,
 800afcc:	f7fe f86e 	bl	80090ac <GetTempInfoStruct>
 800afd0:	2411      	movs	r4, #17
 800afd2:	2327      	movs	r3, #39	; 0x27
 800afd4:	2233      	movs	r2, #51	; 0x33
 800afd6:	211b      	movs	r1, #27
 800afd8:	9004      	str	r0, [sp, #16]
 800afda:	f8cd 800c 	str.w	r8, [sp, #12]
 800afde:	2012      	movs	r0, #18
 800afe0:	f8cd 8008 	str.w	r8, [sp, #8]
 800afe4:	f8cd 8004 	str.w	r8, [sp, #4]
 800afe8:	9400      	str	r4, [sp, #0]
 800afea:	f001 f9a5 	bl	800c338 <InfoLogAdd>
		ErrorAddLog(
 800afee:	f7fe f855 	bl	800909c <GetErrorStruct>
 800aff2:	4623      	mov	r3, r4
 800aff4:	9003      	str	r0, [sp, #12]
 800aff6:	f8cd 8008 	str.w	r8, [sp, #8]
 800affa:	f8cd 8004 	str.w	r8, [sp, #4]
 800affe:	f8cd 8000 	str.w	r8, [sp]
 800b002:	2227      	movs	r2, #39	; 0x27
 800b004:	2133      	movs	r1, #51	; 0x33
 800b006:	201b      	movs	r0, #27
 800b008:	f001 f946 	bl	800c298 <ErrorAddLog>
		rE->subscribeError++;
 800b00c:	f899 3009 	ldrb.w	r3, [r9, #9]
 800b010:	3301      	adds	r3, #1
 800b012:	b2db      	uxtb	r3, r3
		if (rE->subscribeError == MAX_FAILED_ATTEMPTS)
 800b014:	2b03      	cmp	r3, #3
 800b016:	d002      	beq.n	800b01e <RadioStateMachine+0x7f2>
		rE->subscribeError++;
 800b018:	f889 3009 	strb.w	r3, [r9, #9]
 800b01c:	e428      	b.n	800a870 <RadioStateMachine+0x44>
			rE->subscribeErrorCounter++;
 800b01e:	f899 301d 	ldrb.w	r3, [r9, #29]
			rE->subscribeError = 0;
 800b022:	f889 8009 	strb.w	r8, [r9, #9]
			rE->subscribeErrorCounter++;
 800b026:	3301      	adds	r3, #1
 800b028:	f889 301d 	strb.w	r3, [r9, #29]
			MqttDisconnect();
 800b02c:	f000 fbca 	bl	800b7c4 <MqttDisconnect>
	return radioState = rState;
 800b030:	2307      	movs	r3, #7
 800b032:	702b      	strb	r3, [r5, #0]
			rE->trySubscribeAgain = 1;
 800b034:	2301      	movs	r3, #1
 800b036:	f889 301c 	strb.w	r3, [r9, #28]
			if (rE->subscribeErrorCounter == MAX_FAILED_ATTEMPTS)
 800b03a:	f899 301d 	ldrb.w	r3, [r9, #29]
 800b03e:	2b03      	cmp	r3, #3
 800b040:	f47f ac16 	bne.w	800a870 <RadioStateMachine+0x44>
				InfoLogAdd(ERRORLEVEL_HIGH,
 800b044:	f7fe f832 	bl	80090ac <GetTempInfoStruct>
 800b048:	f8cd 800c 	str.w	r8, [sp, #12]
 800b04c:	9004      	str	r0, [sp, #16]
 800b04e:	f8cd 8008 	str.w	r8, [sp, #8]
 800b052:	e88d 0110 	stmia.w	sp, {r4, r8}
 800b056:	2327      	movs	r3, #39	; 0x27
 800b058:	2233      	movs	r2, #51	; 0x33
 800b05a:	211b      	movs	r1, #27
 800b05c:	2016      	movs	r0, #22
 800b05e:	f001 f96b 	bl	800c338 <InfoLogAdd>
				rE->subscribeErrorCounter = 0;
 800b062:	f889 801d 	strb.w	r8, [r9, #29]
 800b066:	e545      	b.n	800aaf4 <RadioStateMachine+0x2c8>
	else if (rS == RADIO_SERVERDO)
 800b068:	2c0b      	cmp	r4, #11
 800b06a:	d16f      	bne.n	800b14c <RadioStateMachine+0x920>
		RadioServerdoState(data, er, GetErrorFlagsStruct(), GetSaraConfigurationStruct());
 800b06c:	f7fe f84e 	bl	800910c <GetErrorFlagsStruct>
 800b070:	4680      	mov	r8, r0
 800b072:	f7fe f847 	bl	8009104 <GetSaraConfigurationStruct>
 800b076:	4682      	mov	sl, r0
	if (ServerDo(sC->connectPubTopic))
 800b078:	3060      	adds	r0, #96	; 0x60
 800b07a:	f000 fae1 	bl	800b640 <ServerDo>
 800b07e:	4604      	mov	r4, r0
 800b080:	b198      	cbz	r0, 800b0aa <RadioStateMachine+0x87e>
		InfoLogAdd(ERRORLEVEL_INFO,
 800b082:	f7fe f813 	bl	80090ac <GetTempInfoStruct>
 800b086:	2400      	movs	r4, #0
 800b088:	9004      	str	r0, [sp, #16]
 800b08a:	2012      	movs	r0, #18
 800b08c:	2314      	movs	r3, #20
 800b08e:	9403      	str	r4, [sp, #12]
 800b090:	9402      	str	r4, [sp, #8]
 800b092:	9401      	str	r4, [sp, #4]
 800b094:	9000      	str	r0, [sp, #0]
 800b096:	2233      	movs	r2, #51	; 0x33
 800b098:	211b      	movs	r1, #27
 800b09a:	f001 f94d 	bl	800c338 <InfoLogAdd>
	return radioState = rState;
 800b09e:	230c      	movs	r3, #12
 800b0a0:	702b      	strb	r3, [r5, #0]
		rE->serverDo = 0;
 800b0a2:	f888 400c 	strb.w	r4, [r8, #12]
 800b0a6:	f7ff bbe3 	b.w	800a870 <RadioStateMachine+0x44>
		rE->serverDo++;
 800b0aa:	f898 300c 	ldrb.w	r3, [r8, #12]
 800b0ae:	3301      	adds	r3, #1
 800b0b0:	f888 300c 	strb.w	r3, [r8, #12]
		InfoLogAdd(ERRORLEVEL_INFO,
 800b0b4:	f7fd fffa 	bl	80090ac <GetTempInfoStruct>
 800b0b8:	f04f 0911 	mov.w	r9, #17
 800b0bc:	9004      	str	r0, [sp, #16]
 800b0be:	2314      	movs	r3, #20
 800b0c0:	9403      	str	r4, [sp, #12]
 800b0c2:	9402      	str	r4, [sp, #8]
 800b0c4:	9401      	str	r4, [sp, #4]
 800b0c6:	f8cd 9000 	str.w	r9, [sp]
 800b0ca:	2233      	movs	r2, #51	; 0x33
 800b0cc:	211b      	movs	r1, #27
 800b0ce:	2012      	movs	r0, #18
 800b0d0:	f001 f932 	bl	800c338 <InfoLogAdd>
		if (rE->serverDo >= MAX_FAILED_ATTEMPTS_SERVER)
 800b0d4:	f898 300c 	ldrb.w	r3, [r8, #12]
 800b0d8:	2b09      	cmp	r3, #9
 800b0da:	f67f abc9 	bls.w	800a870 <RadioStateMachine+0x44>
			rE->serverDo = 0;
 800b0de:	f888 400c 	strb.w	r4, [r8, #12]
			rE->alreadyConnected = 0;
 800b0e2:	f888 401a 	strb.w	r4, [r8, #26]
			MqttUnSubscribe(sC->connectSubTopic);
 800b0e6:	f10a 0050 	add.w	r0, sl, #80	; 0x50
 800b0ea:	f000 fb51 	bl	800b790 <MqttUnSubscribe>
	return radioState = rState;
 800b0ee:	2309      	movs	r3, #9
 800b0f0:	702b      	strb	r3, [r5, #0]
			rE->triedToSendCount++;
 800b0f2:	f898 301b 	ldrb.w	r3, [r8, #27]
 800b0f6:	3301      	adds	r3, #1
 800b0f8:	f888 301b 	strb.w	r3, [r8, #27]
			InfoLogAdd(ERRORLEVEL_HIGH,
 800b0fc:	f7fd ffd6 	bl	80090ac <GetTempInfoStruct>
 800b100:	2314      	movs	r3, #20
 800b102:	2233      	movs	r2, #51	; 0x33
 800b104:	211b      	movs	r1, #27
 800b106:	9004      	str	r0, [sp, #16]
 800b108:	9403      	str	r4, [sp, #12]
 800b10a:	2016      	movs	r0, #22
 800b10c:	9402      	str	r4, [sp, #8]
 800b10e:	9401      	str	r4, [sp, #4]
 800b110:	f8cd 9000 	str.w	r9, [sp]
 800b114:	f001 f910 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(
 800b118:	f7fd ffc0 	bl	800909c <GetErrorStruct>
 800b11c:	464b      	mov	r3, r9
 800b11e:	9003      	str	r0, [sp, #12]
 800b120:	9402      	str	r4, [sp, #8]
 800b122:	9401      	str	r4, [sp, #4]
 800b124:	9400      	str	r4, [sp, #0]
 800b126:	2214      	movs	r2, #20
 800b128:	2133      	movs	r1, #51	; 0x33
 800b12a:	201b      	movs	r0, #27
 800b12c:	f001 f8b4 	bl	800c298 <ErrorAddLog>
			if (rE->triedToSendCount >= MAX_FAILED_ATTEMPTS)
 800b130:	f898 301b 	ldrb.w	r3, [r8, #27]
 800b134:	2b02      	cmp	r3, #2
 800b136:	f67f ab9b 	bls.w	800a870 <RadioStateMachine+0x44>
				rE->triedToSendCount = 0;
 800b13a:	f888 401b 	strb.w	r4, [r8, #27]
 800b13e:	e4d9      	b.n	800aaf4 <RadioStateMachine+0x2c8>
 800b140:	0800f85c 	.word	0x0800f85c
 800b144:	2000c5c0 	.word	0x2000c5c0
 800b148:	0800faa7 	.word	0x0800faa7
	else if (rS == RADIO_TODO)
 800b14c:	2c0c      	cmp	r4, #12
 800b14e:	f040 808d 	bne.w	800b26c <RadioStateMachine+0xa40>
		RadioTodoState(data, er, GetErrorFlagsStruct(), GetSaraConfigurationStruct());
 800b152:	f7fd ffdb 	bl	800910c <GetErrorFlagsStruct>
 800b156:	4680      	mov	r8, r0
 800b158:	f7fd ffd4 	bl	8009104 <GetSaraConfigurationStruct>
 800b15c:	4604      	mov	r4, r0
	EnableSD_Card();
 800b15e:	f7fc fccd 	bl	8007afc <EnableSD_Card>
	if (sC->serverToDo == 3)
 800b162:	6ce3      	ldr	r3, [r4, #76]	; 0x4c
 800b164:	2b03      	cmp	r3, #3
 800b166:	d158      	bne.n	800b21a <RadioStateMachine+0x9ee>
		if (SD_Init() == HAL_OK)
 800b168:	f7fc f948 	bl	80073fc <SD_Init>
 800b16c:	2800      	cmp	r0, #0
 800b16e:	f47f ab7f 	bne.w	800a870 <RadioStateMachine+0x44>
			if (FindFile())
 800b172:	f7fc fae1 	bl	8007738 <FindFile>
 800b176:	b108      	cbz	r0, 800b17c <RadioStateMachine+0x950>
				ArchiveFiles();
 800b178:	f7fc fb08 	bl	800778c <ArchiveFiles>
			HAL_Delay(100);
 800b17c:	2064      	movs	r0, #100	; 0x64
 800b17e:	f7f5 fe8d 	bl	8000e9c <HAL_Delay>
			if (!FindFile())
 800b182:	f7fc fad9 	bl	8007738 <FindFile>
 800b186:	4604      	mov	r4, r0
 800b188:	2800      	cmp	r0, #0
 800b18a:	d13f      	bne.n	800b20c <RadioStateMachine+0x9e0>
				printf("All Data sent\r\n");
 800b18c:	4866      	ldr	r0, [pc, #408]	; (800b328 <RadioStateMachine+0xafc>)
 800b18e:	f002 f94d 	bl	800d42c <puts>
				InfoLogAdd(ERRORLEVEL_INFO,
 800b192:	f7fd ff8b 	bl	80090ac <GetTempInfoStruct>
 800b196:	9004      	str	r0, [sp, #16]
 800b198:	2012      	movs	r0, #18
 800b19a:	2314      	movs	r3, #20
 800b19c:	9403      	str	r4, [sp, #12]
 800b19e:	9402      	str	r4, [sp, #8]
 800b1a0:	9401      	str	r4, [sp, #4]
 800b1a2:	9000      	str	r0, [sp, #0]
 800b1a4:	2233      	movs	r2, #51	; 0x33
 800b1a6:	211b      	movs	r1, #27
 800b1a8:	f001 f8c6 	bl	800c338 <InfoLogAdd>
				rE->everythingOK = 1;
 800b1ac:	2301      	movs	r3, #1
 800b1ae:	f888 3015 	strb.w	r3, [r8, #21]
				rE->radioPublishCounter = 0;
 800b1b2:	f888 401f 	strb.w	r4, [r8, #31]
				if (er->errorCounter > 0)
 800b1b6:	f8b6 3258 	ldrh.w	r3, [r6, #600]	; 0x258
	return radioState = rState;
 800b1ba:	2711      	movs	r7, #17
 800b1bc:	702f      	strb	r7, [r5, #0]
				if (er->errorCounter > 0)
 800b1be:	b12b      	cbz	r3, 800b1cc <RadioStateMachine+0x9a0>
					if (SDwriteErrorLog(er) == HAL_OK)
 800b1c0:	4630      	mov	r0, r6
 800b1c2:	f7fc fdb3 	bl	8007d2c <SDwriteErrorLog>
 800b1c6:	b9a0      	cbnz	r0, 800b1f2 <RadioStateMachine+0x9c6>
						er->errorCounter = 0;
 800b1c8:	f8a6 0258 	strh.w	r0, [r6, #600]	; 0x258
				if (GetInfoStruct()->infoCounter > 0)
 800b1cc:	f7fd ff6a 	bl	80090a4 <GetInfoStruct>
 800b1d0:	f642 63e0 	movw	r3, #12000	; 0x2ee0
 800b1d4:	5ac3      	ldrh	r3, [r0, r3]
 800b1d6:	b143      	cbz	r3, 800b1ea <RadioStateMachine+0x9be>
					if (SD_WriteInfoLog(GetInfoStruct()) == HAL_OK)
 800b1d8:	f7fd ff64 	bl	80090a4 <GetInfoStruct>
 800b1dc:	f7fc fd40 	bl	8007c60 <SD_WriteInfoLog>
 800b1e0:	b918      	cbnz	r0, 800b1ea <RadioStateMachine+0x9be>
						ResetInfoStruct(GetInfoStruct());
 800b1e2:	f7fd ff5f 	bl	80090a4 <GetInfoStruct>
 800b1e6:	f001 f890 	bl	800c30a <ResetInfoStruct>
				DisableSD_Card();
 800b1ea:	f7fd ff9f 	bl	800912c <DisableSD_Card>
 800b1ee:	f7ff bb3f 	b.w	800a870 <RadioStateMachine+0x44>
						ErrorAddLog(LOG_FUNC_STATE, LOG_SUB_WRITE_ERROR,
 800b1f2:	f7fd ff53 	bl	800909c <GetErrorStruct>
 800b1f6:	9402      	str	r4, [sp, #8]
 800b1f8:	9003      	str	r0, [sp, #12]
 800b1fa:	9401      	str	r4, [sp, #4]
 800b1fc:	9400      	str	r4, [sp, #0]
 800b1fe:	463b      	mov	r3, r7
 800b200:	2215      	movs	r2, #21
 800b202:	2120      	movs	r1, #32
 800b204:	201b      	movs	r0, #27
 800b206:	f001 f847 	bl	800c298 <ErrorAddLog>
 800b20a:	e7df      	b.n	800b1cc <RadioStateMachine+0x9a0>
	return radioState = rState;
 800b20c:	2309      	movs	r3, #9
 800b20e:	702b      	strb	r3, [r5, #0]
				rE->radioPublishCounter = 0;
 800b210:	2300      	movs	r3, #0
		rE->radioPublishCounter++;
 800b212:	f888 301f 	strb.w	r3, [r8, #31]
 800b216:	f7ff bb2b 	b.w	800a870 <RadioStateMachine+0x44>
		printf("Not all data sent\r\n");
 800b21a:	4844      	ldr	r0, [pc, #272]	; (800b32c <RadioStateMachine+0xb00>)
 800b21c:	f002 f906 	bl	800d42c <puts>
	return radioState = rState;
 800b220:	2309      	movs	r3, #9
 800b222:	702b      	strb	r3, [r5, #0]
		rE->radioPublishCounter++;
 800b224:	f898 301f 	ldrb.w	r3, [r8, #31]
 800b228:	3301      	adds	r3, #1
 800b22a:	b2db      	uxtb	r3, r3
		if (rE->radioPublishCounter >= MAX_FAILED_ATTEMPTS)
 800b22c:	2b02      	cmp	r3, #2
 800b22e:	d9f0      	bls.n	800b212 <RadioStateMachine+0x9e6>
			rE->radioPublishCounter = 0;
 800b230:	2400      	movs	r4, #0
 800b232:	f888 401f 	strb.w	r4, [r8, #31]
			InfoLogAdd(ERRORLEVEL_HIGH,
 800b236:	f7fd ff39 	bl	80090ac <GetTempInfoStruct>
 800b23a:	2313      	movs	r3, #19
 800b23c:	9004      	str	r0, [sp, #16]
 800b23e:	9300      	str	r3, [sp, #0]
 800b240:	2233      	movs	r2, #51	; 0x33
 800b242:	2314      	movs	r3, #20
 800b244:	211b      	movs	r1, #27
 800b246:	9403      	str	r4, [sp, #12]
 800b248:	9402      	str	r4, [sp, #8]
 800b24a:	9401      	str	r4, [sp, #4]
 800b24c:	2016      	movs	r0, #22
 800b24e:	f001 f873 	bl	800c338 <InfoLogAdd>
			ErrorAddLog(
 800b252:	f7fd ff23 	bl	800909c <GetErrorStruct>
 800b256:	9402      	str	r4, [sp, #8]
 800b258:	9003      	str	r0, [sp, #12]
 800b25a:	9401      	str	r4, [sp, #4]
 800b25c:	9400      	str	r4, [sp, #0]
 800b25e:	2311      	movs	r3, #17
 800b260:	2214      	movs	r2, #20
 800b262:	2133      	movs	r1, #51	; 0x33
 800b264:	201b      	movs	r0, #27
 800b266:	f001 f817 	bl	800c298 <ErrorAddLog>
 800b26a:	e443      	b.n	800aaf4 <RadioStateMachine+0x2c8>
	else if (rS == RADIO_DISCONNECT)
 800b26c:	2c11      	cmp	r4, #17
 800b26e:	d11c      	bne.n	800b2aa <RadioStateMachine+0xa7e>
		RadioDisconnectState(GetErrorFlagsStruct());
 800b270:	f7fd ff4c 	bl	800910c <GetErrorFlagsStruct>
 800b274:	4604      	mov	r4, r0
	if (MqttDisconnect())
 800b276:	f000 faa5 	bl	800b7c4 <MqttDisconnect>
 800b27a:	230e      	movs	r3, #14
 800b27c:	4606      	mov	r6, r0
	return radioState = rState;
 800b27e:	f888 3000 	strb.w	r3, [r8]
	if (MqttDisconnect())
 800b282:	b148      	cbz	r0, 800b298 <RadioStateMachine+0xa6c>
		printf("Disconnected from server\r\n");
 800b284:	482a      	ldr	r0, [pc, #168]	; (800b330 <RadioStateMachine+0xb04>)
 800b286:	f002 f8d1 	bl	800d42c <puts>
		rE->alreadyConnected = 0;
 800b28a:	2300      	movs	r3, #0
 800b28c:	76a3      	strb	r3, [r4, #26]
		rE->errorDayCounter = 0;
 800b28e:	7123      	strb	r3, [r4, #4]
		rE->errorHourCounter = 0;
 800b290:	70e3      	strb	r3, [r4, #3]
		rE->everythingOK = 0;
 800b292:	7563      	strb	r3, [r4, #21]
 800b294:	f7ff baec 	b.w	800a870 <RadioStateMachine+0x44>
		printf("Just turn off\r\n");
 800b298:	4826      	ldr	r0, [pc, #152]	; (800b334 <RadioStateMachine+0xb08>)
 800b29a:	f002 f8c7 	bl	800d42c <puts>
		rE->alreadyConnected = 0;
 800b29e:	76a6      	strb	r6, [r4, #26]
		rE->errorDayCounter = 0;
 800b2a0:	7126      	strb	r6, [r4, #4]
		rE->errorHourCounter = 0;
 800b2a2:	70e6      	strb	r6, [r4, #3]
		rE->everythingOK = 0;
 800b2a4:	7566      	strb	r6, [r4, #21]
 800b2a6:	f7ff bae3 	b.w	800a870 <RadioStateMachine+0x44>
	else if (rS == RADIO_POWEROFF)
 800b2aa:	2c0e      	cmp	r4, #14
 800b2ac:	d120      	bne.n	800b2f0 <RadioStateMachine+0xac4>
		RadioPoweroffState(GetErrorFlagsStruct());
 800b2ae:	f7fd ff2d 	bl	800910c <GetErrorFlagsStruct>
	debugPrint(&hlpuart1, "RPON");
 800b2b2:	4921      	ldr	r1, [pc, #132]	; (800b338 <RadioStateMachine+0xb0c>)
		RadioPoweroffState(GetErrorFlagsStruct());
 800b2b4:	4604      	mov	r4, r0
	debugPrint(&hlpuart1, "RPON");
 800b2b6:	4821      	ldr	r0, [pc, #132]	; (800b33c <RadioStateMachine+0xb10>)
 800b2b8:	f7ff f9ee 	bl	800a698 <debugPrint>
	rE->alreadyConnected = 0;
 800b2bc:	2300      	movs	r3, #0
 800b2be:	76a3      	strb	r3, [r4, #26]
	rE->trySubscribeAgain = 0;
 800b2c0:	7723      	strb	r3, [r4, #28]
	StartTurnOffCounter();
 800b2c2:	f7ff f9fd 	bl	800a6c0 <StartTurnOffCounter>
	while (!SaraPowerDown())
 800b2c6:	f000 fc2f 	bl	800bb28 <SaraPowerDown>
 800b2ca:	b938      	cbnz	r0, 800b2dc <RadioStateMachine+0xab0>
		if (CompareTurnOffTimers())
 800b2cc:	f7ff fa00 	bl	800a6d0 <CompareTurnOffTimers>
 800b2d0:	2800      	cmp	r0, #0
 800b2d2:	d0f8      	beq.n	800b2c6 <RadioStateMachine+0xa9a>
			if (ResetRadio())
 800b2d4:	f7ff fa15 	bl	800a702 <ResetRadio>
 800b2d8:	2800      	cmp	r0, #0
 800b2da:	d0f4      	beq.n	800b2c6 <RadioStateMachine+0xa9a>
	debugPrint(&hlpuart1, "RPOFF");
 800b2dc:	4918      	ldr	r1, [pc, #96]	; (800b340 <RadioStateMachine+0xb14>)
 800b2de:	4817      	ldr	r0, [pc, #92]	; (800b33c <RadioStateMachine+0xb10>)
 800b2e0:	f7ff f9da 	bl	800a698 <debugPrint>
	return radioState = rState;
 800b2e4:	2310      	movs	r3, #16
 800b2e6:	702b      	strb	r3, [r5, #0]
	StartTurnOffCounter();
 800b2e8:	f7ff f9ea 	bl	800a6c0 <StartTurnOffCounter>
 800b2ec:	f7ff bac0 	b.w	800a870 <RadioStateMachine+0x44>
	else if (rS == RADIO_CHECKPOWER)
 800b2f0:	2c10      	cmp	r4, #16
 800b2f2:	f47f aabd 	bne.w	800a870 <RadioStateMachine+0x44>
	GPIO_PinState checkPowerOff = HAL_GPIO_ReadPin(VINT_Sense_GPIO_Port, VINT_Sense_Pin);
 800b2f6:	4621      	mov	r1, r4
 800b2f8:	4812      	ldr	r0, [pc, #72]	; (800b344 <RadioStateMachine+0xb18>)
 800b2fa:	f7f6 ff33 	bl	8002164 <HAL_GPIO_ReadPin>
	if (checkPowerOff == GPIO_PIN_SET)
 800b2fe:	2801      	cmp	r0, #1
	GPIO_PinState checkPowerOff = HAL_GPIO_ReadPin(VINT_Sense_GPIO_Port, VINT_Sense_Pin);
 800b300:	4604      	mov	r4, r0
	if (checkPowerOff == GPIO_PIN_SET)
 800b302:	d109      	bne.n	800b318 <RadioStateMachine+0xaec>
		printf("Still on\r\n");
 800b304:	4810      	ldr	r0, [pc, #64]	; (800b348 <RadioStateMachine+0xb1c>)
 800b306:	f002 f891 	bl	800d42c <puts>
		if (CompareTurnOffTimers())
 800b30a:	f7ff f9e1 	bl	800a6d0 <CompareTurnOffTimers>
 800b30e:	2800      	cmp	r0, #0
 800b310:	f43f aaae 	beq.w	800a870 <RadioStateMachine+0x44>
	return radioState = rState;
 800b314:	230e      	movs	r3, #14
 800b316:	e5e5      	b.n	800aee4 <RadioStateMachine+0x6b8>
	if (checkPowerOff == GPIO_PIN_RESET)
 800b318:	2800      	cmp	r0, #0
 800b31a:	f47f aaa9 	bne.w	800a870 <RadioStateMachine+0x44>
		printf("Radio Off\r\n");
 800b31e:	480b      	ldr	r0, [pc, #44]	; (800b34c <RadioStateMachine+0xb20>)
 800b320:	f002 f884 	bl	800d42c <puts>
 800b324:	e650      	b.n	800afc8 <RadioStateMachine+0x79c>
 800b326:	bf00      	nop
 800b328:	0800faab 	.word	0x0800faab
 800b32c:	0800faba 	.word	0x0800faba
 800b330:	0800facd 	.word	0x0800facd
 800b334:	0800fae7 	.word	0x0800fae7
 800b338:	0800faf6 	.word	0x0800faf6
 800b33c:	2000c5c0 	.word	0x2000c5c0
 800b340:	0800fafb 	.word	0x0800fafb
 800b344:	48000800 	.word	0x48000800
 800b348:	0800fb01 	.word	0x0800fb01
 800b34c:	0800fb0b 	.word	0x0800fb0b

0800b350 <SensorStateMachine>:
	LOG_STATUS_PASSED, 0, 0, 0, GetTempInfoStruct());
}

/* SensorStateMachine, goes through each step and gets one sensor value (NOT OPTIMIZED DUE TO HAL_DELAY) */
void SensorStateMachine(Data *data, Error *er)
{
 800b350:	b5f0      	push	{r4, r5, r6, r7, lr}
	return sensorState;
 800b352:	4d7d      	ldr	r5, [pc, #500]	; (800b548 <SensorStateMachine+0x1f8>)
 800b354:	782b      	ldrb	r3, [r5, #0]
{
 800b356:	b087      	sub	sp, #28
 800b358:	4604      	mov	r4, r0
 800b35a:	462e      	mov	r6, r5
	SensorStates sS = GetSensorState();

	/* Idle stage, do nothing */
	if (sS == SENSOR_IDLE)
 800b35c:	2b00      	cmp	r3, #0
 800b35e:	f000 80c5 	beq.w	800b4ec <SensorStateMachine+0x19c>
	{

	}

	/* Sensor is now awake */
	else if (sS == SENSOR_AWAKE)
 800b362:	2b01      	cmp	r3, #1
 800b364:	d116      	bne.n	800b394 <SensorStateMachine+0x44>
	MX_ADC1_Init();
 800b366:	f7fe fa51 	bl	800980c <MX_ADC1_Init>
	MX_LPTIM1_Init();
 800b36a:	f7fe feb3 	bl	800a0d4 <MX_LPTIM1_Init>
	MX_I2C1_Init();
 800b36e:	f7fe fd79 	bl	8009e64 <MX_I2C1_Init>
	MX_I2C2_Init();
 800b372:	f7fe fdab 	bl	8009ecc <MX_I2C2_Init>
	return sensorState = sState;
 800b376:	2302      	movs	r3, #2
 800b378:	702b      	strb	r3, [r5, #0]
	InfoLogAdd(ERRORLEVEL_INFO,
 800b37a:	f7fd fe97 	bl	80090ac <GetTempInfoStruct>
 800b37e:	2300      	movs	r3, #0
 800b380:	9004      	str	r0, [sp, #16]
 800b382:	2012      	movs	r0, #18
 800b384:	9303      	str	r3, [sp, #12]
 800b386:	9302      	str	r3, [sp, #8]
 800b388:	9301      	str	r3, [sp, #4]
 800b38a:	9000      	str	r0, [sp, #0]
 800b38c:	2339      	movs	r3, #57	; 0x39
	InfoLogAdd(ERRORLEVEL_INFO,
 800b38e:	2239      	movs	r2, #57	; 0x39
 800b390:	211b      	movs	r1, #27
 800b392:	e0a9      	b.n	800b4e8 <SensorStateMachine+0x198>
	{
		SensorAwakeState();
	}

	/* Init sensors */
	else if (sS == SENSOR_INIT)
 800b394:	2b02      	cmp	r3, #2
 800b396:	d133      	bne.n	800b400 <SensorStateMachine+0xb0>
	if (data->sensCounter == 0)
 800b398:	f645 2308 	movw	r3, #23048	; 0x5a08
 800b39c:	5ac3      	ldrh	r3, [r0, r3]
 800b39e:	b9fb      	cbnz	r3, 800b3e0 <SensorStateMachine+0x90>
		DisEnableSensorPins(1);
 800b3a0:	2001      	movs	r0, #1
 800b3a2:	f7fe fce3 	bl	8009d6c <DisEnableSensorPins>
		Battery_init();
 800b3a6:	f7fb ffad 	bl	8007304 <Battery_init>
	TMP112_Init();
 800b3aa:	f7fd fad7 	bl	800895c <TMP112_Init>
	HDC1080_Init();
 800b3ae:	f7fd f8f2 	bl	8008596 <HDC1080_Init>
	VEML7700_Initialize();
 800b3b2:	f7fd fc29 	bl	8008c08 <VEML7700_Initialize>
	debugPrint(&hlpuart1, "-");
 800b3b6:	4965      	ldr	r1, [pc, #404]	; (800b54c <SensorStateMachine+0x1fc>)
 800b3b8:	4865      	ldr	r0, [pc, #404]	; (800b550 <SensorStateMachine+0x200>)
 800b3ba:	f7ff f96d 	bl	800a698 <debugPrint>
	if (data->sensCounter == 0)
 800b3be:	f645 2308 	movw	r3, #23048	; 0x5a08
 800b3c2:	5ae3      	ldrh	r3, [r4, r3]
 800b3c4:	b9d3      	cbnz	r3, 800b3fc <SensorStateMachine+0xac>
	return sensorState = sState;
 800b3c6:	2303      	movs	r3, #3
 800b3c8:	7033      	strb	r3, [r6, #0]
	InfoLogAdd(ERRORLEVEL_INFO,
 800b3ca:	f7fd fe6f 	bl	80090ac <GetTempInfoStruct>
 800b3ce:	2300      	movs	r3, #0
 800b3d0:	9004      	str	r0, [sp, #16]
 800b3d2:	2012      	movs	r0, #18
 800b3d4:	9303      	str	r3, [sp, #12]
 800b3d6:	9302      	str	r3, [sp, #8]
 800b3d8:	9301      	str	r3, [sp, #4]
 800b3da:	9000      	str	r0, [sp, #0]
 800b3dc:	2320      	movs	r3, #32
 800b3de:	e7d6      	b.n	800b38e <SensorStateMachine+0x3e>
		HAL_GPIO_WritePin(Temperature_EN_GPIO_Port, Temperature_EN_Pin, GPIO_PIN_SET);
 800b3e0:	2201      	movs	r2, #1
 800b3e2:	2140      	movs	r1, #64	; 0x40
 800b3e4:	485b      	ldr	r0, [pc, #364]	; (800b554 <SensorStateMachine+0x204>)
 800b3e6:	f7f6 fec3 	bl	8002170 <HAL_GPIO_WritePin>
		HAL_GPIO_WritePin(Spectrum_EN_GPIO_Port, Spectrum_EN_Pin, GPIO_PIN_SET);
 800b3ea:	2201      	movs	r2, #1
 800b3ec:	2120      	movs	r1, #32
 800b3ee:	4859      	ldr	r0, [pc, #356]	; (800b554 <SensorStateMachine+0x204>)
 800b3f0:	f7f6 febe 	bl	8002170 <HAL_GPIO_WritePin>
		HAL_Delay(10);
 800b3f4:	200a      	movs	r0, #10
 800b3f6:	f7f5 fd51 	bl	8000e9c <HAL_Delay>
 800b3fa:	e7d6      	b.n	800b3aa <SensorStateMachine+0x5a>
	return sensorState = sState;
 800b3fc:	2305      	movs	r3, #5
 800b3fe:	e7e3      	b.n	800b3c8 <SensorStateMachine+0x78>
	{
		SensorInitState(data);
	}

	/* First sensor value, check time and battery */
	else if (sS == SENSOR_FIRST)
 800b400:	2b03      	cmp	r3, #3
 800b402:	d11b      	bne.n	800b43c <SensorStateMachine+0xec>
	data->readData.timeStamp = RTC_Get_DateTime_Comp();
 800b404:	f7fe ff42 	bl	800a28c <RTC_Get_DateTime_Comp>
 800b408:	6020      	str	r0, [r4, #0]
	data->readData.batteryLevel = Battery_GetLevel();
 800b40a:	f7fb ff45 	bl	8007298 <Battery_GetLevel>
	HAL_GPIO_WritePin(VBAT_Sense_EN_GPIO_Port, VBAT_Sense_EN_Pin, GPIO_PIN_RESET);
 800b40e:	2200      	movs	r2, #0
	data->readData.batteryLevel = Battery_GetLevel();
 800b410:	7120      	strb	r0, [r4, #4]
	HAL_GPIO_WritePin(VBAT_Sense_EN_GPIO_Port, VBAT_Sense_EN_Pin, GPIO_PIN_RESET);
 800b412:	2104      	movs	r1, #4
 800b414:	4850      	ldr	r0, [pc, #320]	; (800b558 <SensorStateMachine+0x208>)
 800b416:	f7f6 feab 	bl	8002170 <HAL_GPIO_WritePin>
	return sensorState = sState;
 800b41a:	2305      	movs	r3, #5
	debugPrint(&hlpuart1, "-");
 800b41c:	494b      	ldr	r1, [pc, #300]	; (800b54c <SensorStateMachine+0x1fc>)
 800b41e:	484c      	ldr	r0, [pc, #304]	; (800b550 <SensorStateMachine+0x200>)
	return sensorState = sState;
 800b420:	702b      	strb	r3, [r5, #0]
	debugPrint(&hlpuart1, "-");
 800b422:	f7ff f939 	bl	800a698 <debugPrint>
	InfoLogAdd(ERRORLEVEL_INFO,
 800b426:	f7fd fe41 	bl	80090ac <GetTempInfoStruct>
 800b42a:	2300      	movs	r3, #0
 800b42c:	9004      	str	r0, [sp, #16]
 800b42e:	2012      	movs	r0, #18
 800b430:	9303      	str	r3, [sp, #12]
 800b432:	9302      	str	r3, [sp, #8]
 800b434:	9301      	str	r3, [sp, #4]
 800b436:	9000      	str	r0, [sp, #0]
 800b438:	2316      	movs	r3, #22
 800b43a:	e7a8      	b.n	800b38e <SensorStateMachine+0x3e>
	{
		SensorFirstState(data);
	}

	/* Sensor have a wake-up time, MCU sleep during this */
	else if (sS == SENSOR_SLEEP)
 800b43c:	2b05      	cmp	r3, #5
 800b43e:	d157      	bne.n	800b4f0 <SensorStateMachine+0x1a0>
	InfoLogAdd(ERRORLEVEL_INFO,
 800b440:	f7fd fe34 	bl	80090ac <GetTempInfoStruct>
 800b444:	2400      	movs	r4, #0
 800b446:	2612      	movs	r6, #18
 800b448:	211b      	movs	r1, #27
 800b44a:	2334      	movs	r3, #52	; 0x34
 800b44c:	2239      	movs	r2, #57	; 0x39
	HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
 800b44e:	4f43      	ldr	r7, [pc, #268]	; (800b55c <SensorStateMachine+0x20c>)
	InfoLogAdd(ERRORLEVEL_INFO,
 800b450:	9004      	str	r0, [sp, #16]
 800b452:	9403      	str	r4, [sp, #12]
 800b454:	4630      	mov	r0, r6
 800b456:	9402      	str	r4, [sp, #8]
 800b458:	9401      	str	r4, [sp, #4]
 800b45a:	9600      	str	r6, [sp, #0]
 800b45c:	f000 ff6c 	bl	800c338 <InfoLogAdd>
	RTC_SetAlarmB(1);
 800b460:	2001      	movs	r0, #1
 800b462:	f7fe ff8b 	bl	800a37c <RTC_SetAlarmB>
	SD_DeInitTest();
 800b466:	f7fc fdcf 	bl	8008008 <SD_DeInitTest>
	MX_I2C1_DeInit();
 800b46a:	f7fe fdcd 	bl	800a008 <MX_I2C1_DeInit>
	MX_I2C2_DeInit();
 800b46e:	f7fe fdd1 	bl	800a014 <MX_I2C2_DeInit>
	MX_LPUART1_UART_DeInit();
 800b472:	f7ff f91f 	bl	800a6b4 <MX_LPUART1_UART_DeInit>
	MX_ADC_DeInit();
 800b476:	f7fb ff8b 	bl	8007390 <MX_ADC_DeInit>
	GPIOSetAnalogSensor();
 800b47a:	f7fd fe81 	bl	8009180 <GPIOSetAnalogSensor>
	HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
 800b47e:	4638      	mov	r0, r7
 800b480:	f7f8 fc5b 	bl	8003d3a <HAL_RTCEx_DeactivateWakeUpTimer>
	HAL_PWREx_EnterSTOP2Mode(PWR_STOPENTRY_WFI);
 800b484:	2001      	movs	r0, #1
 800b486:	f7f7 fbad 	bl	8002be4 <HAL_PWREx_EnterSTOP2Mode>
	__HAL_RTC_WAKEUPTIMER_CLEAR_FLAG(&hrtc, RTC_FLAG_WUTF);
 800b48a:	683a      	ldr	r2, [r7, #0]
 800b48c:	68d3      	ldr	r3, [r2, #12]
 800b48e:	b2db      	uxtb	r3, r3
 800b490:	f463 6390 	orn	r3, r3, #1152	; 0x480
 800b494:	60d3      	str	r3, [r2, #12]
	__HAL_RTC_CLEAR_FLAG(RTC_EXTI_LINE_WAKEUPTIMER_EVENT);
 800b496:	4b32      	ldr	r3, [pc, #200]	; (800b560 <SensorStateMachine+0x210>)
 800b498:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 800b49c:	615a      	str	r2, [r3, #20]
	HAL_RTCEx_DeactivateWakeUpTimer(&hrtc);
 800b49e:	4638      	mov	r0, r7
 800b4a0:	f7f8 fc4b 	bl	8003d3a <HAL_RTCEx_DeactivateWakeUpTimer>
	SystemClock_Config();
 800b4a4:	f7fd ff34 	bl	8009310 <SystemClock_Config>
	GPIOInitSensor();
 800b4a8:	f7fe fbbe 	bl	8009c28 <GPIOInitSensor>
	MX_LPUART1_UART_Init();
 800b4ac:	f7ff f83a 	bl	800a524 <MX_LPUART1_UART_Init>
	MX_USART2_UART_Init();
 800b4b0:	f7ff f858 	bl	800a564 <MX_USART2_UART_Init>
	MX_ADC1_Init();
 800b4b4:	f7fe f9aa 	bl	800980c <MX_ADC1_Init>
	MX_LPTIM1_Init();
 800b4b8:	f7fe fe0c 	bl	800a0d4 <MX_LPTIM1_Init>
	MX_FATFS_Init();
 800b4bc:	f7fc fce8 	bl	8007e90 <MX_FATFS_Init>
	printf("Start Sensor\r\n");
 800b4c0:	4828      	ldr	r0, [pc, #160]	; (800b564 <SensorStateMachine+0x214>)
 800b4c2:	f001 ffb3 	bl	800d42c <puts>
	MX_I2C1_Init();
 800b4c6:	f7fe fccd 	bl	8009e64 <MX_I2C1_Init>
	MX_I2C2_Init();
 800b4ca:	f7fe fcff 	bl	8009ecc <MX_I2C2_Init>
	return sensorState = sState;
 800b4ce:	2304      	movs	r3, #4
 800b4d0:	702b      	strb	r3, [r5, #0]
	InfoLogAdd(ERRORLEVEL_INFO,
 800b4d2:	f7fd fdeb 	bl	80090ac <GetTempInfoStruct>
 800b4d6:	9403      	str	r4, [sp, #12]
 800b4d8:	9004      	str	r0, [sp, #16]
 800b4da:	9402      	str	r4, [sp, #8]
 800b4dc:	9401      	str	r4, [sp, #4]
 800b4de:	9600      	str	r6, [sp, #0]
 800b4e0:	2317      	movs	r3, #23
 800b4e2:	2239      	movs	r2, #57	; 0x39
 800b4e4:	211b      	movs	r1, #27
 800b4e6:	4630      	mov	r0, r6
	InfoLogAdd(ERRORLEVEL_INFO,
 800b4e8:	f000 ff26 	bl	800c338 <InfoLogAdd>
	/* Take measure of all sensors */
	else if (sS == SENSOR_MEASURE)
	{
		SensorMeasureState(data);
	}
}
 800b4ec:	b007      	add	sp, #28
 800b4ee:	bdf0      	pop	{r4, r5, r6, r7, pc}
	else if (sS == SENSOR_MEASURE)
 800b4f0:	2b04      	cmp	r3, #4
 800b4f2:	d1fb      	bne.n	800b4ec <SensorStateMachine+0x19c>
	MultiSensor_takeMeasurements(&data->readData.sensData[data->sensCounter]);
 800b4f4:	f645 2508 	movw	r5, #23048	; 0x5a08
 800b4f8:	5b40      	ldrh	r0, [r0, r5]
 800b4fa:	eb04 1000 	add.w	r0, r4, r0, lsl #4
 800b4fe:	3008      	adds	r0, #8
 800b500:	f7fd f926 	bl	8008750 <MultiSensor_takeMeasurements>
	data->sensCounter++;
 800b504:	5b63      	ldrh	r3, [r4, r5]
 800b506:	3301      	adds	r3, #1
 800b508:	b29b      	uxth	r3, r3
	if (data->sensCounter >= SENSOR_STRUCT_ARRAY_SIZE)
 800b50a:	f5b3 6fb4 	cmp.w	r3, #1440	; 0x5a0
	data->sensCounter++;
 800b50e:	5363      	strh	r3, [r4, r5]
	if (data->sensCounter >= SENSOR_STRUCT_ARRAY_SIZE)
 800b510:	d306      	bcc.n	800b520 <SensorStateMachine+0x1d0>
		EnableSD_Card();
 800b512:	f7fc faf3 	bl	8007afc <EnableSD_Card>
		SDWriteSensorData(data);
 800b516:	4620      	mov	r0, r4
 800b518:	f7fc fb24 	bl	8007b64 <SDWriteSensorData>
		DisableSD_Card();
 800b51c:	f7fd fe06 	bl	800912c <DisableSD_Card>
	return sensorState = sState;
 800b520:	2500      	movs	r5, #0
	PrintSensorData(data);
 800b522:	4620      	mov	r0, r4
	return sensorState = sState;
 800b524:	7035      	strb	r5, [r6, #0]
	PrintSensorData(data);
 800b526:	f7fd f94b 	bl	80087c0 <PrintSensorData>
	debugPrint(&hlpuart1, "-");
 800b52a:	4908      	ldr	r1, [pc, #32]	; (800b54c <SensorStateMachine+0x1fc>)
 800b52c:	4808      	ldr	r0, [pc, #32]	; (800b550 <SensorStateMachine+0x200>)
 800b52e:	f7ff f8b3 	bl	800a698 <debugPrint>
	InfoLogAdd(ERRORLEVEL_INFO,
 800b532:	f7fd fdbb 	bl	80090ac <GetTempInfoStruct>
 800b536:	9004      	str	r0, [sp, #16]
 800b538:	2012      	movs	r0, #18
 800b53a:	9503      	str	r5, [sp, #12]
 800b53c:	9502      	str	r5, [sp, #8]
 800b53e:	9501      	str	r5, [sp, #4]
 800b540:	9000      	str	r0, [sp, #0]
 800b542:	2314      	movs	r3, #20
 800b544:	e723      	b.n	800b38e <SensorStateMachine+0x3e>
 800b546:	bf00      	nop
 800b548:	2000029a 	.word	0x2000029a
 800b54c:	080100a2 	.word	0x080100a2
 800b550:	2000c5c0 	.word	0x2000c5c0
 800b554:	48000400 	.word	0x48000400
 800b558:	48000800 	.word	0x48000800
 800b55c:	2000c59c 	.word	0x2000c59c
 800b560:	40010400 	.word	0x40010400
 800b564:	0800fb16 	.word	0x0800fb16

0800b568 <SleepStateMachine>:

/* Sleeps when Radio and Sensors are IDLE, Should also implement sleep when Radio is searching for network */
void SleepStateMachine()
{
 800b568:	b508      	push	{r3, lr}
	return radioState;
 800b56a:	4b20      	ldr	r3, [pc, #128]	; (800b5ec <SleepStateMachine+0x84>)
 800b56c:	781a      	ldrb	r2, [r3, #0]
	return sensorState;
 800b56e:	4b20      	ldr	r3, [pc, #128]	; (800b5f0 <SleepStateMachine+0x88>)
 800b570:	781b      	ldrb	r3, [r3, #0]

	RadioStates rS = GetRadioState();

	SensorStates sS = GetSensorState();

	if (rS == RADIO_IDLE && sS == SENSOR_IDLE)
 800b572:	bb8a      	cbnz	r2, 800b5d8 <SleepStateMachine+0x70>
 800b574:	bbcb      	cbnz	r3, 800b5ea <SleepStateMachine+0x82>
	{
		debugPrint(&hlpuart1, "!");
 800b576:	491f      	ldr	r1, [pc, #124]	; (800b5f4 <SleepStateMachine+0x8c>)
 800b578:	481f      	ldr	r0, [pc, #124]	; (800b5f8 <SleepStateMachine+0x90>)
 800b57a:	f7ff f88d 	bl	800a698 <debugPrint>

		/* DeInitialize SD */
		SD_DeInit();
 800b57e:	f7fc f809 	bl	8007594 <SD_DeInit>

		/* If some error has occurred during the iteration, add the whole iteration to Infostruct */
		if (GetTempInfoStruct()->highestError >= ERRORLEVEL_WARNING)
 800b582:	f7fd fd93 	bl	80090ac <GetTempInfoStruct>
 800b586:	f642 63e2 	movw	r3, #12002	; 0x2ee2
 800b58a:	5cc3      	ldrb	r3, [r0, r3]
 800b58c:	2b13      	cmp	r3, #19
 800b58e:	d901      	bls.n	800b594 <SleepStateMachine+0x2c>
		{
			CopyTempToInfo();
 800b590:	f000 ff2c 	bl	800c3ec <CopyTempToInfo>
		}

		/* Check if USB is plugged in, in that case save InfoStruct to SD */
		if ((HAL_GPIO_ReadPin(Charge_Detect_GPIO_Port, Charge_Detect_Pin) == GPIO_PIN_RESET)
 800b594:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 800b598:	4818      	ldr	r0, [pc, #96]	; (800b5fc <SleepStateMachine+0x94>)
 800b59a:	f7f6 fde3 	bl	8002164 <HAL_GPIO_ReadPin>
 800b59e:	b998      	cbnz	r0, 800b5c8 <SleepStateMachine+0x60>
				&& (HAL_GPIO_ReadPin(VBUS_Detect_GPIO_Port, VBUS_Detect_Pin) == GPIO_PIN_SET))
 800b5a0:	f44f 7100 	mov.w	r1, #512	; 0x200
 800b5a4:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 800b5a8:	f7f6 fddc 	bl	8002164 <HAL_GPIO_ReadPin>
 800b5ac:	2801      	cmp	r0, #1
 800b5ae:	d10b      	bne.n	800b5c8 <SleepStateMachine+0x60>
		{
			EnableSD_Card();
 800b5b0:	f7fc faa4 	bl	8007afc <EnableSD_Card>

			/* Write to SD card */
			SD_WriteInfoLog(GetInfoStruct());
 800b5b4:	f7fd fd76 	bl	80090a4 <GetInfoStruct>
 800b5b8:	f7fc fb52 	bl	8007c60 <SD_WriteInfoLog>

			/* Reset everything in the InfoStruct */
			ResetInfoStruct(GetInfoStruct());
 800b5bc:	f7fd fd72 	bl	80090a4 <GetInfoStruct>
 800b5c0:	f000 fea3 	bl	800c30a <ResetInfoStruct>

			DisableSD_Card();
 800b5c4:	f7fd fdb2 	bl	800912c <DisableSD_Card>
		}

		/* Reset the iteration Info struct */
		ResetInfoStruct(GetTempInfoStruct());
 800b5c8:	f7fd fd70 	bl	80090ac <GetTempInfoStruct>
 800b5cc:	f000 fe9d 	bl	800c30a <ResetInfoStruct>

		EnterStopRadioNetwork();
		//EnterStopModeForEverythingButRadio();
	}

}
 800b5d0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		SystemSleepAndWakeUp();
 800b5d4:	f7fd bf22 	b.w	800941c <SystemSleepAndWakeUp>
	else if (rS == RADIO_NETWORK && sS == SENSOR_IDLE)
 800b5d8:	2a04      	cmp	r2, #4
 800b5da:	d106      	bne.n	800b5ea <SleepStateMachine+0x82>
 800b5dc:	b92b      	cbnz	r3, 800b5ea <SleepStateMachine+0x82>
		SD_DeInit();
 800b5de:	f7fb ffd9 	bl	8007594 <SD_DeInit>
}
 800b5e2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		EnterStopRadioNetwork();
 800b5e6:	f7fe b807 	b.w	80095f8 <EnterStopRadioNetwork>
 800b5ea:	bd08      	pop	{r3, pc}
 800b5ec:	20000028 	.word	0x20000028
 800b5f0:	2000029a 	.word	0x2000029a
 800b5f4:	0800fb24 	.word	0x0800fb24
 800b5f8:	2000c5c0 	.word	0x2000c5c0
 800b5fc:	48000400 	.word	0x48000400

0800b600 <CopySettings>:
#include "mqtt.h"
#include "Global.h"

/* Copy settings from one struct to another of same type */
uint8_t CopySettings(SaraConfig *to, SaraConfig *from)
{
 800b600:	b508      	push	{r3, lr}
	if (!to || !from)
 800b602:	b128      	cbz	r0, 800b610 <CopySettings+0x10>
 800b604:	b129      	cbz	r1, 800b612 <CopySettings+0x12>
		return false;

	/* Copy structs */
	memcpy(to, from, sizeof(SaraConfig));
 800b606:	22b0      	movs	r2, #176	; 0xb0
 800b608:	f001 fb6d 	bl	800cce6 <memcpy>
	return SUCCESS;
 800b60c:	2001      	movs	r0, #1
 800b60e:	bd08      	pop	{r3, pc}
 800b610:	bd08      	pop	{r3, pc}
		return false;
 800b612:	4608      	mov	r0, r1
}
 800b614:	bd08      	pop	{r3, pc}
	...

0800b618 <ServerMessage>:

uint8_t ServerMessage(uint8_t *rxBuff)
{
 800b618:	b510      	push	{r4, lr}
 800b61a:	4604      	mov	r4, r0
	uint8_t retVal = false;

	/* Check if server returned anything */
	SaraSendCommand("AT+UMQTTC=6\r\n");
 800b61c:	4807      	ldr	r0, [pc, #28]	; (800b63c <ServerMessage+0x24>)
 800b61e:	f000 fa03 	bl	800ba28 <SaraSendCommand>
	SaraWaitForResponse(rxBuff, TX_BUFF_SIZE - 1, 2 * DEFAULT_TIMEOUT);
 800b622:	f44f 62fa 	mov.w	r2, #2000	; 0x7d0
 800b626:	21ff      	movs	r1, #255	; 0xff
 800b628:	4620      	mov	r0, r4
 800b62a:	f000 f99d 	bl	800b968 <SaraWaitForResponse>

	/* If there is a message on the topic, read it */
	if (MqttCheckRxData(rxBuff))
 800b62e:	4620      	mov	r0, r4
 800b630:	f000 f8d2 	bl	800b7d8 <MqttCheckRxData>
		retVal = true;
	}

	/* Return true or false */
	return retVal;
}
 800b634:	3000      	adds	r0, #0
 800b636:	bf18      	it	ne
 800b638:	2001      	movne	r0, #1
 800b63a:	bd10      	pop	{r4, pc}
 800b63c:	0800fb26 	.word	0x0800fb26

0800b640 <ServerDo>:

uint8_t ServerDo(char *topic)
{
 800b640:	b530      	push	{r4, r5, lr}
 800b642:	f5ad 7d2d 	sub.w	sp, sp, #692	; 0x2b4
 800b646:	4605      	mov	r5, r0
	SaraConfig *sC = GetSaraConfigurationStruct();
 800b648:	f7fd fd5c 	bl	8009104 <GetSaraConfigurationStruct>

	/* Init all buffers that are needed */
	uint8_t rxBuff[TX_BUFF_SIZE] = { 0 };
 800b64c:	f44f 7280 	mov.w	r2, #256	; 0x100
	SaraConfig *sC = GetSaraConfigurationStruct();
 800b650:	4604      	mov	r4, r0
	uint8_t rxBuff[TX_BUFF_SIZE] = { 0 };
 800b652:	2100      	movs	r1, #0
 800b654:	a82c      	add	r0, sp, #176	; 0xb0
 800b656:	f001 fb51 	bl	800ccfc <memset>
	uint8_t JSONBuff[TX_BUFF_SIZE] = { 0 };
 800b65a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800b65e:	2100      	movs	r1, #0
 800b660:	a86c      	add	r0, sp, #432	; 0x1b0
 800b662:	f001 fb4b 	bl	800ccfc <memset>

	/* Temporary struct */
	SaraConfig tempSara;

	/* Copy previous settings to temp struct */
	CopySettings(&tempSara, GetSaraConfigurationStruct());
 800b666:	f7fd fd4d 	bl	8009104 <GetSaraConfigurationStruct>
 800b66a:	4601      	mov	r1, r0
 800b66c:	4668      	mov	r0, sp
 800b66e:	f7ff ffc7 	bl	800b600 <CopySettings>

	/* Publish to testTT */
	if (MqttPublish(topic, sC->id, 0, 0))
 800b672:	2300      	movs	r3, #0
 800b674:	461a      	mov	r2, r3
 800b676:	4621      	mov	r1, r4
 800b678:	4628      	mov	r0, r5
 800b67a:	f000 f843 	bl	800b704 <MqttPublish>
 800b67e:	b918      	cbnz	r0, 800b688 <ServerDo+0x48>
	uint8_t retVal = false;
 800b680:	2000      	movs	r0, #0
			}
		}
	}
	/* Return true or false */
	return retVal;
}
 800b682:	f50d 7d2d 	add.w	sp, sp, #692	; 0x2b4
 800b686:	bd30      	pop	{r4, r5, pc}
		if (ServerMessage(rxBuff))
 800b688:	a82c      	add	r0, sp, #176	; 0xb0
 800b68a:	f7ff ffc5 	bl	800b618 <ServerMessage>
 800b68e:	2800      	cmp	r0, #0
 800b690:	d0f6      	beq.n	800b680 <ServerDo+0x40>
			if (FetchVerifyParseJSON(rxBuff, JSONBuff, &tempSara))
 800b692:	466a      	mov	r2, sp
 800b694:	a96c      	add	r1, sp, #432	; 0x1b0
 800b696:	a82c      	add	r0, sp, #176	; 0xb0
 800b698:	f000 f8e2 	bl	800b860 <FetchVerifyParseJSON>
 800b69c:	2800      	cmp	r0, #0
 800b69e:	d0ef      	beq.n	800b680 <ServerDo+0x40>
				if (!strcmp(tempSara.id, sC->id))
 800b6a0:	4621      	mov	r1, r4
 800b6a2:	4668      	mov	r0, sp
 800b6a4:	f7f4 fd9c 	bl	80001e0 <strcmp>
 800b6a8:	2800      	cmp	r0, #0
 800b6aa:	d1e9      	bne.n	800b680 <ServerDo+0x40>
					CopySettings(GetSaraConfigurationStruct(), &tempSara);
 800b6ac:	f7fd fd2a 	bl	8009104 <GetSaraConfigurationStruct>
 800b6b0:	4669      	mov	r1, sp
 800b6b2:	f7ff ffa5 	bl	800b600 <CopySettings>
					retVal = true;
 800b6b6:	2001      	movs	r0, #1
 800b6b8:	e7e3      	b.n	800b682 <ServerDo+0x42>
	...

0800b6bc <MqttConnect>:
 * */
uint8_t MqttConnect()
{
	/* Tries to connect to server, if true -> server connection successful.
	 * If false -> server connection failed */
	return SaraCheckCommand("AT+UMQTTC=1\r\n", "+UMQTTC: 1,1OK+UUMQTTC: 1,0",
 800b6bc:	f241 3288 	movw	r2, #5000	; 0x1388
 800b6c0:	4901      	ldr	r1, [pc, #4]	; (800b6c8 <MqttConnect+0xc>)
 800b6c2:	4802      	ldr	r0, [pc, #8]	; (800b6cc <MqttConnect+0x10>)
 800b6c4:	f000 b9c8 	b.w	800ba58 <SaraCheckCommand>
 800b6c8:	0800fb56 	.word	0x0800fb56
 800b6cc:	0800fb72 	.word	0x0800fb72

0800b6d0 <MqttSetHttp>:
			5 * DEFAULT_TIMEOUT);
}

/* Sets the webPage that Sara should connect against */
uint8_t MqttSetHttp(char *server)
{
 800b6d0:	b510      	push	{r4, lr}
 800b6d2:	b0c0      	sub	sp, #256	; 0x100
 800b6d4:	4604      	mov	r4, r0
	char txBuff[TX_BUFF_SIZE] = { 0 };
 800b6d6:	f44f 7280 	mov.w	r2, #256	; 0x100
 800b6da:	2100      	movs	r1, #0
 800b6dc:	4668      	mov	r0, sp
 800b6de:	f001 fb0d 	bl	800ccfc <memset>

	/* Copying to txBuff */
	sprintf(txBuff, "AT+UMQTT=2,\"%s\"\r\n", server);
 800b6e2:	4622      	mov	r2, r4
 800b6e4:	4905      	ldr	r1, [pc, #20]	; (800b6fc <MqttSetHttp+0x2c>)
 800b6e6:	4668      	mov	r0, sp
 800b6e8:	f001 feb8 	bl	800d45c <siprintf>

	/* If true, server is set. If false, server set failed */
	return SaraCheckCommand(txBuff, "+UMQTT: 2,1OK", LOW_TIMEOUT);
 800b6ec:	220a      	movs	r2, #10
 800b6ee:	4904      	ldr	r1, [pc, #16]	; (800b700 <MqttSetHttp+0x30>)
 800b6f0:	4668      	mov	r0, sp
 800b6f2:	f000 f9b1 	bl	800ba58 <SaraCheckCommand>
}
 800b6f6:	b040      	add	sp, #256	; 0x100
 800b6f8:	bd10      	pop	{r4, pc}
 800b6fa:	bf00      	nop
 800b6fc:	0800fc09 	.word	0x0800fc09
 800b700:	0800fc1b 	.word	0x0800fc1b

0800b704 <MqttPublish>:
 *
 * @return value: True/SUCCESS or False/FAILURE
 * */
uint8_t MqttPublish(const char* topic, const char* message, uint8_t QoS,
	     uint8_t retain)
{
 800b704:	b5f0      	push	{r4, r5, r6, r7, lr}
 800b706:	b0c3      	sub	sp, #268	; 0x10c
 800b708:	4606      	mov	r6, r0
 800b70a:	460f      	mov	r7, r1
 800b70c:	4614      	mov	r4, r2
 800b70e:	461d      	mov	r5, r3
	char txBuff[TX_BUFF_SIZE] = { 0 };
 800b710:	f44f 7280 	mov.w	r2, #256	; 0x100
 800b714:	2100      	movs	r1, #0
 800b716:	a802      	add	r0, sp, #8
 800b718:	f001 faf0 	bl	800ccfc <memset>

	/* Copying to txBuff */
	sprintf((char*) txBuff, "AT+UMQTTC=2,%d,%d,\"%s\",\"%s\"\r\n", QoS, retain,
 800b71c:	462b      	mov	r3, r5
 800b71e:	4622      	mov	r2, r4
 800b720:	e88d 00c0 	stmia.w	sp, {r6, r7}
 800b724:	4905      	ldr	r1, [pc, #20]	; (800b73c <MqttPublish+0x38>)
 800b726:	a802      	add	r0, sp, #8
 800b728:	f001 fe98 	bl	800d45c <siprintf>
	   topic, message);

	/* If true, publish successful */
	return SaraCheckCommand((char*) txBuff, "+UMQTTC: 2,1OK", 5 * DEFAULT_TIMEOUT);
 800b72c:	f241 3288 	movw	r2, #5000	; 0x1388
 800b730:	4903      	ldr	r1, [pc, #12]	; (800b740 <MqttPublish+0x3c>)
 800b732:	a802      	add	r0, sp, #8
 800b734:	f000 f990 	bl	800ba58 <SaraCheckCommand>
}
 800b738:	b043      	add	sp, #268	; 0x10c
 800b73a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800b73c:	0800fb9d 	.word	0x0800fb9d
 800b740:	0800fbbb 	.word	0x0800fbbb

0800b744 <MqttSubscribe>:
 2: exactly once delivery
 *
 * @return value: True/SUCCESS or False/FAILURE
 * */
uint8_t MqttSubscribe(char* topic, uint8_t QoS)
{
 800b744:	b530      	push	{r4, r5, lr}
 800b746:	b0d1      	sub	sp, #324	; 0x144
 800b748:	4605      	mov	r5, r0
 800b74a:	460c      	mov	r4, r1
	char txBuff[TX_BUFF_SIZE] = { 0 };
 800b74c:	f44f 7280 	mov.w	r2, #256	; 0x100
 800b750:	2100      	movs	r1, #0
 800b752:	a810      	add	r0, sp, #64	; 0x40
 800b754:	f001 fad2 	bl	800ccfc <memset>
	char expectedAns[64] = { 0 };
 800b758:	2240      	movs	r2, #64	; 0x40
 800b75a:	2100      	movs	r1, #0
 800b75c:	4668      	mov	r0, sp
 800b75e:	f001 facd 	bl	800ccfc <memset>

	sprintf(expectedAns, "+UMQTTC: 4,1OK");
 800b762:	4909      	ldr	r1, [pc, #36]	; (800b788 <MqttSubscribe+0x44>)
 800b764:	4668      	mov	r0, sp
 800b766:	f001 ff29 	bl	800d5bc <strcpy>

	/* Copying to txBuff */
	sprintf(txBuff, "AT+UMQTTC=4,%d,\"%s\"\r\n", QoS, topic);
 800b76a:	462b      	mov	r3, r5
 800b76c:	4622      	mov	r2, r4
 800b76e:	4907      	ldr	r1, [pc, #28]	; (800b78c <MqttSubscribe+0x48>)
 800b770:	a810      	add	r0, sp, #64	; 0x40
 800b772:	f001 fe73 	bl	800d45c <siprintf>

	/* If true, Subscribe successful */
	return SaraCheckCommand(txBuff, expectedAns, 5 * DEFAULT_TIMEOUT);
 800b776:	f241 3288 	movw	r2, #5000	; 0x1388
 800b77a:	4669      	mov	r1, sp
 800b77c:	a810      	add	r0, sp, #64	; 0x40
 800b77e:	f000 f96b 	bl	800ba58 <SaraCheckCommand>

//return true;
}
 800b782:	b051      	add	sp, #324	; 0x144
 800b784:	bd30      	pop	{r4, r5, pc}
 800b786:	bf00      	nop
 800b788:	0800fc29 	.word	0x0800fc29
 800b78c:	0800fc38 	.word	0x0800fc38

0800b790 <MqttUnSubscribe>:
 * @topic	- The topic that you would like to unsubscribe to
 *
 * @return value: True/SUCCESS or False/FAILURE
 * */
uint8_t MqttUnSubscribe(char* topic)
{
 800b790:	b510      	push	{r4, lr}
 800b792:	b0c0      	sub	sp, #256	; 0x100
 800b794:	4604      	mov	r4, r0
	char txBuff[TX_BUFF_SIZE] = { 0 };
 800b796:	f44f 7280 	mov.w	r2, #256	; 0x100
 800b79a:	2100      	movs	r1, #0
 800b79c:	4668      	mov	r0, sp
 800b79e:	f001 faad 	bl	800ccfc <memset>

	/* Copying to txBuff */
	sprintf(txBuff, "AT+UMQTTC=5,\"%s\"\r\n", topic);
 800b7a2:	4622      	mov	r2, r4
 800b7a4:	4905      	ldr	r1, [pc, #20]	; (800b7bc <MqttUnSubscribe+0x2c>)
 800b7a6:	4668      	mov	r0, sp
 800b7a8:	f001 fe58 	bl	800d45c <siprintf>

	/* If true, Unsubscription successful */
	return SaraCheckCommand(txBuff, "+UMQTTC: 5,1OK", 5 * DEFAULT_TIMEOUT);
 800b7ac:	f241 3288 	movw	r2, #5000	; 0x1388
 800b7b0:	4903      	ldr	r1, [pc, #12]	; (800b7c0 <MqttUnSubscribe+0x30>)
 800b7b2:	4668      	mov	r0, sp
 800b7b4:	f000 f950 	bl	800ba58 <SaraCheckCommand>
}
 800b7b8:	b040      	add	sp, #256	; 0x100
 800b7ba:	bd10      	pop	{r4, pc}
 800b7bc:	0800fc4e 	.word	0x0800fc4e
 800b7c0:	0800fc61 	.word	0x0800fc61

0800b7c4 <MqttDisconnect>:
 * @return value: True/SUCCESS or False/FAILURE
 * */
uint8_t MqttDisconnect()
{
	/* If true, disconnect successful */
	return SaraCheckCommand("AT+UMQTTC=0\r\n", "+UMQTTC: 0,1OK",
 800b7c4:	f241 3288 	movw	r2, #5000	; 0x1388
 800b7c8:	4901      	ldr	r1, [pc, #4]	; (800b7d0 <MqttDisconnect+0xc>)
 800b7ca:	4802      	ldr	r0, [pc, #8]	; (800b7d4 <MqttDisconnect+0x10>)
 800b7cc:	f000 b944 	b.w	800ba58 <SaraCheckCommand>
 800b7d0:	0800fb80 	.word	0x0800fb80
 800b7d4:	0800fb8f 	.word	0x0800fb8f

0800b7d8 <MqttCheckRxData>:
//	return false;
//}

/* Not used for Version 1 */
uint8_t MqttCheckRxData(uint8_t * buffRX)
{
 800b7d8:	b510      	push	{r4, lr}
	char *p;

	/* Debug */
	printf("BufferRead: %s\r\n", (char*) buffRX);
 800b7da:	4601      	mov	r1, r0
{
 800b7dc:	4604      	mov	r4, r0
	printf("BufferRead: %s\r\n", (char*) buffRX);
 800b7de:	4805      	ldr	r0, [pc, #20]	; (800b7f4 <MqttCheckRxData+0x1c>)
 800b7e0:	f001 fd9c 	bl	800d31c <iprintf>

	/* Check if message has been received */
	p = strstr((char*) buffRX, "+UUMQTTCM:");
 800b7e4:	4904      	ldr	r1, [pc, #16]	; (800b7f8 <MqttCheckRxData+0x20>)
 800b7e6:	4620      	mov	r0, r4
 800b7e8:	f001 ff05 	bl	800d5f6 <strstr>
	/* If true, continue */
	if (p != NULL) {
		return true;
	}
	return false;
}
 800b7ec:	3000      	adds	r0, #0
 800b7ee:	bf18      	it	ne
 800b7f0:	2001      	movne	r0, #1
 800b7f2:	bd10      	pop	{r4, pc}
 800b7f4:	0800fb3a 	.word	0x0800fb3a
 800b7f8:	0800fb4b 	.word	0x0800fb4b

0800b7fc <MqttParseJSONMessage>:
}

/* Parses out the first JSON string that are in the buffer */
uint8_t MqttParseJSONMessage(uint8_t *get, const char *startPattern,
		      const char *endPattern, uint8_t *set)
{
 800b7fc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800b800:	af00      	add	r7, sp, #0
 800b802:	4690      	mov	r8, r2
 800b804:	461e      	mov	r6, r3
	/* Check if the startpattern appears in the string */
	const char *iStartPattern = strstr((char*) get, startPattern);
 800b806:	f001 fef6 	bl	800d5f6 <strstr>

	/* If it appears */
	if (iStartPattern != NULL)
 800b80a:	4605      	mov	r5, r0
 800b80c:	b330      	cbz	r0, 800b85c <MqttParseJSONMessage+0x60>
    {
		/* Check if endpattern appears */
		const size_t placeEnd = strlen(endPattern);
 800b80e:	4640      	mov	r0, r8
 800b810:	f7f4 fcf0 	bl	80001f4 <strlen>
		const char *iEndPattern = strstr(iStartPattern, endPattern);
 800b814:	4641      	mov	r1, r8
		const size_t placeEnd = strlen(endPattern);
 800b816:	4604      	mov	r4, r0
		const char *iEndPattern = strstr(iStartPattern, endPattern);
 800b818:	4628      	mov	r0, r5
 800b81a:	f001 feec 	bl	800d5f6 <strstr>

		/* if it appears */
		if (iEndPattern != NULL) {
 800b81e:	b1a8      	cbz	r0, 800b84c <MqttParseJSONMessage+0x50>
			/* length of JSON will be the start of startpattern and END of endpattern */
			const size_t messageLen = iEndPattern + placeEnd - (iStartPattern);
 800b820:	4420      	add	r0, r4
 800b822:	1b44      	subs	r4, r0, r5

			/* Assign buffer */
			uint8_t ret[messageLen + 1];
 800b824:	f104 0308 	add.w	r3, r4, #8
 800b828:	f023 0307 	bic.w	r3, r3, #7
		if (iEndPattern != NULL) {
 800b82c:	46e8      	mov	r8, sp
			uint8_t ret[messageLen + 1];
 800b82e:	ebad 0d03 	sub.w	sp, sp, r3

			/* If buffer isn't null, continue */
			if (ret != NULL) {
				/* Copy the message to buffer */
				memcpy(ret, iStartPattern, messageLen);
 800b832:	4622      	mov	r2, r4
 800b834:	4629      	mov	r1, r5
 800b836:	4668      	mov	r0, sp
 800b838:	f001 fa55 	bl	800cce6 <memcpy>

				/* put an end sign to the buffer */
				ret[messageLen] = '\0';
 800b83c:	2300      	movs	r3, #0
 800b83e:	f80d 3004 	strb.w	r3, [sp, r4]
			uint8_t ret[messageLen + 1];
 800b842:	46e9      	mov	r9, sp

				/* Copy to the set buffer */
				for (int i = 0; i < messageLen; i++) {
 800b844:	42a3      	cmp	r3, r4
 800b846:	d104      	bne.n	800b852 <MqttParseJSONMessage+0x56>
					set[i] = ret[i];
				}

				/* return true */
				return true;
 800b848:	2001      	movs	r0, #1
 800b84a:	46c5      	mov	sp, r8
			}
		}
    }
	/* start/endpattern not found, return false */
	return false;
}
 800b84c:	46bd      	mov	sp, r7
 800b84e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
					set[i] = ret[i];
 800b852:	f819 2003 	ldrb.w	r2, [r9, r3]
 800b856:	54f2      	strb	r2, [r6, r3]
				for (int i = 0; i < messageLen; i++) {
 800b858:	3301      	adds	r3, #1
 800b85a:	e7f3      	b.n	800b844 <MqttParseJSONMessage+0x48>
 800b85c:	e7f6      	b.n	800b84c <MqttParseJSONMessage+0x50>
	...

0800b860 <FetchVerifyParseJSON>:
	return false;
}

/* These are used for fething settings */
uint8_t FetchVerifyParseJSON(uint8_t *get, uint8_t *set, SaraConfig *s)
{
 800b860:	b538      	push	{r3, r4, r5, lr}
 800b862:	460c      	mov	r4, r1
 800b864:	4615      	mov	r5, r2
	/* init values needed */
	uint8_t retVal = false;
	uint32_t fCrc, cCrc;

	if (MqttParseJSONMessage(get, "{\"", "\"}", set))
 800b866:	460b      	mov	r3, r1
 800b868:	4a06      	ldr	r2, [pc, #24]	; (800b884 <FetchVerifyParseJSON+0x24>)
 800b86a:	4907      	ldr	r1, [pc, #28]	; (800b888 <FetchVerifyParseJSON+0x28>)
 800b86c:	f7ff ffc6 	bl	800b7fc <MqttParseJSONMessage>
 800b870:	b130      	cbz	r0, 800b880 <FetchVerifyParseJSON+0x20>
//		{
			/* Compare CRC */
//			if (VerifyFile(set, &fCrc, &cCrc))
//			{
				/* Parse JSON into struct of choice */
				if (ParseSettingsString((char*) set, s))
 800b872:	4629      	mov	r1, r5
 800b874:	4620      	mov	r0, r4
 800b876:	f000 fc11 	bl	800c09c <ParseSettingsString>
	uint8_t retVal = false;
 800b87a:	3000      	adds	r0, #0
 800b87c:	bf18      	it	ne
 800b87e:	2001      	movne	r0, #1
				}
//			}
//		}
	}
	return retVal;
}
 800b880:	bd38      	pop	{r3, r4, r5, pc}
 800b882:	bf00      	nop
 800b884:	0800fb34 	.word	0x0800fb34
 800b888:	0800fb37 	.word	0x0800fb37

0800b88c <GetCRC>:

uint8_t GetCRC(uint8_t *get, uint32_t *cCrc)
{
 800b88c:	b570      	push	{r4, r5, r6, lr}
	uint32_t bSize = 0;

	/* Reset local CRC calculator */
	__HAL_CRC_DR_RESET(&hcrc);
 800b88e:	4c09      	ldr	r4, [pc, #36]	; (800b8b4 <GetCRC+0x28>)
 800b890:	6822      	ldr	r2, [r4, #0]
 800b892:	6893      	ldr	r3, [r2, #8]
 800b894:	f043 0301 	orr.w	r3, r3, #1
 800b898:	6093      	str	r3, [r2, #8]
{
 800b89a:	460d      	mov	r5, r1
 800b89c:	4606      	mov	r6, r0

	/* define size of string */
	bSize = strlen((char*) get);
 800b89e:	f7f4 fca9 	bl	80001f4 <strlen>

	/* Calculated CRC-32/MPEG-2 for the buffer */
	*cCrc = HAL_CRC_Accumulate(&hcrc, (uint32_t*) get, bSize);
 800b8a2:	4631      	mov	r1, r6
 800b8a4:	4602      	mov	r2, r0
 800b8a6:	4620      	mov	r0, r4
 800b8a8:	f7f6 f946 	bl	8001b38 <HAL_CRC_Accumulate>
 800b8ac:	6028      	str	r0, [r5, #0]

	return true;
}
 800b8ae:	2001      	movs	r0, #1
 800b8b0:	bd70      	pop	{r4, r5, r6, pc}
 800b8b2:	bf00      	nop
 800b8b4:	2000c498 	.word	0x2000c498

0800b8b8 <MqttPushPublishSD>:
{
 800b8b8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800b8bc:	b0c9      	sub	sp, #292	; 0x124
 800b8be:	460c      	mov	r4, r1
 800b8c0:	461e      	mov	r6, r3
 800b8c2:	4615      	mov	r5, r2
 800b8c4:	4607      	mov	r7, r0
	SaraConfig *sC = GetSaraConfigurationStruct();
 800b8c6:	f7fd fc1d 	bl	8009104 <GetSaraConfigurationStruct>
 800b8ca:	4680      	mov	r8, r0
	radioFlags *rE = GetErrorFlagsStruct();
 800b8cc:	f7fd fc1e 	bl	800910c <GetErrorFlagsStruct>
	char txBuff[256] = { 0 };
 800b8d0:	f44f 7280 	mov.w	r2, #256	; 0x100
	radioFlags *rE = GetErrorFlagsStruct();
 800b8d4:	4681      	mov	r9, r0
	char txBuff[256] = { 0 };
 800b8d6:	2100      	movs	r1, #0
 800b8d8:	a808      	add	r0, sp, #32
 800b8da:	f001 fa0f 	bl	800ccfc <memset>
	GetCRC((uint8_t*) message, &cCrc);
 800b8de:	a907      	add	r1, sp, #28
 800b8e0:	4620      	mov	r0, r4
 800b8e2:	f7ff ffd3 	bl	800b88c <GetCRC>
	sprintf((char*) txBuff, "AT+UMQTTC=2,%d,%d,\"%s\",\"$%s@%d%s^%08X#\"\r\n", QoS, retain, topic,
 800b8e6:	9b07      	ldr	r3, [sp, #28]
 800b8e8:	9304      	str	r3, [sp, #16]
 800b8ea:	9403      	str	r4, [sp, #12]
 800b8ec:	f8b9 3018 	ldrh.w	r3, [r9, #24]
 800b8f0:	9302      	str	r3, [sp, #8]
 800b8f2:	462a      	mov	r2, r5
 800b8f4:	4633      	mov	r3, r6
 800b8f6:	e88d 0180 	stmia.w	sp, {r7, r8}
 800b8fa:	490a      	ldr	r1, [pc, #40]	; (800b924 <MqttPushPublishSD+0x6c>)
 800b8fc:	a808      	add	r0, sp, #32
 800b8fe:	f001 fdad 	bl	800d45c <siprintf>
	printf("DataSentFromSara: %s", message);
 800b902:	4621      	mov	r1, r4
 800b904:	4808      	ldr	r0, [pc, #32]	; (800b928 <MqttPushPublishSD+0x70>)
 800b906:	f001 fd09 	bl	800d31c <iprintf>
	SaraCheckCommand(txBuff, "+UMQTTC: 2,1OK", LOW_TIMEOUT);
 800b90a:	220a      	movs	r2, #10
 800b90c:	4907      	ldr	r1, [pc, #28]	; (800b92c <MqttPushPublishSD+0x74>)
 800b90e:	a808      	add	r0, sp, #32
 800b910:	f000 f8a2 	bl	800ba58 <SaraCheckCommand>
	HAL_Delay(50);
 800b914:	2032      	movs	r0, #50	; 0x32
 800b916:	f7f5 fac1 	bl	8000e9c <HAL_Delay>
}
 800b91a:	2001      	movs	r0, #1
 800b91c:	b049      	add	sp, #292	; 0x124
 800b91e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800b922:	bf00      	nop
 800b924:	0800fbca 	.word	0x0800fbca
 800b928:	0800fbf4 	.word	0x0800fbf4
 800b92c:	0800fbbb 	.word	0x0800fbbb

0800b930 <USART2_Callback>:
/* Usart1 IRQ handler */
void USART2_Callback(void)
{

	/* Check if RXNE flag high */
	if ((USART2->ISR & USART_ISR_RXNE) == USART_ISR_RXNE)
 800b930:	4b0a      	ldr	r3, [pc, #40]	; (800b95c <USART2_Callback+0x2c>)
 800b932:	69da      	ldr	r2, [r3, #28]
 800b934:	0692      	lsls	r2, r2, #26
 800b936:	d510      	bpl.n	800b95a <USART2_Callback+0x2a>
	{
		/* Read Data Register on USART1 (Sara module) */
		uint8_t data = USART2->RDR;
 800b938:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800b93a:	4a09      	ldr	r2, [pc, #36]	; (800b960 <USART2_Callback+0x30>)
 800b93c:	b2db      	uxtb	r3, r3

		/* Disable \r and \n from buffer */
		if (data != '\r')
 800b93e:	2b0d      	cmp	r3, #13
 800b940:	d006      	beq.n	800b950 <USART2_Callback+0x20>
		{
			if (data != '\n')
 800b942:	2b0a      	cmp	r3, #10
 800b944:	d004      	beq.n	800b950 <USART2_Callback+0x20>
			{
				/* Add data to Buffer */
				uart_Buffer[headTail.Head] = data;
 800b946:	8811      	ldrh	r1, [r2, #0]
 800b948:	4806      	ldr	r0, [pc, #24]	; (800b964 <USART2_Callback+0x34>)
 800b94a:	5443      	strb	r3, [r0, r1]
				headTail.Head++;
 800b94c:	3101      	adds	r1, #1
 800b94e:	8011      	strh	r1, [r2, #0]
			}
		}

		/* Overflow Safety */
		if (headTail.Head > TX_BUFF_SIZE - 1)
 800b950:	8813      	ldrh	r3, [r2, #0]
 800b952:	2bff      	cmp	r3, #255	; 0xff
		{
			headTail.Head = 0;
 800b954:	bf84      	itt	hi
 800b956:	2300      	movhi	r3, #0
 800b958:	8013      	strhhi	r3, [r2, #0]
 800b95a:	4770      	bx	lr
 800b95c:	40004400 	.word	0x40004400
 800b960:	2000c638 	.word	0x2000c638
 800b964:	2000029b 	.word	0x2000029b

0800b968 <SaraWaitForResponse>:
	return SaraCheckCommand("AT+CFUN=15\r\n", "OK", DEFAULT_TIMEOUT);
}

/* Wait for response from sara module after AT command */
uint16_t SaraWaitForResponse(uint8_t *get, uint16_t count, uint32_t timeout_ms)
{
 800b968:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	uint16_t u_counter = 0;

	/* Loop for 'timeout' specified time */
	while (loop <= timeout_ms)
	{
		if (headTail.Head < headTail.Tail)
 800b96c:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 800ba24 <SaraWaitForResponse+0xbc>
{
 800b970:	4605      	mov	r5, r0
 800b972:	460e      	mov	r6, r1
 800b974:	4692      	mov	sl, r2
	uint32_t loop = 0;
 800b976:	f04f 0800 	mov.w	r8, #0
 800b97a:	464f      	mov	r7, r9
		if (headTail.Head < headTail.Tail)
 800b97c:	f8b9 4000 	ldrh.w	r4, [r9]
 800b980:	f8b9 3002 	ldrh.w	r3, [r9, #2]
 800b984:	429c      	cmp	r4, r3
		{
			u_counter = TX_BUFF_SIZE - (headTail.Tail - headTail.Head);
 800b986:	bf38      	it	cc
 800b988:	f504 7480 	addcc.w	r4, r4, #256	; 0x100
		}

		else
		{
			u_counter = headTail.Head - headTail.Tail;
 800b98c:	1ae4      	subs	r4, r4, r3
 800b98e:	b2a4      	uxth	r4, r4
		}

		/* When uart buffer has specified number of bytes, copy them */
		if (count == u_counter)
 800b990:	42b4      	cmp	r4, r6
 800b992:	d119      	bne.n	800b9c8 <SaraWaitForResponse+0x60>
		{
			/* Fetch the data back to call */
			for (int i = 0; i < count; i++)
			{
				/* Assign received buffer the values of UART buffer */
				get[i] = uart_Buffer[headTail.Tail];
 800b994:	4920      	ldr	r1, [pc, #128]	; (800ba18 <SaraWaitForResponse+0xb0>)
		if (count == u_counter)
 800b996:	462a      	mov	r2, r5

				/* If tail gets bigger than buffer */
				if (headTail.Tail > TX_BUFF_SIZE - 1)
				{
					/* Jump back to first position */
					headTail.Tail = 0;
 800b998:	2000      	movs	r0, #0
			for (int i = 0; i < count; i++)
 800b99a:	1b53      	subs	r3, r2, r5
 800b99c:	42a3      	cmp	r3, r4
 800b99e:	db07      	blt.n	800b9b0 <SaraWaitForResponse+0x48>
				}
			}
			/* Reset counter for next command */
			headTail.Tail = headTail.Head;
 800b9a0:	883b      	ldrh	r3, [r7, #0]

			/* Return number of bytes copied */
			printf("count == counter\r\n");
 800b9a2:	481e      	ldr	r0, [pc, #120]	; (800ba1c <SaraWaitForResponse+0xb4>)
			headTail.Tail = headTail.Head;
 800b9a4:	807b      	strh	r3, [r7, #2]
	}
	/* Make sure that the tail = head so that they start at same place for new command */
	headTail.Tail = headTail.Head;

	/* Return number of bytes copied */
	printf("count != counter\r\n");
 800b9a6:	f001 fd41 	bl	800d42c <puts>
	return u_counter;
}
 800b9aa:	4620      	mov	r0, r4
 800b9ac:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
				get[i] = uart_Buffer[headTail.Tail];
 800b9b0:	887b      	ldrh	r3, [r7, #2]
 800b9b2:	5ccb      	ldrb	r3, [r1, r3]
 800b9b4:	f802 3b01 	strb.w	r3, [r2], #1
				headTail.Tail++;
 800b9b8:	887b      	ldrh	r3, [r7, #2]
 800b9ba:	3301      	adds	r3, #1
 800b9bc:	b29b      	uxth	r3, r3
				if (headTail.Tail > TX_BUFF_SIZE - 1)
 800b9be:	2bff      	cmp	r3, #255	; 0xff
				headTail.Tail++;
 800b9c0:	bf94      	ite	ls
 800b9c2:	807b      	strhls	r3, [r7, #2]
					headTail.Tail = 0;
 800b9c4:	8078      	strhhi	r0, [r7, #2]
 800b9c6:	e7e8      	b.n	800b99a <SaraWaitForResponse+0x32>
		HAL_Delay(1);
 800b9c8:	2001      	movs	r0, #1
		loop += 1;
 800b9ca:	f108 0801 	add.w	r8, r8, #1
		HAL_Delay(1);
 800b9ce:	f7f5 fa65 	bl	8000e9c <HAL_Delay>
	while (loop <= timeout_ms)
 800b9d2:	45c2      	cmp	sl, r8
 800b9d4:	d2d2      	bcs.n	800b97c <SaraWaitForResponse+0x14>
	if (headTail.Head < headTail.Tail)
 800b9d6:	883c      	ldrh	r4, [r7, #0]
 800b9d8:	887b      	ldrh	r3, [r7, #2]
		get[i] = uart_Buffer[headTail.Tail];
 800b9da:	490f      	ldr	r1, [pc, #60]	; (800ba18 <SaraWaitForResponse+0xb0>)
	if (headTail.Head < headTail.Tail)
 800b9dc:	429c      	cmp	r4, r3
		u_counter = TX_BUFF_SIZE - (headTail.Tail - headTail.Head);
 800b9de:	bf38      	it	cc
 800b9e0:	f504 7480 	addcc.w	r4, r4, #256	; 0x100
		u_counter = headTail.Head - headTail.Tail;
 800b9e4:	1ae4      	subs	r4, r4, r3
 800b9e6:	b2a4      	uxth	r4, r4
 800b9e8:	42b4      	cmp	r4, r6
 800b9ea:	bf28      	it	cs
 800b9ec:	4634      	movcs	r4, r6
		if (count == u_counter)
 800b9ee:	462a      	mov	r2, r5
			headTail.Tail = 0;
 800b9f0:	2000      	movs	r0, #0
	for (int i = 0; i < u_counter; i++)
 800b9f2:	1b53      	subs	r3, r2, r5
 800b9f4:	429c      	cmp	r4, r3
 800b9f6:	dc03      	bgt.n	800ba00 <SaraWaitForResponse+0x98>
	headTail.Tail = headTail.Head;
 800b9f8:	883b      	ldrh	r3, [r7, #0]
 800b9fa:	807b      	strh	r3, [r7, #2]
	printf("count != counter\r\n");
 800b9fc:	4808      	ldr	r0, [pc, #32]	; (800ba20 <SaraWaitForResponse+0xb8>)
 800b9fe:	e7d2      	b.n	800b9a6 <SaraWaitForResponse+0x3e>
		get[i] = uart_Buffer[headTail.Tail];
 800ba00:	887b      	ldrh	r3, [r7, #2]
 800ba02:	5ccb      	ldrb	r3, [r1, r3]
 800ba04:	f802 3b01 	strb.w	r3, [r2], #1
		headTail.Tail++;
 800ba08:	887b      	ldrh	r3, [r7, #2]
 800ba0a:	3301      	adds	r3, #1
 800ba0c:	b29b      	uxth	r3, r3
		if (headTail.Tail > TX_BUFF_SIZE - 1)
 800ba0e:	2bff      	cmp	r3, #255	; 0xff
		headTail.Tail++;
 800ba10:	bf94      	ite	ls
 800ba12:	807b      	strhls	r3, [r7, #2]
			headTail.Tail = 0;
 800ba14:	8078      	strhhi	r0, [r7, #2]
 800ba16:	e7ec      	b.n	800b9f2 <SaraWaitForResponse+0x8a>
 800ba18:	2000029b 	.word	0x2000029b
 800ba1c:	0800fdb1 	.word	0x0800fdb1
 800ba20:	0800fdc3 	.word	0x0800fdc3
 800ba24:	2000c638 	.word	0x2000c638

0800ba28 <SaraSendCommand>:

/* Send Command to sara module */
void SaraSendCommand(const char *cmd)
{
 800ba28:	b510      	push	{r4, lr}
 800ba2a:	4604      	mov	r4, r0
	uint8_t len = strlen(cmd);
 800ba2c:	f7f4 fbe2 	bl	80001f4 <strlen>
 800ba30:	4b08      	ldr	r3, [pc, #32]	; (800ba54 <SaraSendCommand+0x2c>)
 800ba32:	b2c0      	uxtb	r0, r0
	uint8_t *pchar = (uint8_t*) cmd;

	/* Send characters one per one, until last char to be sent */
	for (uint8_t i = 0; i < len; i++)
 800ba34:	4621      	mov	r1, r4
 800ba36:	1b0a      	subs	r2, r1, r4
 800ba38:	b2d2      	uxtb	r2, r2
 800ba3a:	4282      	cmp	r2, r0
 800ba3c:	d303      	bcc.n	800ba46 <SaraSendCommand+0x1e>
  return (READ_BIT(USARTx->ISR, USART_ISR_TC) == (USART_ISR_TC));
 800ba3e:	69da      	ldr	r2, [r3, #28]
		 TXE flag is cleared by writing data in TDR register */
		LL_USART_TransmitData8(USART2, *pchar++);
	}

	/* Wait for TC flag to be raised for last char */
	while (!LL_USART_IsActiveFlag_TC(USART2))
 800ba40:	0652      	lsls	r2, r2, #25
 800ba42:	d5fc      	bpl.n	800ba3e <SaraSendCommand+0x16>
	{
	}

}
 800ba44:	bd10      	pop	{r4, pc}
  return (READ_BIT(USARTx->ISR, USART_ISR_TXE) == (USART_ISR_TXE));
 800ba46:	69da      	ldr	r2, [r3, #28]
		while (!LL_USART_IsActiveFlag_TXE(USART2))
 800ba48:	0612      	lsls	r2, r2, #24
 800ba4a:	d5fc      	bpl.n	800ba46 <SaraSendCommand+0x1e>
  * @param  Value between Min_Data=0x00 and Max_Data=0xFF
  * @retval None
  */
__STATIC_INLINE void LL_USART_TransmitData8(USART_TypeDef *USARTx, uint8_t Value)
{
  USARTx->TDR = Value;
 800ba4c:	f811 2b01 	ldrb.w	r2, [r1], #1
 800ba50:	851a      	strh	r2, [r3, #40]	; 0x28
 800ba52:	e7f0      	b.n	800ba36 <SaraSendCommand+0xe>
 800ba54:	40004400 	.word	0x40004400

0800ba58 <SaraCheckCommand>:

/* Send command and check if the received command is as expected */
uint8_t SaraCheckCommand(const char *sendCommand, const char *receiveCommand, uint32_t timeout_ms)
{
 800ba58:	b5f0      	push	{r4, r5, r6, r7, lr}
 800ba5a:	4607      	mov	r7, r0
 800ba5c:	b0c1      	sub	sp, #260	; 0x104
	/* Get length of expected response */
	uint8_t len = strlen(receiveCommand);
 800ba5e:	4608      	mov	r0, r1
{
 800ba60:	460d      	mov	r5, r1
 800ba62:	4616      	mov	r6, r2
	uint8_t len = strlen(receiveCommand);
 800ba64:	f7f4 fbc6 	bl	80001f4 <strlen>

	/* Init local receiveBuffer to compare against expected response */
	uint8_t receiveBuff[TX_BUFF_SIZE] = { 0 };
 800ba68:	f44f 7280 	mov.w	r2, #256	; 0x100
 800ba6c:	2100      	movs	r1, #0
	uint8_t len = strlen(receiveCommand);
 800ba6e:	4604      	mov	r4, r0
	uint8_t receiveBuff[TX_BUFF_SIZE] = { 0 };
 800ba70:	4668      	mov	r0, sp
 800ba72:	f001 f943 	bl	800ccfc <memset>

	/* Send desired command to Sara module */
	SaraSendCommand(sendCommand);

	/* Wait for response from Sara module with the given length of expected response */
	SaraWaitForResponse(receiveBuff, len, timeout_ms);
 800ba76:	b2e4      	uxtb	r4, r4
	SaraSendCommand(sendCommand);
 800ba78:	4638      	mov	r0, r7
 800ba7a:	f7ff ffd5 	bl	800ba28 <SaraSendCommand>
	SaraWaitForResponse(receiveBuff, len, timeout_ms);
 800ba7e:	4632      	mov	r2, r6
 800ba80:	4621      	mov	r1, r4
 800ba82:	4668      	mov	r0, sp
 800ba84:	f7ff ff70 	bl	800b968 <SaraWaitForResponse>

	/* Debug */
	printf("Received data: %s, Expected Data: %s\r\n", receiveBuff, receiveCommand);
 800ba88:	462a      	mov	r2, r5
 800ba8a:	4669      	mov	r1, sp
 800ba8c:	4808      	ldr	r0, [pc, #32]	; (800bab0 <SaraCheckCommand+0x58>)
 800ba8e:	f001 fc45 	bl	800d31c <iprintf>

	/* Loop through both Buffers to see if they match */
	for (int i = 0; i < len; i++)
 800ba92:	2300      	movs	r3, #0
 800ba94:	42a3      	cmp	r3, r4
 800ba96:	db02      	blt.n	800ba9e <SaraCheckCommand+0x46>
			return false;
		}
	}

	/* If all element do match, print the response and the expected response */
	return true;
 800ba98:	2001      	movs	r0, #1

}
 800ba9a:	b041      	add	sp, #260	; 0x104
 800ba9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (receiveBuff[i] != receiveCommand[i])
 800ba9e:	f81d 1003 	ldrb.w	r1, [sp, r3]
 800baa2:	5cea      	ldrb	r2, [r5, r3]
 800baa4:	4291      	cmp	r1, r2
 800baa6:	d101      	bne.n	800baac <SaraCheckCommand+0x54>
	for (int i = 0; i < len; i++)
 800baa8:	3301      	adds	r3, #1
 800baaa:	e7f3      	b.n	800ba94 <SaraCheckCommand+0x3c>
			return false;
 800baac:	2000      	movs	r0, #0
 800baae:	e7f4      	b.n	800ba9a <SaraCheckCommand+0x42>
 800bab0:	0800fcdf 	.word	0x0800fcdf

0800bab4 <StartUpSara>:
{
 800bab4:	b510      	push	{r4, lr}
	LED_Blink();
 800bab6:	f000 ffdd 	bl	800ca74 <LED_Blink>
	DisEnableRadioPin(1);
 800baba:	2001      	movs	r0, #1
 800babc:	f7fe f98e 	bl	8009ddc <DisEnableRadioPin>
	HAL_Delay(1000);
 800bac0:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800bac4:	f7f5 f9ea 	bl	8000e9c <HAL_Delay>
	if (SaraCheckCommand("AT\r\n", "OK", LOW_TIMEOUT))
 800bac8:	220a      	movs	r2, #10
 800baca:	4912      	ldr	r1, [pc, #72]	; (800bb14 <StartUpSara+0x60>)
 800bacc:	4812      	ldr	r0, [pc, #72]	; (800bb18 <StartUpSara+0x64>)
 800bace:	f7ff ffc3 	bl	800ba58 <SaraCheckCommand>
 800bad2:	4604      	mov	r4, r0
		return true;
 800bad4:	2001      	movs	r0, #1
	if (SaraCheckCommand("AT\r\n", "OK", LOW_TIMEOUT))
 800bad6:	b9e4      	cbnz	r4, 800bb12 <StartUpSara+0x5e>
	DisEnableSaraPin(1);
 800bad8:	f7fe f9b6 	bl	8009e48 <DisEnableSaraPin>
	HAL_Delay(1050);
 800badc:	f240 401a 	movw	r0, #1050	; 0x41a
 800bae0:	f7f5 f9dc 	bl	8000e9c <HAL_Delay>
	DisEnableSaraPin(0);
 800bae4:	4620      	mov	r0, r4
 800bae6:	f7fe f9af 	bl	8009e48 <DisEnableSaraPin>
	HAL_Delay(5000);
 800baea:	f241 3088 	movw	r0, #5000	; 0x1388
 800baee:	f7f5 f9d5 	bl	8000e9c <HAL_Delay>
	LED_Blink();
 800baf2:	f000 ffbf 	bl	800ca74 <LED_Blink>
  return (uint8_t)(READ_BIT(USARTx->RDR, USART_RDR_RDR));
 800baf6:	4b09      	ldr	r3, [pc, #36]	; (800bb1c <StartUpSara+0x68>)
	if (SaraCheckCommand("AT\r\n", "ATOK", LOW_TIMEOUT))
 800baf8:	4909      	ldr	r1, [pc, #36]	; (800bb20 <StartUpSara+0x6c>)
 800bafa:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
	headTail.Head = 0;
 800bafc:	4b09      	ldr	r3, [pc, #36]	; (800bb24 <StartUpSara+0x70>)
	if (SaraCheckCommand("AT\r\n", "ATOK", LOW_TIMEOUT))
 800bafe:	4806      	ldr	r0, [pc, #24]	; (800bb18 <StartUpSara+0x64>)
	headTail.Head = 0;
 800bb00:	801c      	strh	r4, [r3, #0]
	if (SaraCheckCommand("AT\r\n", "ATOK", LOW_TIMEOUT))
 800bb02:	220a      	movs	r2, #10
	headTail.Tail = 0;
 800bb04:	805c      	strh	r4, [r3, #2]
	if (SaraCheckCommand("AT\r\n", "ATOK", LOW_TIMEOUT))
 800bb06:	f7ff ffa7 	bl	800ba58 <SaraCheckCommand>
		return true;
 800bb0a:	3000      	adds	r0, #0
 800bb0c:	bf18      	it	ne
 800bb0e:	2001      	movne	r0, #1
 800bb10:	bd10      	pop	{r4, pc}
}
 800bb12:	bd10      	pop	{r4, pc}
 800bb14:	0800fd39 	.word	0x0800fd39
 800bb18:	0800fd9f 	.word	0x0800fd9f
 800bb1c:	40004400 	.word	0x40004400
 800bb20:	0800fdd5 	.word	0x0800fdd5
 800bb24:	2000c638 	.word	0x2000c638

0800bb28 <SaraPowerDown>:
	return SaraCheckCommand("AT+CPWROFF\r\n", "OK", DEFAULT_TIMEOUT);
 800bb28:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800bb2c:	4901      	ldr	r1, [pc, #4]	; (800bb34 <SaraPowerDown+0xc>)
 800bb2e:	4802      	ldr	r0, [pc, #8]	; (800bb38 <SaraPowerDown+0x10>)
 800bb30:	f7ff bf92 	b.w	800ba58 <SaraCheckCommand>
 800bb34:	0800fd39 	.word	0x0800fd39
 800bb38:	0800fda4 	.word	0x0800fda4

0800bb3c <SaraDisableEchoMode>:
{
 800bb3c:	b508      	push	{r3, lr}
	if (SaraCheckCommand("ATE0\r\n", "ATE0OK", LOW_TIMEOUT))
 800bb3e:	220a      	movs	r2, #10
 800bb40:	4907      	ldr	r1, [pc, #28]	; (800bb60 <SaraDisableEchoMode+0x24>)
 800bb42:	4808      	ldr	r0, [pc, #32]	; (800bb64 <SaraDisableEchoMode+0x28>)
 800bb44:	f7ff ff88 	bl	800ba58 <SaraCheckCommand>
 800bb48:	b940      	cbnz	r0, 800bb5c <SaraDisableEchoMode+0x20>
	else if (SaraCheckCommand("ATE0\r\n", "OK", LOW_TIMEOUT))
 800bb4a:	220a      	movs	r2, #10
 800bb4c:	4906      	ldr	r1, [pc, #24]	; (800bb68 <SaraDisableEchoMode+0x2c>)
 800bb4e:	4805      	ldr	r0, [pc, #20]	; (800bb64 <SaraDisableEchoMode+0x28>)
 800bb50:	f7ff ff82 	bl	800ba58 <SaraCheckCommand>
		return true;
 800bb54:	3000      	adds	r0, #0
 800bb56:	bf18      	it	ne
 800bb58:	2001      	movne	r0, #1
 800bb5a:	bd08      	pop	{r3, pc}
 800bb5c:	2001      	movs	r0, #1
}
 800bb5e:	bd08      	pop	{r3, pc}
 800bb60:	0800fd35 	.word	0x0800fd35
 800bb64:	0800fd3c 	.word	0x0800fd3c
 800bb68:	0800fd39 	.word	0x0800fd39

0800bb6c <SaraCheckSimStatus>:
	return SaraCheckCommand(
 800bb6c:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800bb70:	4901      	ldr	r1, [pc, #4]	; (800bb78 <SaraCheckSimStatus+0xc>)
 800bb72:	4802      	ldr	r0, [pc, #8]	; (800bb7c <SaraCheckSimStatus+0x10>)
 800bb74:	f7ff bf70 	b.w	800ba58 <SaraCheckCommand>
 800bb78:	0800fd06 	.word	0x0800fd06
 800bb7c:	0800fd15 	.word	0x0800fd15

0800bb80 <SaraInitAtCommands>:
{
 800bb80:	b508      	push	{r3, lr}
	if (!SaraDisableEchoMode())
 800bb82:	f7ff ffdb 	bl	800bb3c <SaraDisableEchoMode>
 800bb86:	b908      	cbnz	r0, 800bb8c <SaraInitAtCommands+0xc>
		return false;
 800bb88:	2000      	movs	r0, #0
 800bb8a:	bd08      	pop	{r3, pc}
	if (!SaraCheckCommand("AT+UGPIOC=16,2\r\n", "OK", LOW_TIMEOUT))
 800bb8c:	220a      	movs	r2, #10
 800bb8e:	4906      	ldr	r1, [pc, #24]	; (800bba8 <SaraInitAtCommands+0x28>)
 800bb90:	4806      	ldr	r0, [pc, #24]	; (800bbac <SaraInitAtCommands+0x2c>)
 800bb92:	f7ff ff61 	bl	800ba58 <SaraCheckCommand>
 800bb96:	2800      	cmp	r0, #0
 800bb98:	d0f6      	beq.n	800bb88 <SaraInitAtCommands+0x8>
	if (!SaraCheckSimStatus())
 800bb9a:	f7ff ffe7 	bl	800bb6c <SaraCheckSimStatus>
		return false;
 800bb9e:	3000      	adds	r0, #0
 800bba0:	bf18      	it	ne
 800bba2:	2001      	movne	r0, #1
}
 800bba4:	bd08      	pop	{r3, pc}
 800bba6:	bf00      	nop
 800bba8:	0800fd39 	.word	0x0800fd39
 800bbac:	0800fd8e 	.word	0x0800fd8e

0800bbb0 <SARA_getRealTimeClock>:

/* Gets the internet clock from Sara */
void SARA_getRealTimeClock(char *time)
{
 800bbb0:	b510      	push	{r4, lr}
 800bbb2:	b090      	sub	sp, #64	; 0x40
	int i = 0;
	char *p;
	uint8_t tmp[64] = { '\0' };
 800bbb4:	2240      	movs	r2, #64	; 0x40
 800bbb6:	2100      	movs	r1, #0
{
 800bbb8:	4604      	mov	r4, r0
	uint8_t tmp[64] = { '\0' };
 800bbba:	4668      	mov	r0, sp
 800bbbc:	f001 f89e 	bl	800ccfc <memset>

	/* Command to Sara to send the internet clock */
	SaraSendCommand("AT+CCLK?\r");
 800bbc0:	480b      	ldr	r0, [pc, #44]	; (800bbf0 <SARA_getRealTimeClock+0x40>)
 800bbc2:	f7ff ff31 	bl	800ba28 <SaraSendCommand>

	/* Wait for Response with the clock */
	SaraWaitForResponse(tmp, sizeof tmp - 1, 100);
 800bbc6:	213f      	movs	r1, #63	; 0x3f
 800bbc8:	2264      	movs	r2, #100	; 0x64
 800bbca:	4668      	mov	r0, sp
 800bbcc:	f7ff fecc 	bl	800b968 <SaraWaitForResponse>

	/* See if there is a "+CCLK:" in the answer */
	if (NULL != (p = strstr((char*) tmp, "+CCLK:")))
 800bbd0:	4908      	ldr	r1, [pc, #32]	; (800bbf4 <SARA_getRealTimeClock+0x44>)
 800bbd2:	4668      	mov	r0, sp
 800bbd4:	f001 fd0f 	bl	800d5f6 <strstr>
 800bbd8:	b128      	cbz	r0, 800bbe6 <SARA_getRealTimeClock+0x36>
 800bbda:	3007      	adds	r0, #7
	{
		i = 8;
		while (*(p + i) != '\"' && *(p + i) != '\0')
 800bbdc:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 800bbe0:	2b22      	cmp	r3, #34	; 0x22
 800bbe2:	d000      	beq.n	800bbe6 <SARA_getRealTimeClock+0x36>
 800bbe4:	b90b      	cbnz	r3, 800bbea <SARA_getRealTimeClock+0x3a>
	else
	{
		/* Read Real Time Clock Failed */
		return;
	}
}
 800bbe6:	b010      	add	sp, #64	; 0x40
 800bbe8:	bd10      	pop	{r4, pc}
			*(time++) = *(p + i);
 800bbea:	f804 3b01 	strb.w	r3, [r4], #1
 800bbee:	e7f5      	b.n	800bbdc <SARA_getRealTimeClock+0x2c>
 800bbf0:	0800fcce 	.word	0x0800fcce
 800bbf4:	0800fcd8 	.word	0x0800fcd8

0800bbf8 <GMTcalculator>:

/* Calculate the time after GMT conversion and assign it to timestruct when sara last was connected */
uint8_t GMTcalculator(int *year, int *month, int *day, int *hour, int *minute, int *second,
		int *GMT, Time *timeSaraLastConnected)
{
 800bbf8:	b530      	push	{r4, r5, lr}
 800bbfa:	b08b      	sub	sp, #44	; 0x2c
	int multiplier = *GMT;

	timeGMT.tm_year = 100 + *year;
	timeGMT.tm_mon = *month - 1;
	timeGMT.tm_mday = *day;
	timeGMT.tm_hour = *hour;
 800bbfc:	681b      	ldr	r3, [r3, #0]
	int multiplier = *GMT;
 800bbfe:	9d10      	ldr	r5, [sp, #64]	; 0x40
	timeGMT.tm_hour = *hour;
 800bc00:	9303      	str	r3, [sp, #12]
	timeGMT.tm_min = *minute + multiplier * 15;
 800bc02:	9b0e      	ldr	r3, [sp, #56]	; 0x38
	int multiplier = *GMT;
 800bc04:	682d      	ldr	r5, [r5, #0]
	timeGMT.tm_min = *minute + multiplier * 15;
 800bc06:	681b      	ldr	r3, [r3, #0]
	timeGMT.tm_year = 100 + *year;
 800bc08:	6800      	ldr	r0, [r0, #0]
	timeGMT.tm_mon = *month - 1;
 800bc0a:	6809      	ldr	r1, [r1, #0]
	timeGMT.tm_mday = *day;
 800bc0c:	6812      	ldr	r2, [r2, #0]
{
 800bc0e:	9c11      	ldr	r4, [sp, #68]	; 0x44
	timeGMT.tm_mday = *day;
 800bc10:	9204      	str	r2, [sp, #16]
	timeGMT.tm_min = *minute + multiplier * 15;
 800bc12:	ebc5 1505 	rsb	r5, r5, r5, lsl #4
 800bc16:	441d      	add	r5, r3
	timeGMT.tm_sec = *second;
 800bc18:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
	timeGMT.tm_min = *minute + multiplier * 15;
 800bc1a:	9502      	str	r5, [sp, #8]
	timeGMT.tm_sec = *second;
 800bc1c:	681b      	ldr	r3, [r3, #0]
 800bc1e:	9301      	str	r3, [sp, #4]
	timeGMT.tm_year = 100 + *year;
 800bc20:	3064      	adds	r0, #100	; 0x64
	timeGMT.tm_isdst = 0;
 800bc22:	2300      	movs	r3, #0
	timeGMT.tm_mon = *month - 1;
 800bc24:	3901      	subs	r1, #1
	timeGMT.tm_year = 100 + *year;
 800bc26:	9006      	str	r0, [sp, #24]
	timeGMT.tm_wday = 0;
	timeGMT.tm_yday = 0;

//printf("The current date/time is: %s", asctime(&timeGMT));

	mktime(&timeGMT);
 800bc28:	a801      	add	r0, sp, #4
	timeGMT.tm_mon = *month - 1;
 800bc2a:	9105      	str	r1, [sp, #20]
	timeGMT.tm_isdst = 0;
 800bc2c:	9309      	str	r3, [sp, #36]	; 0x24
	timeGMT.tm_wday = 0;
 800bc2e:	9307      	str	r3, [sp, #28]
	timeGMT.tm_yday = 0;
 800bc30:	9308      	str	r3, [sp, #32]
	mktime(&timeGMT);
 800bc32:	f001 f94b 	bl	800cecc <mktime>

	timeSaraLastConnected->Year = (uint8_t) ((timeGMT.tm_year - 100) & 0xFF);
 800bc36:	9b06      	ldr	r3, [sp, #24]
 800bc38:	3b64      	subs	r3, #100	; 0x64
 800bc3a:	7023      	strb	r3, [r4, #0]
	timeSaraLastConnected->Month = (uint8_t) ((timeGMT.tm_mon + 1) & 0xFF);
 800bc3c:	9b05      	ldr	r3, [sp, #20]
 800bc3e:	3301      	adds	r3, #1
 800bc40:	7063      	strb	r3, [r4, #1]
	timeSaraLastConnected->Day = (uint8_t) (timeGMT.tm_mday & 0xFF);
 800bc42:	9b04      	ldr	r3, [sp, #16]
 800bc44:	70a3      	strb	r3, [r4, #2]
	timeSaraLastConnected->Hour = (uint8_t) (timeGMT.tm_hour & 0xFF);
 800bc46:	9b03      	ldr	r3, [sp, #12]
 800bc48:	70e3      	strb	r3, [r4, #3]
	timeSaraLastConnected->Minute = (uint8_t) (timeGMT.tm_min & 0xFF);
 800bc4a:	9b02      	ldr	r3, [sp, #8]
 800bc4c:	7123      	strb	r3, [r4, #4]
	timeSaraLastConnected->Second = (uint8_t) (timeGMT.tm_sec & 0xFF);
 800bc4e:	9b01      	ldr	r3, [sp, #4]
 800bc50:	7163      	strb	r3, [r4, #5]

	printf("The current date/time is: %s", asctime(&timeGMT));
 800bc52:	a801      	add	r0, sp, #4
 800bc54:	f000 ffbe 	bl	800cbd4 <asctime>
 800bc58:	4601      	mov	r1, r0
 800bc5a:	4803      	ldr	r0, [pc, #12]	; (800bc68 <GMTcalculator+0x70>)
 800bc5c:	f001 fb5e 	bl	800d31c <iprintf>

	return true;
}
 800bc60:	2001      	movs	r0, #1
 800bc62:	b00b      	add	sp, #44	; 0x2c
 800bc64:	bd30      	pop	{r4, r5, pc}
 800bc66:	bf00      	nop
 800bc68:	0800fc70 	.word	0x0800fc70

0800bc6c <SaraCompareRealTimeClock>:

/* Compare MCU and network clock */
uint8_t SaraCompareRealTimeClock(char *time, Time *timeSaraLastConnected, Time *mcuClock)
{
 800bc6c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800bc70:	b08f      	sub	sp, #60	; 0x3c
	int year, month, day, hour, minute, second;
	int GMT = 0;

	/* Extracts year, month, day, hour, minute, second, NOT SURE GMT WORKS */
	if (6
			<= (sscanf(
 800bc72:	af0d      	add	r7, sp, #52	; 0x34
 800bc74:	ae0c      	add	r6, sp, #48	; 0x30
 800bc76:	ad0b      	add	r5, sp, #44	; 0x2c
 800bc78:	f10d 0b28 	add.w	fp, sp, #40	; 0x28
 800bc7c:	f10d 0a24 	add.w	sl, sp, #36	; 0x24
{
 800bc80:	4688      	mov	r8, r1
 800bc82:	4691      	mov	r9, r2
	int GMT = 0;
 800bc84:	2400      	movs	r4, #0
			<= (sscanf(
 800bc86:	9704      	str	r7, [sp, #16]
 800bc88:	9603      	str	r6, [sp, #12]
 800bc8a:	9502      	str	r5, [sp, #8]
 800bc8c:	f8cd b004 	str.w	fp, [sp, #4]
 800bc90:	f8cd a000 	str.w	sl, [sp]
 800bc94:	ab08      	add	r3, sp, #32
 800bc96:	aa07      	add	r2, sp, #28
 800bc98:	4921      	ldr	r1, [pc, #132]	; (800bd20 <SaraCompareRealTimeClock+0xb4>)
	int GMT = 0;
 800bc9a:	940d      	str	r4, [sp, #52]	; 0x34
			<= (sscanf(
 800bc9c:	f001 fc02 	bl	800d4a4 <siscanf>
	if (6
 800bca0:	2805      	cmp	r0, #5
 800bca2:	dd38      	ble.n	800bd16 <SaraCompareRealTimeClock+0xaa>
					(int*) &second,
					&GMT)))
	{
		/* Sometimes the Internet clock reads wrong (from start of time) this is
		 * fail-safe, this means that the code needs to be updated before 2059 */
		if (year > 60)
 800bca4:	9b07      	ldr	r3, [sp, #28]
 800bca6:	2b3c      	cmp	r3, #60	; 0x3c
 800bca8:	dc35      	bgt.n	800bd16 <SaraCompareRealTimeClock+0xaa>
		{
			return false;
		}

		// Convert Time zone aquired by GMT (each GMT is "worth" 15min)
		GMTcalculator(&year, &month, &day, &hour, &minute, &second, &GMT, timeSaraLastConnected);
 800bcaa:	465b      	mov	r3, fp
 800bcac:	4652      	mov	r2, sl
 800bcae:	a908      	add	r1, sp, #32
 800bcb0:	e88d 01e0 	stmia.w	sp, {r5, r6, r7, r8}
 800bcb4:	a807      	add	r0, sp, #28
 800bcb6:	f7ff ff9f 	bl	800bbf8 <GMTcalculator>
	{
		return false;
	}

	/* Gets time on MCU */
	GetTime(mcuClock);
 800bcba:	4648      	mov	r0, r9
 800bcbc:	f000 fe8e 	bl	800c9dc <GetTime>

	printTime(mcuClock);
 800bcc0:	4648      	mov	r0, r9
 800bcc2:	f000 fe33 	bl	800c92c <printTime>

	/* Compares the two clocks */
	int32_t differenceSeconds = RTC_GetElapsedSeconds(timeSaraLastConnected, mcuClock);
 800bcc6:	4649      	mov	r1, r9
 800bcc8:	4640      	mov	r0, r8
 800bcca:	f000 fe41 	bl	800c950 <RTC_GetElapsedSeconds>

	/* If the difference in seconds are too big (15 sec now, can be re-defined)
	 * change the MCU clock to internet clock */
	if (abs(differenceSeconds) > MAX_SECOND_DIFFERENCE)
 800bcce:	2800      	cmp	r0, #0
 800bcd0:	bfb8      	it	lt
 800bcd2:	4240      	neglt	r0, r0
 800bcd4:	280f      	cmp	r0, #15
 800bcd6:	dd1c      	ble.n	800bd12 <SaraCompareRealTimeClock+0xa6>
	{
		/* Change the MCU clock to the network clock */
		sDateGT.Year = timeSaraLastConnected->Year;
 800bcd8:	4d12      	ldr	r5, [pc, #72]	; (800bd24 <SaraCompareRealTimeClock+0xb8>)
 800bcda:	f898 3000 	ldrb.w	r3, [r8]
 800bcde:	70eb      	strb	r3, [r5, #3]
		sDateGT.Month = timeSaraLastConnected->Month;
 800bce0:	f898 3001 	ldrb.w	r3, [r8, #1]
		sDateGT.Date = timeSaraLastConnected->Day;
		timeStructGT.Hours = timeSaraLastConnected->Hour;
 800bce4:	4910      	ldr	r1, [pc, #64]	; (800bd28 <SaraCompareRealTimeClock+0xbc>)
		sDateGT.Month = timeSaraLastConnected->Month;
 800bce6:	706b      	strb	r3, [r5, #1]
		sDateGT.Date = timeSaraLastConnected->Day;
 800bce8:	f898 3002 	ldrb.w	r3, [r8, #2]
 800bcec:	70ab      	strb	r3, [r5, #2]
		timeStructGT.Hours = timeSaraLastConnected->Hour;
 800bcee:	f898 3003 	ldrb.w	r3, [r8, #3]
 800bcf2:	700b      	strb	r3, [r1, #0]
		timeStructGT.Minutes = timeSaraLastConnected->Minute;
 800bcf4:	f898 3004 	ldrb.w	r3, [r8, #4]
 800bcf8:	704b      	strb	r3, [r1, #1]
		timeStructGT.Seconds = timeSaraLastConnected->Second;

		/* Set the time of MCU */
		HAL_RTC_SetTime(&hrtc, &timeStructGT, RTC_FORMAT_BIN);
 800bcfa:	4622      	mov	r2, r4
		timeStructGT.Seconds = timeSaraLastConnected->Second;
 800bcfc:	f898 3005 	ldrb.w	r3, [r8, #5]
		HAL_RTC_SetTime(&hrtc, &timeStructGT, RTC_FORMAT_BIN);
 800bd00:	480a      	ldr	r0, [pc, #40]	; (800bd2c <SaraCompareRealTimeClock+0xc0>)
		timeStructGT.Seconds = timeSaraLastConnected->Second;
 800bd02:	708b      	strb	r3, [r1, #2]
		HAL_RTC_SetTime(&hrtc, &timeStructGT, RTC_FORMAT_BIN);
 800bd04:	f7f7 fe2c 	bl	8003960 <HAL_RTC_SetTime>
		HAL_RTC_SetDate(&hrtc, &sDateGT, RTC_FORMAT_BIN);
 800bd08:	4622      	mov	r2, r4
 800bd0a:	4629      	mov	r1, r5
 800bd0c:	4807      	ldr	r0, [pc, #28]	; (800bd2c <SaraCompareRealTimeClock+0xc0>)
 800bd0e:	f7f7 fea0 	bl	8003a52 <HAL_RTC_SetDate>
	}

	return true;
 800bd12:	2001      	movs	r0, #1
 800bd14:	e000      	b.n	800bd18 <SaraCompareRealTimeClock+0xac>
		return false;
 800bd16:	4620      	mov	r0, r4
}
 800bd18:	b00f      	add	sp, #60	; 0x3c
 800bd1a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800bd1e:	bf00      	nop
 800bd20:	0800fd20 	.word	0x0800fd20
 800bd24:	200037f6 	.word	0x200037f6
 800bd28:	200008d0 	.word	0x200008d0
 800bd2c:	2000c59c 	.word	0x2000c59c

0800bd30 <SaraGetSignalStrength>:
	return false;
}

/* Gets signal strength indication */
uint8_t SaraGetSignalStrength()
{
 800bd30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800bd34:	f5ad 6d83 	sub.w	sp, sp, #1048	; 0x418
 800bd38:	af06      	add	r7, sp, #24

	uint8_t rxBuff[1024] = { 0 };
 800bd3a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800bd3e:	2100      	movs	r1, #0
 800bd40:	4638      	mov	r0, r7
 800bd42:	f000 ffdb 	bl	800ccfc <memset>
	/* Sending command to SARA and reads reply */
	SaraSendCommand("AT+CSQ\r\n");
 800bd46:	4824      	ldr	r0, [pc, #144]	; (800bdd8 <SaraGetSignalStrength+0xa8>)
 800bd48:	f7ff fe6e 	bl	800ba28 <SaraSendCommand>
	SaraWaitForResponse(rxBuff, 1024, LOW_TIMEOUT);
 800bd4c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800bd50:	220a      	movs	r2, #10
 800bd52:	4638      	mov	r0, r7
 800bd54:	f7ff fe08 	bl	800b968 <SaraWaitForResponse>
	/* Define where in the answer the CSQ will be */
	const char* startPattern = ": ";
	const char* endPattern = ",";

	/* Checks if the startPattern appears, otherwise the reply hasn't arrived */
	const char *iStartPattern = strstr((char*) rxBuff, startPattern);
 800bd58:	4920      	ldr	r1, [pc, #128]	; (800bddc <SaraGetSignalStrength+0xac>)
 800bd5a:	4638      	mov	r0, r7
 800bd5c:	f001 fc4b 	bl	800d5f6 <strstr>
	if (iStartPattern != NULL)
 800bd60:	b390      	cbz	r0, 800bdc8 <SaraGetSignalStrength+0x98>
	{
		/* Jump to the start of message */
		const size_t placeStart = strlen(startPattern);

		/* Check if there is an endPattern, otherwise return false */
		const char *iEndPattern = strstr(iStartPattern + placeStart, endPattern);
 800bd62:	1c84      	adds	r4, r0, #2
 800bd64:	212c      	movs	r1, #44	; 0x2c
 800bd66:	4620      	mov	r0, r4
 800bd68:	f001 fc1a 	bl	800d5a0 <strchr>

		/* If iEndPattern is in the array (endPattern occurs), enter loop */
		if (iEndPattern != NULL)
 800bd6c:	b360      	cbz	r0, 800bdc8 <SaraGetSignalStrength+0x98>
		{
			/* Define message length (End - Start) */
			const size_t messageLen = iEndPattern - (iStartPattern + placeStart);
 800bd6e:	1b06      	subs	r6, r0, r4

			/* Assign an array that matches that length */
			char *ret[messageLen];
 800bd70:	00b3      	lsls	r3, r6, #2
 800bd72:	330a      	adds	r3, #10
 800bd74:	f023 0307 	bic.w	r3, r3, #7
		{
 800bd78:	466d      	mov	r5, sp
			char *ret[messageLen];
 800bd7a:	ebad 0d03 	sub.w	sp, sp, r3
 800bd7e:	ab06      	add	r3, sp, #24
			if (ret != NULL)

			{
				/* Assign a signal strength variable */
				uint16_t sigSTR;
				memcpy(ret, iStartPattern + placeStart, messageLen);
 800bd80:	4632      	mov	r2, r6
 800bd82:	4621      	mov	r1, r4
 800bd84:	4618      	mov	r0, r3
 800bd86:	f000 ffae 	bl	800cce6 <memcpy>
				ret[messageLen] = '\0';
 800bd8a:	2400      	movs	r4, #0
 800bd8c:	f840 4026 	str.w	r4, [r0, r6, lsl #2]

				/* Signal Strength is equal to the processed message */
				sigSTR = atoi((char*) ret);
 800bd90:	f000 ff5c 	bl	800cc4c <atoi>
 800bd94:	b286      	uxth	r6, r0

				/* Add to InfoLog so that one can see the RSSI in Info */
				InfoLogAdd(ERRORLEVEL_WARNING,
 800bd96:	f7fd f989 	bl	80090ac <GetTempInfoStruct>
 800bd9a:	2312      	movs	r3, #18
 800bd9c:	9300      	str	r3, [sp, #0]
 800bd9e:	2314      	movs	r3, #20
 800bda0:	9004      	str	r0, [sp, #16]
 800bda2:	2231      	movs	r2, #49	; 0x31
 800bda4:	4618      	mov	r0, r3
 800bda6:	211b      	movs	r1, #27
 800bda8:	9403      	str	r4, [sp, #12]
 800bdaa:	9602      	str	r6, [sp, #8]
 800bdac:	9401      	str	r4, [sp, #4]
 800bdae:	f000 fac3 	bl	800c338 <InfoLogAdd>
				LOG_FUNC_STATE,
				LOG_SUB_RSSI,
				LOG_TYPE_READ,
				LOG_STATUS_PASSED, 0, sigSTR, 0, GetTempInfoStruct());

				printf("Signal Strength: __%d__\r\n", sigSTR);
 800bdb2:	4631      	mov	r1, r6
 800bdb4:	480a      	ldr	r0, [pc, #40]	; (800bde0 <SaraGetSignalStrength+0xb0>)
 800bdb6:	f001 fab1 	bl	800d31c <iprintf>

				/* If the RSSI is below a certain threshold, don't proceed */
				if (sigSTR < 5 || sigSTR == 99)
 800bdba:	2e04      	cmp	r6, #4
 800bdbc:	d909      	bls.n	800bdd2 <SaraGetSignalStrength+0xa2>
 800bdbe:	f1b6 0063 	subs.w	r0, r6, #99	; 0x63
 800bdc2:	bf18      	it	ne
 800bdc4:	2001      	movne	r0, #1
 800bdc6:	46ad      	mov	sp, r5
				return true;
			}
		}
	}
	return false;
}
 800bdc8:	f507 6780 	add.w	r7, r7, #1024	; 0x400
 800bdcc:	46bd      	mov	sp, r7
 800bdce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800bdd2:	4620      	mov	r0, r4
 800bdd4:	e7f7      	b.n	800bdc6 <SaraGetSignalStrength+0x96>
 800bdd6:	bf00      	nop
 800bdd8:	0800fd68 	.word	0x0800fd68
 800bddc:	0800fd71 	.word	0x0800fd71
 800bde0:	0800fd74 	.word	0x0800fd74

0800bde4 <SaraClearBuffer>:
/* Never Used */
void SaraClearBuffer()
{
	for (int i = TX_BUFF_SIZE - 1; i >= 0; i--)
	{
		uart_Buffer[i] = '\0';
 800bde4:	4905      	ldr	r1, [pc, #20]	; (800bdfc <SaraClearBuffer+0x18>)
	for (int i = TX_BUFF_SIZE - 1; i >= 0; i--)
 800bde6:	23ff      	movs	r3, #255	; 0xff
		uart_Buffer[i] = '\0';
 800bde8:	2200      	movs	r2, #0
 800bdea:	54ca      	strb	r2, [r1, r3]
	for (int i = TX_BUFF_SIZE - 1; i >= 0; i--)
 800bdec:	f113 33ff 	adds.w	r3, r3, #4294967295
 800bdf0:	d2fb      	bcs.n	800bdea <SaraClearBuffer+0x6>
 800bdf2:	4b03      	ldr	r3, [pc, #12]	; (800be00 <SaraClearBuffer+0x1c>)
 800bdf4:	801a      	strh	r2, [r3, #0]
 800bdf6:	805a      	strh	r2, [r3, #2]
 800bdf8:	4770      	bx	lr
 800bdfa:	bf00      	nop
 800bdfc:	2000029b 	.word	0x2000029b
 800be00:	2000c638 	.word	0x2000c638

0800be04 <SaraGetRSSI>:
{
 800be04:	b510      	push	{r4, lr}
 800be06:	f5ad 6d85 	sub.w	sp, sp, #1064	; 0x428
	char rxBuff[1024] = { 0 };
 800be0a:	f44f 6280 	mov.w	r2, #1024	; 0x400
 800be0e:	2100      	movs	r1, #0
 800be10:	a80a      	add	r0, sp, #40	; 0x28
 800be12:	f000 ff73 	bl	800ccfc <memset>
	SaraClearBuffer();
 800be16:	f7ff ffe5 	bl	800bde4 <SaraClearBuffer>
	SaraSendCommand("AT+CESQ\r\n");
 800be1a:	4811      	ldr	r0, [pc, #68]	; (800be60 <SaraGetRSSI+0x5c>)
 800be1c:	f7ff fe04 	bl	800ba28 <SaraSendCommand>
	SaraWaitForResponse((uint8_t*) rxBuff, 1024, LOW_TIMEOUT);
 800be20:	220a      	movs	r2, #10
 800be22:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800be26:	a80a      	add	r0, sp, #40	; 0x28
 800be28:	f7ff fd9e 	bl	800b968 <SaraWaitForResponse>
			== (sscanf(
 800be2c:	ab08      	add	r3, sp, #32
 800be2e:	9302      	str	r3, [sp, #8]
 800be30:	ab07      	add	r3, sp, #28
 800be32:	9301      	str	r3, [sp, #4]
 800be34:	ac09      	add	r4, sp, #36	; 0x24
 800be36:	ab06      	add	r3, sp, #24
 800be38:	9300      	str	r3, [sp, #0]
 800be3a:	9403      	str	r4, [sp, #12]
 800be3c:	ab05      	add	r3, sp, #20
 800be3e:	aa04      	add	r2, sp, #16
 800be40:	4908      	ldr	r1, [pc, #32]	; (800be64 <SaraGetRSSI+0x60>)
 800be42:	a80a      	add	r0, sp, #40	; 0x28
 800be44:	f001 fb2e 	bl	800d4a4 <siscanf>
	if (6
 800be48:	2806      	cmp	r0, #6
 800be4a:	d106      	bne.n	800be5a <SaraGetRSSI+0x56>
		if (RSRP == 255)
 800be4c:	6820      	ldr	r0, [r4, #0]
 800be4e:	38ff      	subs	r0, #255	; 0xff
 800be50:	bf18      	it	ne
 800be52:	2001      	movne	r0, #1
}
 800be54:	f50d 6d85 	add.w	sp, sp, #1064	; 0x428
 800be58:	bd10      	pop	{r4, pc}
 800be5a:	2000      	movs	r0, #0
 800be5c:	e7fa      	b.n	800be54 <SaraGetRSSI+0x50>
 800be5e:	bf00      	nop
 800be60:	0800fd43 	.word	0x0800fd43
 800be64:	0800fd4d 	.word	0x0800fd4d

0800be68 <InitErrorStruct>:
}

/* Init values in error struct */
void InitErrorStruct(struct radioFlags *rF)
{
	rF->radioEnableFlag = 1;
 800be68:	2301      	movs	r3, #1
 800be6a:	7083      	strb	r3, [r0, #2]
	rF->firstRun = 1;
 800be6c:	74c3      	strb	r3, [r0, #19]
	rF->firstErrorOfDay = 1;
 800be6e:	7583      	strb	r3, [r0, #22]
	rF->counterMessage = 1;
 800be70:	8303      	strh	r3, [r0, #24]

	rF->errorDayCounter = 0;
 800be72:	2300      	movs	r3, #0
 800be74:	7103      	strb	r3, [r0, #4]
	rF->errorDayFlag = 0;
 800be76:	7043      	strb	r3, [r0, #1]
	rF->errorHourCounter = 0;
 800be78:	70c3      	strb	r3, [r0, #3]
	rF->errorHourFlag = 0;
 800be7a:	7003      	strb	r3, [r0, #0]
	rF->noNewSettings = 0;
 800be7c:	72c3      	strb	r3, [r0, #11]
	rF->publishError = 0;
 800be7e:	7203      	strb	r3, [r0, #8]
	rF->serverDo = 0;
 800be80:	7303      	strb	r3, [r0, #12]
	rF->startUpError = 0;
 800be82:	7343      	strb	r3, [r0, #13]
	rF->subscribeError = 0;
 800be84:	7243      	strb	r3, [r0, #9]
	rF->testCounterConnectServer = 0;
 800be86:	7183      	strb	r3, [r0, #6]
	rF->testCounterGetSignal = 0;
 800be88:	7143      	strb	r3, [r0, #5]
	rF->testCounterTime = 0;
 800be8a:	71c3      	strb	r3, [r0, #7]
	rF->updateError = 0;
 800be8c:	7283      	strb	r3, [r0, #10]
	rF->AtInit = 0;
 800be8e:	7383      	strb	r3, [r0, #14]
	rF->setServerError = 0;
 800be90:	73c3      	strb	r3, [r0, #15]
	rF->dataPublishedFlag = 0;
 800be92:	7403      	strb	r3, [r0, #16]
	rF->adjustedHours = 0;
 800be94:	7443      	strb	r3, [r0, #17]
	rF->adjusted = 0;
 800be96:	7483      	strb	r3, [r0, #18]
	rF->errorStart = 0;
 800be98:	7503      	strb	r3, [r0, #20]
	rF->everythingOK = 0;
 800be9a:	7543      	strb	r3, [r0, #21]
	rF->alreadyConnected = 0;
 800be9c:	7683      	strb	r3, [r0, #26]
	rF->triedToSendCount = 0;
 800be9e:	76c3      	strb	r3, [r0, #27]
	rF->trySubscribeAgain = 0;
 800bea0:	7703      	strb	r3, [r0, #28]
	rF->subscribeErrorCounter = 0;
 800bea2:	7743      	strb	r3, [r0, #29]
	rF->radioRTC = 0;
 800bea4:	7783      	strb	r3, [r0, #30]
	rF->radioPublishCounter = 0;
 800bea6:	77c3      	strb	r3, [r0, #31]
 800bea8:	4770      	bx	lr
	...

0800beac <InitSaraStruct>:

}

/* Init values to Sara configuration */
void InitSaraStruct(SaraConfig *s)
{
 800beac:	b510      	push	{r4, lr}
	/* Init the SaraConfiguration to "Start Settings" */
	strcpy(s->id, "anfr");
 800beae:	4919      	ldr	r1, [pc, #100]	; (800bf14 <InitSaraStruct+0x68>)
{
 800beb0:	4604      	mov	r4, r0
	strcpy(s->id, "anfr");
 800beb2:	f001 fb83 	bl	800d5bc <strcpy>
	strcpy(s->ip, "83.182.202.21");
 800beb6:	4918      	ldr	r1, [pc, #96]	; (800bf18 <InitSaraStruct+0x6c>)
 800beb8:	f104 0020 	add.w	r0, r4, #32
 800bebc:	f001 fb7e 	bl	800d5bc <strcpy>
	strcpy(s->revision, "1.01");
 800bec0:	4916      	ldr	r1, [pc, #88]	; (800bf1c <InitSaraStruct+0x70>)
 800bec2:	f104 0044 	add.w	r0, r4, #68	; 0x44
 800bec6:	f001 fb79 	bl	800d5bc <strcpy>
	strcpy(s->connectSubTopic, "SaraSub"); //Where server publishes
 800beca:	4915      	ldr	r1, [pc, #84]	; (800bf20 <InitSaraStruct+0x74>)
 800becc:	f104 0050 	add.w	r0, r4, #80	; 0x50
 800bed0:	f001 fb74 	bl	800d5bc <strcpy>
	strcpy(s->connectPubTopic, "SaraPub");    //Where Sara publishes
 800bed4:	4913      	ldr	r1, [pc, #76]	; (800bf24 <InitSaraStruct+0x78>)
 800bed6:	f104 0060 	add.w	r0, r4, #96	; 0x60
 800beda:	f001 fb6f 	bl	800d5bc <strcpy>
	strcpy(s->connectComTopic, "SaraCom");    //Where Sara publishes
 800bede:	4912      	ldr	r1, [pc, #72]	; (800bf28 <InitSaraStruct+0x7c>)
 800bee0:	f104 0070 	add.w	r0, r4, #112	; 0x70
 800bee4:	f001 fb6a 	bl	800d5bc <strcpy>
	s->port = 1883;
 800bee8:	f240 735b 	movw	r3, #1883	; 0x75b
 800beec:	6423      	str	r3, [r4, #64]	; 0x40
	s->serverToDo = 0;
 800beee:	2300      	movs	r3, #0
 800bef0:	64e3      	str	r3, [r4, #76]	; 0x4c
	s->updateFrequency = 120; //This is in seconds
 800bef2:	2378      	movs	r3, #120	; 0x78
 800bef4:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
	s->hourToSend = 3;
 800bef8:	2303      	movs	r3, #3
 800befa:	f884 3084 	strb.w	r3, [r4, #132]	; 0x84
	strcpy(s->webPage, "mbqtest.ddns.net");
 800befe:	490b      	ldr	r1, [pc, #44]	; (800bf2c <InitSaraStruct+0x80>)
 800bf00:	f104 0085 	add.w	r0, r4, #133	; 0x85
 800bf04:	f001 fb5a 	bl	800d5bc <strcpy>
	s->firstMessageToReSend = 1;
 800bf08:	2301      	movs	r3, #1
 800bf0a:	f8c4 30a8 	str.w	r3, [r4, #168]	; 0xa8
	s->lastMessageToReSend = 1;
 800bf0e:	f8c4 30ac 	str.w	r3, [r4, #172]	; 0xac
 800bf12:	bd10      	pop	{r4, pc}
 800bf14:	0800fc8d 	.word	0x0800fc8d
 800bf18:	0800fc92 	.word	0x0800fc92
 800bf1c:	0800fca0 	.word	0x0800fca0
 800bf20:	0800fca5 	.word	0x0800fca5
 800bf24:	0800fcad 	.word	0x0800fcad
 800bf28:	0800fcb5 	.word	0x0800fcb5
 800bf2c:	0800fcbd 	.word	0x0800fcbd

0800bf30 <InitTimeStruct>:
}

/* Init timestruct to current MCU time */
void InitTimeStruct(Time *tS)
{
 800bf30:	b513      	push	{r0, r1, r4, lr}
 800bf32:	4604      	mov	r4, r0
	Time iT;
	GetTime(&iT);
 800bf34:	4668      	mov	r0, sp
 800bf36:	f000 fd51 	bl	800c9dc <GetTime>

	tS->Year = iT.Year;
 800bf3a:	f89d 3000 	ldrb.w	r3, [sp]
 800bf3e:	7023      	strb	r3, [r4, #0]
	tS->Month = iT.Month;
 800bf40:	f89d 3001 	ldrb.w	r3, [sp, #1]
 800bf44:	7063      	strb	r3, [r4, #1]
	tS->Day = iT.Day;
 800bf46:	f89d 3002 	ldrb.w	r3, [sp, #2]
 800bf4a:	70a3      	strb	r3, [r4, #2]
	tS->Hour = iT.Hour;
 800bf4c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800bf50:	70e3      	strb	r3, [r4, #3]
	tS->Minute = iT.Minute;
 800bf52:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800bf56:	7123      	strb	r3, [r4, #4]
	tS->Second = iT.Second;
 800bf58:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800bf5c:	7163      	strb	r3, [r4, #5]
}
 800bf5e:	b002      	add	sp, #8
 800bf60:	bd10      	pop	{r4, pc}

0800bf62 <SetServerToDo>:
	return ret;
}

/* Assign if server want the module to do something to struct */
uint8_t SetServerToDo(char *data, int len, SaraConfig *s)
{
 800bf62:	b510      	push	{r4, lr}
	uint8_t ret = SUCCESS;

	/* Write to struct */
	s->serverToDo = strtol(data, NULL, 10);
 800bf64:	2100      	movs	r1, #0
{
 800bf66:	4614      	mov	r4, r2
	s->serverToDo = strtol(data, NULL, 10);
 800bf68:	220a      	movs	r2, #10
 800bf6a:	f001 fbf1 	bl	800d750 <strtol>
 800bf6e:	64e0      	str	r0, [r4, #76]	; 0x4c

	return ret;
}
 800bf70:	2001      	movs	r0, #1
 800bf72:	bd10      	pop	{r4, pc}

0800bf74 <SetUpdateFrequency>:

uint8_t SetUpdateFrequency(char *data, int len, SaraConfig *s)
{
 800bf74:	b510      	push	{r4, lr}
	uint8_t ret = SUCCESS;

	/* Write to struct */
	s->updateFrequency = strtol(data, NULL, 10);
 800bf76:	2100      	movs	r1, #0
{
 800bf78:	4614      	mov	r4, r2
	s->updateFrequency = strtol(data, NULL, 10);
 800bf7a:	220a      	movs	r2, #10
 800bf7c:	f001 fbe8 	bl	800d750 <strtol>
 800bf80:	f8c4 0080 	str.w	r0, [r4, #128]	; 0x80

	return ret;
}
 800bf84:	2001      	movs	r0, #1
 800bf86:	bd10      	pop	{r4, pc}

0800bf88 <SetHourToSend>:

uint8_t SetHourToSend(char *data, int len, SaraConfig *s)
{
 800bf88:	b510      	push	{r4, lr}
	uint8_t ret = SUCCESS;

	/* Write to struct */
	s->hourToSend = strtol(data, NULL, 10);
 800bf8a:	2100      	movs	r1, #0
{
 800bf8c:	4614      	mov	r4, r2
	s->hourToSend = strtol(data, NULL, 10);
 800bf8e:	220a      	movs	r2, #10
 800bf90:	f001 fbde 	bl	800d750 <strtol>
 800bf94:	f884 0084 	strb.w	r0, [r4, #132]	; 0x84

	return ret;
}
 800bf98:	2001      	movs	r0, #1
 800bf9a:	bd10      	pop	{r4, pc}

0800bf9c <FirstMessageToResend>:

uint8_t FirstMessageToResend(char *data, int len, SaraConfig *s)
{
 800bf9c:	b510      	push	{r4, lr}
	uint8_t ret = SUCCESS;

	/* Write to struct */
	s->firstMessageToReSend = strtol(data, NULL, 10);
 800bf9e:	2100      	movs	r1, #0
{
 800bfa0:	4614      	mov	r4, r2
	s->firstMessageToReSend = strtol(data, NULL, 10);
 800bfa2:	220a      	movs	r2, #10
 800bfa4:	f001 fbd4 	bl	800d750 <strtol>
 800bfa8:	f8c4 00a8 	str.w	r0, [r4, #168]	; 0xa8

	return ret;
}
 800bfac:	2001      	movs	r0, #1
 800bfae:	bd10      	pop	{r4, pc}

0800bfb0 <LastMessageToResend>:

uint8_t LastMessageToResend(char *data, int len, SaraConfig *s)
{
 800bfb0:	b510      	push	{r4, lr}
	uint8_t ret = SUCCESS;

	/* Write to struct */
	s->lastMessageToReSend = strtol(data, NULL, 10);
 800bfb2:	2100      	movs	r1, #0
{
 800bfb4:	4614      	mov	r4, r2
	s->lastMessageToReSend = strtol(data, NULL, 10);
 800bfb6:	220a      	movs	r2, #10
 800bfb8:	f001 fbca 	bl	800d750 <strtol>
 800bfbc:	f8c4 00ac 	str.w	r0, [r4, #172]	; 0xac

	return ret;
}
 800bfc0:	2001      	movs	r0, #1
 800bfc2:	bd10      	pop	{r4, pc}

0800bfc4 <ParseJSMNForHeader>:




TOKHeader ParseJSMNForHeader(const char *js, JsmnTok tok)
{
 800bfc4:	b084      	sub	sp, #16
 800bfc6:	b530      	push	{r4, r5, lr}
 800bfc8:	b089      	sub	sp, #36	; 0x24
 800bfca:	4605      	mov	r5, r0
 800bfcc:	a80d      	add	r0, sp, #52	; 0x34
 800bfce:	e880 000e 	stmia.w	r0, {r1, r2, r3}
	TOKHeader h = TOK_NO_HEADER;
	char str[32] = {0};
 800bfd2:	2220      	movs	r2, #32
 800bfd4:	2100      	movs	r1, #0
 800bfd6:	4668      	mov	r0, sp
 800bfd8:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 800bfda:	f000 fe8f 	bl	800ccfc <memset>
	int len = tok.end - tok.start;

	if(js)
 800bfde:	b3ad      	cbz	r5, 800c04c <ParseJSMNForHeader+0x88>
	int len = tok.end - tok.start;
 800bfe0:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 800bfe2:	1b12      	subs	r2, r2, r4
	{
		/* If data length between 0 and 32 = header */
		if(len > 0 && len < 32)
 800bfe4:	1e53      	subs	r3, r2, #1
 800bfe6:	2b1e      	cmp	r3, #30
 800bfe8:	d830      	bhi.n	800c04c <ParseJSMNForHeader+0x88>
		{
			/* Copy substring to str */
			strncpy(str, (js + tok.start), len);
 800bfea:	1929      	adds	r1, r5, r4
 800bfec:	4668      	mov	r0, sp
 800bfee:	f001 faed 	bl	800d5cc <strncpy>

			if (!strcmp(str, "ip"))
 800bff2:	4921      	ldr	r1, [pc, #132]	; (800c078 <ParseJSMNForHeader+0xb4>)
 800bff4:	4668      	mov	r0, sp
 800bff6:	f7f4 f8f3 	bl	80001e0 <strcmp>
 800bffa:	b340      	cbz	r0, 800c04e <ParseJSMNForHeader+0x8a>
			{
				h = TOK_IP;
			}
			else if (!strcmp(str, "port"))
 800bffc:	491f      	ldr	r1, [pc, #124]	; (800c07c <ParseJSMNForHeader+0xb8>)
 800bffe:	4668      	mov	r0, sp
 800c000:	f7f4 f8ee 	bl	80001e0 <strcmp>
 800c004:	b340      	cbz	r0, 800c058 <ParseJSMNForHeader+0x94>
			{
				h = TOK_PORT;
			}
			else if (!strcmp(str, "id"))
 800c006:	491e      	ldr	r1, [pc, #120]	; (800c080 <ParseJSMNForHeader+0xbc>)
 800c008:	4668      	mov	r0, sp
 800c00a:	f7f4 f8e9 	bl	80001e0 <strcmp>
 800c00e:	b328      	cbz	r0, 800c05c <ParseJSMNForHeader+0x98>
			{
				h = TOK_ID;
			}
			else if (!strcmp(str, "serverToDo"))
 800c010:	491c      	ldr	r1, [pc, #112]	; (800c084 <ParseJSMNForHeader+0xc0>)
 800c012:	4668      	mov	r0, sp
 800c014:	f7f4 f8e4 	bl	80001e0 <strcmp>
 800c018:	b310      	cbz	r0, 800c060 <ParseJSMNForHeader+0x9c>
			{
				h = TOK_SERVERTODO;
			}
			else if (!strcmp(str, "updateFrequency"))
 800c01a:	491b      	ldr	r1, [pc, #108]	; (800c088 <ParseJSMNForHeader+0xc4>)
 800c01c:	4668      	mov	r0, sp
 800c01e:	f7f4 f8df 	bl	80001e0 <strcmp>
 800c022:	b1f8      	cbz	r0, 800c064 <ParseJSMNForHeader+0xa0>
			{
				h = TOK_UPDATEFREQ;
			}
			else if (!strcmp(str, "hourToSend"))
 800c024:	4919      	ldr	r1, [pc, #100]	; (800c08c <ParseJSMNForHeader+0xc8>)
 800c026:	4668      	mov	r0, sp
 800c028:	f7f4 f8da 	bl	80001e0 <strcmp>
 800c02c:	b1e0      	cbz	r0, 800c068 <ParseJSMNForHeader+0xa4>
			{
				h = TOK_HOURTOSEND;
			}
			else if (!strcmp(str, "revision"))
 800c02e:	4918      	ldr	r1, [pc, #96]	; (800c090 <ParseJSMNForHeader+0xcc>)
 800c030:	4668      	mov	r0, sp
 800c032:	f7f4 f8d5 	bl	80001e0 <strcmp>
 800c036:	b1c8      	cbz	r0, 800c06c <ParseJSMNForHeader+0xa8>
			{
				h = TOK_REVISION;
			}
			else if (!strcmp(str, "fMTR")) //firstMessageToResend
 800c038:	4916      	ldr	r1, [pc, #88]	; (800c094 <ParseJSMNForHeader+0xd0>)
 800c03a:	4668      	mov	r0, sp
 800c03c:	f7f4 f8d0 	bl	80001e0 <strcmp>
 800c040:	b1b0      	cbz	r0, 800c070 <ParseJSMNForHeader+0xac>
			{
				h = TOK_FIRSTMESSAGE;
			}
			else if (!strcmp(str, "lMTR")) //firstMessageToResend
 800c042:	4915      	ldr	r1, [pc, #84]	; (800c098 <ParseJSMNForHeader+0xd4>)
 800c044:	4668      	mov	r0, sp
 800c046:	f7f4 f8cb 	bl	80001e0 <strcmp>
 800c04a:	b198      	cbz	r0, 800c074 <ParseJSMNForHeader+0xb0>
			{
				h = TOK_LASTMESSAGE;
			}
			else
			{
				h = TOK_NO_HEADER;
 800c04c:	2007      	movs	r0, #7
			}
		}
	}

	return h;
}
 800c04e:	b009      	add	sp, #36	; 0x24
 800c050:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800c054:	b004      	add	sp, #16
 800c056:	4770      	bx	lr
				h = TOK_PORT;
 800c058:	2002      	movs	r0, #2
 800c05a:	e7f8      	b.n	800c04e <ParseJSMNForHeader+0x8a>
				h = TOK_ID;
 800c05c:	2003      	movs	r0, #3
 800c05e:	e7f6      	b.n	800c04e <ParseJSMNForHeader+0x8a>
				h = TOK_SERVERTODO;
 800c060:	2004      	movs	r0, #4
 800c062:	e7f4      	b.n	800c04e <ParseJSMNForHeader+0x8a>
				h = TOK_UPDATEFREQ;
 800c064:	2005      	movs	r0, #5
 800c066:	e7f2      	b.n	800c04e <ParseJSMNForHeader+0x8a>
				h = TOK_HOURTOSEND;
 800c068:	2006      	movs	r0, #6
 800c06a:	e7f0      	b.n	800c04e <ParseJSMNForHeader+0x8a>
				h = TOK_REVISION;
 800c06c:	2001      	movs	r0, #1
 800c06e:	e7ee      	b.n	800c04e <ParseJSMNForHeader+0x8a>
				h = TOK_FIRSTMESSAGE;
 800c070:	200a      	movs	r0, #10
 800c072:	e7ec      	b.n	800c04e <ParseJSMNForHeader+0x8a>
				h = TOK_LASTMESSAGE;
 800c074:	2009      	movs	r0, #9
 800c076:	e7ea      	b.n	800c04e <ParseJSMNForHeader+0x8a>
 800c078:	0800fdda 	.word	0x0800fdda
 800c07c:	0800fddd 	.word	0x0800fddd
 800c080:	0800fde2 	.word	0x0800fde2
 800c084:	0800fde5 	.word	0x0800fde5
 800c088:	0800fdf0 	.word	0x0800fdf0
 800c08c:	0800fe00 	.word	0x0800fe00
 800c090:	0800fe0b 	.word	0x0800fe0b
 800c094:	0800fe14 	.word	0x0800fe14
 800c098:	0800fe19 	.word	0x0800fe19

0800c09c <ParseSettingsString>:

	return res;
}

uint8_t ParseSettingsString(char *set, SaraConfig *s)
{
 800c09c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800c0a0:	f2ad 4d54 	subw	sp, sp, #1108	; 0x454
 800c0a4:	4682      	mov	sl, r0
	JsmnTok tok[66]; //1 data pair = 2 tokens ("unitId":":1234567890")
	uint8_t ret = SUCCESS;
	int i = 1;

	/* Initialize JSMN */
	JsmnInitialize(&p);
 800c0a6:	a809      	add	r0, sp, #36	; 0x24
{
 800c0a8:	460f      	mov	r7, r1
	JsmnInitialize(&p);
 800c0aa:	f000 fc37 	bl	800c91c <JsmnInitialize>

	if(set && s)
 800c0ae:	f1ba 0f00 	cmp.w	sl, #0
 800c0b2:	f000 80db 	beq.w	800c26c <ParseSettingsString+0x1d0>
 800c0b6:	2f00      	cmp	r7, #0
 800c0b8:	f000 80d8 	beq.w	800c26c <ParseSettingsString+0x1d0>
	{
		/* Parse string (max 64 headers + data ) */
		if(JsmnParse(&p, set, tok, 64) == JSMN_SUCCESS)
 800c0bc:	2340      	movs	r3, #64	; 0x40
 800c0be:	aa0c      	add	r2, sp, #48	; 0x30
 800c0c0:	4651      	mov	r1, sl
 800c0c2:	a809      	add	r0, sp, #36	; 0x24
 800c0c4:	f000 fb0e 	bl	800c6e4 <JsmnParse>
 800c0c8:	4605      	mov	r5, r0
 800c0ca:	2800      	cmp	r0, #0
 800c0cc:	f040 80c0 	bne.w	800c250 <ParseSettingsString+0x1b4>
		{
			/* If token 0 is a object = { yyyy } */
			if(tok[0].type == JSMN_OBJECT)
 800c0d0:	f89d 8030 	ldrb.w	r8, [sp, #48]	; 0x30
 800c0d4:	f1b8 0f01 	cmp.w	r8, #1
 800c0d8:	f040 80ac 	bne.w	800c234 <ParseSettingsString+0x198>
 800c0dc:	f10d 0930 	add.w	r9, sp, #48	; 0x30
 800c0e0:	4644      	mov	r4, r8
			{
				/* Run trough all data tokens in object */
				for(i = 1; (i <= tok[0].size) && (ret == SUCCESS); i += 2)
 800c0e2:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 800c0e4:	4598      	cmp	r8, r3
 800c0e6:	dc01      	bgt.n	800c0ec <ParseSettingsString+0x50>
 800c0e8:	2c01      	cmp	r4, #1
 800c0ea:	d004      	beq.n	800c0f6 <ParseSettingsString+0x5a>

		ret = false;
	}

	return ret;
}
 800c0ec:	4620      	mov	r0, r4
 800c0ee:	f20d 4d54 	addw	sp, sp, #1108	; 0x454
 800c0f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					if(tok[i].type == JSMN_STRING)
 800c0f6:	f899 3010 	ldrb.w	r3, [r9, #16]
 800c0fa:	2b03      	cmp	r3, #3
 800c0fc:	f040 8090 	bne.w	800c220 <ParseSettingsString+0x184>
						ret = ParseJSMNData(set, tok[i + 1], ParseJSMNForHeader(set, tok[i]), s);
 800c100:	ab0c      	add	r3, sp, #48	; 0x30
 800c102:	eb03 1308 	add.w	r3, r3, r8, lsl #4
 800c106:	4650      	mov	r0, sl
 800c108:	68da      	ldr	r2, [r3, #12]
 800c10a:	9200      	str	r2, [sp, #0]
 800c10c:	cb0e      	ldmia	r3, {r1, r2, r3}
 800c10e:	f7ff ff59 	bl	800bfc4 <ParseJSMNForHeader>
		if(h != TOK_NO_HEADER)
 800c112:	2807      	cmp	r0, #7
						ret = ParseJSMNData(set, tok[i + 1], ParseJSMNForHeader(set, tok[i]), s);
 800c114:	9006      	str	r0, [sp, #24]
		if(h != TOK_NO_HEADER)
 800c116:	d07a      	beq.n	800c20e <ParseSettingsString+0x172>
 800c118:	f8d9 3024 	ldr.w	r3, [r9, #36]	; 0x24
 800c11c:	9305      	str	r3, [sp, #20]
	int dataLen = tok.end - tok.start;
 800c11e:	9a05      	ldr	r2, [sp, #20]
 800c120:	f8d9 3028 	ldr.w	r3, [r9, #40]	; 0x28
 800c124:	eba3 0b02 	sub.w	fp, r3, r2
			if(dataLen > 0 && dataLen < 4096)
 800c128:	f10b 31ff 	add.w	r1, fp, #4294967295
 800c12c:	f640 72fe 	movw	r2, #4094	; 0xffe
 800c130:	4291      	cmp	r1, r2
 800c132:	d862      	bhi.n	800c1fa <ParseSettingsString+0x15e>
				data = malloc(dataLen + 1);
 800c134:	f10b 0201 	add.w	r2, fp, #1
 800c138:	4610      	mov	r0, r2
 800c13a:	9207      	str	r2, [sp, #28]
 800c13c:	f000 fdb4 	bl	800cca8 <malloc>
				if(data)
 800c140:	4606      	mov	r6, r0
 800c142:	2800      	cmp	r0, #0
 800c144:	d04b      	beq.n	800c1de <ParseSettingsString+0x142>
					memset(data, 0, dataLen + 1);
 800c146:	9a07      	ldr	r2, [sp, #28]
 800c148:	2100      	movs	r1, #0
 800c14a:	f000 fdd7 	bl	800ccfc <memset>
					strncpy(data, (js + tok.start), dataLen);
 800c14e:	9b05      	ldr	r3, [sp, #20]
 800c150:	4453      	add	r3, sl
 800c152:	4619      	mov	r1, r3
 800c154:	465a      	mov	r2, fp
 800c156:	4630      	mov	r0, r6
 800c158:	f001 fa38 	bl	800d5cc <strncpy>
					switch(h)
 800c15c:	9b06      	ldr	r3, [sp, #24]
 800c15e:	2b0a      	cmp	r3, #10
 800c160:	d80b      	bhi.n	800c17a <ParseSettingsString+0xde>
 800c162:	e8df f003 	tbb	[pc, r3]
 800c166:	2c15      	.short	0x2c15
 800c168:	20190612 	.word	0x20190612
 800c16c:	360a0a26 	.word	0x360a0a26
 800c170:	30          	.byte	0x30
 800c171:	00          	.byte	0x00
	strcpy((char*) s->id, data);
 800c172:	4631      	mov	r1, r6
 800c174:	4638      	mov	r0, r7
	strcpy((char*) s->port, data);
 800c176:	f001 fa21 	bl	800d5bc <strcpy>
					free(data);
 800c17a:	4630      	mov	r0, r6
 800c17c:	f000 fd9c 	bl	800ccb8 <free>
				for(i = 1; (i <= tok[0].size) && (ret == SUCCESS); i += 2)
 800c180:	f108 0802 	add.w	r8, r8, #2
 800c184:	f109 0920 	add.w	r9, r9, #32
 800c188:	e7ab      	b.n	800c0e2 <ParseSettingsString+0x46>
	strcpy((char*) s->port, data);
 800c18a:	4631      	mov	r1, r6
 800c18c:	6c38      	ldr	r0, [r7, #64]	; 0x40
 800c18e:	e7f2      	b.n	800c176 <ParseSettingsString+0xda>
	strcpy(s->ip, data);
 800c190:	4631      	mov	r1, r6
 800c192:	f107 0020 	add.w	r0, r7, #32
 800c196:	e7ee      	b.n	800c176 <ParseSettingsString+0xda>
						res = SetServerToDo(data, dataLen, s);
 800c198:	463a      	mov	r2, r7
 800c19a:	4659      	mov	r1, fp
 800c19c:	4630      	mov	r0, r6
 800c19e:	f7ff fee0 	bl	800bf62 <SetServerToDo>
						res = LastMessageToResend(data, dataLen, s);
 800c1a2:	4604      	mov	r4, r0
 800c1a4:	e7e9      	b.n	800c17a <ParseSettingsString+0xde>
						res = SetUpdateFrequency(data, dataLen, s);
 800c1a6:	463a      	mov	r2, r7
 800c1a8:	4659      	mov	r1, fp
 800c1aa:	4630      	mov	r0, r6
 800c1ac:	f7ff fee2 	bl	800bf74 <SetUpdateFrequency>
 800c1b0:	e7f7      	b.n	800c1a2 <ParseSettingsString+0x106>
						res = SetHourToSend(data, dataLen, s);
 800c1b2:	463a      	mov	r2, r7
 800c1b4:	4659      	mov	r1, fp
 800c1b6:	4630      	mov	r0, r6
 800c1b8:	f7ff fee6 	bl	800bf88 <SetHourToSend>
 800c1bc:	e7f1      	b.n	800c1a2 <ParseSettingsString+0x106>
	strcpy((char*) s->revision, data);
 800c1be:	4631      	mov	r1, r6
 800c1c0:	f107 0044 	add.w	r0, r7, #68	; 0x44
 800c1c4:	e7d7      	b.n	800c176 <ParseSettingsString+0xda>
						res = FirstMessageToResend(data, dataLen, s);
 800c1c6:	463a      	mov	r2, r7
 800c1c8:	4659      	mov	r1, fp
 800c1ca:	4630      	mov	r0, r6
 800c1cc:	f7ff fee6 	bl	800bf9c <FirstMessageToResend>
 800c1d0:	e7e7      	b.n	800c1a2 <ParseSettingsString+0x106>
						res = LastMessageToResend(data, dataLen, s);
 800c1d2:	463a      	mov	r2, r7
 800c1d4:	4659      	mov	r1, fp
 800c1d6:	4630      	mov	r0, r6
 800c1d8:	f7ff feea 	bl	800bfb0 <LastMessageToResend>
 800c1dc:	e7e1      	b.n	800c1a2 <ParseSettingsString+0x106>
					ErrorAddLog(LOG_FUNC_SETTING, LOG_SUB_SECTOR, LOG_TYPE_WRITE, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 800c1de:	f7fc ff5d 	bl	800909c <GetErrorStruct>
 800c1e2:	9602      	str	r6, [sp, #8]
 800c1e4:	9003      	str	r0, [sp, #12]
 800c1e6:	9601      	str	r6, [sp, #4]
 800c1e8:	9600      	str	r6, [sp, #0]
 800c1ea:	2311      	movs	r3, #17
 800c1ec:	2215      	movs	r2, #21
 800c1ee:	2113      	movs	r1, #19
						ErrorAddLog(LOG_FUNC_SETTING, LOG_SUB_JSMN, LOG_TYPE_ID, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 800c1f0:	201c      	movs	r0, #28
 800c1f2:	f000 f851 	bl	800c298 <ErrorAddLog>
						ret = false;
 800c1f6:	2400      	movs	r4, #0
 800c1f8:	e7c2      	b.n	800c180 <ParseSettingsString+0xe4>
				ErrorAddLog(LOG_FUNC_SETTING, LOG_SUB_PARSE, LOG_TYPE_WRITE, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 800c1fa:	f7fc ff4f 	bl	800909c <GetErrorStruct>
 800c1fe:	9502      	str	r5, [sp, #8]
 800c200:	9003      	str	r0, [sp, #12]
 800c202:	9501      	str	r5, [sp, #4]
 800c204:	9500      	str	r5, [sp, #0]
 800c206:	2311      	movs	r3, #17
 800c208:	2215      	movs	r2, #21
			ErrorAddLog(LOG_FUNC_SETTING, LOG_SUB_PARSE, LOG_TYPE_START, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 800c20a:	2134      	movs	r1, #52	; 0x34
 800c20c:	e7f0      	b.n	800c1f0 <ParseSettingsString+0x154>
 800c20e:	f7fc ff45 	bl	800909c <GetErrorStruct>
 800c212:	9502      	str	r5, [sp, #8]
 800c214:	9003      	str	r0, [sp, #12]
 800c216:	9501      	str	r5, [sp, #4]
 800c218:	9500      	str	r5, [sp, #0]
 800c21a:	2311      	movs	r3, #17
 800c21c:	2216      	movs	r2, #22
 800c21e:	e7f4      	b.n	800c20a <ParseSettingsString+0x16e>
						ErrorAddLog(LOG_FUNC_SETTING, LOG_SUB_JSMN, LOG_TYPE_ID, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 800c220:	f7fc ff3c 	bl	800909c <GetErrorStruct>
 800c224:	9502      	str	r5, [sp, #8]
 800c226:	9003      	str	r0, [sp, #12]
 800c228:	9501      	str	r5, [sp, #4]
 800c22a:	9500      	str	r5, [sp, #0]
 800c22c:	2311      	movs	r3, #17
 800c22e:	2213      	movs	r2, #19
 800c230:	2135      	movs	r1, #53	; 0x35
 800c232:	e7dd      	b.n	800c1f0 <ParseSettingsString+0x154>
				ErrorAddLog(LOG_FUNC_SETTING, LOG_SUB_JSMN, LOG_TYPE_READ, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 800c234:	f7fc ff32 	bl	800909c <GetErrorStruct>
 800c238:	9502      	str	r5, [sp, #8]
 800c23a:	9003      	str	r0, [sp, #12]
 800c23c:	9501      	str	r5, [sp, #4]
 800c23e:	9500      	str	r5, [sp, #0]
 800c240:	2311      	movs	r3, #17
 800c242:	2214      	movs	r2, #20
 800c244:	2135      	movs	r1, #53	; 0x35
 800c246:	201c      	movs	r0, #28
 800c248:	f000 f826 	bl	800c298 <ErrorAddLog>
				ret = false;
 800c24c:	462c      	mov	r4, r5
 800c24e:	e74d      	b.n	800c0ec <ParseSettingsString+0x50>
			ErrorAddLog(LOG_FUNC_SETTING, LOG_SUB_JSMN, LOG_TYPE_SEEK, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 800c250:	f7fc ff24 	bl	800909c <GetErrorStruct>
 800c254:	2400      	movs	r4, #0
 800c256:	9003      	str	r0, [sp, #12]
 800c258:	9402      	str	r4, [sp, #8]
 800c25a:	9401      	str	r4, [sp, #4]
 800c25c:	9400      	str	r4, [sp, #0]
 800c25e:	2311      	movs	r3, #17
 800c260:	2219      	movs	r2, #25
		ErrorAddLog(LOG_FUNC_SETTING, LOG_SUB_JSMN, LOG_TYPE_NONE, LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());
 800c262:	2135      	movs	r1, #53	; 0x35
 800c264:	201c      	movs	r0, #28
 800c266:	f000 f817 	bl	800c298 <ErrorAddLog>
 800c26a:	e73f      	b.n	800c0ec <ParseSettingsString+0x50>
 800c26c:	f7fc ff16 	bl	800909c <GetErrorStruct>
 800c270:	2400      	movs	r4, #0
 800c272:	2311      	movs	r3, #17
 800c274:	9003      	str	r0, [sp, #12]
 800c276:	9402      	str	r4, [sp, #8]
 800c278:	9401      	str	r4, [sp, #4]
 800c27a:	9400      	str	r4, [sp, #0]
 800c27c:	461a      	mov	r2, r3
 800c27e:	e7f0      	b.n	800c262 <ParseSettingsString+0x1c6>

0800c280 <ErrorStruct_init>:
/*
 * Initialize the error struct
 */
void ErrorStruct_init(Error *er)
{
	er->errorCounter = 0;
 800c280:	2300      	movs	r3, #0
 800c282:	f8a0 3258 	strh.w	r3, [r0, #600]	; 0x258
 800c286:	7103      	strb	r3, [r0, #4]
 800c288:	7143      	strb	r3, [r0, #5]
 800c28a:	7183      	strb	r3, [r0, #6]
 800c28c:	71c3      	strb	r3, [r0, #7]
 800c28e:	6083      	str	r3, [r0, #8]
 800c290:	60c3      	str	r3, [r0, #12]
 800c292:	6003      	str	r3, [r0, #0]
 800c294:	7403      	strb	r3, [r0, #16]
 800c296:	4770      	bx	lr

0800c298 <ErrorAddLog>:
/*
 * Adds an error the the errorlog
 * Todo implement a system for the logLevel
 */
void ErrorAddLog(uint8_t function, uint8_t subFunction, uint8_t type, uint8_t status, uint32_t valueA, uint32_t valueB, uint8_t logLevel, Error *er)
{
 800c298:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800c29a:	9c09      	ldr	r4, [sp, #36]	; 0x24

	/* If the buffer is full this error should be written */
	if (er->errorCounter >= ERROR_LOGG_ARRAY_SIZE)
 800c29c:	f8b4 6258 	ldrh.w	r6, [r4, #600]	; 0x258
 800c2a0:	2e1d      	cmp	r6, #29
 800c2a2:	d919      	bls.n	800c2d8 <ErrorAddLog+0x40>
	{
		er->errorCounter = ERROR_LOGG_ARRAY_SIZE - 1;
 800c2a4:	231d      	movs	r3, #29
 800c2a6:	f8a4 3258 	strh.w	r3, [r4, #600]	; 0x258
		er->errorLog[er->errorCounter].function = LOG_FUNC_ERROR;
 800c2aa:	2317      	movs	r3, #23
 800c2ac:	f884 3248 	strb.w	r3, [r4, #584]	; 0x248
		er->errorLog[er->errorCounter].subFunction = LOG_SUB_ADD;
 800c2b0:	231e      	movs	r3, #30
 800c2b2:	f884 3249 	strb.w	r3, [r4, #585]	; 0x249
		er->errorLog[er->errorCounter].type = LOG_TYPE_BUFFER_FULL;
 800c2b6:	f884 324a 	strb.w	r3, [r4, #586]	; 0x24a
		er->errorLog[er->errorCounter].status = LOG_STATUS_FAIL;
 800c2ba:	2311      	movs	r3, #17
 800c2bc:	f884 324b 	strb.w	r3, [r4, #587]	; 0x24b
		er->errorLog[er->errorCounter].valueA = 0;
 800c2c0:	2300      	movs	r3, #0
 800c2c2:	f8c4 324c 	str.w	r3, [r4, #588]	; 0x24c
		er->errorLog[er->errorCounter].valueB = 0;
 800c2c6:	f8c4 3250 	str.w	r3, [r4, #592]	; 0x250
		er->errorLog[er->errorCounter].logLevel = 0;
 800c2ca:	f884 3254 	strb.w	r3, [r4, #596]	; 0x254
		er->errorLog[er->errorCounter].timestamp = RTC_Get_DateTime_Comp();
 800c2ce:	f7fd ffdd 	bl	800a28c <RTC_Get_DateTime_Comp>
 800c2d2:	f8c4 0244 	str.w	r0, [r4, #580]	; 0x244
 800c2d6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c2d8:	2714      	movs	r7, #20
 800c2da:	437e      	muls	r6, r7
 800c2dc:	19a5      	adds	r5, r4, r6
	else
	{
		er->errorLog[er->errorCounter].function = function;
		er->errorLog[er->errorCounter].subFunction = subFunction;
		er->errorLog[er->errorCounter].type = type;
		er->errorLog[er->errorCounter].status = status;
 800c2de:	71eb      	strb	r3, [r5, #7]
		er->errorLog[er->errorCounter].valueA = valueA;
 800c2e0:	9b06      	ldr	r3, [sp, #24]
 800c2e2:	60ab      	str	r3, [r5, #8]
		er->errorLog[er->errorCounter].valueB = valueB;
 800c2e4:	9b07      	ldr	r3, [sp, #28]
		er->errorLog[er->errorCounter].type = type;
 800c2e6:	71aa      	strb	r2, [r5, #6]
		er->errorLog[er->errorCounter].valueB = valueB;
 800c2e8:	60eb      	str	r3, [r5, #12]
		er->errorLog[er->errorCounter].function = function;
 800c2ea:	7128      	strb	r0, [r5, #4]
		er->errorLog[er->errorCounter].subFunction = subFunction;
 800c2ec:	7169      	strb	r1, [r5, #5]
		er->errorLog[er->errorCounter].timestamp = RTC_Get_DateTime_Comp();
 800c2ee:	f7fd ffcd 	bl	800a28c <RTC_Get_DateTime_Comp>
 800c2f2:	51a0      	str	r0, [r4, r6]
		er->errorLog[er->errorCounter].logLevel = logLevel;
 800c2f4:	f8b4 3258 	ldrh.w	r3, [r4, #600]	; 0x258
 800c2f8:	f89d 2020 	ldrb.w	r2, [sp, #32]
 800c2fc:	fb07 4703 	mla	r7, r7, r3, r4

		er->errorCounter++;
 800c300:	3301      	adds	r3, #1
		er->errorLog[er->errorCounter].logLevel = logLevel;
 800c302:	743a      	strb	r2, [r7, #16]
		er->errorCounter++;
 800c304:	f8a4 3258 	strh.w	r3, [r4, #600]	; 0x258
 800c308:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800c30a <ResetInfoStruct>:
/*
 * Re-Initialize/Reset the error struct
 */
void ResetInfoStruct(Info *iL)
{
	iL->infoCounter = 0;
 800c30a:	f642 62e0 	movw	r2, #12000	; 0x2ee0
 800c30e:	2300      	movs	r3, #0
 800c310:	5283      	strh	r3, [r0, r2]
 800c312:	1881      	adds	r1, r0, r2
	iL->highestError = 0;
 800c314:	f642 62e2 	movw	r2, #12002	; 0x2ee2
 800c318:	5483      	strb	r3, [r0, r2]

	for (int i = 0; i < INFO_LOGG_ARRAY_SIZE; i++)
	{
		iL->infoLog[i].function = 0;
 800c31a:	7243      	strb	r3, [r0, #9]
		iL->infoLog[i].subFunction = 0;
 800c31c:	7283      	strb	r3, [r0, #10]
		iL->infoLog[i].type = 0;
 800c31e:	72c3      	strb	r3, [r0, #11]
		iL->infoLog[i].status = 0;
 800c320:	7303      	strb	r3, [r0, #12]
		iL->infoLog[i].timestamp = 0;
 800c322:	6043      	str	r3, [r0, #4]
		iL->infoLog[i].errorLevel = 0;
 800c324:	7203      	strb	r3, [r0, #8]
		iL->infoLog[i].valueA = 0;
 800c326:	7343      	strb	r3, [r0, #13]
		iL->infoLog[i].valueB = 0;
 800c328:	81c3      	strh	r3, [r0, #14]
		iL->infoLog[i].valueC = 0;
 800c32a:	6103      	str	r3, [r0, #16]
 800c32c:	3018      	adds	r0, #24
	for (int i = 0; i < INFO_LOGG_ARRAY_SIZE; i++)
 800c32e:	4288      	cmp	r0, r1
 800c330:	d1f3      	bne.n	800c31a <ResetInfoStruct+0x10>
	}
}
 800c332:	4770      	bx	lr

0800c334 <InitInfoStruct>:
 800c334:	f7ff bfe9 	b.w	800c30a <ResetInfoStruct>

0800c338 <InfoLogAdd>:

/* Debug messages */
void InfoLogAdd(ErrorLevel errorLevel, uint8_t function, uint8_t subFunction, uint8_t type,
		uint8_t status, uint8_t valueA, uint16_t valueB, uint32_t valueC,
		Info *iL)
{
 800c338:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800c33c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
	/* If the buffer is full this error should be written */
	if (iL->infoCounter >= INFO_LOGG_ARRAY_SIZE)
 800c33e:	f642 67e0 	movw	r7, #12000	; 0x2ee0
{
 800c342:	4680      	mov	r8, r0
	if (iL->infoCounter >= INFO_LOGG_ARRAY_SIZE)
 800c344:	5be5      	ldrh	r5, [r4, r7]
 800c346:	f5b5 7ffa 	cmp.w	r5, #500	; 0x1f4
 800c34a:	d325      	bcc.n	800c398 <InfoLogAdd+0x60>
	{
		iL->infoCounter = INFO_LOGG_ARRAY_SIZE - 1;
 800c34c:	f240 13f3 	movw	r3, #499	; 0x1f3
 800c350:	53e3      	strh	r3, [r4, r7]
		iL->infoLog[iL->infoCounter].function = LOG_FUNC_ERROR;
 800c352:	f642 63d1 	movw	r3, #11985	; 0x2ed1
 800c356:	2217      	movs	r2, #23
 800c358:	54e2      	strb	r2, [r4, r3]
		iL->infoLog[iL->infoCounter].subFunction = LOG_SUB_ADD;
 800c35a:	f642 62d2 	movw	r2, #11986	; 0x2ed2
 800c35e:	231e      	movs	r3, #30
 800c360:	54a3      	strb	r3, [r4, r2]
		iL->infoLog[iL->infoCounter].type = LOG_TYPE_BUFFER_FULL;
 800c362:	f642 62d3 	movw	r2, #11987	; 0x2ed3
 800c366:	54a3      	strb	r3, [r4, r2]
		iL->infoLog[iL->infoCounter].status = LOG_STATUS_FAIL;
 800c368:	f642 63d4 	movw	r3, #11988	; 0x2ed4
 800c36c:	2211      	movs	r2, #17
 800c36e:	54e2      	strb	r2, [r4, r3]
		iL->infoLog[iL->infoCounter].errorLevel = 0;
 800c370:	f642 62d0 	movw	r2, #11984	; 0x2ed0
 800c374:	2300      	movs	r3, #0
 800c376:	54a3      	strb	r3, [r4, r2]
		iL->infoLog[iL->infoCounter].valueA = 0;
 800c378:	f642 62d5 	movw	r2, #11989	; 0x2ed5
 800c37c:	54a3      	strb	r3, [r4, r2]
		iL->infoLog[iL->infoCounter].valueB = 0;
 800c37e:	f642 62d6 	movw	r2, #11990	; 0x2ed6
 800c382:	52a3      	strh	r3, [r4, r2]
		iL->infoLog[iL->infoCounter].valueC = 0;
 800c384:	f642 62d8 	movw	r2, #11992	; 0x2ed8
 800c388:	50a3      	str	r3, [r4, r2]
		iL->infoLog[iL->infoCounter].timestamp = RTC_Get_DateTime_Comp();
 800c38a:	f7fd ff7f 	bl	800a28c <RTC_Get_DateTime_Comp>
 800c38e:	f642 63cc 	movw	r3, #11980	; 0x2ecc
 800c392:	50e0      	str	r0, [r4, r3]
 800c394:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	}
	else
	{
		iL->infoLog[iL->infoCounter].function = function;
 800c398:	2618      	movs	r6, #24
 800c39a:	fb06 4505 	mla	r5, r6, r5, r4
		iL->infoLog[iL->infoCounter].subFunction = subFunction;
		iL->infoLog[iL->infoCounter].type = type;
 800c39e:	72eb      	strb	r3, [r5, #11]
		iL->infoLog[iL->infoCounter].status = status;
 800c3a0:	f89d 3018 	ldrb.w	r3, [sp, #24]
		iL->infoLog[iL->infoCounter].function = function;
 800c3a4:	7269      	strb	r1, [r5, #9]
		iL->infoLog[iL->infoCounter].subFunction = subFunction;
 800c3a6:	72aa      	strb	r2, [r5, #10]
		iL->infoLog[iL->infoCounter].status = status;
 800c3a8:	732b      	strb	r3, [r5, #12]
		iL->infoLog[iL->infoCounter].timestamp = RTC_Get_DateTime_Comp();
 800c3aa:	f7fd ff6f 	bl	800a28c <RTC_Get_DateTime_Comp>
		iL->infoLog[iL->infoCounter].errorLevel = errorLevel;
 800c3ae:	5be2      	ldrh	r2, [r4, r7]
		iL->infoLog[iL->infoCounter].valueA = valueA;
 800c3b0:	f89d 101c 	ldrb.w	r1, [sp, #28]
		iL->infoLog[iL->infoCounter].timestamp = RTC_Get_DateTime_Comp();
 800c3b4:	6068      	str	r0, [r5, #4]
		iL->infoLog[iL->infoCounter].errorLevel = errorLevel;
 800c3b6:	fb06 4302 	mla	r3, r6, r2, r4
		iL->infoLog[iL->infoCounter].valueB = valueB;
		iL->infoLog[iL->infoCounter].valueC = valueC;

		iL->infoCounter++;
 800c3ba:	3201      	adds	r2, #1
		iL->infoLog[iL->infoCounter].valueA = valueA;
 800c3bc:	7359      	strb	r1, [r3, #13]
		iL->infoLog[iL->infoCounter].valueB = valueB;
 800c3be:	f8bd 1020 	ldrh.w	r1, [sp, #32]
 800c3c2:	81d9      	strh	r1, [r3, #14]
		iL->infoLog[iL->infoCounter].valueC = valueC;
 800c3c4:	9909      	ldr	r1, [sp, #36]	; 0x24
		iL->infoLog[iL->infoCounter].errorLevel = errorLevel;
 800c3c6:	f883 8008 	strb.w	r8, [r3, #8]
		iL->infoLog[iL->infoCounter].valueC = valueC;
 800c3ca:	6119      	str	r1, [r3, #16]
		iL->infoCounter++;
 800c3cc:	53e2      	strh	r2, [r4, r7]

		/* Updates the highest errorlevel this iteration */
		if (errorLevel > iL->highestError)
 800c3ce:	f642 63e2 	movw	r3, #12002	; 0x2ee2
 800c3d2:	5ce2      	ldrb	r2, [r4, r3]
 800c3d4:	4542      	cmp	r2, r8
		{
			iL->highestError = errorLevel;
 800c3d6:	bf38      	it	cc
 800c3d8:	f804 8003 	strbcc.w	r8, [r4, r3]
 800c3dc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800c3e0 <InfoGetSize>:
}

/* Gets size of current Info-struct */
uint32_t InfoGetSize(Info *in)
{
	uint32_t size = in->infoCounter * sizeof(InfoLog);
 800c3e0:	f642 63e0 	movw	r3, #12000	; 0x2ee0
 800c3e4:	5ac3      	ldrh	r3, [r0, r3]
	return size;
}
 800c3e6:	2018      	movs	r0, #24
 800c3e8:	4358      	muls	r0, r3
 800c3ea:	4770      	bx	lr

0800c3ec <CopyTempToInfo>:
	}
}

/* Copies all data from a temp struct to a permanent one */
void CopyTempToInfo(void)
{
 800c3ec:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int i = 0; i < GetTempInfoStruct()->infoCounter; i++)
	{

		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].startOfInfo = 0xABBABABE;
 800c3f0:	f8df 8160 	ldr.w	r8, [pc, #352]	; 800c554 <CopyTempToInfo+0x168>
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueB =
				GetTempInfoStruct()->infoLog[i].valueB;
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueC =
				GetTempInfoStruct()->infoLog[i].valueC;

		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].endOfInfo = 0xDEADBEEF;
 800c3f4:	f8df 9160 	ldr.w	r9, [pc, #352]	; 800c558 <CopyTempToInfo+0x16c>
	for (int i = 0; i < GetTempInfoStruct()->infoCounter; i++)
 800c3f8:	2700      	movs	r7, #0
 800c3fa:	f642 64e0 	movw	r4, #12000	; 0x2ee0
 800c3fe:	f7fc fe55 	bl	80090ac <GetTempInfoStruct>
 800c402:	5b03      	ldrh	r3, [r0, r4]
 800c404:	429f      	cmp	r7, r3
 800c406:	db01      	blt.n	800c40c <CopyTempToInfo+0x20>

		GetInfoStruct()->infoCounter++;
	}
}
 800c408:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].startOfInfo = 0xABBABABE;
 800c40c:	f7fc fe4a 	bl	80090a4 <GetInfoStruct>
 800c410:	4606      	mov	r6, r0
 800c412:	f7fc fe47 	bl	80090a4 <GetInfoStruct>
 800c416:	5b03      	ldrh	r3, [r0, r4]
 800c418:	2518      	movs	r5, #24
 800c41a:	436b      	muls	r3, r5
 800c41c:	f846 8003 	str.w	r8, [r6, r3]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].timestamp =
 800c420:	f7fc fe40 	bl	80090a4 <GetInfoStruct>
 800c424:	4683      	mov	fp, r0
 800c426:	f7fc fe3d 	bl	80090a4 <GetInfoStruct>
 800c42a:	f830 a004 	ldrh.w	sl, [r0, r4]
				GetTempInfoStruct()->infoLog[i].timestamp;
 800c42e:	f7fc fe3d 	bl	80090ac <GetTempInfoStruct>
 800c432:	fb05 f607 	mul.w	r6, r5, r7
 800c436:	4430      	add	r0, r6
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].timestamp =
 800c438:	fb05 ba0a 	mla	sl, r5, sl, fp
				GetTempInfoStruct()->infoLog[i].timestamp;
 800c43c:	6843      	ldr	r3, [r0, #4]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].timestamp =
 800c43e:	f8ca 3004 	str.w	r3, [sl, #4]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].errorLevel =
 800c442:	f7fc fe2f 	bl	80090a4 <GetInfoStruct>
 800c446:	4683      	mov	fp, r0
 800c448:	f7fc fe2c 	bl	80090a4 <GetInfoStruct>
 800c44c:	f830 a004 	ldrh.w	sl, [r0, r4]
				GetTempInfoStruct()->infoLog[i].errorLevel;
 800c450:	f7fc fe2c 	bl	80090ac <GetTempInfoStruct>
 800c454:	4430      	add	r0, r6
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].errorLevel =
 800c456:	fb05 ba0a 	mla	sl, r5, sl, fp
				GetTempInfoStruct()->infoLog[i].errorLevel;
 800c45a:	7a03      	ldrb	r3, [r0, #8]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].errorLevel =
 800c45c:	f88a 3008 	strb.w	r3, [sl, #8]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].function =
 800c460:	f7fc fe20 	bl	80090a4 <GetInfoStruct>
 800c464:	4683      	mov	fp, r0
 800c466:	f7fc fe1d 	bl	80090a4 <GetInfoStruct>
 800c46a:	f830 a004 	ldrh.w	sl, [r0, r4]
				GetTempInfoStruct()->infoLog[i].function;
 800c46e:	f7fc fe1d 	bl	80090ac <GetTempInfoStruct>
 800c472:	4430      	add	r0, r6
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].function =
 800c474:	fb05 ba0a 	mla	sl, r5, sl, fp
				GetTempInfoStruct()->infoLog[i].function;
 800c478:	7a43      	ldrb	r3, [r0, #9]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].function =
 800c47a:	f88a 3009 	strb.w	r3, [sl, #9]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].subFunction =
 800c47e:	f7fc fe11 	bl	80090a4 <GetInfoStruct>
 800c482:	4683      	mov	fp, r0
 800c484:	f7fc fe0e 	bl	80090a4 <GetInfoStruct>
 800c488:	f830 a004 	ldrh.w	sl, [r0, r4]
				GetTempInfoStruct()->infoLog[i].subFunction;
 800c48c:	f7fc fe0e 	bl	80090ac <GetTempInfoStruct>
 800c490:	4430      	add	r0, r6
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].subFunction =
 800c492:	fb05 ba0a 	mla	sl, r5, sl, fp
				GetTempInfoStruct()->infoLog[i].subFunction;
 800c496:	7a83      	ldrb	r3, [r0, #10]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].subFunction =
 800c498:	f88a 300a 	strb.w	r3, [sl, #10]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].type =
 800c49c:	f7fc fe02 	bl	80090a4 <GetInfoStruct>
 800c4a0:	4683      	mov	fp, r0
 800c4a2:	f7fc fdff 	bl	80090a4 <GetInfoStruct>
 800c4a6:	f830 a004 	ldrh.w	sl, [r0, r4]
				GetTempInfoStruct()->infoLog[i].type;
 800c4aa:	f7fc fdff 	bl	80090ac <GetTempInfoStruct>
 800c4ae:	4430      	add	r0, r6
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].type =
 800c4b0:	fb05 ba0a 	mla	sl, r5, sl, fp
				GetTempInfoStruct()->infoLog[i].type;
 800c4b4:	7ac3      	ldrb	r3, [r0, #11]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].type =
 800c4b6:	f88a 300b 	strb.w	r3, [sl, #11]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].status =
 800c4ba:	f7fc fdf3 	bl	80090a4 <GetInfoStruct>
 800c4be:	4683      	mov	fp, r0
 800c4c0:	f7fc fdf0 	bl	80090a4 <GetInfoStruct>
 800c4c4:	f830 a004 	ldrh.w	sl, [r0, r4]
				GetTempInfoStruct()->infoLog[i].status;
 800c4c8:	f7fc fdf0 	bl	80090ac <GetTempInfoStruct>
 800c4cc:	4430      	add	r0, r6
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].status =
 800c4ce:	fb05 ba0a 	mla	sl, r5, sl, fp
				GetTempInfoStruct()->infoLog[i].status;
 800c4d2:	7b03      	ldrb	r3, [r0, #12]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].status =
 800c4d4:	f88a 300c 	strb.w	r3, [sl, #12]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueA =
 800c4d8:	f7fc fde4 	bl	80090a4 <GetInfoStruct>
 800c4dc:	4683      	mov	fp, r0
 800c4de:	f7fc fde1 	bl	80090a4 <GetInfoStruct>
 800c4e2:	f830 a004 	ldrh.w	sl, [r0, r4]
				GetTempInfoStruct()->infoLog[i].valueA;
 800c4e6:	f7fc fde1 	bl	80090ac <GetTempInfoStruct>
 800c4ea:	4430      	add	r0, r6
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueA =
 800c4ec:	fb05 ba0a 	mla	sl, r5, sl, fp
				GetTempInfoStruct()->infoLog[i].valueA;
 800c4f0:	7b43      	ldrb	r3, [r0, #13]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueA =
 800c4f2:	f88a 300d 	strb.w	r3, [sl, #13]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueB =
 800c4f6:	f7fc fdd5 	bl	80090a4 <GetInfoStruct>
 800c4fa:	4683      	mov	fp, r0
 800c4fc:	f7fc fdd2 	bl	80090a4 <GetInfoStruct>
 800c500:	f830 a004 	ldrh.w	sl, [r0, r4]
				GetTempInfoStruct()->infoLog[i].valueB;
 800c504:	f7fc fdd2 	bl	80090ac <GetTempInfoStruct>
 800c508:	4430      	add	r0, r6
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueB =
 800c50a:	fb05 ba0a 	mla	sl, r5, sl, fp
				GetTempInfoStruct()->infoLog[i].valueB;
 800c50e:	89c3      	ldrh	r3, [r0, #14]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueB =
 800c510:	f8aa 300e 	strh.w	r3, [sl, #14]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueC =
 800c514:	f7fc fdc6 	bl	80090a4 <GetInfoStruct>
 800c518:	4683      	mov	fp, r0
 800c51a:	f7fc fdc3 	bl	80090a4 <GetInfoStruct>
 800c51e:	f830 a004 	ldrh.w	sl, [r0, r4]
				GetTempInfoStruct()->infoLog[i].valueC;
 800c522:	f7fc fdc3 	bl	80090ac <GetTempInfoStruct>
 800c526:	4430      	add	r0, r6
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueC =
 800c528:	fb05 ba0a 	mla	sl, r5, sl, fp
				GetTempInfoStruct()->infoLog[i].valueC;
 800c52c:	6903      	ldr	r3, [r0, #16]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].valueC =
 800c52e:	f8ca 3010 	str.w	r3, [sl, #16]
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].endOfInfo = 0xDEADBEEF;
 800c532:	f7fc fdb7 	bl	80090a4 <GetInfoStruct>
 800c536:	4606      	mov	r6, r0
 800c538:	f7fc fdb4 	bl	80090a4 <GetInfoStruct>
 800c53c:	5b03      	ldrh	r3, [r0, r4]
 800c53e:	fb05 6503 	mla	r5, r5, r3, r6
	for (int i = 0; i < GetTempInfoStruct()->infoCounter; i++)
 800c542:	3701      	adds	r7, #1
		GetInfoStruct()->infoLog[GetInfoStruct()->infoCounter].endOfInfo = 0xDEADBEEF;
 800c544:	f8c5 9014 	str.w	r9, [r5, #20]
		GetInfoStruct()->infoCounter++;
 800c548:	f7fc fdac 	bl	80090a4 <GetInfoStruct>
 800c54c:	5b03      	ldrh	r3, [r0, r4]
 800c54e:	3301      	adds	r3, #1
 800c550:	5303      	strh	r3, [r0, r4]
 800c552:	e754      	b.n	800c3fe <CopyTempToInfo+0x12>
 800c554:	abbababe 	.word	0xabbababe
 800c558:	deadbeef 	.word	0xdeadbeef

0800c55c <ErrorGetSize>:
/*
 * Gets the current size of the errorLog
 */
uint32_t ErrorGetSize(Error *er)
{
	uint32_t size = er->errorCounter * sizeof(ErrorLog);
 800c55c:	f8b0 3258 	ldrh.w	r3, [r0, #600]	; 0x258
	return size;
}
 800c560:	2014      	movs	r0, #20
 800c562:	4358      	muls	r0, r3
 800c564:	4770      	bx	lr
	...

0800c568 <ErrorTimerHourly>:


/* Radio Errors */

void ErrorTimerHourly(errorTimer *sTimer, radioFlags *rFlags)
{
 800c568:	b570      	push	{r4, r5, r6, lr}
	RTC_DateTypeDef sDate;
	RTC_TimeTypeDef timeStruct;

	/* Get current time of MCU */
	HAL_RTC_GetTime(&hrtc, &timeStruct, RTC_FORMAT_BIN);
 800c56a:	4e13      	ldr	r6, [pc, #76]	; (800c5b8 <ErrorTimerHourly+0x50>)
{
 800c56c:	b086      	sub	sp, #24
 800c56e:	4604      	mov	r4, r0
 800c570:	460d      	mov	r5, r1
	HAL_RTC_GetTime(&hrtc, &timeStruct, RTC_FORMAT_BIN);
 800c572:	2200      	movs	r2, #0
 800c574:	a901      	add	r1, sp, #4
 800c576:	4630      	mov	r0, r6
 800c578:	f7f7 fb97 	bl	8003caa <HAL_RTC_GetTime>
	HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BIN);
 800c57c:	2200      	movs	r2, #0
 800c57e:	4669      	mov	r1, sp
 800c580:	4630      	mov	r0, r6
 800c582:	f7f7 fbba 	bl	8003cfa <HAL_RTC_GetDate>

	/* Assign the values to startTimer */
	sTimer->oneHourError.Year = sDate.Year;
 800c586:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c58a:	7023      	strb	r3, [r4, #0]
	sTimer->oneHourError.Month = sDate.Month;
 800c58c:	f89d 3001 	ldrb.w	r3, [sp, #1]
 800c590:	7063      	strb	r3, [r4, #1]
	sTimer->oneHourError.Day = sDate.Date;
 800c592:	f89d 3002 	ldrb.w	r3, [sp, #2]
 800c596:	70a3      	strb	r3, [r4, #2]
	sTimer->oneHourError.Hour = timeStruct.Hours;
 800c598:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800c59c:	70e3      	strb	r3, [r4, #3]
	sTimer->oneHourError.Minute = timeStruct.Minutes;
 800c59e:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800c5a2:	7123      	strb	r3, [r4, #4]
	sTimer->oneHourError.Second = timeStruct.Seconds;
 800c5a4:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800c5a8:	7163      	strb	r3, [r4, #5]

	/* Disable radio unit and enable error handler */
	rFlags->radioEnableFlag = 0;
 800c5aa:	2300      	movs	r3, #0
 800c5ac:	70ab      	strb	r3, [r5, #2]
	rFlags->errorHourFlag = 1;
 800c5ae:	2301      	movs	r3, #1
 800c5b0:	702b      	strb	r3, [r5, #0]
}
 800c5b2:	b006      	add	sp, #24
 800c5b4:	bd70      	pop	{r4, r5, r6, pc}
 800c5b6:	bf00      	nop
 800c5b8:	2000c59c 	.word	0x2000c59c

0800c5bc <ErrorTimerHourlyCheck>:

void ErrorTimerHourlyCheck(errorTimer *sTimer, errorTimer *eTimer,
		struct radioFlags *rFlags)
{
 800c5bc:	b570      	push	{r4, r5, r6, lr}
 800c5be:	b08c      	sub	sp, #48	; 0x30
 800c5c0:	460d      	mov	r5, r1
 800c5c2:	4606      	mov	r6, r0
	/* Try again in next time its scheduled (next day) */

	RTC_DateTypeDef sDate;
	RTC_TimeTypeDef timeStruct;
	/* Get current time of MCU */
	HAL_RTC_GetTime(&hrtc, &timeStruct, RTC_FORMAT_BIN);
 800c5c4:	a907      	add	r1, sp, #28
{
 800c5c6:	4614      	mov	r4, r2
	HAL_RTC_GetTime(&hrtc, &timeStruct, RTC_FORMAT_BIN);
 800c5c8:	4843      	ldr	r0, [pc, #268]	; (800c6d8 <ErrorTimerHourlyCheck+0x11c>)
 800c5ca:	2200      	movs	r2, #0
 800c5cc:	f7f7 fb6d 	bl	8003caa <HAL_RTC_GetTime>
	HAL_RTC_GetDate(&hrtc, &sDate, RTC_FORMAT_BIN);
 800c5d0:	2200      	movs	r2, #0
 800c5d2:	a906      	add	r1, sp, #24
 800c5d4:	4840      	ldr	r0, [pc, #256]	; (800c6d8 <ErrorTimerHourlyCheck+0x11c>)
 800c5d6:	f7f7 fb90 	bl	8003cfa <HAL_RTC_GetDate>

	/* Assign current time to endTimer */
	eTimer->oneHourError.Year = sDate.Year;
 800c5da:	f89d 301b 	ldrb.w	r3, [sp, #27]
 800c5de:	702b      	strb	r3, [r5, #0]
	eTimer->oneHourError.Month = sDate.Month;
 800c5e0:	f89d 3019 	ldrb.w	r3, [sp, #25]
 800c5e4:	706b      	strb	r3, [r5, #1]
	eTimer->oneHourError.Day = sDate.Date;
 800c5e6:	f89d 301a 	ldrb.w	r3, [sp, #26]
 800c5ea:	70ab      	strb	r3, [r5, #2]
	eTimer->oneHourError.Hour = timeStruct.Hours;
 800c5ec:	f89d 301c 	ldrb.w	r3, [sp, #28]
 800c5f0:	70eb      	strb	r3, [r5, #3]
	eTimer->oneHourError.Minute = timeStruct.Minutes;
 800c5f2:	f89d 301d 	ldrb.w	r3, [sp, #29]
 800c5f6:	712b      	strb	r3, [r5, #4]
	eTimer->oneHourError.Second = timeStruct.Seconds;
 800c5f8:	f89d 301e 	ldrb.w	r3, [sp, #30]
 800c5fc:	716b      	strb	r3, [r5, #5]

	printf("ErrorHourlyCheck\r\n");
 800c5fe:	4837      	ldr	r0, [pc, #220]	; (800c6dc <ErrorTimerHourlyCheck+0x120>)
 800c600:	f000 ff14 	bl	800d42c <puts>
	//HAL_Delay(1000);

	/* Calculate the difference in seconds between startTimer and endTimer */
	int32_t diffSeconds = RTC_GetElapsedSeconds(&sTimer->oneHourError, &eTimer->oneHourError);
 800c604:	4629      	mov	r1, r5
 800c606:	4630      	mov	r0, r6
 800c608:	f000 f9a2 	bl	800c950 <RTC_GetElapsedSeconds>

	/* If the clocks differ more than TIMEOUT_BEFORE_START_AGAIN, it has waited enough time */
	if (diffSeconds > TIMEOUT_BEFORE_START_AGAIN)
 800c60c:	f5b0 6f61 	cmp.w	r0, #3600	; 0xe10
 800c610:	dd0d      	ble.n	800c62e <ErrorTimerHourlyCheck+0x72>
	{
		/* Time to try the radio module again */
		rFlags->errorHourFlag = 0;
 800c612:	2300      	movs	r3, #0
 800c614:	7023      	strb	r3, [r4, #0]
		rFlags->radioEnableFlag = 1;
 800c616:	2301      	movs	r3, #1
 800c618:	70a3      	strb	r3, [r4, #2]

		/* Hour-error incremented */
		rFlags->errorHourCounter++;
 800c61a:	78e3      	ldrb	r3, [r4, #3]
 800c61c:	3301      	adds	r3, #1
 800c61e:	70e3      	strb	r3, [r4, #3]

		MX_USART2_UART_Init();
 800c620:	f7fd ffa0 	bl	800a564 <MX_USART2_UART_Init>

		MX_LPTIM1_Init();
 800c624:	f7fd fd56 	bl	800a0d4 <MX_LPTIM1_Init>

		/* Wake up and try again */
		SetRadioState(RADIO_STARTUP); //TODO
 800c628:	2002      	movs	r0, #2
 800c62a:	f7fe f881 	bl	800a730 <SetRadioState>
	}

	/* If the module has failed more than 3 times this day, go to sleep til next time its
	 * time to try sending data */
	if (rFlags->errorHourCounter >= MAX_FAILED_ATTEMPTS_HOURS)
 800c62e:	78e3      	ldrb	r3, [r4, #3]
 800c630:	2b02      	cmp	r3, #2
 800c632:	d945      	bls.n	800c6c0 <ErrorTimerHourlyCheck+0x104>
	{
		/* Daily error incremented, and hourly error reset */
		rFlags->errorDayCounter++;
 800c634:	7923      	ldrb	r3, [r4, #4]
		rFlags->errorHourCounter = 0;
 800c636:	2500      	movs	r5, #0
		rFlags->errorDayCounter++;
 800c638:	3301      	adds	r3, #1
 800c63a:	7123      	strb	r3, [r4, #4]
		rFlags->errorHourCounter = 0;
 800c63c:	70e5      	strb	r5, [r4, #3]

//		DisEnableSDPin(0);

		/* Sleep until next day */
		SetRadioState(RADIO_IDLE); //TODO
 800c63e:	4628      	mov	r0, r5
 800c640:	f7fe f876 	bl	800a730 <SetRadioState>

		InfoLogAdd(ERRORLEVEL_SEVERE,
 800c644:	f7fc fd32 	bl	80090ac <GetTempInfoStruct>
 800c648:	2611      	movs	r6, #17
 800c64a:	2317      	movs	r3, #23
 800c64c:	4619      	mov	r1, r3
 800c64e:	2236      	movs	r2, #54	; 0x36
 800c650:	9004      	str	r0, [sp, #16]
 800c652:	9503      	str	r5, [sp, #12]
 800c654:	2015      	movs	r0, #21
 800c656:	9502      	str	r5, [sp, #8]
 800c658:	9501      	str	r5, [sp, #4]
 800c65a:	9600      	str	r6, [sp, #0]
 800c65c:	f7ff fe6c 	bl	800c338 <InfoLogAdd>
		LOG_FUNC_ERROR, LOG_SUB_DAILY,
		LOG_TYPE_SET,
		LOG_STATUS_FAIL, 0, 0, 0, GetTempInfoStruct());

		/* Add to error log */
		ErrorAddLog(
 800c660:	f7fc fd1c 	bl	800909c <GetErrorStruct>
 800c664:	2217      	movs	r2, #23
 800c666:	9003      	str	r0, [sp, #12]
 800c668:	4633      	mov	r3, r6
 800c66a:	9502      	str	r5, [sp, #8]
 800c66c:	9501      	str	r5, [sp, #4]
 800c66e:	9500      	str	r5, [sp, #0]
 800c670:	2136      	movs	r1, #54	; 0x36
 800c672:	4610      	mov	r0, r2
 800c674:	f7ff fe10 	bl	800c298 <ErrorAddLog>
		LOG_FUNC_ERROR, LOG_SUB_DAILY,
		LOG_TYPE_SET,
		LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());

		/* If the radio module has failed more than X days in a row, CRITICAL ERROR */
		if (rFlags->errorDayCounter == MAX_FAILED_ATTEMPTS_DAYS)
 800c678:	7923      	ldrb	r3, [r4, #4]
 800c67a:	2b05      	cmp	r3, #5
 800c67c:	d120      	bne.n	800c6c0 <ErrorTimerHourlyCheck+0x104>
			/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*/

			int n = 10;
			while (n-- > 0)
			{
				printf("Sara exploding in %d seconds\r\n", n);
 800c67e:	4e18      	ldr	r6, [pc, #96]	; (800c6e0 <ErrorTimerHourlyCheck+0x124>)
 800c680:	250a      	movs	r5, #10
			while (n-- > 0)
 800c682:	f115 35ff 	adds.w	r5, r5, #4294967295
 800c686:	d21d      	bcs.n	800c6c4 <ErrorTimerHourlyCheck+0x108>
				HAL_Delay(1000);
				/* Lite kul fr man ha */
			}

			InfoLogAdd(ERRORLEVEL_FATAL,
 800c688:	f7fc fd10 	bl	80090ac <GetTempInfoStruct>
 800c68c:	2500      	movs	r5, #0
 800c68e:	2317      	movs	r3, #23
 800c690:	2611      	movs	r6, #17
 800c692:	4619      	mov	r1, r3
 800c694:	2237      	movs	r2, #55	; 0x37
 800c696:	9004      	str	r0, [sp, #16]
 800c698:	9503      	str	r5, [sp, #12]
 800c69a:	4618      	mov	r0, r3
 800c69c:	9502      	str	r5, [sp, #8]
 800c69e:	9501      	str	r5, [sp, #4]
 800c6a0:	9600      	str	r6, [sp, #0]
 800c6a2:	f7ff fe49 	bl	800c338 <InfoLogAdd>
			LOG_FUNC_ERROR, LOG_SUB_CRITICAL,
			LOG_TYPE_SET,
			LOG_STATUS_FAIL, 0, 0, 0, GetTempInfoStruct());

			/* Add to error log */
			ErrorAddLog(
 800c6a6:	f7fc fcf9 	bl	800909c <GetErrorStruct>
 800c6aa:	2217      	movs	r2, #23
 800c6ac:	9003      	str	r0, [sp, #12]
 800c6ae:	9502      	str	r5, [sp, #8]
 800c6b0:	9501      	str	r5, [sp, #4]
 800c6b2:	9500      	str	r5, [sp, #0]
 800c6b4:	4633      	mov	r3, r6
 800c6b6:	2137      	movs	r1, #55	; 0x37
 800c6b8:	4610      	mov	r0, r2
 800c6ba:	f7ff fded 	bl	800c298 <ErrorAddLog>
			LOG_FUNC_ERROR, LOG_SUB_CRITICAL,
			LOG_TYPE_SET,
			LOG_STATUS_FAIL, 0, 0, 0, GetErrorStruct());

			rFlags->errorDayCounter = 0;
 800c6be:	7125      	strb	r5, [r4, #4]
		}
	}
}
 800c6c0:	b00c      	add	sp, #48	; 0x30
 800c6c2:	bd70      	pop	{r4, r5, r6, pc}
				printf("Sara exploding in %d seconds\r\n", n);
 800c6c4:	4629      	mov	r1, r5
 800c6c6:	4630      	mov	r0, r6
 800c6c8:	f000 fe28 	bl	800d31c <iprintf>
				HAL_Delay(1000);
 800c6cc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800c6d0:	f7f4 fbe4 	bl	8000e9c <HAL_Delay>
 800c6d4:	e7d5      	b.n	800c682 <ErrorTimerHourlyCheck+0xc6>
 800c6d6:	bf00      	nop
 800c6d8:	2000c59c 	.word	0x2000c59c
 800c6dc:	0800fe1e 	.word	0x0800fe1e
 800c6e0:	0800fe30 	.word	0x0800fe30

0800c6e4 <JsmnParse>:

/**
 * Parse JSON string and fill tokens.
 */
JsmnErr JsmnParse(JsmnParser *parser, const char *js, JsmnTok *tokens, unsigned int num_tokens)
{
 800c6e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	token->type = type;
 800c6e8:	f04f 0c03 	mov.w	ip, #3
 800c6ec:	2600      	movs	r6, #0
	tok->start = tok->end = -1;
 800c6ee:	f04f 3eff 	mov.w	lr, #4294967295
	JsmnTok *token;
	JsmnType type;
	char c;
	int i;

	for (; js[parser->pos] != '\0'; parser->pos++)
 800c6f2:	6805      	ldr	r5, [r0, #0]
 800c6f4:	5d4c      	ldrb	r4, [r1, r5]
 800c6f6:	b94c      	cbnz	r4, 800c70c <JsmnParse+0x28>
#endif

		}
	}

	for (i = parser->toknext - 1; i >= 0; i--)
 800c6f8:	6841      	ldr	r1, [r0, #4]
 800c6fa:	1e4b      	subs	r3, r1, #1
 800c6fc:	eb02 1201 	add.w	r2, r2, r1, lsl #4
 800c700:	2b00      	cmp	r3, #0
 800c702:	f280 80fb 	bge.w	800c8fc <JsmnParse+0x218>
		{
			return JSMN_ERROR_PART;
		}
	}

	return JSMN_SUCCESS;
 800c706:	2000      	movs	r0, #0
 800c708:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		switch (c)
 800c70c:	2c2c      	cmp	r4, #44	; 0x2c
 800c70e:	d006      	beq.n	800c71e <JsmnParse+0x3a>
 800c710:	d828      	bhi.n	800c764 <JsmnParse+0x80>
 800c712:	2c0d      	cmp	r4, #13
 800c714:	d003      	beq.n	800c71e <JsmnParse+0x3a>
 800c716:	d806      	bhi.n	800c726 <JsmnParse+0x42>
 800c718:	3c09      	subs	r4, #9
 800c71a:	2c01      	cmp	r4, #1
 800c71c:	d808      	bhi.n	800c730 <JsmnParse+0x4c>
	for (; js[parser->pos] != '\0'; parser->pos++)
 800c71e:	6804      	ldr	r4, [r0, #0]
 800c720:	3401      	adds	r4, #1
 800c722:	6004      	str	r4, [r0, #0]
 800c724:	e7e5      	b.n	800c6f2 <JsmnParse+0xe>
		switch (c)
 800c726:	2c20      	cmp	r4, #32
 800c728:	d0f9      	beq.n	800c71e <JsmnParse+0x3a>
 800c72a:	2c22      	cmp	r4, #34	; 0x22
 800c72c:	f000 8086 	beq.w	800c83c <JsmnParse+0x158>
	for (; js[parser->pos] != '\0'; parser->pos++)
 800c730:	6807      	ldr	r7, [r0, #0]
 800c732:	5dcc      	ldrb	r4, [r1, r7]
 800c734:	2c00      	cmp	r4, #0
 800c736:	f040 80c4 	bne.w	800c8c2 <JsmnParse+0x1de>
	if (parser->toknext >= (int)num_tokens)
 800c73a:	6844      	ldr	r4, [r0, #4]
 800c73c:	429c      	cmp	r4, r3
 800c73e:	f280 80e8 	bge.w	800c912 <JsmnParse+0x22e>
	tok = &tokens[parser->toknext++];
 800c742:	f104 0801 	add.w	r8, r4, #1
 800c746:	0124      	lsls	r4, r4, #4
 800c748:	f8c0 8004 	str.w	r8, [r0, #4]
 800c74c:	eb02 0804 	add.w	r8, r2, r4
	token->type = type;
 800c750:	5516      	strb	r6, [r2, r4]
	token->end = end;
 800c752:	f8c8 7008 	str.w	r7, [r8, #8]
	parser->pos--;
 800c756:	3f01      	subs	r7, #1
	token->start = start;
 800c758:	f8c8 5004 	str.w	r5, [r8, #4]
	token->size = 0;
 800c75c:	f8c8 600c 	str.w	r6, [r8, #12]
	parser->pos--;
 800c760:	6007      	str	r7, [r0, #0]
 800c762:	e086      	b.n	800c872 <JsmnParse+0x18e>
		switch (c)
 800c764:	2c5d      	cmp	r4, #93	; 0x5d
 800c766:	d036      	beq.n	800c7d6 <JsmnParse+0xf2>
 800c768:	d82e      	bhi.n	800c7c8 <JsmnParse+0xe4>
 800c76a:	2c3a      	cmp	r4, #58	; 0x3a
 800c76c:	d0d7      	beq.n	800c71e <JsmnParse+0x3a>
 800c76e:	2c5b      	cmp	r4, #91	; 0x5b
 800c770:	d1de      	bne.n	800c730 <JsmnParse+0x4c>
	if (parser->toknext >= (int)num_tokens)
 800c772:	f8d0 9004 	ldr.w	r9, [r0, #4]
 800c776:	4599      	cmp	r9, r3
 800c778:	f280 80cc 	bge.w	800c914 <JsmnParse+0x230>
	tok = &tokens[parser->toknext++];
 800c77c:	f109 0701 	add.w	r7, r9, #1
 800c780:	6047      	str	r7, [r0, #4]
				if (parser->toksuper != -1)
 800c782:	6887      	ldr	r7, [r0, #8]
	tok = &tokens[parser->toknext++];
 800c784:	ea4f 1b09 	mov.w	fp, r9, lsl #4
				if (parser->toksuper != -1)
 800c788:	f1b7 3fff 	cmp.w	r7, #4294967295
	tok = &tokens[parser->toknext++];
 800c78c:	eb02 0a0b 	add.w	sl, r2, fp
					tokens[parser->toksuper].size++;
 800c790:	bf18      	it	ne
 800c792:	eb02 1807 	addne.w	r8, r2, r7, lsl #4
	tok->size = 0;
 800c796:	f8ca 600c 	str.w	r6, [sl, #12]
					tokens[parser->toksuper].size++;
 800c79a:	bf18      	it	ne
 800c79c:	f8d8 700c 	ldrne.w	r7, [r8, #12]
	tok->start = tok->end = -1;
 800c7a0:	f8ca e004 	str.w	lr, [sl, #4]
					tokens[parser->toksuper].size++;
 800c7a4:	bf18      	it	ne
 800c7a6:	3701      	addne	r7, #1
	tok->start = tok->end = -1;
 800c7a8:	f8ca e008 	str.w	lr, [sl, #8]
					tokens[parser->toksuper].size++;
 800c7ac:	bf18      	it	ne
 800c7ae:	f8c8 700c 	strne.w	r7, [r8, #12]
				token->type = (c == '{' ? JSMN_OBJECT : JSMN_ARRAY);
 800c7b2:	2c7b      	cmp	r4, #123	; 0x7b
 800c7b4:	bf14      	ite	ne
 800c7b6:	2402      	movne	r4, #2
 800c7b8:	2401      	moveq	r4, #1
 800c7ba:	f802 400b 	strb.w	r4, [r2, fp]
				token->start = parser->pos;
 800c7be:	f8ca 5004 	str.w	r5, [sl, #4]
				parser->toksuper = parser->toknext - 1;
 800c7c2:	f8c0 9008 	str.w	r9, [r0, #8]
			break;
 800c7c6:	e7aa      	b.n	800c71e <JsmnParse+0x3a>
		switch (c)
 800c7c8:	2c7b      	cmp	r4, #123	; 0x7b
 800c7ca:	d0d2      	beq.n	800c772 <JsmnParse+0x8e>
 800c7cc:	2c7d      	cmp	r4, #125	; 0x7d
 800c7ce:	d1af      	bne.n	800c730 <JsmnParse+0x4c>
			type = (c == '}' ? JSMN_OBJECT : JSMN_ARRAY);
 800c7d0:	f04f 0901 	mov.w	r9, #1
 800c7d4:	e001      	b.n	800c7da <JsmnParse+0xf6>
 800c7d6:	f04f 0902 	mov.w	r9, #2
			for (i = parser->toknext - 1; i >= 0; i--)
 800c7da:	6844      	ldr	r4, [r0, #4]
 800c7dc:	3c01      	subs	r4, #1
 800c7de:	eb02 1804 	add.w	r8, r2, r4, lsl #4
 800c7e2:	2c00      	cmp	r4, #0
 800c7e4:	da05      	bge.n	800c7f2 <JsmnParse+0x10e>
			if (i == -1)
 800c7e6:	3401      	adds	r4, #1
 800c7e8:	d199      	bne.n	800c71e <JsmnParse+0x3a>
						return JSMN_ERROR_INVAL;
 800c7ea:	f06f 0001 	mvn.w	r0, #1
 800c7ee:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				if (token->start != -1 && token->end == -1)
 800c7f2:	f8d8 7004 	ldr.w	r7, [r8, #4]
 800c7f6:	3701      	adds	r7, #1
 800c7f8:	d016      	beq.n	800c828 <JsmnParse+0x144>
 800c7fa:	f8d8 7008 	ldr.w	r7, [r8, #8]
 800c7fe:	f1b7 3fff 	cmp.w	r7, #4294967295
 800c802:	d111      	bne.n	800c828 <JsmnParse+0x144>
					if (token->type != type)
 800c804:	f898 a000 	ldrb.w	sl, [r8]
 800c808:	45ca      	cmp	sl, r9
 800c80a:	d1ee      	bne.n	800c7ea <JsmnParse+0x106>
					token->end = parser->pos + 1;
 800c80c:	3501      	adds	r5, #1
					parser->toksuper = -1;
 800c80e:	6087      	str	r7, [r0, #8]
					token->end = parser->pos + 1;
 800c810:	f8c8 5008 	str.w	r5, [r8, #8]
 800c814:	eb02 1704 	add.w	r7, r2, r4, lsl #4
				if (token->start != -1 && token->end == -1)
 800c818:	687d      	ldr	r5, [r7, #4]
 800c81a:	3501      	adds	r5, #1
 800c81c:	d008      	beq.n	800c830 <JsmnParse+0x14c>
 800c81e:	68bd      	ldr	r5, [r7, #8]
 800c820:	3501      	adds	r5, #1
 800c822:	d105      	bne.n	800c830 <JsmnParse+0x14c>
					parser->toksuper = i;
 800c824:	6084      	str	r4, [r0, #8]
					break;
 800c826:	e77a      	b.n	800c71e <JsmnParse+0x3a>
			for (i = parser->toknext - 1; i >= 0; i--)
 800c828:	3c01      	subs	r4, #1
 800c82a:	f1a8 0810 	sub.w	r8, r8, #16
 800c82e:	e7d8      	b.n	800c7e2 <JsmnParse+0xfe>
			for (; i >= 0; i--)
 800c830:	3c01      	subs	r4, #1
 800c832:	1c65      	adds	r5, r4, #1
 800c834:	f1a7 0710 	sub.w	r7, r7, #16
 800c838:	d1ee      	bne.n	800c818 <JsmnParse+0x134>
 800c83a:	e770      	b.n	800c71e <JsmnParse+0x3a>
	parser->pos++;
 800c83c:	f105 0801 	add.w	r8, r5, #1
 800c840:	f8c0 8000 	str.w	r8, [r0]
	for (; js[parser->pos] != '\0'; parser->pos++)
 800c844:	6804      	ldr	r4, [r0, #0]
 800c846:	5d0f      	ldrb	r7, [r1, r4]
 800c848:	b927      	cbnz	r7, 800c854 <JsmnParse+0x170>
	parser->pos = start;
 800c84a:	6005      	str	r5, [r0, #0]
			return JSMN_ERROR_PART;
 800c84c:	f06f 0002 	mvn.w	r0, #2
 800c850:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (c == '\"')
 800c854:	2f22      	cmp	r7, #34	; 0x22
 800c856:	d115      	bne.n	800c884 <JsmnParse+0x1a0>
	if (parser->toknext >= (int)num_tokens)
 800c858:	6847      	ldr	r7, [r0, #4]
 800c85a:	429f      	cmp	r7, r3
 800c85c:	da59      	bge.n	800c912 <JsmnParse+0x22e>
	tok = &tokens[parser->toknext++];
 800c85e:	1c7d      	adds	r5, r7, #1
 800c860:	013f      	lsls	r7, r7, #4
 800c862:	6045      	str	r5, [r0, #4]
 800c864:	19d5      	adds	r5, r2, r7
	token->type = type;
 800c866:	f802 c007 	strb.w	ip, [r2, r7]
	token->start = start;
 800c86a:	f8c5 8004 	str.w	r8, [r5, #4]
	token->end = end;
 800c86e:	60ac      	str	r4, [r5, #8]
	token->size = 0;
 800c870:	60ee      	str	r6, [r5, #12]
				if (parser->toksuper != -1)
 800c872:	6885      	ldr	r5, [r0, #8]
 800c874:	1c6c      	adds	r4, r5, #1
					tokens[parser->toksuper].size++;
 800c876:	bf1f      	itttt	ne
 800c878:	eb02 1505 	addne.w	r5, r2, r5, lsl #4
 800c87c:	68ec      	ldrne	r4, [r5, #12]
 800c87e:	3401      	addne	r4, #1
 800c880:	60ec      	strne	r4, [r5, #12]
 800c882:	e74c      	b.n	800c71e <JsmnParse+0x3a>
		if (c == '\\')
 800c884:	2f5c      	cmp	r7, #92	; 0x5c
 800c886:	d118      	bne.n	800c8ba <JsmnParse+0x1d6>
			parser->pos++;
 800c888:	3401      	adds	r4, #1
 800c88a:	6004      	str	r4, [r0, #0]
			switch (js[parser->pos])
 800c88c:	5d0c      	ldrb	r4, [r1, r4]
 800c88e:	2c66      	cmp	r4, #102	; 0x66
 800c890:	d013      	beq.n	800c8ba <JsmnParse+0x1d6>
 800c892:	d80a      	bhi.n	800c8aa <JsmnParse+0x1c6>
 800c894:	2c2f      	cmp	r4, #47	; 0x2f
 800c896:	d010      	beq.n	800c8ba <JsmnParse+0x1d6>
 800c898:	d803      	bhi.n	800c8a2 <JsmnParse+0x1be>
 800c89a:	2c22      	cmp	r4, #34	; 0x22
 800c89c:	d00d      	beq.n	800c8ba <JsmnParse+0x1d6>
			parser->pos = start;
 800c89e:	6005      	str	r5, [r0, #0]
 800c8a0:	e7a3      	b.n	800c7ea <JsmnParse+0x106>
			switch (js[parser->pos])
 800c8a2:	2c5c      	cmp	r4, #92	; 0x5c
 800c8a4:	d009      	beq.n	800c8ba <JsmnParse+0x1d6>
 800c8a6:	2c62      	cmp	r4, #98	; 0x62
 800c8a8:	e7f8      	b.n	800c89c <JsmnParse+0x1b8>
 800c8aa:	2c72      	cmp	r4, #114	; 0x72
 800c8ac:	d005      	beq.n	800c8ba <JsmnParse+0x1d6>
 800c8ae:	d801      	bhi.n	800c8b4 <JsmnParse+0x1d0>
 800c8b0:	2c6e      	cmp	r4, #110	; 0x6e
 800c8b2:	e7f3      	b.n	800c89c <JsmnParse+0x1b8>
 800c8b4:	3c74      	subs	r4, #116	; 0x74
 800c8b6:	2c01      	cmp	r4, #1
 800c8b8:	d8f1      	bhi.n	800c89e <JsmnParse+0x1ba>
	for (; js[parser->pos] != '\0'; parser->pos++)
 800c8ba:	6804      	ldr	r4, [r0, #0]
 800c8bc:	3401      	adds	r4, #1
 800c8be:	6004      	str	r4, [r0, #0]
 800c8c0:	e7c0      	b.n	800c844 <JsmnParse+0x160>
		switch (js[parser->pos])
 800c8c2:	2c20      	cmp	r4, #32
 800c8c4:	f43f af39 	beq.w	800c73a <JsmnParse+0x56>
 800c8c8:	d80d      	bhi.n	800c8e6 <JsmnParse+0x202>
 800c8ca:	2c09      	cmp	r4, #9
 800c8cc:	d305      	bcc.n	800c8da <JsmnParse+0x1f6>
 800c8ce:	2c0a      	cmp	r4, #10
 800c8d0:	f67f af33 	bls.w	800c73a <JsmnParse+0x56>
 800c8d4:	2c0d      	cmp	r4, #13
 800c8d6:	f43f af30 	beq.w	800c73a <JsmnParse+0x56>
		if (js[parser->pos] < 32 || js[parser->pos] >= 127)
 800c8da:	3c20      	subs	r4, #32
 800c8dc:	2c5e      	cmp	r4, #94	; 0x5e
 800c8de:	d8de      	bhi.n	800c89e <JsmnParse+0x1ba>
	for (; js[parser->pos] != '\0'; parser->pos++)
 800c8e0:	3701      	adds	r7, #1
 800c8e2:	6007      	str	r7, [r0, #0]
 800c8e4:	e724      	b.n	800c730 <JsmnParse+0x4c>
		switch (js[parser->pos])
 800c8e6:	2c3a      	cmp	r4, #58	; 0x3a
 800c8e8:	f43f af27 	beq.w	800c73a <JsmnParse+0x56>
 800c8ec:	d801      	bhi.n	800c8f2 <JsmnParse+0x20e>
 800c8ee:	2c2c      	cmp	r4, #44	; 0x2c
 800c8f0:	e7f1      	b.n	800c8d6 <JsmnParse+0x1f2>
 800c8f2:	2c5d      	cmp	r4, #93	; 0x5d
 800c8f4:	f43f af21 	beq.w	800c73a <JsmnParse+0x56>
 800c8f8:	2c7d      	cmp	r4, #125	; 0x7d
 800c8fa:	e7ec      	b.n	800c8d6 <JsmnParse+0x1f2>
		if (tokens[i].start != -1 && tokens[i].end == -1)
 800c8fc:	f852 1c0c 	ldr.w	r1, [r2, #-12]
 800c900:	3101      	adds	r1, #1
 800c902:	d003      	beq.n	800c90c <JsmnParse+0x228>
 800c904:	f852 1c08 	ldr.w	r1, [r2, #-8]
 800c908:	3101      	adds	r1, #1
 800c90a:	d09f      	beq.n	800c84c <JsmnParse+0x168>
	for (i = parser->toknext - 1; i >= 0; i--)
 800c90c:	3b01      	subs	r3, #1
 800c90e:	3a10      	subs	r2, #16
 800c910:	e6f6      	b.n	800c700 <JsmnParse+0x1c>
		parser->pos = start;
 800c912:	6005      	str	r5, [r0, #0]
		return JSMN_ERROR_NOMEM;
 800c914:	f04f 30ff 	mov.w	r0, #4294967295
}
 800c918:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800c91c <JsmnInitialize>:
 * Creates a new parser based over a given  buffer with an array of tokens 
 * available.
 */
void JsmnInitialize(JsmnParser *parser)
{
	parser->pos = 0;
 800c91c:	2300      	movs	r3, #0
 800c91e:	6003      	str	r3, [r0, #0]
	parser->toknext = 0;
 800c920:	6043      	str	r3, [r0, #4]
	parser->toksuper = -1;
 800c922:	f04f 33ff 	mov.w	r3, #4294967295
 800c926:	6083      	str	r3, [r0, #8]
 800c928:	4770      	bx	lr
	...

0800c92c <printTime>:
	printTime(s);
}

/* */
void printTime(Time *s)
{
 800c92c:	b51f      	push	{r0, r1, r2, r3, r4, lr}
	printf("%d/%d/%d - %d:%d:%d\r\n", s->Year, s->Month, s->Day, s->Hour, s->Minute, s->Second);
 800c92e:	7944      	ldrb	r4, [r0, #5]
 800c930:	7883      	ldrb	r3, [r0, #2]
 800c932:	7842      	ldrb	r2, [r0, #1]
 800c934:	7801      	ldrb	r1, [r0, #0]
 800c936:	9402      	str	r4, [sp, #8]
 800c938:	7904      	ldrb	r4, [r0, #4]
 800c93a:	9401      	str	r4, [sp, #4]
 800c93c:	78c0      	ldrb	r0, [r0, #3]
 800c93e:	9000      	str	r0, [sp, #0]
 800c940:	4802      	ldr	r0, [pc, #8]	; (800c94c <printTime+0x20>)
 800c942:	f000 fceb 	bl	800d31c <iprintf>
}
 800c946:	b004      	add	sp, #16
 800c948:	bd10      	pop	{r4, pc}
 800c94a:	bf00      	nop
 800c94c:	0800fe52 	.word	0x0800fe52

0800c950 <RTC_GetElapsedSeconds>:
{
 800c950:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	printf("-----------------\r\n");
 800c952:	4e1e      	ldr	r6, [pc, #120]	; (800c9cc <RTC_GetElapsedSeconds+0x7c>)
{
 800c954:	4604      	mov	r4, r0
	printf("-----------------\r\n");
 800c956:	4630      	mov	r0, r6
{
 800c958:	460d      	mov	r5, r1
	printf("-----------------\r\n");
 800c95a:	f000 fd67 	bl	800d42c <puts>
	printTime(startTime);
 800c95e:	4620      	mov	r0, r4
 800c960:	f7ff ffe4 	bl	800c92c <printTime>
	printf("-----------------\r\n");
 800c964:	4630      	mov	r0, r6
 800c966:	f000 fd61 	bl	800d42c <puts>
	printTime(endTime);
 800c96a:	4628      	mov	r0, r5
 800c96c:	f7ff ffde 	bl	800c92c <printTime>
	printf("-----------------\r\n");
 800c970:	4630      	mov	r0, r6
 800c972:	f000 fd5b 	bl	800d42c <puts>
	startSeconds += (int32_t) startTime->Month * 30 * 24 * 60 * 60;
 800c976:	7861      	ldrb	r1, [r4, #1]
 800c978:	4a15      	ldr	r2, [pc, #84]	; (800c9d0 <RTC_GetElapsedSeconds+0x80>)
	startSeconds = (int32_t) (startTime->Year) * 365 * 24 * 60 * 60;
 800c97a:	4816      	ldr	r0, [pc, #88]	; (800c9d4 <RTC_GetElapsedSeconds+0x84>)
 800c97c:	7826      	ldrb	r6, [r4, #0]
	startSeconds += (int32_t) startTime->Day * 24 * 60 * 60;
 800c97e:	f8df e058 	ldr.w	lr, [pc, #88]	; 800c9d8 <RTC_GetElapsedSeconds+0x88>
	endSeconds += (int32_t) endTime->Month * 30 * 24 * 60 * 60;
 800c982:	f895 c001 	ldrb.w	ip, [r5, #1]
	startSeconds += (int32_t) startTime->Month * 30 * 24 * 60 * 60;
 800c986:	4351      	muls	r1, r2
 800c988:	fb00 1606 	mla	r6, r0, r6, r1
	startSeconds += (int32_t) startTime->Day * 24 * 60 * 60;
 800c98c:	78a1      	ldrb	r1, [r4, #2]
 800c98e:	fb0e 6601 	mla	r6, lr, r1, r6
	startSeconds += (int32_t) startTime->Hour * 60 * 60;
 800c992:	78e1      	ldrb	r1, [r4, #3]
 800c994:	f44f 6761 	mov.w	r7, #3600	; 0xe10
 800c998:	fb07 6101 	mla	r1, r7, r1, r6
	startSeconds += (int32_t) startTime->Minute * 60;
 800c99c:	7926      	ldrb	r6, [r4, #4]
 800c99e:	233c      	movs	r3, #60	; 0x3c
 800c9a0:	fb13 1106 	smlabb	r1, r3, r6, r1
	endSeconds = (int32_t) (endTime->Year) * 365 * 24 * 60 * 60;
 800c9a4:	782e      	ldrb	r6, [r5, #0]
	endSeconds += (int32_t) endTime->Month * 30 * 24 * 60 * 60;
 800c9a6:	fb02 f20c 	mul.w	r2, r2, ip
 800c9aa:	fb00 2206 	mla	r2, r0, r6, r2
	endSeconds += (int32_t) endTime->Day * 24 * 60 * 60;
 800c9ae:	78a8      	ldrb	r0, [r5, #2]
 800c9b0:	fb0e 2200 	mla	r2, lr, r0, r2
	endSeconds += (int32_t) endTime->Hour * 60 * 60;
 800c9b4:	78e8      	ldrb	r0, [r5, #3]
 800c9b6:	fb07 2000 	mla	r0, r7, r0, r2
	endSeconds += (int32_t) endTime->Minute * 60;
 800c9ba:	792a      	ldrb	r2, [r5, #4]
 800c9bc:	fb13 0302 	smlabb	r3, r3, r2, r0
	endSeconds += (int32_t) endTime->Second;
 800c9c0:	7968      	ldrb	r0, [r5, #5]
	startSeconds += (int32_t) startTime->Second;
 800c9c2:	7962      	ldrb	r2, [r4, #5]
	endSeconds += (int32_t) endTime->Second;
 800c9c4:	4418      	add	r0, r3
	startSeconds += (int32_t) startTime->Second;
 800c9c6:	440a      	add	r2, r1
}
 800c9c8:	1a80      	subs	r0, r0, r2
 800c9ca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800c9cc:	0800f9de 	.word	0x0800f9de
 800c9d0:	00278d00 	.word	0x00278d00
 800c9d4:	01e13380 	.word	0x01e13380
 800c9d8:	00015180 	.word	0x00015180

0800c9dc <GetTime>:
{
 800c9dc:	b530      	push	{r4, r5, lr}
	HAL_RTC_GetTime(&hrtc, &tS, RTC_FORMAT_BIN);
 800c9de:	4d12      	ldr	r5, [pc, #72]	; (800ca28 <GetTime+0x4c>)
{
 800c9e0:	b087      	sub	sp, #28
 800c9e2:	4604      	mov	r4, r0
	HAL_RTC_GetTime(&hrtc, &tS, RTC_FORMAT_BIN);
 800c9e4:	a901      	add	r1, sp, #4
 800c9e6:	2200      	movs	r2, #0
 800c9e8:	4628      	mov	r0, r5
 800c9ea:	f7f7 f95e 	bl	8003caa <HAL_RTC_GetTime>
	HAL_RTC_GetDate(&hrtc, &sD, RTC_FORMAT_BIN);
 800c9ee:	2200      	movs	r2, #0
 800c9f0:	4669      	mov	r1, sp
 800c9f2:	4628      	mov	r0, r5
 800c9f4:	f7f7 f981 	bl	8003cfa <HAL_RTC_GetDate>
	s->Year = sD.Year;
 800c9f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c9fc:	7023      	strb	r3, [r4, #0]
	s->Month = sD.Month;
 800c9fe:	f89d 3001 	ldrb.w	r3, [sp, #1]
 800ca02:	7063      	strb	r3, [r4, #1]
	s->Day = sD.Date;
 800ca04:	f89d 3002 	ldrb.w	r3, [sp, #2]
 800ca08:	70a3      	strb	r3, [r4, #2]
	s->Hour = tS.Hours;
 800ca0a:	f89d 3004 	ldrb.w	r3, [sp, #4]
 800ca0e:	70e3      	strb	r3, [r4, #3]
	s->Minute = tS.Minutes;
 800ca10:	f89d 3005 	ldrb.w	r3, [sp, #5]
 800ca14:	7123      	strb	r3, [r4, #4]
	s->Second = tS.Seconds;
 800ca16:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800ca1a:	7163      	strb	r3, [r4, #5]
	printTime(s);
 800ca1c:	4620      	mov	r0, r4
 800ca1e:	f7ff ff85 	bl	800c92c <printTime>
}
 800ca22:	b007      	add	sp, #28
 800ca24:	bd30      	pop	{r4, r5, pc}
 800ca26:	bf00      	nop
 800ca28:	2000c59c 	.word	0x2000c59c

0800ca2c <TimeToSend>:

/* Configures when it is time to activate the Radio */
uint8_t TimeToSend(Time *sT, Time *eT, Data *data)
{
 800ca2c:	b570      	push	{r4, r5, r6, lr}
 800ca2e:	460c      	mov	r4, r1
 800ca30:	4606      	mov	r6, r0
	SaraConfig *sC = GetSaraConfigurationStruct();
 800ca32:	f7fc fb67 	bl	8009104 <GetSaraConfigurationStruct>
 800ca36:	4605      	mov	r5, r0

	/* Get MCU clock */
	GetTime(eT);
 800ca38:	4620      	mov	r0, r4
 800ca3a:	f7ff ffcf 	bl	800c9dc <GetTime>

	/* Calculate elapsed seconds between last connected and now */
	int32_t elapsedSec = RTC_GetElapsedSeconds(sT, eT);
 800ca3e:	4621      	mov	r1, r4
 800ca40:	4630      	mov	r0, r6
 800ca42:	f7ff ff85 	bl	800c950 <RTC_GetElapsedSeconds>
//	}
//	/* Lux analysis is within 2 hours */


		/* If MCU clock is equal to hour to send */
	if (eT->Hour == sC->hourToSend && abs(elapsedSec > 3600))
 800ca46:	78e2      	ldrb	r2, [r4, #3]
 800ca48:	f895 3084 	ldrb.w	r3, [r5, #132]	; 0x84
 800ca4c:	429a      	cmp	r2, r3
 800ca4e:	d10b      	bne.n	800ca68 <TimeToSend+0x3c>
 800ca50:	f5b0 6f61 	cmp.w	r0, #3600	; 0xe10
 800ca54:	dd08      	ble.n	800ca68 <TimeToSend+0x3c>
//		if (abs(elapsedSec > 30))
	{
		debugPrint(&hlpuart1, "nC");
 800ca56:	4805      	ldr	r0, [pc, #20]	; (800ca6c <TimeToSend+0x40>)
 800ca58:	4905      	ldr	r1, [pc, #20]	; (800ca70 <TimeToSend+0x44>)
 800ca5a:	f7fd fe1d 	bl	800a698 <debugPrint>

		/* Start radio up */
		return SetRadioState(RADIO_AWAKE);
 800ca5e:	2001      	movs	r0, #1
	}
	/* If its not time to send */
	return false;
}
 800ca60:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		return SetRadioState(RADIO_AWAKE);
 800ca64:	f7fd be64 	b.w	800a730 <SetRadioState>
}
 800ca68:	2000      	movs	r0, #0
 800ca6a:	bd70      	pop	{r4, r5, r6, pc}
 800ca6c:	2000c5c0 	.word	0x2000c5c0
 800ca70:	0800fe4f 	.word	0x0800fe4f

0800ca74 <LED_Blink>:
}

/* Blinks Heartbeat LED */
void LED_Blink(void)
{
	HAL_GPIO_TogglePin(Heartbeat_GPIO_Port, Heartbeat_Pin);
 800ca74:	2140      	movs	r1, #64	; 0x40
 800ca76:	4801      	ldr	r0, [pc, #4]	; (800ca7c <LED_Blink+0x8>)
 800ca78:	f7f5 bb7f 	b.w	800217a <HAL_GPIO_TogglePin>
 800ca7c:	48000800 	.word	0x48000800

0800ca80 <main>:
  * @brief  The application entry point.
  *
  * @retval None
  */
int main(void)
{
 800ca80:	b570      	push	{r4, r5, r6, lr}
 800ca82:	b086      	sub	sp, #24
	/* Init peripherals */
	InitAll();
 800ca84:	f7fc fe92 	bl	80097ac <InitAll>

	/* Init every struct that is needed in the run */
	InitSaraStruct(GetSaraConfigurationStruct());
 800ca88:	f7fc fb3c 	bl	8009104 <GetSaraConfigurationStruct>
 800ca8c:	f7ff fa0e 	bl	800beac <InitSaraStruct>
	InitErrorStruct(GetErrorFlagsStruct());
 800ca90:	f7fc fb3c 	bl	800910c <GetErrorFlagsStruct>
 800ca94:	f7ff f9e8 	bl	800be68 <InitErrorStruct>

	/* Reason for the two InfoStructs, one is for each iteration (temp), if an error occurs,
	 * it will be written over to the other, which will be written to the SD card when its time */
	InitInfoStruct(GetInfoStruct());
 800ca98:	f7fc fb04 	bl	80090a4 <GetInfoStruct>
 800ca9c:	f7ff fc4a 	bl	800c334 <InitInfoStruct>
	InitInfoStruct(GetTempInfoStruct());
 800caa0:	f7fc fb04 	bl	80090ac <GetTempInfoStruct>
 800caa4:	f7ff fc46 	bl	800c334 <InitInfoStruct>

	Data *data = GetDataStruct();
 800caa8:	f7fc faf4 	bl	8009094 <GetDataStruct>
 800caac:	4606      	mov	r6, r0
	Error *er = GetErrorStruct();
 800caae:	f7fc faf5 	bl	800909c <GetErrorStruct>
 800cab2:	4604      	mov	r4, r0
	radioFlags *rE = GetErrorFlagsStruct();
 800cab4:	f7fc fb2a 	bl	800910c <GetErrorFlagsStruct>
 800cab8:	4605      	mov	r5, r0
	DataStruct_init(data);
 800caba:	4630      	mov	r0, r6
 800cabc:	f7fb fe74 	bl	80087a8 <DataStruct_init>
	ErrorStruct_init(er);
 800cac0:	4620      	mov	r0, r4
 800cac2:	f7ff fbdd 	bl	800c280 <ErrorStruct_init>
	
	/* Program Option bits so that IWDG freezes in shutdown mode */
	Program_IWDG_Freeze_Shutdown();
 800cac6:	f7fd facd 	bl	800a064 <Program_IWDG_Freeze_Shutdown>


	printf("\r\n\r\n\t ** STARTaaa! ** \r\n\r\n");
 800caca:	4828      	ldr	r0, [pc, #160]	; (800cb6c <main+0xec>)

	/* Turn SD Power pin low */
	DisEnableSDPin(0);

	/* Debug, check the reason for reset */
	printf("Reason for reset: %d\r\n", checkResetCause);
 800cacc:	4c28      	ldr	r4, [pc, #160]	; (800cb70 <main+0xf0>)
	printf("\r\n\r\n\t ** STARTaaa! ** \r\n\r\n");
 800cace:	f000 fcad 	bl	800d42c <puts>
	DisEnableSDPin(1);
 800cad2:	2001      	movs	r0, #1
 800cad4:	f7fd f990 	bl	8009df8 <DisEnableSDPin>
	HAL_Delay(1000);
 800cad8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800cadc:	f7f4 f9de 	bl	8000e9c <HAL_Delay>
	InitFoldersSD();
 800cae0:	f7fa fcc2 	bl	8007468 <InitFoldersSD>
	DisEnableSDPin(0);
 800cae4:	2000      	movs	r0, #0
 800cae6:	f7fd f987 	bl	8009df8 <DisEnableSDPin>
	printf("Reason for reset: %d\r\n", checkResetCause);
 800caea:	7821      	ldrb	r1, [r4, #0]
 800caec:	4821      	ldr	r0, [pc, #132]	; (800cb74 <main+0xf4>)
 800caee:	f000 fc15 	bl	800d31c <iprintf>
	printf("---------------------\r\n");
 800caf2:	4821      	ldr	r0, [pc, #132]	; (800cb78 <main+0xf8>)
 800caf4:	f000 fc9a 	bl	800d42c <puts>

	/* Add to InfoLog the reason for reset */
	InfoLogAdd(ERRORLEVEL_FATAL,
 800caf8:	7824      	ldrb	r4, [r4, #0]
 800cafa:	f7fc fad7 	bl	80090ac <GetTempInfoStruct>
 800cafe:	2300      	movs	r3, #0
 800cb00:	9303      	str	r3, [sp, #12]
 800cb02:	9302      	str	r3, [sp, #8]
 800cb04:	2312      	movs	r3, #18
 800cb06:	9004      	str	r0, [sp, #16]
 800cb08:	9300      	str	r3, [sp, #0]
 800cb0a:	9401      	str	r4, [sp, #4]
 800cb0c:	2316      	movs	r3, #22
 800cb0e:	2215      	movs	r2, #21
 800cb10:	211a      	movs	r1, #26
 800cb12:	2017      	movs	r0, #23
 800cb14:	f7ff fc10 	bl	800c338 <InfoLogAdd>

  while (1)
  {

		/* Resets/kicks the WatchDog so that the module can be on for another 32 sec */
		ResetIWDG();
 800cb18:	f7fd fa9c 	bl	800a054 <ResetIWDG>

		/* If Radio is enabled (no errors in radio) */
		if (rE->radioEnableFlag == 1)
 800cb1c:	78ab      	ldrb	r3, [r5, #2]
 800cb1e:	2b01      	cmp	r3, #1
 800cb20:	d114      	bne.n	800cb4c <main+0xcc>
		{
			/* Go into radio state machine */
			RadioStateMachine(GetDataStruct(), GetErrorStruct());
 800cb22:	f7fc fab7 	bl	8009094 <GetDataStruct>
 800cb26:	4604      	mov	r4, r0
 800cb28:	f7fc fab8 	bl	800909c <GetErrorStruct>
 800cb2c:	4601      	mov	r1, r0
 800cb2e:	4620      	mov	r0, r4
 800cb30:	f7fd fe7c 	bl	800a82c <RadioStateMachine>
					GetErrorTimerStruct(endTimerEnum),
					GetErrorFlagsStruct());
		}

		/* Enter Sensor state machine */
		SensorStateMachine(GetDataStruct(), GetErrorStruct());
 800cb34:	f7fc faae 	bl	8009094 <GetDataStruct>
 800cb38:	4604      	mov	r4, r0
 800cb3a:	f7fc faaf 	bl	800909c <GetErrorStruct>
 800cb3e:	4601      	mov	r1, r0
 800cb40:	4620      	mov	r0, r4
 800cb42:	f7fe fc05 	bl	800b350 <SensorStateMachine>

		/* Enter sleep state machine */
		SleepStateMachine();
 800cb46:	f7fe fd0f 	bl	800b568 <SleepStateMachine>
		ResetIWDG();
 800cb4a:	e7e5      	b.n	800cb18 <main+0x98>
					GetErrorTimerStruct(startTimerEnum),
 800cb4c:	2000      	movs	r0, #0
 800cb4e:	f7fc fae1 	bl	8009114 <GetErrorTimerStruct>
 800cb52:	4604      	mov	r4, r0
					GetErrorTimerStruct(endTimerEnum),
 800cb54:	2001      	movs	r0, #1
 800cb56:	f7fc fadd 	bl	8009114 <GetErrorTimerStruct>
 800cb5a:	4606      	mov	r6, r0
					GetErrorFlagsStruct());
 800cb5c:	f7fc fad6 	bl	800910c <GetErrorFlagsStruct>
			ErrorTimerHourlyCheck(
 800cb60:	4631      	mov	r1, r6
 800cb62:	4602      	mov	r2, r0
 800cb64:	4620      	mov	r0, r4
 800cb66:	f7ff fd29 	bl	800c5bc <ErrorTimerHourlyCheck>
 800cb6a:	e7e3      	b.n	800cb34 <main+0xb4>
 800cb6c:	0800fe68 	.word	0x0800fe68
 800cb70:	2000039b 	.word	0x2000039b
 800cb74:	0800fe82 	.word	0x0800fe82
 800cb78:	0800f9da 	.word	0x0800f9da

0800cb7c <_Error_Handler>:
  * @param  file: The file name as string.
  * @param  line: The line in file as a number.
  * @retval None
  */
void _Error_Handler(char *file, int line)
{
 800cb7c:	e7fe      	b.n	800cb7c <_Error_Handler>
	...

0800cb80 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800cb80:	f8df d034 	ldr.w	sp, [pc, #52]	; 800cbb8 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 800cb84:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 800cb86:	e003      	b.n	800cb90 <LoopCopyDataInit>

0800cb88 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 800cb88:	4b0c      	ldr	r3, [pc, #48]	; (800cbbc <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 800cb8a:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 800cb8c:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 800cb8e:	3104      	adds	r1, #4

0800cb90 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 800cb90:	480b      	ldr	r0, [pc, #44]	; (800cbc0 <LoopForever+0xa>)
	ldr	r3, =_edata
 800cb92:	4b0c      	ldr	r3, [pc, #48]	; (800cbc4 <LoopForever+0xe>)
	adds	r2, r0, r1
 800cb94:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 800cb96:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 800cb98:	d3f6      	bcc.n	800cb88 <CopyDataInit>
	ldr	r2, =_sbss
 800cb9a:	4a0b      	ldr	r2, [pc, #44]	; (800cbc8 <LoopForever+0x12>)
	b	LoopFillZerobss
 800cb9c:	e002      	b.n	800cba4 <LoopFillZerobss>

0800cb9e <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 800cb9e:	2300      	movs	r3, #0
	str	r3, [r2], #4
 800cba0:	f842 3b04 	str.w	r3, [r2], #4

0800cba4 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 800cba4:	4b09      	ldr	r3, [pc, #36]	; (800cbcc <LoopForever+0x16>)
	cmp	r2, r3
 800cba6:	429a      	cmp	r2, r3
	bcc	FillZerobss
 800cba8:	d3f9      	bcc.n	800cb9e <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 800cbaa:	f7fd fc97 	bl	800a4dc <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 800cbae:	f000 f857 	bl	800cc60 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 800cbb2:	f7ff ff65 	bl	800ca80 <main>

0800cbb6 <LoopForever>:

LoopForever:
    b LoopForever
 800cbb6:	e7fe      	b.n	800cbb6 <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 800cbb8:	20028000 	.word	0x20028000
	ldr	r3, =_sidata
 800cbbc:	080101bc 	.word	0x080101bc
	ldr	r0, =_sdata
 800cbc0:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 800cbc4:	20000248 	.word	0x20000248
	ldr	r2, =_sbss
 800cbc8:	20000248 	.word	0x20000248
	ldr	r3, = _ebss
 800cbcc:	2000c640 	.word	0x2000c640

0800cbd0 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 800cbd0:	e7fe      	b.n	800cbd0 <ADC1_IRQHandler>
	...

0800cbd4 <asctime>:
 800cbd4:	4b09      	ldr	r3, [pc, #36]	; (800cbfc <asctime+0x28>)
 800cbd6:	b570      	push	{r4, r5, r6, lr}
 800cbd8:	681c      	ldr	r4, [r3, #0]
 800cbda:	6c25      	ldr	r5, [r4, #64]	; 0x40
 800cbdc:	4606      	mov	r6, r0
 800cbde:	b93d      	cbnz	r5, 800cbf0 <asctime+0x1c>
 800cbe0:	201a      	movs	r0, #26
 800cbe2:	f000 f861 	bl	800cca8 <malloc>
 800cbe6:	221a      	movs	r2, #26
 800cbe8:	6420      	str	r0, [r4, #64]	; 0x40
 800cbea:	4629      	mov	r1, r5
 800cbec:	f000 f886 	bl	800ccfc <memset>
 800cbf0:	6c21      	ldr	r1, [r4, #64]	; 0x40
 800cbf2:	4630      	mov	r0, r6
 800cbf4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800cbf8:	f000 b802 	b.w	800cc00 <asctime_r>
 800cbfc:	2000002c 	.word	0x2000002c

0800cc00 <asctime_r>:
 800cc00:	b510      	push	{r4, lr}
 800cc02:	460c      	mov	r4, r1
 800cc04:	6941      	ldr	r1, [r0, #20]
 800cc06:	6903      	ldr	r3, [r0, #16]
 800cc08:	6982      	ldr	r2, [r0, #24]
 800cc0a:	b086      	sub	sp, #24
 800cc0c:	f201 716c 	addw	r1, r1, #1900	; 0x76c
 800cc10:	9104      	str	r1, [sp, #16]
 800cc12:	6801      	ldr	r1, [r0, #0]
 800cc14:	9103      	str	r1, [sp, #12]
 800cc16:	6841      	ldr	r1, [r0, #4]
 800cc18:	9102      	str	r1, [sp, #8]
 800cc1a:	6881      	ldr	r1, [r0, #8]
 800cc1c:	9101      	str	r1, [sp, #4]
 800cc1e:	68c1      	ldr	r1, [r0, #12]
 800cc20:	9100      	str	r1, [sp, #0]
 800cc22:	4907      	ldr	r1, [pc, #28]	; (800cc40 <asctime_r+0x40>)
 800cc24:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 800cc28:	440b      	add	r3, r1
 800cc2a:	4906      	ldr	r1, [pc, #24]	; (800cc44 <asctime_r+0x44>)
 800cc2c:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800cc30:	440a      	add	r2, r1
 800cc32:	4620      	mov	r0, r4
 800cc34:	4904      	ldr	r1, [pc, #16]	; (800cc48 <asctime_r+0x48>)
 800cc36:	f000 fc11 	bl	800d45c <siprintf>
 800cc3a:	4620      	mov	r0, r4
 800cc3c:	b006      	add	sp, #24
 800cc3e:	bd10      	pop	{r4, pc}
 800cc40:	0800fece 	.word	0x0800fece
 800cc44:	0800feb9 	.word	0x0800feb9
 800cc48:	0800fe99 	.word	0x0800fe99

0800cc4c <atoi>:
 800cc4c:	220a      	movs	r2, #10
 800cc4e:	2100      	movs	r1, #0
 800cc50:	f000 bd7e 	b.w	800d750 <strtol>

0800cc54 <__errno>:
 800cc54:	4b01      	ldr	r3, [pc, #4]	; (800cc5c <__errno+0x8>)
 800cc56:	6818      	ldr	r0, [r3, #0]
 800cc58:	4770      	bx	lr
 800cc5a:	bf00      	nop
 800cc5c:	2000002c 	.word	0x2000002c

0800cc60 <__libc_init_array>:
 800cc60:	b570      	push	{r4, r5, r6, lr}
 800cc62:	4e0d      	ldr	r6, [pc, #52]	; (800cc98 <__libc_init_array+0x38>)
 800cc64:	4c0d      	ldr	r4, [pc, #52]	; (800cc9c <__libc_init_array+0x3c>)
 800cc66:	1ba4      	subs	r4, r4, r6
 800cc68:	10a4      	asrs	r4, r4, #2
 800cc6a:	2500      	movs	r5, #0
 800cc6c:	42a5      	cmp	r5, r4
 800cc6e:	d109      	bne.n	800cc84 <__libc_init_array+0x24>
 800cc70:	4e0b      	ldr	r6, [pc, #44]	; (800cca0 <__libc_init_array+0x40>)
 800cc72:	4c0c      	ldr	r4, [pc, #48]	; (800cca4 <__libc_init_array+0x44>)
 800cc74:	f002 fc56 	bl	800f524 <_init>
 800cc78:	1ba4      	subs	r4, r4, r6
 800cc7a:	10a4      	asrs	r4, r4, #2
 800cc7c:	2500      	movs	r5, #0
 800cc7e:	42a5      	cmp	r5, r4
 800cc80:	d105      	bne.n	800cc8e <__libc_init_array+0x2e>
 800cc82:	bd70      	pop	{r4, r5, r6, pc}
 800cc84:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800cc88:	4798      	blx	r3
 800cc8a:	3501      	adds	r5, #1
 800cc8c:	e7ee      	b.n	800cc6c <__libc_init_array+0xc>
 800cc8e:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800cc92:	4798      	blx	r3
 800cc94:	3501      	adds	r5, #1
 800cc96:	e7f2      	b.n	800cc7e <__libc_init_array+0x1e>
 800cc98:	080101b4 	.word	0x080101b4
 800cc9c:	080101b4 	.word	0x080101b4
 800cca0:	080101b4 	.word	0x080101b4
 800cca4:	080101b8 	.word	0x080101b8

0800cca8 <malloc>:
 800cca8:	4b02      	ldr	r3, [pc, #8]	; (800ccb4 <malloc+0xc>)
 800ccaa:	4601      	mov	r1, r0
 800ccac:	6818      	ldr	r0, [r3, #0]
 800ccae:	f000 bad7 	b.w	800d260 <_malloc_r>
 800ccb2:	bf00      	nop
 800ccb4:	2000002c 	.word	0x2000002c

0800ccb8 <free>:
 800ccb8:	4b02      	ldr	r3, [pc, #8]	; (800ccc4 <free+0xc>)
 800ccba:	4601      	mov	r1, r0
 800ccbc:	6818      	ldr	r0, [r3, #0]
 800ccbe:	f000 ba81 	b.w	800d1c4 <_free_r>
 800ccc2:	bf00      	nop
 800ccc4:	2000002c 	.word	0x2000002c

0800ccc8 <memcmp>:
 800ccc8:	b510      	push	{r4, lr}
 800ccca:	3901      	subs	r1, #1
 800cccc:	4402      	add	r2, r0
 800ccce:	4290      	cmp	r0, r2
 800ccd0:	d101      	bne.n	800ccd6 <memcmp+0xe>
 800ccd2:	2000      	movs	r0, #0
 800ccd4:	bd10      	pop	{r4, pc}
 800ccd6:	f810 3b01 	ldrb.w	r3, [r0], #1
 800ccda:	f811 4f01 	ldrb.w	r4, [r1, #1]!
 800ccde:	42a3      	cmp	r3, r4
 800cce0:	d0f5      	beq.n	800ccce <memcmp+0x6>
 800cce2:	1b18      	subs	r0, r3, r4
 800cce4:	bd10      	pop	{r4, pc}

0800cce6 <memcpy>:
 800cce6:	b510      	push	{r4, lr}
 800cce8:	1e43      	subs	r3, r0, #1
 800ccea:	440a      	add	r2, r1
 800ccec:	4291      	cmp	r1, r2
 800ccee:	d100      	bne.n	800ccf2 <memcpy+0xc>
 800ccf0:	bd10      	pop	{r4, pc}
 800ccf2:	f811 4b01 	ldrb.w	r4, [r1], #1
 800ccf6:	f803 4f01 	strb.w	r4, [r3, #1]!
 800ccfa:	e7f7      	b.n	800ccec <memcpy+0x6>

0800ccfc <memset>:
 800ccfc:	4402      	add	r2, r0
 800ccfe:	4603      	mov	r3, r0
 800cd00:	4293      	cmp	r3, r2
 800cd02:	d100      	bne.n	800cd06 <memset+0xa>
 800cd04:	4770      	bx	lr
 800cd06:	f803 1b01 	strb.w	r1, [r3], #1
 800cd0a:	e7f9      	b.n	800cd00 <memset+0x4>

0800cd0c <validate_structure>:
 800cd0c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 800cd0e:	6801      	ldr	r1, [r0, #0]
 800cd10:	293b      	cmp	r1, #59	; 0x3b
 800cd12:	4604      	mov	r4, r0
 800cd14:	d911      	bls.n	800cd3a <validate_structure+0x2e>
 800cd16:	223c      	movs	r2, #60	; 0x3c
 800cd18:	4668      	mov	r0, sp
 800cd1a:	f001 f843 	bl	800dda4 <div>
 800cd1e:	9a01      	ldr	r2, [sp, #4]
 800cd20:	6863      	ldr	r3, [r4, #4]
 800cd22:	9900      	ldr	r1, [sp, #0]
 800cd24:	2a00      	cmp	r2, #0
 800cd26:	440b      	add	r3, r1
 800cd28:	6063      	str	r3, [r4, #4]
 800cd2a:	bfbb      	ittet	lt
 800cd2c:	323c      	addlt	r2, #60	; 0x3c
 800cd2e:	f103 33ff 	addlt.w	r3, r3, #4294967295
 800cd32:	6022      	strge	r2, [r4, #0]
 800cd34:	6022      	strlt	r2, [r4, #0]
 800cd36:	bfb8      	it	lt
 800cd38:	6063      	strlt	r3, [r4, #4]
 800cd3a:	6861      	ldr	r1, [r4, #4]
 800cd3c:	293b      	cmp	r1, #59	; 0x3b
 800cd3e:	d911      	bls.n	800cd64 <validate_structure+0x58>
 800cd40:	223c      	movs	r2, #60	; 0x3c
 800cd42:	4668      	mov	r0, sp
 800cd44:	f001 f82e 	bl	800dda4 <div>
 800cd48:	9a01      	ldr	r2, [sp, #4]
 800cd4a:	68a3      	ldr	r3, [r4, #8]
 800cd4c:	9900      	ldr	r1, [sp, #0]
 800cd4e:	2a00      	cmp	r2, #0
 800cd50:	440b      	add	r3, r1
 800cd52:	60a3      	str	r3, [r4, #8]
 800cd54:	bfbb      	ittet	lt
 800cd56:	323c      	addlt	r2, #60	; 0x3c
 800cd58:	f103 33ff 	addlt.w	r3, r3, #4294967295
 800cd5c:	6062      	strge	r2, [r4, #4]
 800cd5e:	6062      	strlt	r2, [r4, #4]
 800cd60:	bfb8      	it	lt
 800cd62:	60a3      	strlt	r3, [r4, #8]
 800cd64:	68a1      	ldr	r1, [r4, #8]
 800cd66:	2917      	cmp	r1, #23
 800cd68:	d911      	bls.n	800cd8e <validate_structure+0x82>
 800cd6a:	2218      	movs	r2, #24
 800cd6c:	4668      	mov	r0, sp
 800cd6e:	f001 f819 	bl	800dda4 <div>
 800cd72:	9a01      	ldr	r2, [sp, #4]
 800cd74:	68e3      	ldr	r3, [r4, #12]
 800cd76:	9900      	ldr	r1, [sp, #0]
 800cd78:	2a00      	cmp	r2, #0
 800cd7a:	440b      	add	r3, r1
 800cd7c:	60e3      	str	r3, [r4, #12]
 800cd7e:	bfbb      	ittet	lt
 800cd80:	3218      	addlt	r2, #24
 800cd82:	f103 33ff 	addlt.w	r3, r3, #4294967295
 800cd86:	60a2      	strge	r2, [r4, #8]
 800cd88:	60a2      	strlt	r2, [r4, #8]
 800cd8a:	bfb8      	it	lt
 800cd8c:	60e3      	strlt	r3, [r4, #12]
 800cd8e:	6921      	ldr	r1, [r4, #16]
 800cd90:	290b      	cmp	r1, #11
 800cd92:	d911      	bls.n	800cdb8 <validate_structure+0xac>
 800cd94:	220c      	movs	r2, #12
 800cd96:	4668      	mov	r0, sp
 800cd98:	f001 f804 	bl	800dda4 <div>
 800cd9c:	9a01      	ldr	r2, [sp, #4]
 800cd9e:	6963      	ldr	r3, [r4, #20]
 800cda0:	9900      	ldr	r1, [sp, #0]
 800cda2:	2a00      	cmp	r2, #0
 800cda4:	440b      	add	r3, r1
 800cda6:	6163      	str	r3, [r4, #20]
 800cda8:	bfbb      	ittet	lt
 800cdaa:	320c      	addlt	r2, #12
 800cdac:	f103 33ff 	addlt.w	r3, r3, #4294967295
 800cdb0:	6122      	strge	r2, [r4, #16]
 800cdb2:	6122      	strlt	r2, [r4, #16]
 800cdb4:	bfb8      	it	lt
 800cdb6:	6163      	strlt	r3, [r4, #20]
 800cdb8:	6963      	ldr	r3, [r4, #20]
 800cdba:	0799      	lsls	r1, r3, #30
 800cdbc:	d143      	bne.n	800ce46 <validate_structure+0x13a>
 800cdbe:	2164      	movs	r1, #100	; 0x64
 800cdc0:	fb93 f2f1 	sdiv	r2, r3, r1
 800cdc4:	fb01 3212 	mls	r2, r1, r2, r3
 800cdc8:	2a00      	cmp	r2, #0
 800cdca:	d13e      	bne.n	800ce4a <validate_structure+0x13e>
 800cdcc:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 800cdd0:	f44f 71c8 	mov.w	r1, #400	; 0x190
 800cdd4:	fb93 f2f1 	sdiv	r2, r3, r1
 800cdd8:	fb01 3312 	mls	r3, r1, r2, r3
 800cddc:	2b00      	cmp	r3, #0
 800cdde:	bf14      	ite	ne
 800cde0:	231c      	movne	r3, #28
 800cde2:	231d      	moveq	r3, #29
 800cde4:	68e2      	ldr	r2, [r4, #12]
 800cde6:	2a00      	cmp	r2, #0
 800cde8:	dd31      	ble.n	800ce4e <validate_structure+0x142>
 800cdea:	4f37      	ldr	r7, [pc, #220]	; (800cec8 <validate_structure+0x1bc>)
 800cdec:	2602      	movs	r6, #2
 800cdee:	f04f 0e00 	mov.w	lr, #0
 800cdf2:	2064      	movs	r0, #100	; 0x64
 800cdf4:	f44f 75c8 	mov.w	r5, #400	; 0x190
 800cdf8:	6921      	ldr	r1, [r4, #16]
 800cdfa:	68e2      	ldr	r2, [r4, #12]
 800cdfc:	2901      	cmp	r1, #1
 800cdfe:	d05d      	beq.n	800cebc <validate_structure+0x1b0>
 800ce00:	f857 c021 	ldr.w	ip, [r7, r1, lsl #2]
 800ce04:	4562      	cmp	r2, ip
 800ce06:	dd2c      	ble.n	800ce62 <validate_structure+0x156>
 800ce08:	3101      	adds	r1, #1
 800ce0a:	eba2 020c 	sub.w	r2, r2, ip
 800ce0e:	290c      	cmp	r1, #12
 800ce10:	60e2      	str	r2, [r4, #12]
 800ce12:	6121      	str	r1, [r4, #16]
 800ce14:	d1f0      	bne.n	800cdf8 <validate_structure+0xec>
 800ce16:	6963      	ldr	r3, [r4, #20]
 800ce18:	f8c4 e010 	str.w	lr, [r4, #16]
 800ce1c:	1c5a      	adds	r2, r3, #1
 800ce1e:	0791      	lsls	r1, r2, #30
 800ce20:	6162      	str	r2, [r4, #20]
 800ce22:	d147      	bne.n	800ceb4 <validate_structure+0x1a8>
 800ce24:	fb92 f1f0 	sdiv	r1, r2, r0
 800ce28:	fb00 2211 	mls	r2, r0, r1, r2
 800ce2c:	2a00      	cmp	r2, #0
 800ce2e:	d143      	bne.n	800ceb8 <validate_structure+0x1ac>
 800ce30:	f203 736d 	addw	r3, r3, #1901	; 0x76d
 800ce34:	fb93 f2f5 	sdiv	r2, r3, r5
 800ce38:	fb05 3312 	mls	r3, r5, r2, r3
 800ce3c:	2b00      	cmp	r3, #0
 800ce3e:	bf14      	ite	ne
 800ce40:	231c      	movne	r3, #28
 800ce42:	231d      	moveq	r3, #29
 800ce44:	e7d8      	b.n	800cdf8 <validate_structure+0xec>
 800ce46:	231c      	movs	r3, #28
 800ce48:	e7cc      	b.n	800cde4 <validate_structure+0xd8>
 800ce4a:	231d      	movs	r3, #29
 800ce4c:	e7ca      	b.n	800cde4 <validate_structure+0xd8>
 800ce4e:	4f1e      	ldr	r7, [pc, #120]	; (800cec8 <validate_structure+0x1bc>)
 800ce50:	260b      	movs	r6, #11
 800ce52:	2064      	movs	r0, #100	; 0x64
 800ce54:	f44f 75c8 	mov.w	r5, #400	; 0x190
 800ce58:	f8d4 e00c 	ldr.w	lr, [r4, #12]
 800ce5c:	f1be 0f00 	cmp.w	lr, #0
 800ce60:	dd01      	ble.n	800ce66 <validate_structure+0x15a>
 800ce62:	b003      	add	sp, #12
 800ce64:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800ce66:	6921      	ldr	r1, [r4, #16]
 800ce68:	3901      	subs	r1, #1
 800ce6a:	6121      	str	r1, [r4, #16]
 800ce6c:	3101      	adds	r1, #1
 800ce6e:	d114      	bne.n	800ce9a <validate_structure+0x18e>
 800ce70:	6963      	ldr	r3, [r4, #20]
 800ce72:	6126      	str	r6, [r4, #16]
 800ce74:	1e59      	subs	r1, r3, #1
 800ce76:	078a      	lsls	r2, r1, #30
 800ce78:	6161      	str	r1, [r4, #20]
 800ce7a:	d117      	bne.n	800ceac <validate_structure+0x1a0>
 800ce7c:	fb91 f2f0 	sdiv	r2, r1, r0
 800ce80:	fb00 1112 	mls	r1, r0, r2, r1
 800ce84:	b9a1      	cbnz	r1, 800ceb0 <validate_structure+0x1a4>
 800ce86:	f203 736b 	addw	r3, r3, #1899	; 0x76b
 800ce8a:	fb93 f2f5 	sdiv	r2, r3, r5
 800ce8e:	fb05 3312 	mls	r3, r5, r2, r3
 800ce92:	2b00      	cmp	r3, #0
 800ce94:	bf14      	ite	ne
 800ce96:	231c      	movne	r3, #28
 800ce98:	231d      	moveq	r3, #29
 800ce9a:	6922      	ldr	r2, [r4, #16]
 800ce9c:	2a01      	cmp	r2, #1
 800ce9e:	bf14      	ite	ne
 800cea0:	f857 2022 	ldrne.w	r2, [r7, r2, lsl #2]
 800cea4:	461a      	moveq	r2, r3
 800cea6:	4472      	add	r2, lr
 800cea8:	60e2      	str	r2, [r4, #12]
 800ceaa:	e7d5      	b.n	800ce58 <validate_structure+0x14c>
 800ceac:	231c      	movs	r3, #28
 800ceae:	e7f4      	b.n	800ce9a <validate_structure+0x18e>
 800ceb0:	231d      	movs	r3, #29
 800ceb2:	e7f2      	b.n	800ce9a <validate_structure+0x18e>
 800ceb4:	231c      	movs	r3, #28
 800ceb6:	e79f      	b.n	800cdf8 <validate_structure+0xec>
 800ceb8:	231d      	movs	r3, #29
 800ceba:	e79d      	b.n	800cdf8 <validate_structure+0xec>
 800cebc:	4293      	cmp	r3, r2
 800cebe:	dad0      	bge.n	800ce62 <validate_structure+0x156>
 800cec0:	1ad2      	subs	r2, r2, r3
 800cec2:	60e2      	str	r2, [r4, #12]
 800cec4:	6126      	str	r6, [r4, #16]
 800cec6:	e797      	b.n	800cdf8 <validate_structure+0xec>
 800cec8:	0800fef8 	.word	0x0800fef8

0800cecc <mktime>:
 800cecc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800ced0:	4681      	mov	r9, r0
 800ced2:	f001 f93f 	bl	800e154 <__gettzinfo>
 800ced6:	4680      	mov	r8, r0
 800ced8:	4648      	mov	r0, r9
 800ceda:	f7ff ff17 	bl	800cd0c <validate_structure>
 800cede:	e899 0081 	ldmia.w	r9, {r0, r7}
 800cee2:	f8d9 3010 	ldr.w	r3, [r9, #16]
 800cee6:	4ab4      	ldr	r2, [pc, #720]	; (800d1b8 <mktime+0x2ec>)
 800cee8:	f8d9 400c 	ldr.w	r4, [r9, #12]
 800ceec:	f852 2023 	ldr.w	r2, [r2, r3, lsl #2]
 800cef0:	253c      	movs	r5, #60	; 0x3c
 800cef2:	fb05 0707 	mla	r7, r5, r7, r0
 800cef6:	f8d9 0008 	ldr.w	r0, [r9, #8]
 800cefa:	f44f 6561 	mov.w	r5, #3600	; 0xe10
 800cefe:	3c01      	subs	r4, #1
 800cf00:	2b01      	cmp	r3, #1
 800cf02:	fb05 7000 	mla	r0, r5, r0, r7
 800cf06:	4414      	add	r4, r2
 800cf08:	f8d9 3014 	ldr.w	r3, [r9, #20]
 800cf0c:	dd11      	ble.n	800cf32 <mktime+0x66>
 800cf0e:	0799      	lsls	r1, r3, #30
 800cf10:	d10f      	bne.n	800cf32 <mktime+0x66>
 800cf12:	2164      	movs	r1, #100	; 0x64
 800cf14:	fb93 f2f1 	sdiv	r2, r3, r1
 800cf18:	fb01 3212 	mls	r2, r1, r2, r3
 800cf1c:	b942      	cbnz	r2, 800cf30 <mktime+0x64>
 800cf1e:	f203 756c 	addw	r5, r3, #1900	; 0x76c
 800cf22:	f44f 71c8 	mov.w	r1, #400	; 0x190
 800cf26:	fb95 f2f1 	sdiv	r2, r5, r1
 800cf2a:	fb01 5212 	mls	r2, r1, r2, r5
 800cf2e:	b902      	cbnz	r2, 800cf32 <mktime+0x66>
 800cf30:	3401      	adds	r4, #1
 800cf32:	f503 521c 	add.w	r2, r3, #9984	; 0x2700
 800cf36:	3210      	adds	r2, #16
 800cf38:	f644 6120 	movw	r1, #20000	; 0x4e20
 800cf3c:	428a      	cmp	r2, r1
 800cf3e:	f8c9 401c 	str.w	r4, [r9, #28]
 800cf42:	f200 812d 	bhi.w	800d1a0 <mktime+0x2d4>
 800cf46:	2b46      	cmp	r3, #70	; 0x46
 800cf48:	dd70      	ble.n	800d02c <mktime+0x160>
 800cf4a:	2546      	movs	r5, #70	; 0x46
 800cf4c:	f240 176d 	movw	r7, #365	; 0x16d
 800cf50:	2164      	movs	r1, #100	; 0x64
 800cf52:	f44f 76c8 	mov.w	r6, #400	; 0x190
 800cf56:	07aa      	lsls	r2, r5, #30
 800cf58:	d162      	bne.n	800d020 <mktime+0x154>
 800cf5a:	fb95 f2f1 	sdiv	r2, r5, r1
 800cf5e:	fb01 5212 	mls	r2, r1, r2, r5
 800cf62:	2a00      	cmp	r2, #0
 800cf64:	d15f      	bne.n	800d026 <mktime+0x15a>
 800cf66:	f205 7e6c 	addw	lr, r5, #1900	; 0x76c
 800cf6a:	fb9e f2f6 	sdiv	r2, lr, r6
 800cf6e:	fb06 e212 	mls	r2, r6, r2, lr
 800cf72:	2a00      	cmp	r2, #0
 800cf74:	bf14      	ite	ne
 800cf76:	463a      	movne	r2, r7
 800cf78:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 800cf7c:	3501      	adds	r5, #1
 800cf7e:	42ab      	cmp	r3, r5
 800cf80:	4414      	add	r4, r2
 800cf82:	d1e8      	bne.n	800cf56 <mktime+0x8a>
 800cf84:	4f8d      	ldr	r7, [pc, #564]	; (800d1bc <mktime+0x2f0>)
 800cf86:	fb07 0704 	mla	r7, r7, r4, r0
 800cf8a:	f000 fc9f 	bl	800d8cc <__tz_lock>
 800cf8e:	f000 fc9f 	bl	800d8d0 <_tzset_unlocked>
 800cf92:	4b8b      	ldr	r3, [pc, #556]	; (800d1c0 <mktime+0x2f4>)
 800cf94:	681e      	ldr	r6, [r3, #0]
 800cf96:	2e00      	cmp	r6, #0
 800cf98:	f000 810a 	beq.w	800d1b0 <mktime+0x2e4>
 800cf9c:	f8d9 3020 	ldr.w	r3, [r9, #32]
 800cfa0:	f8d9 0014 	ldr.w	r0, [r9, #20]
 800cfa4:	2b01      	cmp	r3, #1
 800cfa6:	bfa8      	it	ge
 800cfa8:	2301      	movge	r3, #1
 800cfaa:	469a      	mov	sl, r3
 800cfac:	f8d8 3004 	ldr.w	r3, [r8, #4]
 800cfb0:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 800cfb4:	4298      	cmp	r0, r3
 800cfb6:	d17c      	bne.n	800d0b2 <mktime+0x1e6>
 800cfb8:	f8d8 2038 	ldr.w	r2, [r8, #56]	; 0x38
 800cfbc:	f8d8 3020 	ldr.w	r3, [r8, #32]
 800cfc0:	f8d8 003c 	ldr.w	r0, [r8, #60]	; 0x3c
 800cfc4:	f8d8 101c 	ldr.w	r1, [r8, #28]
 800cfc8:	1ad6      	subs	r6, r2, r3
 800cfca:	42b7      	cmp	r7, r6
 800cfcc:	eba1 0100 	sub.w	r1, r1, r0
 800cfd0:	da76      	bge.n	800d0c0 <mktime+0x1f4>
 800cfd2:	f8d8 2000 	ldr.w	r2, [r8]
 800cfd6:	2a00      	cmp	r2, #0
 800cfd8:	d076      	beq.n	800d0c8 <mktime+0x1fc>
 800cfda:	428f      	cmp	r7, r1
 800cfdc:	f2c0 80e3 	blt.w	800d1a6 <mktime+0x2da>
 800cfe0:	42b7      	cmp	r7, r6
 800cfe2:	bfac      	ite	ge
 800cfe4:	2600      	movge	r6, #0
 800cfe6:	2601      	movlt	r6, #1
 800cfe8:	f1ba 0f00 	cmp.w	sl, #0
 800cfec:	da72      	bge.n	800d0d4 <mktime+0x208>
 800cfee:	2e01      	cmp	r6, #1
 800cff0:	f040 80de 	bne.w	800d1b0 <mktime+0x2e4>
 800cff4:	f8d8 503c 	ldr.w	r5, [r8, #60]	; 0x3c
 800cff8:	2601      	movs	r6, #1
 800cffa:	443d      	add	r5, r7
 800cffc:	f000 fc67 	bl	800d8ce <__tz_unlock>
 800d000:	3404      	adds	r4, #4
 800d002:	2307      	movs	r3, #7
 800d004:	fb94 f3f3 	sdiv	r3, r4, r3
 800d008:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 800d00c:	1ae4      	subs	r4, r4, r3
 800d00e:	bf48      	it	mi
 800d010:	3407      	addmi	r4, #7
 800d012:	f8c9 6020 	str.w	r6, [r9, #32]
 800d016:	f8c9 4018 	str.w	r4, [r9, #24]
 800d01a:	4628      	mov	r0, r5
 800d01c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800d020:	f240 126d 	movw	r2, #365	; 0x16d
 800d024:	e7aa      	b.n	800cf7c <mktime+0xb0>
 800d026:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 800d02a:	e7a7      	b.n	800cf7c <mktime+0xb0>
 800d02c:	d01e      	beq.n	800d06c <mktime+0x1a0>
 800d02e:	2245      	movs	r2, #69	; 0x45
 800d030:	f240 176d 	movw	r7, #365	; 0x16d
 800d034:	2564      	movs	r5, #100	; 0x64
 800d036:	f44f 76c8 	mov.w	r6, #400	; 0x190
 800d03a:	429a      	cmp	r2, r3
 800d03c:	dc18      	bgt.n	800d070 <mktime+0x1a4>
 800d03e:	079d      	lsls	r5, r3, #30
 800d040:	d131      	bne.n	800d0a6 <mktime+0x1da>
 800d042:	2164      	movs	r1, #100	; 0x64
 800d044:	fb93 f2f1 	sdiv	r2, r3, r1
 800d048:	fb01 3212 	mls	r2, r1, r2, r3
 800d04c:	bb72      	cbnz	r2, 800d0ac <mktime+0x1e0>
 800d04e:	f203 756c 	addw	r5, r3, #1900	; 0x76c
 800d052:	f44f 71c8 	mov.w	r1, #400	; 0x190
 800d056:	fb95 f2f1 	sdiv	r2, r5, r1
 800d05a:	fb01 5212 	mls	r2, r1, r2, r5
 800d05e:	2a00      	cmp	r2, #0
 800d060:	f240 126d 	movw	r2, #365	; 0x16d
 800d064:	bf08      	it	eq
 800d066:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 800d06a:	1aa4      	subs	r4, r4, r2
 800d06c:	461d      	mov	r5, r3
 800d06e:	e789      	b.n	800cf84 <mktime+0xb8>
 800d070:	0791      	lsls	r1, r2, #30
 800d072:	d112      	bne.n	800d09a <mktime+0x1ce>
 800d074:	fb92 f1f5 	sdiv	r1, r2, r5
 800d078:	fb05 2111 	mls	r1, r5, r1, r2
 800d07c:	b981      	cbnz	r1, 800d0a0 <mktime+0x1d4>
 800d07e:	f202 7e6c 	addw	lr, r2, #1900	; 0x76c
 800d082:	fb9e f1f6 	sdiv	r1, lr, r6
 800d086:	fb06 e111 	mls	r1, r6, r1, lr
 800d08a:	2900      	cmp	r1, #0
 800d08c:	bf14      	ite	ne
 800d08e:	4639      	movne	r1, r7
 800d090:	f44f 71b7 	moveq.w	r1, #366	; 0x16e
 800d094:	1a64      	subs	r4, r4, r1
 800d096:	3a01      	subs	r2, #1
 800d098:	e7cf      	b.n	800d03a <mktime+0x16e>
 800d09a:	f240 116d 	movw	r1, #365	; 0x16d
 800d09e:	e7f9      	b.n	800d094 <mktime+0x1c8>
 800d0a0:	f44f 71b7 	mov.w	r1, #366	; 0x16e
 800d0a4:	e7f6      	b.n	800d094 <mktime+0x1c8>
 800d0a6:	f240 126d 	movw	r2, #365	; 0x16d
 800d0aa:	e7de      	b.n	800d06a <mktime+0x19e>
 800d0ac:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 800d0b0:	e7db      	b.n	800d06a <mktime+0x19e>
 800d0b2:	f000 fb63 	bl	800d77c <__tzcalc_limits>
 800d0b6:	2800      	cmp	r0, #0
 800d0b8:	f47f af7e 	bne.w	800cfb8 <mktime+0xec>
 800d0bc:	4656      	mov	r6, sl
 800d0be:	e796      	b.n	800cfee <mktime+0x122>
 800d0c0:	1a12      	subs	r2, r2, r0
 800d0c2:	4297      	cmp	r7, r2
 800d0c4:	dbfa      	blt.n	800d0bc <mktime+0x1f0>
 800d0c6:	e784      	b.n	800cfd2 <mktime+0x106>
 800d0c8:	428f      	cmp	r7, r1
 800d0ca:	db89      	blt.n	800cfe0 <mktime+0x114>
 800d0cc:	f1ba 0f00 	cmp.w	sl, #0
 800d0d0:	db90      	blt.n	800cff4 <mktime+0x128>
 800d0d2:	2601      	movs	r6, #1
 800d0d4:	ea8a 0a06 	eor.w	sl, sl, r6
 800d0d8:	f1ba 0f01 	cmp.w	sl, #1
 800d0dc:	d187      	bne.n	800cfee <mktime+0x122>
 800d0de:	1a1b      	subs	r3, r3, r0
 800d0e0:	b906      	cbnz	r6, 800d0e4 <mktime+0x218>
 800d0e2:	425b      	negs	r3, r3
 800d0e4:	f8d9 2000 	ldr.w	r2, [r9]
 800d0e8:	f8d9 a00c 	ldr.w	sl, [r9, #12]
 800d0ec:	441a      	add	r2, r3
 800d0ee:	f8c9 2000 	str.w	r2, [r9]
 800d0f2:	4648      	mov	r0, r9
 800d0f4:	441f      	add	r7, r3
 800d0f6:	f7ff fe09 	bl	800cd0c <validate_structure>
 800d0fa:	f8d9 300c 	ldr.w	r3, [r9, #12]
 800d0fe:	ebb3 030a 	subs.w	r3, r3, sl
 800d102:	f43f af74 	beq.w	800cfee <mktime+0x122>
 800d106:	2b01      	cmp	r3, #1
 800d108:	dc21      	bgt.n	800d14e <mktime+0x282>
 800d10a:	1c98      	adds	r0, r3, #2
 800d10c:	bfd8      	it	le
 800d10e:	2301      	movle	r3, #1
 800d110:	f8d9 201c 	ldr.w	r2, [r9, #28]
 800d114:	441c      	add	r4, r3
 800d116:	189b      	adds	r3, r3, r2
 800d118:	d522      	bpl.n	800d160 <mktime+0x294>
 800d11a:	1e6a      	subs	r2, r5, #1
 800d11c:	0791      	lsls	r1, r2, #30
 800d11e:	d119      	bne.n	800d154 <mktime+0x288>
 800d120:	2164      	movs	r1, #100	; 0x64
 800d122:	fb92 f3f1 	sdiv	r3, r2, r1
 800d126:	fb01 2313 	mls	r3, r1, r3, r2
 800d12a:	b9b3      	cbnz	r3, 800d15a <mktime+0x28e>
 800d12c:	f205 756b 	addw	r5, r5, #1899	; 0x76b
 800d130:	f44f 72c8 	mov.w	r2, #400	; 0x190
 800d134:	fb95 f3f2 	sdiv	r3, r5, r2
 800d138:	fb02 5513 	mls	r5, r2, r3, r5
 800d13c:	2d00      	cmp	r5, #0
 800d13e:	f240 136d 	movw	r3, #365	; 0x16d
 800d142:	bf18      	it	ne
 800d144:	f44f 73b6 	movne.w	r3, #364	; 0x16c
 800d148:	f8c9 301c 	str.w	r3, [r9, #28]
 800d14c:	e74f      	b.n	800cfee <mktime+0x122>
 800d14e:	f04f 33ff 	mov.w	r3, #4294967295
 800d152:	e7dd      	b.n	800d110 <mktime+0x244>
 800d154:	f44f 73b6 	mov.w	r3, #364	; 0x16c
 800d158:	e7f6      	b.n	800d148 <mktime+0x27c>
 800d15a:	f240 136d 	movw	r3, #365	; 0x16d
 800d15e:	e7f3      	b.n	800d148 <mktime+0x27c>
 800d160:	07aa      	lsls	r2, r5, #30
 800d162:	d117      	bne.n	800d194 <mktime+0x2c8>
 800d164:	2164      	movs	r1, #100	; 0x64
 800d166:	fb95 f2f1 	sdiv	r2, r5, r1
 800d16a:	fb01 5212 	mls	r2, r1, r2, r5
 800d16e:	b9a2      	cbnz	r2, 800d19a <mktime+0x2ce>
 800d170:	f205 756c 	addw	r5, r5, #1900	; 0x76c
 800d174:	f44f 71c8 	mov.w	r1, #400	; 0x190
 800d178:	fb95 f2f1 	sdiv	r2, r5, r1
 800d17c:	fb01 5512 	mls	r5, r1, r2, r5
 800d180:	2d00      	cmp	r5, #0
 800d182:	f240 126d 	movw	r2, #365	; 0x16d
 800d186:	bf08      	it	eq
 800d188:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 800d18c:	429a      	cmp	r2, r3
 800d18e:	bfd8      	it	le
 800d190:	1a9b      	suble	r3, r3, r2
 800d192:	e7d9      	b.n	800d148 <mktime+0x27c>
 800d194:	f240 126d 	movw	r2, #365	; 0x16d
 800d198:	e7f8      	b.n	800d18c <mktime+0x2c0>
 800d19a:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 800d19e:	e7f5      	b.n	800d18c <mktime+0x2c0>
 800d1a0:	f04f 35ff 	mov.w	r5, #4294967295
 800d1a4:	e739      	b.n	800d01a <mktime+0x14e>
 800d1a6:	f1ba 0f00 	cmp.w	sl, #0
 800d1aa:	f04f 0600 	mov.w	r6, #0
 800d1ae:	da91      	bge.n	800d0d4 <mktime+0x208>
 800d1b0:	f8d8 5020 	ldr.w	r5, [r8, #32]
 800d1b4:	443d      	add	r5, r7
 800d1b6:	e721      	b.n	800cffc <mktime+0x130>
 800d1b8:	0800ff28 	.word	0x0800ff28
 800d1bc:	00015180 	.word	0x00015180
 800d1c0:	200003c0 	.word	0x200003c0

0800d1c4 <_free_r>:
 800d1c4:	b538      	push	{r3, r4, r5, lr}
 800d1c6:	4605      	mov	r5, r0
 800d1c8:	2900      	cmp	r1, #0
 800d1ca:	d045      	beq.n	800d258 <_free_r+0x94>
 800d1cc:	f851 3c04 	ldr.w	r3, [r1, #-4]
 800d1d0:	1f0c      	subs	r4, r1, #4
 800d1d2:	2b00      	cmp	r3, #0
 800d1d4:	bfb8      	it	lt
 800d1d6:	18e4      	addlt	r4, r4, r3
 800d1d8:	f001 f85a 	bl	800e290 <__malloc_lock>
 800d1dc:	4a1f      	ldr	r2, [pc, #124]	; (800d25c <_free_r+0x98>)
 800d1de:	6813      	ldr	r3, [r2, #0]
 800d1e0:	4610      	mov	r0, r2
 800d1e2:	b933      	cbnz	r3, 800d1f2 <_free_r+0x2e>
 800d1e4:	6063      	str	r3, [r4, #4]
 800d1e6:	6014      	str	r4, [r2, #0]
 800d1e8:	4628      	mov	r0, r5
 800d1ea:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800d1ee:	f001 b850 	b.w	800e292 <__malloc_unlock>
 800d1f2:	42a3      	cmp	r3, r4
 800d1f4:	d90c      	bls.n	800d210 <_free_r+0x4c>
 800d1f6:	6821      	ldr	r1, [r4, #0]
 800d1f8:	1862      	adds	r2, r4, r1
 800d1fa:	4293      	cmp	r3, r2
 800d1fc:	bf04      	itt	eq
 800d1fe:	681a      	ldreq	r2, [r3, #0]
 800d200:	685b      	ldreq	r3, [r3, #4]
 800d202:	6063      	str	r3, [r4, #4]
 800d204:	bf04      	itt	eq
 800d206:	1852      	addeq	r2, r2, r1
 800d208:	6022      	streq	r2, [r4, #0]
 800d20a:	6004      	str	r4, [r0, #0]
 800d20c:	e7ec      	b.n	800d1e8 <_free_r+0x24>
 800d20e:	4613      	mov	r3, r2
 800d210:	685a      	ldr	r2, [r3, #4]
 800d212:	b10a      	cbz	r2, 800d218 <_free_r+0x54>
 800d214:	42a2      	cmp	r2, r4
 800d216:	d9fa      	bls.n	800d20e <_free_r+0x4a>
 800d218:	6819      	ldr	r1, [r3, #0]
 800d21a:	1858      	adds	r0, r3, r1
 800d21c:	42a0      	cmp	r0, r4
 800d21e:	d10b      	bne.n	800d238 <_free_r+0x74>
 800d220:	6820      	ldr	r0, [r4, #0]
 800d222:	4401      	add	r1, r0
 800d224:	1858      	adds	r0, r3, r1
 800d226:	4282      	cmp	r2, r0
 800d228:	6019      	str	r1, [r3, #0]
 800d22a:	d1dd      	bne.n	800d1e8 <_free_r+0x24>
 800d22c:	6810      	ldr	r0, [r2, #0]
 800d22e:	6852      	ldr	r2, [r2, #4]
 800d230:	605a      	str	r2, [r3, #4]
 800d232:	4401      	add	r1, r0
 800d234:	6019      	str	r1, [r3, #0]
 800d236:	e7d7      	b.n	800d1e8 <_free_r+0x24>
 800d238:	d902      	bls.n	800d240 <_free_r+0x7c>
 800d23a:	230c      	movs	r3, #12
 800d23c:	602b      	str	r3, [r5, #0]
 800d23e:	e7d3      	b.n	800d1e8 <_free_r+0x24>
 800d240:	6820      	ldr	r0, [r4, #0]
 800d242:	1821      	adds	r1, r4, r0
 800d244:	428a      	cmp	r2, r1
 800d246:	bf04      	itt	eq
 800d248:	6811      	ldreq	r1, [r2, #0]
 800d24a:	6852      	ldreq	r2, [r2, #4]
 800d24c:	6062      	str	r2, [r4, #4]
 800d24e:	bf04      	itt	eq
 800d250:	1809      	addeq	r1, r1, r0
 800d252:	6021      	streq	r1, [r4, #0]
 800d254:	605c      	str	r4, [r3, #4]
 800d256:	e7c7      	b.n	800d1e8 <_free_r+0x24>
 800d258:	bd38      	pop	{r3, r4, r5, pc}
 800d25a:	bf00      	nop
 800d25c:	2000039c 	.word	0x2000039c

0800d260 <_malloc_r>:
 800d260:	b570      	push	{r4, r5, r6, lr}
 800d262:	1ccd      	adds	r5, r1, #3
 800d264:	f025 0503 	bic.w	r5, r5, #3
 800d268:	3508      	adds	r5, #8
 800d26a:	2d0c      	cmp	r5, #12
 800d26c:	bf38      	it	cc
 800d26e:	250c      	movcc	r5, #12
 800d270:	2d00      	cmp	r5, #0
 800d272:	4606      	mov	r6, r0
 800d274:	db01      	blt.n	800d27a <_malloc_r+0x1a>
 800d276:	42a9      	cmp	r1, r5
 800d278:	d903      	bls.n	800d282 <_malloc_r+0x22>
 800d27a:	230c      	movs	r3, #12
 800d27c:	6033      	str	r3, [r6, #0]
 800d27e:	2000      	movs	r0, #0
 800d280:	bd70      	pop	{r4, r5, r6, pc}
 800d282:	f001 f805 	bl	800e290 <__malloc_lock>
 800d286:	4a23      	ldr	r2, [pc, #140]	; (800d314 <_malloc_r+0xb4>)
 800d288:	6814      	ldr	r4, [r2, #0]
 800d28a:	4621      	mov	r1, r4
 800d28c:	b991      	cbnz	r1, 800d2b4 <_malloc_r+0x54>
 800d28e:	4c22      	ldr	r4, [pc, #136]	; (800d318 <_malloc_r+0xb8>)
 800d290:	6823      	ldr	r3, [r4, #0]
 800d292:	b91b      	cbnz	r3, 800d29c <_malloc_r+0x3c>
 800d294:	4630      	mov	r0, r6
 800d296:	f000 f8d1 	bl	800d43c <_sbrk_r>
 800d29a:	6020      	str	r0, [r4, #0]
 800d29c:	4629      	mov	r1, r5
 800d29e:	4630      	mov	r0, r6
 800d2a0:	f000 f8cc 	bl	800d43c <_sbrk_r>
 800d2a4:	1c43      	adds	r3, r0, #1
 800d2a6:	d126      	bne.n	800d2f6 <_malloc_r+0x96>
 800d2a8:	230c      	movs	r3, #12
 800d2aa:	6033      	str	r3, [r6, #0]
 800d2ac:	4630      	mov	r0, r6
 800d2ae:	f000 fff0 	bl	800e292 <__malloc_unlock>
 800d2b2:	e7e4      	b.n	800d27e <_malloc_r+0x1e>
 800d2b4:	680b      	ldr	r3, [r1, #0]
 800d2b6:	1b5b      	subs	r3, r3, r5
 800d2b8:	d41a      	bmi.n	800d2f0 <_malloc_r+0x90>
 800d2ba:	2b0b      	cmp	r3, #11
 800d2bc:	d90f      	bls.n	800d2de <_malloc_r+0x7e>
 800d2be:	600b      	str	r3, [r1, #0]
 800d2c0:	50cd      	str	r5, [r1, r3]
 800d2c2:	18cc      	adds	r4, r1, r3
 800d2c4:	4630      	mov	r0, r6
 800d2c6:	f000 ffe4 	bl	800e292 <__malloc_unlock>
 800d2ca:	f104 000b 	add.w	r0, r4, #11
 800d2ce:	1d23      	adds	r3, r4, #4
 800d2d0:	f020 0007 	bic.w	r0, r0, #7
 800d2d4:	1ac3      	subs	r3, r0, r3
 800d2d6:	d01b      	beq.n	800d310 <_malloc_r+0xb0>
 800d2d8:	425a      	negs	r2, r3
 800d2da:	50e2      	str	r2, [r4, r3]
 800d2dc:	bd70      	pop	{r4, r5, r6, pc}
 800d2de:	428c      	cmp	r4, r1
 800d2e0:	bf0d      	iteet	eq
 800d2e2:	6863      	ldreq	r3, [r4, #4]
 800d2e4:	684b      	ldrne	r3, [r1, #4]
 800d2e6:	6063      	strne	r3, [r4, #4]
 800d2e8:	6013      	streq	r3, [r2, #0]
 800d2ea:	bf18      	it	ne
 800d2ec:	460c      	movne	r4, r1
 800d2ee:	e7e9      	b.n	800d2c4 <_malloc_r+0x64>
 800d2f0:	460c      	mov	r4, r1
 800d2f2:	6849      	ldr	r1, [r1, #4]
 800d2f4:	e7ca      	b.n	800d28c <_malloc_r+0x2c>
 800d2f6:	1cc4      	adds	r4, r0, #3
 800d2f8:	f024 0403 	bic.w	r4, r4, #3
 800d2fc:	42a0      	cmp	r0, r4
 800d2fe:	d005      	beq.n	800d30c <_malloc_r+0xac>
 800d300:	1a21      	subs	r1, r4, r0
 800d302:	4630      	mov	r0, r6
 800d304:	f000 f89a 	bl	800d43c <_sbrk_r>
 800d308:	3001      	adds	r0, #1
 800d30a:	d0cd      	beq.n	800d2a8 <_malloc_r+0x48>
 800d30c:	6025      	str	r5, [r4, #0]
 800d30e:	e7d9      	b.n	800d2c4 <_malloc_r+0x64>
 800d310:	bd70      	pop	{r4, r5, r6, pc}
 800d312:	bf00      	nop
 800d314:	2000039c 	.word	0x2000039c
 800d318:	200003a0 	.word	0x200003a0

0800d31c <iprintf>:
 800d31c:	b40f      	push	{r0, r1, r2, r3}
 800d31e:	4b0a      	ldr	r3, [pc, #40]	; (800d348 <iprintf+0x2c>)
 800d320:	b513      	push	{r0, r1, r4, lr}
 800d322:	681c      	ldr	r4, [r3, #0]
 800d324:	b124      	cbz	r4, 800d330 <iprintf+0x14>
 800d326:	69a3      	ldr	r3, [r4, #24]
 800d328:	b913      	cbnz	r3, 800d330 <iprintf+0x14>
 800d32a:	4620      	mov	r0, r4
 800d32c:	f000 fe40 	bl	800dfb0 <__sinit>
 800d330:	ab05      	add	r3, sp, #20
 800d332:	9a04      	ldr	r2, [sp, #16]
 800d334:	68a1      	ldr	r1, [r4, #8]
 800d336:	9301      	str	r3, [sp, #4]
 800d338:	4620      	mov	r0, r4
 800d33a:	f001 fad3 	bl	800e8e4 <_vfiprintf_r>
 800d33e:	b002      	add	sp, #8
 800d340:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 800d344:	b004      	add	sp, #16
 800d346:	4770      	bx	lr
 800d348:	2000002c 	.word	0x2000002c

0800d34c <putchar>:
 800d34c:	b538      	push	{r3, r4, r5, lr}
 800d34e:	4b08      	ldr	r3, [pc, #32]	; (800d370 <putchar+0x24>)
 800d350:	681c      	ldr	r4, [r3, #0]
 800d352:	4605      	mov	r5, r0
 800d354:	b124      	cbz	r4, 800d360 <putchar+0x14>
 800d356:	69a3      	ldr	r3, [r4, #24]
 800d358:	b913      	cbnz	r3, 800d360 <putchar+0x14>
 800d35a:	4620      	mov	r0, r4
 800d35c:	f000 fe28 	bl	800dfb0 <__sinit>
 800d360:	68a2      	ldr	r2, [r4, #8]
 800d362:	4629      	mov	r1, r5
 800d364:	4620      	mov	r0, r4
 800d366:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800d36a:	f001 bebf 	b.w	800f0ec <_putc_r>
 800d36e:	bf00      	nop
 800d370:	2000002c 	.word	0x2000002c

0800d374 <_puts_r>:
 800d374:	b570      	push	{r4, r5, r6, lr}
 800d376:	460e      	mov	r6, r1
 800d378:	4605      	mov	r5, r0
 800d37a:	b118      	cbz	r0, 800d384 <_puts_r+0x10>
 800d37c:	6983      	ldr	r3, [r0, #24]
 800d37e:	b90b      	cbnz	r3, 800d384 <_puts_r+0x10>
 800d380:	f000 fe16 	bl	800dfb0 <__sinit>
 800d384:	69ab      	ldr	r3, [r5, #24]
 800d386:	68ac      	ldr	r4, [r5, #8]
 800d388:	b913      	cbnz	r3, 800d390 <_puts_r+0x1c>
 800d38a:	4628      	mov	r0, r5
 800d38c:	f000 fe10 	bl	800dfb0 <__sinit>
 800d390:	4b23      	ldr	r3, [pc, #140]	; (800d420 <_puts_r+0xac>)
 800d392:	429c      	cmp	r4, r3
 800d394:	d117      	bne.n	800d3c6 <_puts_r+0x52>
 800d396:	686c      	ldr	r4, [r5, #4]
 800d398:	89a3      	ldrh	r3, [r4, #12]
 800d39a:	071b      	lsls	r3, r3, #28
 800d39c:	d51d      	bpl.n	800d3da <_puts_r+0x66>
 800d39e:	6923      	ldr	r3, [r4, #16]
 800d3a0:	b1db      	cbz	r3, 800d3da <_puts_r+0x66>
 800d3a2:	3e01      	subs	r6, #1
 800d3a4:	68a3      	ldr	r3, [r4, #8]
 800d3a6:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 800d3aa:	3b01      	subs	r3, #1
 800d3ac:	60a3      	str	r3, [r4, #8]
 800d3ae:	b9e9      	cbnz	r1, 800d3ec <_puts_r+0x78>
 800d3b0:	2b00      	cmp	r3, #0
 800d3b2:	da2e      	bge.n	800d412 <_puts_r+0x9e>
 800d3b4:	4622      	mov	r2, r4
 800d3b6:	210a      	movs	r1, #10
 800d3b8:	4628      	mov	r0, r5
 800d3ba:	f000 fc11 	bl	800dbe0 <__swbuf_r>
 800d3be:	3001      	adds	r0, #1
 800d3c0:	d011      	beq.n	800d3e6 <_puts_r+0x72>
 800d3c2:	200a      	movs	r0, #10
 800d3c4:	bd70      	pop	{r4, r5, r6, pc}
 800d3c6:	4b17      	ldr	r3, [pc, #92]	; (800d424 <_puts_r+0xb0>)
 800d3c8:	429c      	cmp	r4, r3
 800d3ca:	d101      	bne.n	800d3d0 <_puts_r+0x5c>
 800d3cc:	68ac      	ldr	r4, [r5, #8]
 800d3ce:	e7e3      	b.n	800d398 <_puts_r+0x24>
 800d3d0:	4b15      	ldr	r3, [pc, #84]	; (800d428 <_puts_r+0xb4>)
 800d3d2:	429c      	cmp	r4, r3
 800d3d4:	bf08      	it	eq
 800d3d6:	68ec      	ldreq	r4, [r5, #12]
 800d3d8:	e7de      	b.n	800d398 <_puts_r+0x24>
 800d3da:	4621      	mov	r1, r4
 800d3dc:	4628      	mov	r0, r5
 800d3de:	f000 fc63 	bl	800dca8 <__swsetup_r>
 800d3e2:	2800      	cmp	r0, #0
 800d3e4:	d0dd      	beq.n	800d3a2 <_puts_r+0x2e>
 800d3e6:	f04f 30ff 	mov.w	r0, #4294967295
 800d3ea:	bd70      	pop	{r4, r5, r6, pc}
 800d3ec:	2b00      	cmp	r3, #0
 800d3ee:	da04      	bge.n	800d3fa <_puts_r+0x86>
 800d3f0:	69a2      	ldr	r2, [r4, #24]
 800d3f2:	4293      	cmp	r3, r2
 800d3f4:	db06      	blt.n	800d404 <_puts_r+0x90>
 800d3f6:	290a      	cmp	r1, #10
 800d3f8:	d004      	beq.n	800d404 <_puts_r+0x90>
 800d3fa:	6823      	ldr	r3, [r4, #0]
 800d3fc:	1c5a      	adds	r2, r3, #1
 800d3fe:	6022      	str	r2, [r4, #0]
 800d400:	7019      	strb	r1, [r3, #0]
 800d402:	e7cf      	b.n	800d3a4 <_puts_r+0x30>
 800d404:	4622      	mov	r2, r4
 800d406:	4628      	mov	r0, r5
 800d408:	f000 fbea 	bl	800dbe0 <__swbuf_r>
 800d40c:	3001      	adds	r0, #1
 800d40e:	d1c9      	bne.n	800d3a4 <_puts_r+0x30>
 800d410:	e7e9      	b.n	800d3e6 <_puts_r+0x72>
 800d412:	6823      	ldr	r3, [r4, #0]
 800d414:	200a      	movs	r0, #10
 800d416:	1c5a      	adds	r2, r3, #1
 800d418:	6022      	str	r2, [r4, #0]
 800d41a:	7018      	strb	r0, [r3, #0]
 800d41c:	bd70      	pop	{r4, r5, r6, pc}
 800d41e:	bf00      	nop
 800d420:	0800ffb4 	.word	0x0800ffb4
 800d424:	0800ffd4 	.word	0x0800ffd4
 800d428:	0800ff94 	.word	0x0800ff94

0800d42c <puts>:
 800d42c:	4b02      	ldr	r3, [pc, #8]	; (800d438 <puts+0xc>)
 800d42e:	4601      	mov	r1, r0
 800d430:	6818      	ldr	r0, [r3, #0]
 800d432:	f7ff bf9f 	b.w	800d374 <_puts_r>
 800d436:	bf00      	nop
 800d438:	2000002c 	.word	0x2000002c

0800d43c <_sbrk_r>:
 800d43c:	b538      	push	{r3, r4, r5, lr}
 800d43e:	4c06      	ldr	r4, [pc, #24]	; (800d458 <_sbrk_r+0x1c>)
 800d440:	2300      	movs	r3, #0
 800d442:	4605      	mov	r5, r0
 800d444:	4608      	mov	r0, r1
 800d446:	6023      	str	r3, [r4, #0]
 800d448:	f002 f85e 	bl	800f508 <_sbrk>
 800d44c:	1c43      	adds	r3, r0, #1
 800d44e:	d102      	bne.n	800d456 <_sbrk_r+0x1a>
 800d450:	6823      	ldr	r3, [r4, #0]
 800d452:	b103      	cbz	r3, 800d456 <_sbrk_r+0x1a>
 800d454:	602b      	str	r3, [r5, #0]
 800d456:	bd38      	pop	{r3, r4, r5, pc}
 800d458:	2000c63c 	.word	0x2000c63c

0800d45c <siprintf>:
 800d45c:	b40e      	push	{r1, r2, r3}
 800d45e:	b500      	push	{lr}
 800d460:	b09c      	sub	sp, #112	; 0x70
 800d462:	f44f 7102 	mov.w	r1, #520	; 0x208
 800d466:	ab1d      	add	r3, sp, #116	; 0x74
 800d468:	f8ad 1014 	strh.w	r1, [sp, #20]
 800d46c:	9002      	str	r0, [sp, #8]
 800d46e:	9006      	str	r0, [sp, #24]
 800d470:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 800d474:	480a      	ldr	r0, [pc, #40]	; (800d4a0 <siprintf+0x44>)
 800d476:	9104      	str	r1, [sp, #16]
 800d478:	9107      	str	r1, [sp, #28]
 800d47a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 800d47e:	f853 2b04 	ldr.w	r2, [r3], #4
 800d482:	f8ad 1016 	strh.w	r1, [sp, #22]
 800d486:	6800      	ldr	r0, [r0, #0]
 800d488:	9301      	str	r3, [sp, #4]
 800d48a:	a902      	add	r1, sp, #8
 800d48c:	f000 ff5e 	bl	800e34c <_svfiprintf_r>
 800d490:	9b02      	ldr	r3, [sp, #8]
 800d492:	2200      	movs	r2, #0
 800d494:	701a      	strb	r2, [r3, #0]
 800d496:	b01c      	add	sp, #112	; 0x70
 800d498:	f85d eb04 	ldr.w	lr, [sp], #4
 800d49c:	b003      	add	sp, #12
 800d49e:	4770      	bx	lr
 800d4a0:	2000002c 	.word	0x2000002c

0800d4a4 <siscanf>:
 800d4a4:	b40e      	push	{r1, r2, r3}
 800d4a6:	b530      	push	{r4, r5, lr}
 800d4a8:	b09c      	sub	sp, #112	; 0x70
 800d4aa:	ac1f      	add	r4, sp, #124	; 0x7c
 800d4ac:	f44f 7201 	mov.w	r2, #516	; 0x204
 800d4b0:	f854 5b04 	ldr.w	r5, [r4], #4
 800d4b4:	f8ad 2014 	strh.w	r2, [sp, #20]
 800d4b8:	9002      	str	r0, [sp, #8]
 800d4ba:	9006      	str	r0, [sp, #24]
 800d4bc:	f7f2 fe9a 	bl	80001f4 <strlen>
 800d4c0:	4b0b      	ldr	r3, [pc, #44]	; (800d4f0 <siscanf+0x4c>)
 800d4c2:	9003      	str	r0, [sp, #12]
 800d4c4:	9007      	str	r0, [sp, #28]
 800d4c6:	930b      	str	r3, [sp, #44]	; 0x2c
 800d4c8:	480a      	ldr	r0, [pc, #40]	; (800d4f4 <siscanf+0x50>)
 800d4ca:	9401      	str	r4, [sp, #4]
 800d4cc:	2300      	movs	r3, #0
 800d4ce:	930f      	str	r3, [sp, #60]	; 0x3c
 800d4d0:	9314      	str	r3, [sp, #80]	; 0x50
 800d4d2:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800d4d6:	f8ad 3016 	strh.w	r3, [sp, #22]
 800d4da:	462a      	mov	r2, r5
 800d4dc:	4623      	mov	r3, r4
 800d4de:	a902      	add	r1, sp, #8
 800d4e0:	6800      	ldr	r0, [r0, #0]
 800d4e2:	f001 f881 	bl	800e5e8 <__ssvfiscanf_r>
 800d4e6:	b01c      	add	sp, #112	; 0x70
 800d4e8:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 800d4ec:	b003      	add	sp, #12
 800d4ee:	4770      	bx	lr
 800d4f0:	0800d51b 	.word	0x0800d51b
 800d4f4:	2000002c 	.word	0x2000002c

0800d4f8 <__sread>:
 800d4f8:	b510      	push	{r4, lr}
 800d4fa:	460c      	mov	r4, r1
 800d4fc:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d500:	f001 fe2a 	bl	800f158 <_read_r>
 800d504:	2800      	cmp	r0, #0
 800d506:	bfab      	itete	ge
 800d508:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800d50a:	89a3      	ldrhlt	r3, [r4, #12]
 800d50c:	181b      	addge	r3, r3, r0
 800d50e:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 800d512:	bfac      	ite	ge
 800d514:	6563      	strge	r3, [r4, #84]	; 0x54
 800d516:	81a3      	strhlt	r3, [r4, #12]
 800d518:	bd10      	pop	{r4, pc}

0800d51a <__seofread>:
 800d51a:	2000      	movs	r0, #0
 800d51c:	4770      	bx	lr

0800d51e <__swrite>:
 800d51e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800d522:	461f      	mov	r7, r3
 800d524:	898b      	ldrh	r3, [r1, #12]
 800d526:	05db      	lsls	r3, r3, #23
 800d528:	4605      	mov	r5, r0
 800d52a:	460c      	mov	r4, r1
 800d52c:	4616      	mov	r6, r2
 800d52e:	d505      	bpl.n	800d53c <__swrite+0x1e>
 800d530:	2302      	movs	r3, #2
 800d532:	2200      	movs	r2, #0
 800d534:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d538:	f000 fe22 	bl	800e180 <_lseek_r>
 800d53c:	89a3      	ldrh	r3, [r4, #12]
 800d53e:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800d542:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 800d546:	81a3      	strh	r3, [r4, #12]
 800d548:	4632      	mov	r2, r6
 800d54a:	463b      	mov	r3, r7
 800d54c:	4628      	mov	r0, r5
 800d54e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 800d552:	f000 bb97 	b.w	800dc84 <_write_r>

0800d556 <__sseek>:
 800d556:	b510      	push	{r4, lr}
 800d558:	460c      	mov	r4, r1
 800d55a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d55e:	f000 fe0f 	bl	800e180 <_lseek_r>
 800d562:	1c43      	adds	r3, r0, #1
 800d564:	89a3      	ldrh	r3, [r4, #12]
 800d566:	bf15      	itete	ne
 800d568:	6560      	strne	r0, [r4, #84]	; 0x54
 800d56a:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 800d56e:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 800d572:	81a3      	strheq	r3, [r4, #12]
 800d574:	bf18      	it	ne
 800d576:	81a3      	strhne	r3, [r4, #12]
 800d578:	bd10      	pop	{r4, pc}

0800d57a <__sclose>:
 800d57a:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800d57e:	f000 bc01 	b.w	800dd84 <_close_r>

0800d582 <strcat>:
 800d582:	b510      	push	{r4, lr}
 800d584:	4602      	mov	r2, r0
 800d586:	4613      	mov	r3, r2
 800d588:	3201      	adds	r2, #1
 800d58a:	781c      	ldrb	r4, [r3, #0]
 800d58c:	2c00      	cmp	r4, #0
 800d58e:	d1fa      	bne.n	800d586 <strcat+0x4>
 800d590:	3b01      	subs	r3, #1
 800d592:	f811 2b01 	ldrb.w	r2, [r1], #1
 800d596:	f803 2f01 	strb.w	r2, [r3, #1]!
 800d59a:	2a00      	cmp	r2, #0
 800d59c:	d1f9      	bne.n	800d592 <strcat+0x10>
 800d59e:	bd10      	pop	{r4, pc}

0800d5a0 <strchr>:
 800d5a0:	b2c9      	uxtb	r1, r1
 800d5a2:	4603      	mov	r3, r0
 800d5a4:	f810 2b01 	ldrb.w	r2, [r0], #1
 800d5a8:	b11a      	cbz	r2, 800d5b2 <strchr+0x12>
 800d5aa:	4291      	cmp	r1, r2
 800d5ac:	d1f9      	bne.n	800d5a2 <strchr+0x2>
 800d5ae:	4618      	mov	r0, r3
 800d5b0:	4770      	bx	lr
 800d5b2:	2900      	cmp	r1, #0
 800d5b4:	bf0c      	ite	eq
 800d5b6:	4618      	moveq	r0, r3
 800d5b8:	2000      	movne	r0, #0
 800d5ba:	4770      	bx	lr

0800d5bc <strcpy>:
 800d5bc:	4603      	mov	r3, r0
 800d5be:	f811 2b01 	ldrb.w	r2, [r1], #1
 800d5c2:	f803 2b01 	strb.w	r2, [r3], #1
 800d5c6:	2a00      	cmp	r2, #0
 800d5c8:	d1f9      	bne.n	800d5be <strcpy+0x2>
 800d5ca:	4770      	bx	lr

0800d5cc <strncpy>:
 800d5cc:	b570      	push	{r4, r5, r6, lr}
 800d5ce:	4604      	mov	r4, r0
 800d5d0:	b902      	cbnz	r2, 800d5d4 <strncpy+0x8>
 800d5d2:	bd70      	pop	{r4, r5, r6, pc}
 800d5d4:	4623      	mov	r3, r4
 800d5d6:	f811 5b01 	ldrb.w	r5, [r1], #1
 800d5da:	f803 5b01 	strb.w	r5, [r3], #1
 800d5de:	1e56      	subs	r6, r2, #1
 800d5e0:	b91d      	cbnz	r5, 800d5ea <strncpy+0x1e>
 800d5e2:	4414      	add	r4, r2
 800d5e4:	42a3      	cmp	r3, r4
 800d5e6:	d103      	bne.n	800d5f0 <strncpy+0x24>
 800d5e8:	bd70      	pop	{r4, r5, r6, pc}
 800d5ea:	461c      	mov	r4, r3
 800d5ec:	4632      	mov	r2, r6
 800d5ee:	e7ef      	b.n	800d5d0 <strncpy+0x4>
 800d5f0:	f803 5b01 	strb.w	r5, [r3], #1
 800d5f4:	e7f6      	b.n	800d5e4 <strncpy+0x18>

0800d5f6 <strstr>:
 800d5f6:	b5f0      	push	{r4, r5, r6, r7, lr}
 800d5f8:	7803      	ldrb	r3, [r0, #0]
 800d5fa:	b133      	cbz	r3, 800d60a <strstr+0x14>
 800d5fc:	4603      	mov	r3, r0
 800d5fe:	4618      	mov	r0, r3
 800d600:	1c5e      	adds	r6, r3, #1
 800d602:	781b      	ldrb	r3, [r3, #0]
 800d604:	b933      	cbnz	r3, 800d614 <strstr+0x1e>
 800d606:	4618      	mov	r0, r3
 800d608:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d60a:	780b      	ldrb	r3, [r1, #0]
 800d60c:	2b00      	cmp	r3, #0
 800d60e:	bf18      	it	ne
 800d610:	2000      	movne	r0, #0
 800d612:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800d614:	1e4d      	subs	r5, r1, #1
 800d616:	1e44      	subs	r4, r0, #1
 800d618:	f815 2f01 	ldrb.w	r2, [r5, #1]!
 800d61c:	2a00      	cmp	r2, #0
 800d61e:	d0f3      	beq.n	800d608 <strstr+0x12>
 800d620:	f814 7f01 	ldrb.w	r7, [r4, #1]!
 800d624:	4297      	cmp	r7, r2
 800d626:	4633      	mov	r3, r6
 800d628:	d0f6      	beq.n	800d618 <strstr+0x22>
 800d62a:	e7e8      	b.n	800d5fe <strstr+0x8>

0800d62c <_strtol_l.isra.0>:
 800d62c:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d630:	4680      	mov	r8, r0
 800d632:	4689      	mov	r9, r1
 800d634:	4692      	mov	sl, r2
 800d636:	461f      	mov	r7, r3
 800d638:	468b      	mov	fp, r1
 800d63a:	465d      	mov	r5, fp
 800d63c:	980a      	ldr	r0, [sp, #40]	; 0x28
 800d63e:	f815 4b01 	ldrb.w	r4, [r5], #1
 800d642:	f000 fd8b 	bl	800e15c <__locale_ctype_ptr_l>
 800d646:	4420      	add	r0, r4
 800d648:	7846      	ldrb	r6, [r0, #1]
 800d64a:	f016 0608 	ands.w	r6, r6, #8
 800d64e:	d10b      	bne.n	800d668 <_strtol_l.isra.0+0x3c>
 800d650:	2c2d      	cmp	r4, #45	; 0x2d
 800d652:	d10b      	bne.n	800d66c <_strtol_l.isra.0+0x40>
 800d654:	782c      	ldrb	r4, [r5, #0]
 800d656:	2601      	movs	r6, #1
 800d658:	f10b 0502 	add.w	r5, fp, #2
 800d65c:	b167      	cbz	r7, 800d678 <_strtol_l.isra.0+0x4c>
 800d65e:	2f10      	cmp	r7, #16
 800d660:	d114      	bne.n	800d68c <_strtol_l.isra.0+0x60>
 800d662:	2c30      	cmp	r4, #48	; 0x30
 800d664:	d00a      	beq.n	800d67c <_strtol_l.isra.0+0x50>
 800d666:	e011      	b.n	800d68c <_strtol_l.isra.0+0x60>
 800d668:	46ab      	mov	fp, r5
 800d66a:	e7e6      	b.n	800d63a <_strtol_l.isra.0+0xe>
 800d66c:	2c2b      	cmp	r4, #43	; 0x2b
 800d66e:	bf04      	itt	eq
 800d670:	782c      	ldrbeq	r4, [r5, #0]
 800d672:	f10b 0502 	addeq.w	r5, fp, #2
 800d676:	e7f1      	b.n	800d65c <_strtol_l.isra.0+0x30>
 800d678:	2c30      	cmp	r4, #48	; 0x30
 800d67a:	d127      	bne.n	800d6cc <_strtol_l.isra.0+0xa0>
 800d67c:	782b      	ldrb	r3, [r5, #0]
 800d67e:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 800d682:	2b58      	cmp	r3, #88	; 0x58
 800d684:	d14b      	bne.n	800d71e <_strtol_l.isra.0+0xf2>
 800d686:	786c      	ldrb	r4, [r5, #1]
 800d688:	2710      	movs	r7, #16
 800d68a:	3502      	adds	r5, #2
 800d68c:	2e00      	cmp	r6, #0
 800d68e:	bf0c      	ite	eq
 800d690:	f06f 4100 	mvneq.w	r1, #2147483648	; 0x80000000
 800d694:	f04f 4100 	movne.w	r1, #2147483648	; 0x80000000
 800d698:	2200      	movs	r2, #0
 800d69a:	fbb1 fef7 	udiv	lr, r1, r7
 800d69e:	4610      	mov	r0, r2
 800d6a0:	fb07 1c1e 	mls	ip, r7, lr, r1
 800d6a4:	f1a4 0330 	sub.w	r3, r4, #48	; 0x30
 800d6a8:	2b09      	cmp	r3, #9
 800d6aa:	d811      	bhi.n	800d6d0 <_strtol_l.isra.0+0xa4>
 800d6ac:	461c      	mov	r4, r3
 800d6ae:	42a7      	cmp	r7, r4
 800d6b0:	dd1d      	ble.n	800d6ee <_strtol_l.isra.0+0xc2>
 800d6b2:	1c53      	adds	r3, r2, #1
 800d6b4:	d007      	beq.n	800d6c6 <_strtol_l.isra.0+0x9a>
 800d6b6:	4586      	cmp	lr, r0
 800d6b8:	d316      	bcc.n	800d6e8 <_strtol_l.isra.0+0xbc>
 800d6ba:	d101      	bne.n	800d6c0 <_strtol_l.isra.0+0x94>
 800d6bc:	45a4      	cmp	ip, r4
 800d6be:	db13      	blt.n	800d6e8 <_strtol_l.isra.0+0xbc>
 800d6c0:	fb00 4007 	mla	r0, r0, r7, r4
 800d6c4:	2201      	movs	r2, #1
 800d6c6:	f815 4b01 	ldrb.w	r4, [r5], #1
 800d6ca:	e7eb      	b.n	800d6a4 <_strtol_l.isra.0+0x78>
 800d6cc:	270a      	movs	r7, #10
 800d6ce:	e7dd      	b.n	800d68c <_strtol_l.isra.0+0x60>
 800d6d0:	f1a4 0341 	sub.w	r3, r4, #65	; 0x41
 800d6d4:	2b19      	cmp	r3, #25
 800d6d6:	d801      	bhi.n	800d6dc <_strtol_l.isra.0+0xb0>
 800d6d8:	3c37      	subs	r4, #55	; 0x37
 800d6da:	e7e8      	b.n	800d6ae <_strtol_l.isra.0+0x82>
 800d6dc:	f1a4 0361 	sub.w	r3, r4, #97	; 0x61
 800d6e0:	2b19      	cmp	r3, #25
 800d6e2:	d804      	bhi.n	800d6ee <_strtol_l.isra.0+0xc2>
 800d6e4:	3c57      	subs	r4, #87	; 0x57
 800d6e6:	e7e2      	b.n	800d6ae <_strtol_l.isra.0+0x82>
 800d6e8:	f04f 32ff 	mov.w	r2, #4294967295
 800d6ec:	e7eb      	b.n	800d6c6 <_strtol_l.isra.0+0x9a>
 800d6ee:	1c53      	adds	r3, r2, #1
 800d6f0:	d108      	bne.n	800d704 <_strtol_l.isra.0+0xd8>
 800d6f2:	2322      	movs	r3, #34	; 0x22
 800d6f4:	f8c8 3000 	str.w	r3, [r8]
 800d6f8:	4608      	mov	r0, r1
 800d6fa:	f1ba 0f00 	cmp.w	sl, #0
 800d6fe:	d107      	bne.n	800d710 <_strtol_l.isra.0+0xe4>
 800d700:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d704:	b106      	cbz	r6, 800d708 <_strtol_l.isra.0+0xdc>
 800d706:	4240      	negs	r0, r0
 800d708:	f1ba 0f00 	cmp.w	sl, #0
 800d70c:	d00c      	beq.n	800d728 <_strtol_l.isra.0+0xfc>
 800d70e:	b122      	cbz	r2, 800d71a <_strtol_l.isra.0+0xee>
 800d710:	3d01      	subs	r5, #1
 800d712:	f8ca 5000 	str.w	r5, [sl]
 800d716:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d71a:	464d      	mov	r5, r9
 800d71c:	e7f9      	b.n	800d712 <_strtol_l.isra.0+0xe6>
 800d71e:	2430      	movs	r4, #48	; 0x30
 800d720:	2f00      	cmp	r7, #0
 800d722:	d1b3      	bne.n	800d68c <_strtol_l.isra.0+0x60>
 800d724:	2708      	movs	r7, #8
 800d726:	e7b1      	b.n	800d68c <_strtol_l.isra.0+0x60>
 800d728:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0800d72c <_strtol_r>:
 800d72c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800d72e:	4c06      	ldr	r4, [pc, #24]	; (800d748 <_strtol_r+0x1c>)
 800d730:	4d06      	ldr	r5, [pc, #24]	; (800d74c <_strtol_r+0x20>)
 800d732:	6824      	ldr	r4, [r4, #0]
 800d734:	6a24      	ldr	r4, [r4, #32]
 800d736:	2c00      	cmp	r4, #0
 800d738:	bf08      	it	eq
 800d73a:	462c      	moveq	r4, r5
 800d73c:	9400      	str	r4, [sp, #0]
 800d73e:	f7ff ff75 	bl	800d62c <_strtol_l.isra.0>
 800d742:	b003      	add	sp, #12
 800d744:	bd30      	pop	{r4, r5, pc}
 800d746:	bf00      	nop
 800d748:	2000002c 	.word	0x2000002c
 800d74c:	200000d8 	.word	0x200000d8

0800d750 <strtol>:
 800d750:	4b08      	ldr	r3, [pc, #32]	; (800d774 <strtol+0x24>)
 800d752:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800d754:	681c      	ldr	r4, [r3, #0]
 800d756:	4d08      	ldr	r5, [pc, #32]	; (800d778 <strtol+0x28>)
 800d758:	6a23      	ldr	r3, [r4, #32]
 800d75a:	2b00      	cmp	r3, #0
 800d75c:	bf08      	it	eq
 800d75e:	462b      	moveq	r3, r5
 800d760:	9300      	str	r3, [sp, #0]
 800d762:	4613      	mov	r3, r2
 800d764:	460a      	mov	r2, r1
 800d766:	4601      	mov	r1, r0
 800d768:	4620      	mov	r0, r4
 800d76a:	f7ff ff5f 	bl	800d62c <_strtol_l.isra.0>
 800d76e:	b003      	add	sp, #12
 800d770:	bd30      	pop	{r4, r5, pc}
 800d772:	bf00      	nop
 800d774:	2000002c 	.word	0x2000002c
 800d778:	200000d8 	.word	0x200000d8

0800d77c <__tzcalc_limits>:
 800d77c:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d780:	4604      	mov	r4, r0
 800d782:	f000 fce7 	bl	800e154 <__gettzinfo>
 800d786:	f240 73b1 	movw	r3, #1969	; 0x7b1
 800d78a:	429c      	cmp	r4, r3
 800d78c:	f340 8098 	ble.w	800d8c0 <__tzcalc_limits+0x144>
 800d790:	f46f 63f6 	mvn.w	r3, #1968	; 0x7b0
 800d794:	18e3      	adds	r3, r4, r3
 800d796:	109b      	asrs	r3, r3, #2
 800d798:	f240 126d 	movw	r2, #365	; 0x16d
 800d79c:	f2a4 75b2 	subw	r5, r4, #1970	; 0x7b2
 800d7a0:	fb02 3505 	mla	r5, r2, r5, r3
 800d7a4:	f06f 0263 	mvn.w	r2, #99	; 0x63
 800d7a8:	f2a4 736d 	subw	r3, r4, #1901	; 0x76d
 800d7ac:	fb93 f3f2 	sdiv	r3, r3, r2
 800d7b0:	f46f 62c8 	mvn.w	r2, #1600	; 0x640
 800d7b4:	441d      	add	r5, r3
 800d7b6:	f44f 73c8 	mov.w	r3, #400	; 0x190
 800d7ba:	18a2      	adds	r2, r4, r2
 800d7bc:	fb94 f7f3 	sdiv	r7, r4, r3
 800d7c0:	fb92 f2f3 	sdiv	r2, r2, r3
 800d7c4:	fb03 4717 	mls	r7, r3, r7, r4
 800d7c8:	f100 0338 	add.w	r3, r0, #56	; 0x38
 800d7cc:	4415      	add	r5, r2
 800d7ce:	fab7 fe87 	clz	lr, r7
 800d7d2:	2264      	movs	r2, #100	; 0x64
 800d7d4:	9301      	str	r3, [sp, #4]
 800d7d6:	f004 0303 	and.w	r3, r4, #3
 800d7da:	fb94 f6f2 	sdiv	r6, r4, r2
 800d7de:	6044      	str	r4, [r0, #4]
 800d7e0:	fb02 4616 	mls	r6, r2, r6, r4
 800d7e4:	ea4f 1e5e 	mov.w	lr, lr, lsr #5
 800d7e8:	4601      	mov	r1, r0
 800d7ea:	9300      	str	r3, [sp, #0]
 800d7ec:	f06f 4c40 	mvn.w	ip, #3221225472	; 0xc0000000
 800d7f0:	7a0b      	ldrb	r3, [r1, #8]
 800d7f2:	2b4a      	cmp	r3, #74	; 0x4a
 800d7f4:	d123      	bne.n	800d83e <__tzcalc_limits+0xc2>
 800d7f6:	694c      	ldr	r4, [r1, #20]
 800d7f8:	9a00      	ldr	r2, [sp, #0]
 800d7fa:	192b      	adds	r3, r5, r4
 800d7fc:	b902      	cbnz	r2, 800d800 <__tzcalc_limits+0x84>
 800d7fe:	b906      	cbnz	r6, 800d802 <__tzcalc_limits+0x86>
 800d800:	b9df      	cbnz	r7, 800d83a <__tzcalc_limits+0xbe>
 800d802:	2c3b      	cmp	r4, #59	; 0x3b
 800d804:	bfd4      	ite	le
 800d806:	2400      	movle	r4, #0
 800d808:	2401      	movgt	r4, #1
 800d80a:	441c      	add	r4, r3
 800d80c:	3c01      	subs	r4, #1
 800d80e:	4b2d      	ldr	r3, [pc, #180]	; (800d8c4 <__tzcalc_limits+0x148>)
 800d810:	698a      	ldr	r2, [r1, #24]
 800d812:	fb03 2404 	mla	r4, r3, r4, r2
 800d816:	6a0b      	ldr	r3, [r1, #32]
 800d818:	441c      	add	r4, r3
 800d81a:	f841 4f1c 	str.w	r4, [r1, #28]!
 800d81e:	9b01      	ldr	r3, [sp, #4]
 800d820:	428b      	cmp	r3, r1
 800d822:	d1e5      	bne.n	800d7f0 <__tzcalc_limits+0x74>
 800d824:	69c3      	ldr	r3, [r0, #28]
 800d826:	6b82      	ldr	r2, [r0, #56]	; 0x38
 800d828:	4293      	cmp	r3, r2
 800d82a:	bfac      	ite	ge
 800d82c:	2300      	movge	r3, #0
 800d82e:	2301      	movlt	r3, #1
 800d830:	6003      	str	r3, [r0, #0]
 800d832:	2001      	movs	r0, #1
 800d834:	b003      	add	sp, #12
 800d836:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d83a:	2400      	movs	r4, #0
 800d83c:	e7e5      	b.n	800d80a <__tzcalc_limits+0x8e>
 800d83e:	2b44      	cmp	r3, #68	; 0x44
 800d840:	d102      	bne.n	800d848 <__tzcalc_limits+0xcc>
 800d842:	694b      	ldr	r3, [r1, #20]
 800d844:	18ec      	adds	r4, r5, r3
 800d846:	e7e2      	b.n	800d80e <__tzcalc_limits+0x92>
 800d848:	9b00      	ldr	r3, [sp, #0]
 800d84a:	bb7b      	cbnz	r3, 800d8ac <__tzcalc_limits+0x130>
 800d84c:	2e00      	cmp	r6, #0
 800d84e:	bf0c      	ite	eq
 800d850:	46f0      	moveq	r8, lr
 800d852:	f04f 0801 	movne.w	r8, #1
 800d856:	4b1c      	ldr	r3, [pc, #112]	; (800d8c8 <__tzcalc_limits+0x14c>)
 800d858:	68cc      	ldr	r4, [r1, #12]
 800d85a:	2230      	movs	r2, #48	; 0x30
 800d85c:	fb02 3808 	mla	r8, r2, r8, r3
 800d860:	f1a8 0a04 	sub.w	sl, r8, #4
 800d864:	462b      	mov	r3, r5
 800d866:	f04f 0901 	mov.w	r9, #1
 800d86a:	45a1      	cmp	r9, r4
 800d86c:	db20      	blt.n	800d8b0 <__tzcalc_limits+0x134>
 800d86e:	2c01      	cmp	r4, #1
 800d870:	bfb8      	it	lt
 800d872:	2401      	movlt	r4, #1
 800d874:	46a1      	mov	r9, r4
 800d876:	f103 0b04 	add.w	fp, r3, #4
 800d87a:	2207      	movs	r2, #7
 800d87c:	694c      	ldr	r4, [r1, #20]
 800d87e:	fb9b faf2 	sdiv	sl, fp, r2
 800d882:	ebca 0aca 	rsb	sl, sl, sl, lsl #3
 800d886:	ebab 0a0a 	sub.w	sl, fp, sl
 800d88a:	ebb4 0a0a 	subs.w	sl, r4, sl
 800d88e:	690c      	ldr	r4, [r1, #16]
 800d890:	44e1      	add	r9, ip
 800d892:	f104 34ff 	add.w	r4, r4, #4294967295
 800d896:	bf48      	it	mi
 800d898:	4492      	addmi	sl, r2
 800d89a:	ebc4 04c4 	rsb	r4, r4, r4, lsl #3
 800d89e:	f858 8029 	ldr.w	r8, [r8, r9, lsl #2]
 800d8a2:	4454      	add	r4, sl
 800d8a4:	4544      	cmp	r4, r8
 800d8a6:	da09      	bge.n	800d8bc <__tzcalc_limits+0x140>
 800d8a8:	441c      	add	r4, r3
 800d8aa:	e7b0      	b.n	800d80e <__tzcalc_limits+0x92>
 800d8ac:	46f0      	mov	r8, lr
 800d8ae:	e7d2      	b.n	800d856 <__tzcalc_limits+0xda>
 800d8b0:	f85a bf04 	ldr.w	fp, [sl, #4]!
 800d8b4:	f109 0901 	add.w	r9, r9, #1
 800d8b8:	445b      	add	r3, fp
 800d8ba:	e7d6      	b.n	800d86a <__tzcalc_limits+0xee>
 800d8bc:	3c07      	subs	r4, #7
 800d8be:	e7f1      	b.n	800d8a4 <__tzcalc_limits+0x128>
 800d8c0:	2000      	movs	r0, #0
 800d8c2:	e7b7      	b.n	800d834 <__tzcalc_limits+0xb8>
 800d8c4:	00015180 	.word	0x00015180
 800d8c8:	0800fffc 	.word	0x0800fffc

0800d8cc <__tz_lock>:
 800d8cc:	4770      	bx	lr

0800d8ce <__tz_unlock>:
 800d8ce:	4770      	bx	lr

0800d8d0 <_tzset_unlocked>:
 800d8d0:	4b01      	ldr	r3, [pc, #4]	; (800d8d8 <_tzset_unlocked+0x8>)
 800d8d2:	6818      	ldr	r0, [r3, #0]
 800d8d4:	f000 b802 	b.w	800d8dc <_tzset_unlocked_r>
 800d8d8:	2000002c 	.word	0x2000002c

0800d8dc <_tzset_unlocked_r>:
 800d8dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800d8e0:	b08d      	sub	sp, #52	; 0x34
 800d8e2:	4607      	mov	r7, r0
 800d8e4:	f000 fc36 	bl	800e154 <__gettzinfo>
 800d8e8:	49b1      	ldr	r1, [pc, #708]	; (800dbb0 <_tzset_unlocked_r+0x2d4>)
 800d8ea:	4eb2      	ldr	r6, [pc, #712]	; (800dbb4 <_tzset_unlocked_r+0x2d8>)
 800d8ec:	4605      	mov	r5, r0
 800d8ee:	4638      	mov	r0, r7
 800d8f0:	f000 fc28 	bl	800e144 <_getenv_r>
 800d8f4:	4604      	mov	r4, r0
 800d8f6:	b970      	cbnz	r0, 800d916 <_tzset_unlocked_r+0x3a>
 800d8f8:	4baf      	ldr	r3, [pc, #700]	; (800dbb8 <_tzset_unlocked_r+0x2dc>)
 800d8fa:	4ab0      	ldr	r2, [pc, #704]	; (800dbbc <_tzset_unlocked_r+0x2e0>)
 800d8fc:	6018      	str	r0, [r3, #0]
 800d8fe:	4bb0      	ldr	r3, [pc, #704]	; (800dbc0 <_tzset_unlocked_r+0x2e4>)
 800d900:	6018      	str	r0, [r3, #0]
 800d902:	4bb0      	ldr	r3, [pc, #704]	; (800dbc4 <_tzset_unlocked_r+0x2e8>)
 800d904:	6830      	ldr	r0, [r6, #0]
 800d906:	601a      	str	r2, [r3, #0]
 800d908:	605a      	str	r2, [r3, #4]
 800d90a:	f7ff f9d5 	bl	800ccb8 <free>
 800d90e:	6034      	str	r4, [r6, #0]
 800d910:	b00d      	add	sp, #52	; 0x34
 800d912:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800d916:	6831      	ldr	r1, [r6, #0]
 800d918:	2900      	cmp	r1, #0
 800d91a:	d160      	bne.n	800d9de <_tzset_unlocked_r+0x102>
 800d91c:	6830      	ldr	r0, [r6, #0]
 800d91e:	f7ff f9cb 	bl	800ccb8 <free>
 800d922:	4620      	mov	r0, r4
 800d924:	f7f2 fc66 	bl	80001f4 <strlen>
 800d928:	1c41      	adds	r1, r0, #1
 800d92a:	4638      	mov	r0, r7
 800d92c:	f7ff fc98 	bl	800d260 <_malloc_r>
 800d930:	6030      	str	r0, [r6, #0]
 800d932:	2800      	cmp	r0, #0
 800d934:	d158      	bne.n	800d9e8 <_tzset_unlocked_r+0x10c>
 800d936:	7823      	ldrb	r3, [r4, #0]
 800d938:	4aa3      	ldr	r2, [pc, #652]	; (800dbc8 <_tzset_unlocked_r+0x2ec>)
 800d93a:	49a4      	ldr	r1, [pc, #656]	; (800dbcc <_tzset_unlocked_r+0x2f0>)
 800d93c:	2b3a      	cmp	r3, #58	; 0x3a
 800d93e:	bf08      	it	eq
 800d940:	3401      	addeq	r4, #1
 800d942:	ae0a      	add	r6, sp, #40	; 0x28
 800d944:	4633      	mov	r3, r6
 800d946:	4620      	mov	r0, r4
 800d948:	f7ff fdac 	bl	800d4a4 <siscanf>
 800d94c:	2800      	cmp	r0, #0
 800d94e:	dddf      	ble.n	800d910 <_tzset_unlocked_r+0x34>
 800d950:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d952:	18e7      	adds	r7, r4, r3
 800d954:	5ce3      	ldrb	r3, [r4, r3]
 800d956:	2b2d      	cmp	r3, #45	; 0x2d
 800d958:	d14a      	bne.n	800d9f0 <_tzset_unlocked_r+0x114>
 800d95a:	3701      	adds	r7, #1
 800d95c:	f04f 34ff 	mov.w	r4, #4294967295
 800d960:	f10d 0a20 	add.w	sl, sp, #32
 800d964:	f10d 0b1e 	add.w	fp, sp, #30
 800d968:	f04f 0800 	mov.w	r8, #0
 800d96c:	9603      	str	r6, [sp, #12]
 800d96e:	f8cd a008 	str.w	sl, [sp, #8]
 800d972:	9601      	str	r6, [sp, #4]
 800d974:	f8cd b000 	str.w	fp, [sp]
 800d978:	4633      	mov	r3, r6
 800d97a:	aa07      	add	r2, sp, #28
 800d97c:	4994      	ldr	r1, [pc, #592]	; (800dbd0 <_tzset_unlocked_r+0x2f4>)
 800d97e:	f8ad 801e 	strh.w	r8, [sp, #30]
 800d982:	4638      	mov	r0, r7
 800d984:	f8ad 8020 	strh.w	r8, [sp, #32]
 800d988:	f7ff fd8c 	bl	800d4a4 <siscanf>
 800d98c:	4540      	cmp	r0, r8
 800d98e:	ddbf      	ble.n	800d910 <_tzset_unlocked_r+0x34>
 800d990:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800d994:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 800d998:	f8df 9240 	ldr.w	r9, [pc, #576]	; 800dbdc <_tzset_unlocked_r+0x300>
 800d99c:	213c      	movs	r1, #60	; 0x3c
 800d99e:	fb01 2203 	mla	r2, r1, r3, r2
 800d9a2:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 800d9a6:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 800d9aa:	fb01 2303 	mla	r3, r1, r3, r2
 800d9ae:	435c      	muls	r4, r3
 800d9b0:	622c      	str	r4, [r5, #32]
 800d9b2:	4c84      	ldr	r4, [pc, #528]	; (800dbc4 <_tzset_unlocked_r+0x2e8>)
 800d9b4:	4b84      	ldr	r3, [pc, #528]	; (800dbc8 <_tzset_unlocked_r+0x2ec>)
 800d9b6:	6023      	str	r3, [r4, #0]
 800d9b8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d9ba:	4984      	ldr	r1, [pc, #528]	; (800dbcc <_tzset_unlocked_r+0x2f0>)
 800d9bc:	441f      	add	r7, r3
 800d9be:	464a      	mov	r2, r9
 800d9c0:	4633      	mov	r3, r6
 800d9c2:	4638      	mov	r0, r7
 800d9c4:	f7ff fd6e 	bl	800d4a4 <siscanf>
 800d9c8:	4540      	cmp	r0, r8
 800d9ca:	dc16      	bgt.n	800d9fa <_tzset_unlocked_r+0x11e>
 800d9cc:	6823      	ldr	r3, [r4, #0]
 800d9ce:	6063      	str	r3, [r4, #4]
 800d9d0:	4b79      	ldr	r3, [pc, #484]	; (800dbb8 <_tzset_unlocked_r+0x2dc>)
 800d9d2:	6a2a      	ldr	r2, [r5, #32]
 800d9d4:	601a      	str	r2, [r3, #0]
 800d9d6:	4b7a      	ldr	r3, [pc, #488]	; (800dbc0 <_tzset_unlocked_r+0x2e4>)
 800d9d8:	f8c3 8000 	str.w	r8, [r3]
 800d9dc:	e798      	b.n	800d910 <_tzset_unlocked_r+0x34>
 800d9de:	f7f2 fbff 	bl	80001e0 <strcmp>
 800d9e2:	2800      	cmp	r0, #0
 800d9e4:	d094      	beq.n	800d910 <_tzset_unlocked_r+0x34>
 800d9e6:	e799      	b.n	800d91c <_tzset_unlocked_r+0x40>
 800d9e8:	4621      	mov	r1, r4
 800d9ea:	f7ff fde7 	bl	800d5bc <strcpy>
 800d9ee:	e7a2      	b.n	800d936 <_tzset_unlocked_r+0x5a>
 800d9f0:	2b2b      	cmp	r3, #43	; 0x2b
 800d9f2:	bf08      	it	eq
 800d9f4:	3701      	addeq	r7, #1
 800d9f6:	2401      	movs	r4, #1
 800d9f8:	e7b2      	b.n	800d960 <_tzset_unlocked_r+0x84>
 800d9fa:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800d9fc:	f8c4 9004 	str.w	r9, [r4, #4]
 800da00:	18fc      	adds	r4, r7, r3
 800da02:	5cfb      	ldrb	r3, [r7, r3]
 800da04:	2b2d      	cmp	r3, #45	; 0x2d
 800da06:	f040 8092 	bne.w	800db2e <_tzset_unlocked_r+0x252>
 800da0a:	3401      	adds	r4, #1
 800da0c:	f04f 37ff 	mov.w	r7, #4294967295
 800da10:	2300      	movs	r3, #0
 800da12:	f8ad 301c 	strh.w	r3, [sp, #28]
 800da16:	f8ad 301e 	strh.w	r3, [sp, #30]
 800da1a:	f8ad 3020 	strh.w	r3, [sp, #32]
 800da1e:	930a      	str	r3, [sp, #40]	; 0x28
 800da20:	9603      	str	r6, [sp, #12]
 800da22:	f8cd a008 	str.w	sl, [sp, #8]
 800da26:	9601      	str	r6, [sp, #4]
 800da28:	f8cd b000 	str.w	fp, [sp]
 800da2c:	4633      	mov	r3, r6
 800da2e:	aa07      	add	r2, sp, #28
 800da30:	4967      	ldr	r1, [pc, #412]	; (800dbd0 <_tzset_unlocked_r+0x2f4>)
 800da32:	4620      	mov	r0, r4
 800da34:	f7ff fd36 	bl	800d4a4 <siscanf>
 800da38:	2800      	cmp	r0, #0
 800da3a:	dc7d      	bgt.n	800db38 <_tzset_unlocked_r+0x25c>
 800da3c:	6a2b      	ldr	r3, [r5, #32]
 800da3e:	f5a3 6361 	sub.w	r3, r3, #3600	; 0xe10
 800da42:	63eb      	str	r3, [r5, #60]	; 0x3c
 800da44:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800da46:	462f      	mov	r7, r5
 800da48:	441c      	add	r4, r3
 800da4a:	f04f 0900 	mov.w	r9, #0
 800da4e:	7823      	ldrb	r3, [r4, #0]
 800da50:	2b2c      	cmp	r3, #44	; 0x2c
 800da52:	bf08      	it	eq
 800da54:	3401      	addeq	r4, #1
 800da56:	f894 8000 	ldrb.w	r8, [r4]
 800da5a:	f1b8 0f4d 	cmp.w	r8, #77	; 0x4d
 800da5e:	d17b      	bne.n	800db58 <_tzset_unlocked_r+0x27c>
 800da60:	f10d 0326 	add.w	r3, sp, #38	; 0x26
 800da64:	9302      	str	r3, [sp, #8]
 800da66:	ab09      	add	r3, sp, #36	; 0x24
 800da68:	9300      	str	r3, [sp, #0]
 800da6a:	9603      	str	r6, [sp, #12]
 800da6c:	9601      	str	r6, [sp, #4]
 800da6e:	4633      	mov	r3, r6
 800da70:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 800da74:	4957      	ldr	r1, [pc, #348]	; (800dbd4 <_tzset_unlocked_r+0x2f8>)
 800da76:	4620      	mov	r0, r4
 800da78:	f7ff fd14 	bl	800d4a4 <siscanf>
 800da7c:	2803      	cmp	r0, #3
 800da7e:	f47f af47 	bne.w	800d910 <_tzset_unlocked_r+0x34>
 800da82:	f8bd 1022 	ldrh.w	r1, [sp, #34]	; 0x22
 800da86:	1e4b      	subs	r3, r1, #1
 800da88:	2b0b      	cmp	r3, #11
 800da8a:	f63f af41 	bhi.w	800d910 <_tzset_unlocked_r+0x34>
 800da8e:	f8bd 2024 	ldrh.w	r2, [sp, #36]	; 0x24
 800da92:	1e53      	subs	r3, r2, #1
 800da94:	2b04      	cmp	r3, #4
 800da96:	f63f af3b 	bhi.w	800d910 <_tzset_unlocked_r+0x34>
 800da9a:	f8bd 3026 	ldrh.w	r3, [sp, #38]	; 0x26
 800da9e:	2b06      	cmp	r3, #6
 800daa0:	f63f af36 	bhi.w	800d910 <_tzset_unlocked_r+0x34>
 800daa4:	f887 8008 	strb.w	r8, [r7, #8]
 800daa8:	60f9      	str	r1, [r7, #12]
 800daaa:	613a      	str	r2, [r7, #16]
 800daac:	617b      	str	r3, [r7, #20]
 800daae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800dab0:	eb04 0803 	add.w	r8, r4, r3
 800dab4:	2302      	movs	r3, #2
 800dab6:	f8ad 301c 	strh.w	r3, [sp, #28]
 800daba:	2300      	movs	r3, #0
 800dabc:	f8ad 301e 	strh.w	r3, [sp, #30]
 800dac0:	f8ad 3020 	strh.w	r3, [sp, #32]
 800dac4:	930a      	str	r3, [sp, #40]	; 0x28
 800dac6:	f898 3000 	ldrb.w	r3, [r8]
 800daca:	2b2f      	cmp	r3, #47	; 0x2f
 800dacc:	d10b      	bne.n	800dae6 <_tzset_unlocked_r+0x20a>
 800dace:	9603      	str	r6, [sp, #12]
 800dad0:	f8cd a008 	str.w	sl, [sp, #8]
 800dad4:	9601      	str	r6, [sp, #4]
 800dad6:	f8cd b000 	str.w	fp, [sp]
 800dada:	4633      	mov	r3, r6
 800dadc:	aa07      	add	r2, sp, #28
 800dade:	493e      	ldr	r1, [pc, #248]	; (800dbd8 <_tzset_unlocked_r+0x2fc>)
 800dae0:	4640      	mov	r0, r8
 800dae2:	f7ff fcdf 	bl	800d4a4 <siscanf>
 800dae6:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800daea:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 800daee:	213c      	movs	r1, #60	; 0x3c
 800daf0:	fb01 2203 	mla	r2, r1, r3, r2
 800daf4:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 800daf8:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 800dafc:	fb01 2303 	mla	r3, r1, r3, r2
 800db00:	61bb      	str	r3, [r7, #24]
 800db02:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 800db04:	f109 0901 	add.w	r9, r9, #1
 800db08:	f1b9 0f02 	cmp.w	r9, #2
 800db0c:	4444      	add	r4, r8
 800db0e:	f107 071c 	add.w	r7, r7, #28
 800db12:	d19c      	bne.n	800da4e <_tzset_unlocked_r+0x172>
 800db14:	6868      	ldr	r0, [r5, #4]
 800db16:	f7ff fe31 	bl	800d77c <__tzcalc_limits>
 800db1a:	4b27      	ldr	r3, [pc, #156]	; (800dbb8 <_tzset_unlocked_r+0x2dc>)
 800db1c:	6a2a      	ldr	r2, [r5, #32]
 800db1e:	601a      	str	r2, [r3, #0]
 800db20:	6beb      	ldr	r3, [r5, #60]	; 0x3c
 800db22:	1a9b      	subs	r3, r3, r2
 800db24:	4a26      	ldr	r2, [pc, #152]	; (800dbc0 <_tzset_unlocked_r+0x2e4>)
 800db26:	bf18      	it	ne
 800db28:	2301      	movne	r3, #1
 800db2a:	6013      	str	r3, [r2, #0]
 800db2c:	e6f0      	b.n	800d910 <_tzset_unlocked_r+0x34>
 800db2e:	2b2b      	cmp	r3, #43	; 0x2b
 800db30:	bf08      	it	eq
 800db32:	3401      	addeq	r4, #1
 800db34:	2701      	movs	r7, #1
 800db36:	e76b      	b.n	800da10 <_tzset_unlocked_r+0x134>
 800db38:	f8bd 301e 	ldrh.w	r3, [sp, #30]
 800db3c:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 800db40:	213c      	movs	r1, #60	; 0x3c
 800db42:	fb01 2203 	mla	r2, r1, r3, r2
 800db46:	f8bd 301c 	ldrh.w	r3, [sp, #28]
 800db4a:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 800db4e:	fb01 2303 	mla	r3, r1, r3, r2
 800db52:	435f      	muls	r7, r3
 800db54:	63ef      	str	r7, [r5, #60]	; 0x3c
 800db56:	e775      	b.n	800da44 <_tzset_unlocked_r+0x168>
 800db58:	f1b8 0f4a 	cmp.w	r8, #74	; 0x4a
 800db5c:	bf06      	itte	eq
 800db5e:	3401      	addeq	r4, #1
 800db60:	4643      	moveq	r3, r8
 800db62:	2344      	movne	r3, #68	; 0x44
 800db64:	220a      	movs	r2, #10
 800db66:	a90b      	add	r1, sp, #44	; 0x2c
 800db68:	4620      	mov	r0, r4
 800db6a:	9305      	str	r3, [sp, #20]
 800db6c:	f001 fbd8 	bl	800f320 <strtoul>
 800db70:	f8dd 802c 	ldr.w	r8, [sp, #44]	; 0x2c
 800db74:	f8ad 0026 	strh.w	r0, [sp, #38]	; 0x26
 800db78:	4544      	cmp	r4, r8
 800db7a:	9b05      	ldr	r3, [sp, #20]
 800db7c:	d114      	bne.n	800dba8 <_tzset_unlocked_r+0x2cc>
 800db7e:	234d      	movs	r3, #77	; 0x4d
 800db80:	f1b9 0f00 	cmp.w	r9, #0
 800db84:	d107      	bne.n	800db96 <_tzset_unlocked_r+0x2ba>
 800db86:	722b      	strb	r3, [r5, #8]
 800db88:	2303      	movs	r3, #3
 800db8a:	60eb      	str	r3, [r5, #12]
 800db8c:	2302      	movs	r3, #2
 800db8e:	612b      	str	r3, [r5, #16]
 800db90:	f8c5 9014 	str.w	r9, [r5, #20]
 800db94:	e78e      	b.n	800dab4 <_tzset_unlocked_r+0x1d8>
 800db96:	f885 3024 	strb.w	r3, [r5, #36]	; 0x24
 800db9a:	230b      	movs	r3, #11
 800db9c:	62ab      	str	r3, [r5, #40]	; 0x28
 800db9e:	2301      	movs	r3, #1
 800dba0:	62eb      	str	r3, [r5, #44]	; 0x2c
 800dba2:	2300      	movs	r3, #0
 800dba4:	632b      	str	r3, [r5, #48]	; 0x30
 800dba6:	e785      	b.n	800dab4 <_tzset_unlocked_r+0x1d8>
 800dba8:	b280      	uxth	r0, r0
 800dbaa:	723b      	strb	r3, [r7, #8]
 800dbac:	6178      	str	r0, [r7, #20]
 800dbae:	e781      	b.n	800dab4 <_tzset_unlocked_r+0x1d8>
 800dbb0:	0800ff58 	.word	0x0800ff58
 800dbb4:	200003bc 	.word	0x200003bc
 800dbb8:	200003c4 	.word	0x200003c4
 800dbbc:	0800ff5b 	.word	0x0800ff5b
 800dbc0:	200003c0 	.word	0x200003c0
 800dbc4:	20000090 	.word	0x20000090
 800dbc8:	200003af 	.word	0x200003af
 800dbcc:	0800ff5f 	.word	0x0800ff5f
 800dbd0:	0800ff82 	.word	0x0800ff82
 800dbd4:	0800ff6e 	.word	0x0800ff6e
 800dbd8:	0800ff81 	.word	0x0800ff81
 800dbdc:	200003a4 	.word	0x200003a4

0800dbe0 <__swbuf_r>:
 800dbe0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800dbe2:	460e      	mov	r6, r1
 800dbe4:	4614      	mov	r4, r2
 800dbe6:	4605      	mov	r5, r0
 800dbe8:	b118      	cbz	r0, 800dbf2 <__swbuf_r+0x12>
 800dbea:	6983      	ldr	r3, [r0, #24]
 800dbec:	b90b      	cbnz	r3, 800dbf2 <__swbuf_r+0x12>
 800dbee:	f000 f9df 	bl	800dfb0 <__sinit>
 800dbf2:	4b21      	ldr	r3, [pc, #132]	; (800dc78 <__swbuf_r+0x98>)
 800dbf4:	429c      	cmp	r4, r3
 800dbf6:	d12a      	bne.n	800dc4e <__swbuf_r+0x6e>
 800dbf8:	686c      	ldr	r4, [r5, #4]
 800dbfa:	69a3      	ldr	r3, [r4, #24]
 800dbfc:	60a3      	str	r3, [r4, #8]
 800dbfe:	89a3      	ldrh	r3, [r4, #12]
 800dc00:	071a      	lsls	r2, r3, #28
 800dc02:	d52e      	bpl.n	800dc62 <__swbuf_r+0x82>
 800dc04:	6923      	ldr	r3, [r4, #16]
 800dc06:	b363      	cbz	r3, 800dc62 <__swbuf_r+0x82>
 800dc08:	6923      	ldr	r3, [r4, #16]
 800dc0a:	6820      	ldr	r0, [r4, #0]
 800dc0c:	1ac0      	subs	r0, r0, r3
 800dc0e:	6963      	ldr	r3, [r4, #20]
 800dc10:	b2f6      	uxtb	r6, r6
 800dc12:	4298      	cmp	r0, r3
 800dc14:	4637      	mov	r7, r6
 800dc16:	db04      	blt.n	800dc22 <__swbuf_r+0x42>
 800dc18:	4621      	mov	r1, r4
 800dc1a:	4628      	mov	r0, r5
 800dc1c:	f000 f95e 	bl	800dedc <_fflush_r>
 800dc20:	bb28      	cbnz	r0, 800dc6e <__swbuf_r+0x8e>
 800dc22:	68a3      	ldr	r3, [r4, #8]
 800dc24:	3b01      	subs	r3, #1
 800dc26:	60a3      	str	r3, [r4, #8]
 800dc28:	6823      	ldr	r3, [r4, #0]
 800dc2a:	1c5a      	adds	r2, r3, #1
 800dc2c:	6022      	str	r2, [r4, #0]
 800dc2e:	701e      	strb	r6, [r3, #0]
 800dc30:	6963      	ldr	r3, [r4, #20]
 800dc32:	3001      	adds	r0, #1
 800dc34:	4298      	cmp	r0, r3
 800dc36:	d004      	beq.n	800dc42 <__swbuf_r+0x62>
 800dc38:	89a3      	ldrh	r3, [r4, #12]
 800dc3a:	07db      	lsls	r3, r3, #31
 800dc3c:	d519      	bpl.n	800dc72 <__swbuf_r+0x92>
 800dc3e:	2e0a      	cmp	r6, #10
 800dc40:	d117      	bne.n	800dc72 <__swbuf_r+0x92>
 800dc42:	4621      	mov	r1, r4
 800dc44:	4628      	mov	r0, r5
 800dc46:	f000 f949 	bl	800dedc <_fflush_r>
 800dc4a:	b190      	cbz	r0, 800dc72 <__swbuf_r+0x92>
 800dc4c:	e00f      	b.n	800dc6e <__swbuf_r+0x8e>
 800dc4e:	4b0b      	ldr	r3, [pc, #44]	; (800dc7c <__swbuf_r+0x9c>)
 800dc50:	429c      	cmp	r4, r3
 800dc52:	d101      	bne.n	800dc58 <__swbuf_r+0x78>
 800dc54:	68ac      	ldr	r4, [r5, #8]
 800dc56:	e7d0      	b.n	800dbfa <__swbuf_r+0x1a>
 800dc58:	4b09      	ldr	r3, [pc, #36]	; (800dc80 <__swbuf_r+0xa0>)
 800dc5a:	429c      	cmp	r4, r3
 800dc5c:	bf08      	it	eq
 800dc5e:	68ec      	ldreq	r4, [r5, #12]
 800dc60:	e7cb      	b.n	800dbfa <__swbuf_r+0x1a>
 800dc62:	4621      	mov	r1, r4
 800dc64:	4628      	mov	r0, r5
 800dc66:	f000 f81f 	bl	800dca8 <__swsetup_r>
 800dc6a:	2800      	cmp	r0, #0
 800dc6c:	d0cc      	beq.n	800dc08 <__swbuf_r+0x28>
 800dc6e:	f04f 37ff 	mov.w	r7, #4294967295
 800dc72:	4638      	mov	r0, r7
 800dc74:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800dc76:	bf00      	nop
 800dc78:	0800ffb4 	.word	0x0800ffb4
 800dc7c:	0800ffd4 	.word	0x0800ffd4
 800dc80:	0800ff94 	.word	0x0800ff94

0800dc84 <_write_r>:
 800dc84:	b538      	push	{r3, r4, r5, lr}
 800dc86:	4c07      	ldr	r4, [pc, #28]	; (800dca4 <_write_r+0x20>)
 800dc88:	4605      	mov	r5, r0
 800dc8a:	4608      	mov	r0, r1
 800dc8c:	4611      	mov	r1, r2
 800dc8e:	2200      	movs	r2, #0
 800dc90:	6022      	str	r2, [r4, #0]
 800dc92:	461a      	mov	r2, r3
 800dc94:	f7fc fce6 	bl	800a664 <_write>
 800dc98:	1c43      	adds	r3, r0, #1
 800dc9a:	d102      	bne.n	800dca2 <_write_r+0x1e>
 800dc9c:	6823      	ldr	r3, [r4, #0]
 800dc9e:	b103      	cbz	r3, 800dca2 <_write_r+0x1e>
 800dca0:	602b      	str	r3, [r5, #0]
 800dca2:	bd38      	pop	{r3, r4, r5, pc}
 800dca4:	2000c63c 	.word	0x2000c63c

0800dca8 <__swsetup_r>:
 800dca8:	4b32      	ldr	r3, [pc, #200]	; (800dd74 <__swsetup_r+0xcc>)
 800dcaa:	b570      	push	{r4, r5, r6, lr}
 800dcac:	681d      	ldr	r5, [r3, #0]
 800dcae:	4606      	mov	r6, r0
 800dcb0:	460c      	mov	r4, r1
 800dcb2:	b125      	cbz	r5, 800dcbe <__swsetup_r+0x16>
 800dcb4:	69ab      	ldr	r3, [r5, #24]
 800dcb6:	b913      	cbnz	r3, 800dcbe <__swsetup_r+0x16>
 800dcb8:	4628      	mov	r0, r5
 800dcba:	f000 f979 	bl	800dfb0 <__sinit>
 800dcbe:	4b2e      	ldr	r3, [pc, #184]	; (800dd78 <__swsetup_r+0xd0>)
 800dcc0:	429c      	cmp	r4, r3
 800dcc2:	d10f      	bne.n	800dce4 <__swsetup_r+0x3c>
 800dcc4:	686c      	ldr	r4, [r5, #4]
 800dcc6:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800dcca:	b29a      	uxth	r2, r3
 800dccc:	0715      	lsls	r5, r2, #28
 800dcce:	d42c      	bmi.n	800dd2a <__swsetup_r+0x82>
 800dcd0:	06d0      	lsls	r0, r2, #27
 800dcd2:	d411      	bmi.n	800dcf8 <__swsetup_r+0x50>
 800dcd4:	2209      	movs	r2, #9
 800dcd6:	6032      	str	r2, [r6, #0]
 800dcd8:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800dcdc:	81a3      	strh	r3, [r4, #12]
 800dcde:	f04f 30ff 	mov.w	r0, #4294967295
 800dce2:	bd70      	pop	{r4, r5, r6, pc}
 800dce4:	4b25      	ldr	r3, [pc, #148]	; (800dd7c <__swsetup_r+0xd4>)
 800dce6:	429c      	cmp	r4, r3
 800dce8:	d101      	bne.n	800dcee <__swsetup_r+0x46>
 800dcea:	68ac      	ldr	r4, [r5, #8]
 800dcec:	e7eb      	b.n	800dcc6 <__swsetup_r+0x1e>
 800dcee:	4b24      	ldr	r3, [pc, #144]	; (800dd80 <__swsetup_r+0xd8>)
 800dcf0:	429c      	cmp	r4, r3
 800dcf2:	bf08      	it	eq
 800dcf4:	68ec      	ldreq	r4, [r5, #12]
 800dcf6:	e7e6      	b.n	800dcc6 <__swsetup_r+0x1e>
 800dcf8:	0751      	lsls	r1, r2, #29
 800dcfa:	d512      	bpl.n	800dd22 <__swsetup_r+0x7a>
 800dcfc:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800dcfe:	b141      	cbz	r1, 800dd12 <__swsetup_r+0x6a>
 800dd00:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800dd04:	4299      	cmp	r1, r3
 800dd06:	d002      	beq.n	800dd0e <__swsetup_r+0x66>
 800dd08:	4630      	mov	r0, r6
 800dd0a:	f7ff fa5b 	bl	800d1c4 <_free_r>
 800dd0e:	2300      	movs	r3, #0
 800dd10:	6363      	str	r3, [r4, #52]	; 0x34
 800dd12:	89a3      	ldrh	r3, [r4, #12]
 800dd14:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 800dd18:	81a3      	strh	r3, [r4, #12]
 800dd1a:	2300      	movs	r3, #0
 800dd1c:	6063      	str	r3, [r4, #4]
 800dd1e:	6923      	ldr	r3, [r4, #16]
 800dd20:	6023      	str	r3, [r4, #0]
 800dd22:	89a3      	ldrh	r3, [r4, #12]
 800dd24:	f043 0308 	orr.w	r3, r3, #8
 800dd28:	81a3      	strh	r3, [r4, #12]
 800dd2a:	6923      	ldr	r3, [r4, #16]
 800dd2c:	b94b      	cbnz	r3, 800dd42 <__swsetup_r+0x9a>
 800dd2e:	89a3      	ldrh	r3, [r4, #12]
 800dd30:	f403 7320 	and.w	r3, r3, #640	; 0x280
 800dd34:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800dd38:	d003      	beq.n	800dd42 <__swsetup_r+0x9a>
 800dd3a:	4621      	mov	r1, r4
 800dd3c:	4630      	mov	r0, r6
 800dd3e:	f000 fa55 	bl	800e1ec <__smakebuf_r>
 800dd42:	89a2      	ldrh	r2, [r4, #12]
 800dd44:	f012 0301 	ands.w	r3, r2, #1
 800dd48:	d00c      	beq.n	800dd64 <__swsetup_r+0xbc>
 800dd4a:	2300      	movs	r3, #0
 800dd4c:	60a3      	str	r3, [r4, #8]
 800dd4e:	6963      	ldr	r3, [r4, #20]
 800dd50:	425b      	negs	r3, r3
 800dd52:	61a3      	str	r3, [r4, #24]
 800dd54:	6923      	ldr	r3, [r4, #16]
 800dd56:	b953      	cbnz	r3, 800dd6e <__swsetup_r+0xc6>
 800dd58:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800dd5c:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 800dd60:	d1ba      	bne.n	800dcd8 <__swsetup_r+0x30>
 800dd62:	bd70      	pop	{r4, r5, r6, pc}
 800dd64:	0792      	lsls	r2, r2, #30
 800dd66:	bf58      	it	pl
 800dd68:	6963      	ldrpl	r3, [r4, #20]
 800dd6a:	60a3      	str	r3, [r4, #8]
 800dd6c:	e7f2      	b.n	800dd54 <__swsetup_r+0xac>
 800dd6e:	2000      	movs	r0, #0
 800dd70:	e7f7      	b.n	800dd62 <__swsetup_r+0xba>
 800dd72:	bf00      	nop
 800dd74:	2000002c 	.word	0x2000002c
 800dd78:	0800ffb4 	.word	0x0800ffb4
 800dd7c:	0800ffd4 	.word	0x0800ffd4
 800dd80:	0800ff94 	.word	0x0800ff94

0800dd84 <_close_r>:
 800dd84:	b538      	push	{r3, r4, r5, lr}
 800dd86:	4c06      	ldr	r4, [pc, #24]	; (800dda0 <_close_r+0x1c>)
 800dd88:	2300      	movs	r3, #0
 800dd8a:	4605      	mov	r5, r0
 800dd8c:	4608      	mov	r0, r1
 800dd8e:	6023      	str	r3, [r4, #0]
 800dd90:	f001 fb92 	bl	800f4b8 <_close>
 800dd94:	1c43      	adds	r3, r0, #1
 800dd96:	d102      	bne.n	800dd9e <_close_r+0x1a>
 800dd98:	6823      	ldr	r3, [r4, #0]
 800dd9a:	b103      	cbz	r3, 800dd9e <_close_r+0x1a>
 800dd9c:	602b      	str	r3, [r5, #0]
 800dd9e:	bd38      	pop	{r3, r4, r5, pc}
 800dda0:	2000c63c 	.word	0x2000c63c

0800dda4 <div>:
 800dda4:	2900      	cmp	r1, #0
 800dda6:	b510      	push	{r4, lr}
 800dda8:	fb91 f4f2 	sdiv	r4, r1, r2
 800ddac:	fb02 1314 	mls	r3, r2, r4, r1
 800ddb0:	db06      	blt.n	800ddc0 <div+0x1c>
 800ddb2:	2b00      	cmp	r3, #0
 800ddb4:	da01      	bge.n	800ddba <div+0x16>
 800ddb6:	3401      	adds	r4, #1
 800ddb8:	1a9b      	subs	r3, r3, r2
 800ddba:	6004      	str	r4, [r0, #0]
 800ddbc:	6043      	str	r3, [r0, #4]
 800ddbe:	bd10      	pop	{r4, pc}
 800ddc0:	2b00      	cmp	r3, #0
 800ddc2:	bfc4      	itt	gt
 800ddc4:	f104 34ff 	addgt.w	r4, r4, #4294967295
 800ddc8:	189b      	addgt	r3, r3, r2
 800ddca:	e7f6      	b.n	800ddba <div+0x16>

0800ddcc <__sflush_r>:
 800ddcc:	898a      	ldrh	r2, [r1, #12]
 800ddce:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ddd2:	4605      	mov	r5, r0
 800ddd4:	0710      	lsls	r0, r2, #28
 800ddd6:	460c      	mov	r4, r1
 800ddd8:	d45a      	bmi.n	800de90 <__sflush_r+0xc4>
 800ddda:	684b      	ldr	r3, [r1, #4]
 800dddc:	2b00      	cmp	r3, #0
 800ddde:	dc05      	bgt.n	800ddec <__sflush_r+0x20>
 800dde0:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 800dde2:	2b00      	cmp	r3, #0
 800dde4:	dc02      	bgt.n	800ddec <__sflush_r+0x20>
 800dde6:	2000      	movs	r0, #0
 800dde8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ddec:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800ddee:	2e00      	cmp	r6, #0
 800ddf0:	d0f9      	beq.n	800dde6 <__sflush_r+0x1a>
 800ddf2:	2300      	movs	r3, #0
 800ddf4:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 800ddf8:	682f      	ldr	r7, [r5, #0]
 800ddfa:	602b      	str	r3, [r5, #0]
 800ddfc:	d033      	beq.n	800de66 <__sflush_r+0x9a>
 800ddfe:	6d60      	ldr	r0, [r4, #84]	; 0x54
 800de00:	89a3      	ldrh	r3, [r4, #12]
 800de02:	075a      	lsls	r2, r3, #29
 800de04:	d505      	bpl.n	800de12 <__sflush_r+0x46>
 800de06:	6863      	ldr	r3, [r4, #4]
 800de08:	1ac0      	subs	r0, r0, r3
 800de0a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800de0c:	b10b      	cbz	r3, 800de12 <__sflush_r+0x46>
 800de0e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800de10:	1ac0      	subs	r0, r0, r3
 800de12:	2300      	movs	r3, #0
 800de14:	4602      	mov	r2, r0
 800de16:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800de18:	6a21      	ldr	r1, [r4, #32]
 800de1a:	4628      	mov	r0, r5
 800de1c:	47b0      	blx	r6
 800de1e:	1c43      	adds	r3, r0, #1
 800de20:	89a3      	ldrh	r3, [r4, #12]
 800de22:	d106      	bne.n	800de32 <__sflush_r+0x66>
 800de24:	6829      	ldr	r1, [r5, #0]
 800de26:	291d      	cmp	r1, #29
 800de28:	d84b      	bhi.n	800dec2 <__sflush_r+0xf6>
 800de2a:	4a2b      	ldr	r2, [pc, #172]	; (800ded8 <__sflush_r+0x10c>)
 800de2c:	40ca      	lsrs	r2, r1
 800de2e:	07d6      	lsls	r6, r2, #31
 800de30:	d547      	bpl.n	800dec2 <__sflush_r+0xf6>
 800de32:	2200      	movs	r2, #0
 800de34:	6062      	str	r2, [r4, #4]
 800de36:	04d9      	lsls	r1, r3, #19
 800de38:	6922      	ldr	r2, [r4, #16]
 800de3a:	6022      	str	r2, [r4, #0]
 800de3c:	d504      	bpl.n	800de48 <__sflush_r+0x7c>
 800de3e:	1c42      	adds	r2, r0, #1
 800de40:	d101      	bne.n	800de46 <__sflush_r+0x7a>
 800de42:	682b      	ldr	r3, [r5, #0]
 800de44:	b903      	cbnz	r3, 800de48 <__sflush_r+0x7c>
 800de46:	6560      	str	r0, [r4, #84]	; 0x54
 800de48:	6b61      	ldr	r1, [r4, #52]	; 0x34
 800de4a:	602f      	str	r7, [r5, #0]
 800de4c:	2900      	cmp	r1, #0
 800de4e:	d0ca      	beq.n	800dde6 <__sflush_r+0x1a>
 800de50:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800de54:	4299      	cmp	r1, r3
 800de56:	d002      	beq.n	800de5e <__sflush_r+0x92>
 800de58:	4628      	mov	r0, r5
 800de5a:	f7ff f9b3 	bl	800d1c4 <_free_r>
 800de5e:	2000      	movs	r0, #0
 800de60:	6360      	str	r0, [r4, #52]	; 0x34
 800de62:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800de66:	6a21      	ldr	r1, [r4, #32]
 800de68:	2301      	movs	r3, #1
 800de6a:	4628      	mov	r0, r5
 800de6c:	47b0      	blx	r6
 800de6e:	1c41      	adds	r1, r0, #1
 800de70:	d1c6      	bne.n	800de00 <__sflush_r+0x34>
 800de72:	682b      	ldr	r3, [r5, #0]
 800de74:	2b00      	cmp	r3, #0
 800de76:	d0c3      	beq.n	800de00 <__sflush_r+0x34>
 800de78:	2b1d      	cmp	r3, #29
 800de7a:	d001      	beq.n	800de80 <__sflush_r+0xb4>
 800de7c:	2b16      	cmp	r3, #22
 800de7e:	d101      	bne.n	800de84 <__sflush_r+0xb8>
 800de80:	602f      	str	r7, [r5, #0]
 800de82:	e7b0      	b.n	800dde6 <__sflush_r+0x1a>
 800de84:	89a3      	ldrh	r3, [r4, #12]
 800de86:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800de8a:	81a3      	strh	r3, [r4, #12]
 800de8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800de90:	690f      	ldr	r7, [r1, #16]
 800de92:	2f00      	cmp	r7, #0
 800de94:	d0a7      	beq.n	800dde6 <__sflush_r+0x1a>
 800de96:	0793      	lsls	r3, r2, #30
 800de98:	680e      	ldr	r6, [r1, #0]
 800de9a:	bf08      	it	eq
 800de9c:	694b      	ldreq	r3, [r1, #20]
 800de9e:	600f      	str	r7, [r1, #0]
 800dea0:	bf18      	it	ne
 800dea2:	2300      	movne	r3, #0
 800dea4:	eba6 0807 	sub.w	r8, r6, r7
 800dea8:	608b      	str	r3, [r1, #8]
 800deaa:	f1b8 0f00 	cmp.w	r8, #0
 800deae:	dd9a      	ble.n	800dde6 <__sflush_r+0x1a>
 800deb0:	4643      	mov	r3, r8
 800deb2:	463a      	mov	r2, r7
 800deb4:	6a21      	ldr	r1, [r4, #32]
 800deb6:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 800deb8:	4628      	mov	r0, r5
 800deba:	47b0      	blx	r6
 800debc:	2800      	cmp	r0, #0
 800debe:	dc07      	bgt.n	800ded0 <__sflush_r+0x104>
 800dec0:	89a3      	ldrh	r3, [r4, #12]
 800dec2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800dec6:	81a3      	strh	r3, [r4, #12]
 800dec8:	f04f 30ff 	mov.w	r0, #4294967295
 800decc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ded0:	4407      	add	r7, r0
 800ded2:	eba8 0800 	sub.w	r8, r8, r0
 800ded6:	e7e8      	b.n	800deaa <__sflush_r+0xde>
 800ded8:	20400001 	.word	0x20400001

0800dedc <_fflush_r>:
 800dedc:	b538      	push	{r3, r4, r5, lr}
 800dede:	690b      	ldr	r3, [r1, #16]
 800dee0:	4605      	mov	r5, r0
 800dee2:	460c      	mov	r4, r1
 800dee4:	b1db      	cbz	r3, 800df1e <_fflush_r+0x42>
 800dee6:	b118      	cbz	r0, 800def0 <_fflush_r+0x14>
 800dee8:	6983      	ldr	r3, [r0, #24]
 800deea:	b90b      	cbnz	r3, 800def0 <_fflush_r+0x14>
 800deec:	f000 f860 	bl	800dfb0 <__sinit>
 800def0:	4b0c      	ldr	r3, [pc, #48]	; (800df24 <_fflush_r+0x48>)
 800def2:	429c      	cmp	r4, r3
 800def4:	d109      	bne.n	800df0a <_fflush_r+0x2e>
 800def6:	686c      	ldr	r4, [r5, #4]
 800def8:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800defc:	b17b      	cbz	r3, 800df1e <_fflush_r+0x42>
 800defe:	4621      	mov	r1, r4
 800df00:	4628      	mov	r0, r5
 800df02:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800df06:	f7ff bf61 	b.w	800ddcc <__sflush_r>
 800df0a:	4b07      	ldr	r3, [pc, #28]	; (800df28 <_fflush_r+0x4c>)
 800df0c:	429c      	cmp	r4, r3
 800df0e:	d101      	bne.n	800df14 <_fflush_r+0x38>
 800df10:	68ac      	ldr	r4, [r5, #8]
 800df12:	e7f1      	b.n	800def8 <_fflush_r+0x1c>
 800df14:	4b05      	ldr	r3, [pc, #20]	; (800df2c <_fflush_r+0x50>)
 800df16:	429c      	cmp	r4, r3
 800df18:	bf08      	it	eq
 800df1a:	68ec      	ldreq	r4, [r5, #12]
 800df1c:	e7ec      	b.n	800def8 <_fflush_r+0x1c>
 800df1e:	2000      	movs	r0, #0
 800df20:	bd38      	pop	{r3, r4, r5, pc}
 800df22:	bf00      	nop
 800df24:	0800ffb4 	.word	0x0800ffb4
 800df28:	0800ffd4 	.word	0x0800ffd4
 800df2c:	0800ff94 	.word	0x0800ff94

0800df30 <_cleanup_r>:
 800df30:	4901      	ldr	r1, [pc, #4]	; (800df38 <_cleanup_r+0x8>)
 800df32:	f000 b8a9 	b.w	800e088 <_fwalk_reent>
 800df36:	bf00      	nop
 800df38:	0800dedd 	.word	0x0800dedd

0800df3c <std.isra.0>:
 800df3c:	2300      	movs	r3, #0
 800df3e:	b510      	push	{r4, lr}
 800df40:	4604      	mov	r4, r0
 800df42:	6003      	str	r3, [r0, #0]
 800df44:	6043      	str	r3, [r0, #4]
 800df46:	6083      	str	r3, [r0, #8]
 800df48:	8181      	strh	r1, [r0, #12]
 800df4a:	6643      	str	r3, [r0, #100]	; 0x64
 800df4c:	81c2      	strh	r2, [r0, #14]
 800df4e:	6103      	str	r3, [r0, #16]
 800df50:	6143      	str	r3, [r0, #20]
 800df52:	6183      	str	r3, [r0, #24]
 800df54:	4619      	mov	r1, r3
 800df56:	2208      	movs	r2, #8
 800df58:	305c      	adds	r0, #92	; 0x5c
 800df5a:	f7fe fecf 	bl	800ccfc <memset>
 800df5e:	4b05      	ldr	r3, [pc, #20]	; (800df74 <std.isra.0+0x38>)
 800df60:	6263      	str	r3, [r4, #36]	; 0x24
 800df62:	4b05      	ldr	r3, [pc, #20]	; (800df78 <std.isra.0+0x3c>)
 800df64:	62a3      	str	r3, [r4, #40]	; 0x28
 800df66:	4b05      	ldr	r3, [pc, #20]	; (800df7c <std.isra.0+0x40>)
 800df68:	62e3      	str	r3, [r4, #44]	; 0x2c
 800df6a:	4b05      	ldr	r3, [pc, #20]	; (800df80 <std.isra.0+0x44>)
 800df6c:	6224      	str	r4, [r4, #32]
 800df6e:	6323      	str	r3, [r4, #48]	; 0x30
 800df70:	bd10      	pop	{r4, pc}
 800df72:	bf00      	nop
 800df74:	0800d4f9 	.word	0x0800d4f9
 800df78:	0800d51f 	.word	0x0800d51f
 800df7c:	0800d557 	.word	0x0800d557
 800df80:	0800d57b 	.word	0x0800d57b

0800df84 <__sfmoreglue>:
 800df84:	b570      	push	{r4, r5, r6, lr}
 800df86:	1e4a      	subs	r2, r1, #1
 800df88:	2568      	movs	r5, #104	; 0x68
 800df8a:	4355      	muls	r5, r2
 800df8c:	460e      	mov	r6, r1
 800df8e:	f105 0174 	add.w	r1, r5, #116	; 0x74
 800df92:	f7ff f965 	bl	800d260 <_malloc_r>
 800df96:	4604      	mov	r4, r0
 800df98:	b140      	cbz	r0, 800dfac <__sfmoreglue+0x28>
 800df9a:	2100      	movs	r1, #0
 800df9c:	e880 0042 	stmia.w	r0, {r1, r6}
 800dfa0:	300c      	adds	r0, #12
 800dfa2:	60a0      	str	r0, [r4, #8]
 800dfa4:	f105 0268 	add.w	r2, r5, #104	; 0x68
 800dfa8:	f7fe fea8 	bl	800ccfc <memset>
 800dfac:	4620      	mov	r0, r4
 800dfae:	bd70      	pop	{r4, r5, r6, pc}

0800dfb0 <__sinit>:
 800dfb0:	6983      	ldr	r3, [r0, #24]
 800dfb2:	b510      	push	{r4, lr}
 800dfb4:	4604      	mov	r4, r0
 800dfb6:	bb33      	cbnz	r3, 800e006 <__sinit+0x56>
 800dfb8:	6483      	str	r3, [r0, #72]	; 0x48
 800dfba:	64c3      	str	r3, [r0, #76]	; 0x4c
 800dfbc:	6503      	str	r3, [r0, #80]	; 0x50
 800dfbe:	4b12      	ldr	r3, [pc, #72]	; (800e008 <__sinit+0x58>)
 800dfc0:	4a12      	ldr	r2, [pc, #72]	; (800e00c <__sinit+0x5c>)
 800dfc2:	681b      	ldr	r3, [r3, #0]
 800dfc4:	6282      	str	r2, [r0, #40]	; 0x28
 800dfc6:	4298      	cmp	r0, r3
 800dfc8:	bf04      	itt	eq
 800dfca:	2301      	moveq	r3, #1
 800dfcc:	6183      	streq	r3, [r0, #24]
 800dfce:	f000 f81f 	bl	800e010 <__sfp>
 800dfd2:	6060      	str	r0, [r4, #4]
 800dfd4:	4620      	mov	r0, r4
 800dfd6:	f000 f81b 	bl	800e010 <__sfp>
 800dfda:	60a0      	str	r0, [r4, #8]
 800dfdc:	4620      	mov	r0, r4
 800dfde:	f000 f817 	bl	800e010 <__sfp>
 800dfe2:	2200      	movs	r2, #0
 800dfe4:	60e0      	str	r0, [r4, #12]
 800dfe6:	2104      	movs	r1, #4
 800dfe8:	6860      	ldr	r0, [r4, #4]
 800dfea:	f7ff ffa7 	bl	800df3c <std.isra.0>
 800dfee:	2201      	movs	r2, #1
 800dff0:	2109      	movs	r1, #9
 800dff2:	68a0      	ldr	r0, [r4, #8]
 800dff4:	f7ff ffa2 	bl	800df3c <std.isra.0>
 800dff8:	2202      	movs	r2, #2
 800dffa:	2112      	movs	r1, #18
 800dffc:	68e0      	ldr	r0, [r4, #12]
 800dffe:	f7ff ff9d 	bl	800df3c <std.isra.0>
 800e002:	2301      	movs	r3, #1
 800e004:	61a3      	str	r3, [r4, #24]
 800e006:	bd10      	pop	{r4, pc}
 800e008:	0800fef4 	.word	0x0800fef4
 800e00c:	0800df31 	.word	0x0800df31

0800e010 <__sfp>:
 800e010:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e012:	4b1c      	ldr	r3, [pc, #112]	; (800e084 <__sfp+0x74>)
 800e014:	681e      	ldr	r6, [r3, #0]
 800e016:	69b3      	ldr	r3, [r6, #24]
 800e018:	4607      	mov	r7, r0
 800e01a:	b913      	cbnz	r3, 800e022 <__sfp+0x12>
 800e01c:	4630      	mov	r0, r6
 800e01e:	f7ff ffc7 	bl	800dfb0 <__sinit>
 800e022:	3648      	adds	r6, #72	; 0x48
 800e024:	68b4      	ldr	r4, [r6, #8]
 800e026:	6873      	ldr	r3, [r6, #4]
 800e028:	3b01      	subs	r3, #1
 800e02a:	d503      	bpl.n	800e034 <__sfp+0x24>
 800e02c:	6833      	ldr	r3, [r6, #0]
 800e02e:	b133      	cbz	r3, 800e03e <__sfp+0x2e>
 800e030:	6836      	ldr	r6, [r6, #0]
 800e032:	e7f7      	b.n	800e024 <__sfp+0x14>
 800e034:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 800e038:	b16d      	cbz	r5, 800e056 <__sfp+0x46>
 800e03a:	3468      	adds	r4, #104	; 0x68
 800e03c:	e7f4      	b.n	800e028 <__sfp+0x18>
 800e03e:	2104      	movs	r1, #4
 800e040:	4638      	mov	r0, r7
 800e042:	f7ff ff9f 	bl	800df84 <__sfmoreglue>
 800e046:	6030      	str	r0, [r6, #0]
 800e048:	2800      	cmp	r0, #0
 800e04a:	d1f1      	bne.n	800e030 <__sfp+0x20>
 800e04c:	230c      	movs	r3, #12
 800e04e:	603b      	str	r3, [r7, #0]
 800e050:	4604      	mov	r4, r0
 800e052:	4620      	mov	r0, r4
 800e054:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800e056:	f64f 73ff 	movw	r3, #65535	; 0xffff
 800e05a:	81e3      	strh	r3, [r4, #14]
 800e05c:	2301      	movs	r3, #1
 800e05e:	81a3      	strh	r3, [r4, #12]
 800e060:	6665      	str	r5, [r4, #100]	; 0x64
 800e062:	6025      	str	r5, [r4, #0]
 800e064:	60a5      	str	r5, [r4, #8]
 800e066:	6065      	str	r5, [r4, #4]
 800e068:	6125      	str	r5, [r4, #16]
 800e06a:	6165      	str	r5, [r4, #20]
 800e06c:	61a5      	str	r5, [r4, #24]
 800e06e:	2208      	movs	r2, #8
 800e070:	4629      	mov	r1, r5
 800e072:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 800e076:	f7fe fe41 	bl	800ccfc <memset>
 800e07a:	6365      	str	r5, [r4, #52]	; 0x34
 800e07c:	63a5      	str	r5, [r4, #56]	; 0x38
 800e07e:	64a5      	str	r5, [r4, #72]	; 0x48
 800e080:	64e5      	str	r5, [r4, #76]	; 0x4c
 800e082:	e7e6      	b.n	800e052 <__sfp+0x42>
 800e084:	0800fef4 	.word	0x0800fef4

0800e088 <_fwalk_reent>:
 800e088:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800e08c:	4680      	mov	r8, r0
 800e08e:	4689      	mov	r9, r1
 800e090:	f100 0448 	add.w	r4, r0, #72	; 0x48
 800e094:	2600      	movs	r6, #0
 800e096:	b914      	cbnz	r4, 800e09e <_fwalk_reent+0x16>
 800e098:	4630      	mov	r0, r6
 800e09a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800e09e:	68a5      	ldr	r5, [r4, #8]
 800e0a0:	6867      	ldr	r7, [r4, #4]
 800e0a2:	3f01      	subs	r7, #1
 800e0a4:	d501      	bpl.n	800e0aa <_fwalk_reent+0x22>
 800e0a6:	6824      	ldr	r4, [r4, #0]
 800e0a8:	e7f5      	b.n	800e096 <_fwalk_reent+0xe>
 800e0aa:	89ab      	ldrh	r3, [r5, #12]
 800e0ac:	2b01      	cmp	r3, #1
 800e0ae:	d907      	bls.n	800e0c0 <_fwalk_reent+0x38>
 800e0b0:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 800e0b4:	3301      	adds	r3, #1
 800e0b6:	d003      	beq.n	800e0c0 <_fwalk_reent+0x38>
 800e0b8:	4629      	mov	r1, r5
 800e0ba:	4640      	mov	r0, r8
 800e0bc:	47c8      	blx	r9
 800e0be:	4306      	orrs	r6, r0
 800e0c0:	3568      	adds	r5, #104	; 0x68
 800e0c2:	e7ee      	b.n	800e0a2 <_fwalk_reent+0x1a>

0800e0c4 <_findenv_r>:
 800e0c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800e0c8:	4606      	mov	r6, r0
 800e0ca:	468a      	mov	sl, r1
 800e0cc:	4617      	mov	r7, r2
 800e0ce:	f001 f985 	bl	800f3dc <__env_lock>
 800e0d2:	4b1b      	ldr	r3, [pc, #108]	; (800e140 <_findenv_r+0x7c>)
 800e0d4:	f8d3 8000 	ldr.w	r8, [r3]
 800e0d8:	4699      	mov	r9, r3
 800e0da:	f1b8 0f00 	cmp.w	r8, #0
 800e0de:	d007      	beq.n	800e0f0 <_findenv_r+0x2c>
 800e0e0:	4654      	mov	r4, sl
 800e0e2:	4623      	mov	r3, r4
 800e0e4:	f813 2b01 	ldrb.w	r2, [r3], #1
 800e0e8:	b332      	cbz	r2, 800e138 <_findenv_r+0x74>
 800e0ea:	2a3d      	cmp	r2, #61	; 0x3d
 800e0ec:	461c      	mov	r4, r3
 800e0ee:	d1f8      	bne.n	800e0e2 <_findenv_r+0x1e>
 800e0f0:	4630      	mov	r0, r6
 800e0f2:	f001 f974 	bl	800f3de <__env_unlock>
 800e0f6:	2000      	movs	r0, #0
 800e0f8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800e0fc:	f108 0804 	add.w	r8, r8, #4
 800e100:	f8d8 0000 	ldr.w	r0, [r8]
 800e104:	2800      	cmp	r0, #0
 800e106:	d0f3      	beq.n	800e0f0 <_findenv_r+0x2c>
 800e108:	4622      	mov	r2, r4
 800e10a:	4651      	mov	r1, sl
 800e10c:	f001 f866 	bl	800f1dc <strncmp>
 800e110:	2800      	cmp	r0, #0
 800e112:	d1f3      	bne.n	800e0fc <_findenv_r+0x38>
 800e114:	f8d8 3000 	ldr.w	r3, [r8]
 800e118:	191d      	adds	r5, r3, r4
 800e11a:	5d1b      	ldrb	r3, [r3, r4]
 800e11c:	2b3d      	cmp	r3, #61	; 0x3d
 800e11e:	d1ed      	bne.n	800e0fc <_findenv_r+0x38>
 800e120:	f8d9 3000 	ldr.w	r3, [r9]
 800e124:	eba8 0303 	sub.w	r3, r8, r3
 800e128:	109b      	asrs	r3, r3, #2
 800e12a:	4630      	mov	r0, r6
 800e12c:	603b      	str	r3, [r7, #0]
 800e12e:	f001 f956 	bl	800f3de <__env_unlock>
 800e132:	1c68      	adds	r0, r5, #1
 800e134:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800e138:	eba4 040a 	sub.w	r4, r4, sl
 800e13c:	e7e0      	b.n	800e100 <_findenv_r+0x3c>
 800e13e:	bf00      	nop
 800e140:	20000244 	.word	0x20000244

0800e144 <_getenv_r>:
 800e144:	b507      	push	{r0, r1, r2, lr}
 800e146:	aa01      	add	r2, sp, #4
 800e148:	f7ff ffbc 	bl	800e0c4 <_findenv_r>
 800e14c:	b003      	add	sp, #12
 800e14e:	f85d fb04 	ldr.w	pc, [sp], #4
	...

0800e154 <__gettzinfo>:
 800e154:	4800      	ldr	r0, [pc, #0]	; (800e158 <__gettzinfo+0x4>)
 800e156:	4770      	bx	lr
 800e158:	20000098 	.word	0x20000098

0800e15c <__locale_ctype_ptr_l>:
 800e15c:	f8d0 00ec 	ldr.w	r0, [r0, #236]	; 0xec
 800e160:	4770      	bx	lr
	...

0800e164 <__locale_ctype_ptr>:
 800e164:	4b04      	ldr	r3, [pc, #16]	; (800e178 <__locale_ctype_ptr+0x14>)
 800e166:	4a05      	ldr	r2, [pc, #20]	; (800e17c <__locale_ctype_ptr+0x18>)
 800e168:	681b      	ldr	r3, [r3, #0]
 800e16a:	6a1b      	ldr	r3, [r3, #32]
 800e16c:	2b00      	cmp	r3, #0
 800e16e:	bf08      	it	eq
 800e170:	4613      	moveq	r3, r2
 800e172:	f8d3 00ec 	ldr.w	r0, [r3, #236]	; 0xec
 800e176:	4770      	bx	lr
 800e178:	2000002c 	.word	0x2000002c
 800e17c:	200000d8 	.word	0x200000d8

0800e180 <_lseek_r>:
 800e180:	b538      	push	{r3, r4, r5, lr}
 800e182:	4c07      	ldr	r4, [pc, #28]	; (800e1a0 <_lseek_r+0x20>)
 800e184:	4605      	mov	r5, r0
 800e186:	4608      	mov	r0, r1
 800e188:	4611      	mov	r1, r2
 800e18a:	2200      	movs	r2, #0
 800e18c:	6022      	str	r2, [r4, #0]
 800e18e:	461a      	mov	r2, r3
 800e190:	f001 f9aa 	bl	800f4e8 <_lseek>
 800e194:	1c43      	adds	r3, r0, #1
 800e196:	d102      	bne.n	800e19e <_lseek_r+0x1e>
 800e198:	6823      	ldr	r3, [r4, #0]
 800e19a:	b103      	cbz	r3, 800e19e <_lseek_r+0x1e>
 800e19c:	602b      	str	r3, [r5, #0]
 800e19e:	bd38      	pop	{r3, r4, r5, pc}
 800e1a0:	2000c63c 	.word	0x2000c63c

0800e1a4 <__swhatbuf_r>:
 800e1a4:	b570      	push	{r4, r5, r6, lr}
 800e1a6:	460e      	mov	r6, r1
 800e1a8:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 800e1ac:	2900      	cmp	r1, #0
 800e1ae:	b090      	sub	sp, #64	; 0x40
 800e1b0:	4614      	mov	r4, r2
 800e1b2:	461d      	mov	r5, r3
 800e1b4:	da07      	bge.n	800e1c6 <__swhatbuf_r+0x22>
 800e1b6:	2300      	movs	r3, #0
 800e1b8:	602b      	str	r3, [r5, #0]
 800e1ba:	89b3      	ldrh	r3, [r6, #12]
 800e1bc:	061a      	lsls	r2, r3, #24
 800e1be:	d410      	bmi.n	800e1e2 <__swhatbuf_r+0x3e>
 800e1c0:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800e1c4:	e00e      	b.n	800e1e4 <__swhatbuf_r+0x40>
 800e1c6:	aa01      	add	r2, sp, #4
 800e1c8:	f001 f90a 	bl	800f3e0 <_fstat_r>
 800e1cc:	2800      	cmp	r0, #0
 800e1ce:	dbf2      	blt.n	800e1b6 <__swhatbuf_r+0x12>
 800e1d0:	9a02      	ldr	r2, [sp, #8]
 800e1d2:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 800e1d6:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 800e1da:	425a      	negs	r2, r3
 800e1dc:	415a      	adcs	r2, r3
 800e1de:	602a      	str	r2, [r5, #0]
 800e1e0:	e7ee      	b.n	800e1c0 <__swhatbuf_r+0x1c>
 800e1e2:	2340      	movs	r3, #64	; 0x40
 800e1e4:	2000      	movs	r0, #0
 800e1e6:	6023      	str	r3, [r4, #0]
 800e1e8:	b010      	add	sp, #64	; 0x40
 800e1ea:	bd70      	pop	{r4, r5, r6, pc}

0800e1ec <__smakebuf_r>:
 800e1ec:	898b      	ldrh	r3, [r1, #12]
 800e1ee:	b573      	push	{r0, r1, r4, r5, r6, lr}
 800e1f0:	079d      	lsls	r5, r3, #30
 800e1f2:	4606      	mov	r6, r0
 800e1f4:	460c      	mov	r4, r1
 800e1f6:	d507      	bpl.n	800e208 <__smakebuf_r+0x1c>
 800e1f8:	f104 0347 	add.w	r3, r4, #71	; 0x47
 800e1fc:	6023      	str	r3, [r4, #0]
 800e1fe:	6123      	str	r3, [r4, #16]
 800e200:	2301      	movs	r3, #1
 800e202:	6163      	str	r3, [r4, #20]
 800e204:	b002      	add	sp, #8
 800e206:	bd70      	pop	{r4, r5, r6, pc}
 800e208:	ab01      	add	r3, sp, #4
 800e20a:	466a      	mov	r2, sp
 800e20c:	f7ff ffca 	bl	800e1a4 <__swhatbuf_r>
 800e210:	9900      	ldr	r1, [sp, #0]
 800e212:	4605      	mov	r5, r0
 800e214:	4630      	mov	r0, r6
 800e216:	f7ff f823 	bl	800d260 <_malloc_r>
 800e21a:	b948      	cbnz	r0, 800e230 <__smakebuf_r+0x44>
 800e21c:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 800e220:	059a      	lsls	r2, r3, #22
 800e222:	d4ef      	bmi.n	800e204 <__smakebuf_r+0x18>
 800e224:	f023 0303 	bic.w	r3, r3, #3
 800e228:	f043 0302 	orr.w	r3, r3, #2
 800e22c:	81a3      	strh	r3, [r4, #12]
 800e22e:	e7e3      	b.n	800e1f8 <__smakebuf_r+0xc>
 800e230:	4b0d      	ldr	r3, [pc, #52]	; (800e268 <__smakebuf_r+0x7c>)
 800e232:	62b3      	str	r3, [r6, #40]	; 0x28
 800e234:	89a3      	ldrh	r3, [r4, #12]
 800e236:	6020      	str	r0, [r4, #0]
 800e238:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800e23c:	81a3      	strh	r3, [r4, #12]
 800e23e:	9b00      	ldr	r3, [sp, #0]
 800e240:	6163      	str	r3, [r4, #20]
 800e242:	9b01      	ldr	r3, [sp, #4]
 800e244:	6120      	str	r0, [r4, #16]
 800e246:	b15b      	cbz	r3, 800e260 <__smakebuf_r+0x74>
 800e248:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 800e24c:	4630      	mov	r0, r6
 800e24e:	f001 f8d9 	bl	800f404 <_isatty_r>
 800e252:	b128      	cbz	r0, 800e260 <__smakebuf_r+0x74>
 800e254:	89a3      	ldrh	r3, [r4, #12]
 800e256:	f023 0303 	bic.w	r3, r3, #3
 800e25a:	f043 0301 	orr.w	r3, r3, #1
 800e25e:	81a3      	strh	r3, [r4, #12]
 800e260:	89a3      	ldrh	r3, [r4, #12]
 800e262:	431d      	orrs	r5, r3
 800e264:	81a5      	strh	r5, [r4, #12]
 800e266:	e7cd      	b.n	800e204 <__smakebuf_r+0x18>
 800e268:	0800df31 	.word	0x0800df31

0800e26c <__ascii_mbtowc>:
 800e26c:	b082      	sub	sp, #8
 800e26e:	b901      	cbnz	r1, 800e272 <__ascii_mbtowc+0x6>
 800e270:	a901      	add	r1, sp, #4
 800e272:	b142      	cbz	r2, 800e286 <__ascii_mbtowc+0x1a>
 800e274:	b14b      	cbz	r3, 800e28a <__ascii_mbtowc+0x1e>
 800e276:	7813      	ldrb	r3, [r2, #0]
 800e278:	600b      	str	r3, [r1, #0]
 800e27a:	7812      	ldrb	r2, [r2, #0]
 800e27c:	1c10      	adds	r0, r2, #0
 800e27e:	bf18      	it	ne
 800e280:	2001      	movne	r0, #1
 800e282:	b002      	add	sp, #8
 800e284:	4770      	bx	lr
 800e286:	4610      	mov	r0, r2
 800e288:	e7fb      	b.n	800e282 <__ascii_mbtowc+0x16>
 800e28a:	f06f 0001 	mvn.w	r0, #1
 800e28e:	e7f8      	b.n	800e282 <__ascii_mbtowc+0x16>

0800e290 <__malloc_lock>:
 800e290:	4770      	bx	lr

0800e292 <__malloc_unlock>:
 800e292:	4770      	bx	lr

0800e294 <__ssputs_r>:
 800e294:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800e298:	688e      	ldr	r6, [r1, #8]
 800e29a:	429e      	cmp	r6, r3
 800e29c:	4682      	mov	sl, r0
 800e29e:	460c      	mov	r4, r1
 800e2a0:	4691      	mov	r9, r2
 800e2a2:	4698      	mov	r8, r3
 800e2a4:	d835      	bhi.n	800e312 <__ssputs_r+0x7e>
 800e2a6:	898a      	ldrh	r2, [r1, #12]
 800e2a8:	f412 6f90 	tst.w	r2, #1152	; 0x480
 800e2ac:	d031      	beq.n	800e312 <__ssputs_r+0x7e>
 800e2ae:	6825      	ldr	r5, [r4, #0]
 800e2b0:	6909      	ldr	r1, [r1, #16]
 800e2b2:	1a6f      	subs	r7, r5, r1
 800e2b4:	6965      	ldr	r5, [r4, #20]
 800e2b6:	2302      	movs	r3, #2
 800e2b8:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 800e2bc:	fb95 f5f3 	sdiv	r5, r5, r3
 800e2c0:	f108 0301 	add.w	r3, r8, #1
 800e2c4:	443b      	add	r3, r7
 800e2c6:	429d      	cmp	r5, r3
 800e2c8:	bf38      	it	cc
 800e2ca:	461d      	movcc	r5, r3
 800e2cc:	0553      	lsls	r3, r2, #21
 800e2ce:	d531      	bpl.n	800e334 <__ssputs_r+0xa0>
 800e2d0:	4629      	mov	r1, r5
 800e2d2:	f7fe ffc5 	bl	800d260 <_malloc_r>
 800e2d6:	4606      	mov	r6, r0
 800e2d8:	b950      	cbnz	r0, 800e2f0 <__ssputs_r+0x5c>
 800e2da:	230c      	movs	r3, #12
 800e2dc:	f8ca 3000 	str.w	r3, [sl]
 800e2e0:	89a3      	ldrh	r3, [r4, #12]
 800e2e2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e2e6:	81a3      	strh	r3, [r4, #12]
 800e2e8:	f04f 30ff 	mov.w	r0, #4294967295
 800e2ec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800e2f0:	463a      	mov	r2, r7
 800e2f2:	6921      	ldr	r1, [r4, #16]
 800e2f4:	f7fe fcf7 	bl	800cce6 <memcpy>
 800e2f8:	89a3      	ldrh	r3, [r4, #12]
 800e2fa:	f423 6390 	bic.w	r3, r3, #1152	; 0x480
 800e2fe:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800e302:	81a3      	strh	r3, [r4, #12]
 800e304:	6126      	str	r6, [r4, #16]
 800e306:	6165      	str	r5, [r4, #20]
 800e308:	443e      	add	r6, r7
 800e30a:	1bed      	subs	r5, r5, r7
 800e30c:	6026      	str	r6, [r4, #0]
 800e30e:	60a5      	str	r5, [r4, #8]
 800e310:	4646      	mov	r6, r8
 800e312:	4546      	cmp	r6, r8
 800e314:	bf28      	it	cs
 800e316:	4646      	movcs	r6, r8
 800e318:	4632      	mov	r2, r6
 800e31a:	4649      	mov	r1, r9
 800e31c:	6820      	ldr	r0, [r4, #0]
 800e31e:	f001 f881 	bl	800f424 <memmove>
 800e322:	68a3      	ldr	r3, [r4, #8]
 800e324:	1b9b      	subs	r3, r3, r6
 800e326:	60a3      	str	r3, [r4, #8]
 800e328:	6823      	ldr	r3, [r4, #0]
 800e32a:	441e      	add	r6, r3
 800e32c:	6026      	str	r6, [r4, #0]
 800e32e:	2000      	movs	r0, #0
 800e330:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800e334:	462a      	mov	r2, r5
 800e336:	f001 f88f 	bl	800f458 <_realloc_r>
 800e33a:	4606      	mov	r6, r0
 800e33c:	2800      	cmp	r0, #0
 800e33e:	d1e1      	bne.n	800e304 <__ssputs_r+0x70>
 800e340:	6921      	ldr	r1, [r4, #16]
 800e342:	4650      	mov	r0, sl
 800e344:	f7fe ff3e 	bl	800d1c4 <_free_r>
 800e348:	e7c7      	b.n	800e2da <__ssputs_r+0x46>
	...

0800e34c <_svfiprintf_r>:
 800e34c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e350:	b09d      	sub	sp, #116	; 0x74
 800e352:	4680      	mov	r8, r0
 800e354:	9303      	str	r3, [sp, #12]
 800e356:	898b      	ldrh	r3, [r1, #12]
 800e358:	061c      	lsls	r4, r3, #24
 800e35a:	460d      	mov	r5, r1
 800e35c:	4616      	mov	r6, r2
 800e35e:	d50f      	bpl.n	800e380 <_svfiprintf_r+0x34>
 800e360:	690b      	ldr	r3, [r1, #16]
 800e362:	b96b      	cbnz	r3, 800e380 <_svfiprintf_r+0x34>
 800e364:	2140      	movs	r1, #64	; 0x40
 800e366:	f7fe ff7b 	bl	800d260 <_malloc_r>
 800e36a:	6028      	str	r0, [r5, #0]
 800e36c:	6128      	str	r0, [r5, #16]
 800e36e:	b928      	cbnz	r0, 800e37c <_svfiprintf_r+0x30>
 800e370:	230c      	movs	r3, #12
 800e372:	f8c8 3000 	str.w	r3, [r8]
 800e376:	f04f 30ff 	mov.w	r0, #4294967295
 800e37a:	e0c5      	b.n	800e508 <_svfiprintf_r+0x1bc>
 800e37c:	2340      	movs	r3, #64	; 0x40
 800e37e:	616b      	str	r3, [r5, #20]
 800e380:	2300      	movs	r3, #0
 800e382:	9309      	str	r3, [sp, #36]	; 0x24
 800e384:	2320      	movs	r3, #32
 800e386:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 800e38a:	2330      	movs	r3, #48	; 0x30
 800e38c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800e390:	f04f 0b01 	mov.w	fp, #1
 800e394:	4637      	mov	r7, r6
 800e396:	463c      	mov	r4, r7
 800e398:	f814 3b01 	ldrb.w	r3, [r4], #1
 800e39c:	2b00      	cmp	r3, #0
 800e39e:	d13c      	bne.n	800e41a <_svfiprintf_r+0xce>
 800e3a0:	ebb7 0a06 	subs.w	sl, r7, r6
 800e3a4:	d00b      	beq.n	800e3be <_svfiprintf_r+0x72>
 800e3a6:	4653      	mov	r3, sl
 800e3a8:	4632      	mov	r2, r6
 800e3aa:	4629      	mov	r1, r5
 800e3ac:	4640      	mov	r0, r8
 800e3ae:	f7ff ff71 	bl	800e294 <__ssputs_r>
 800e3b2:	3001      	adds	r0, #1
 800e3b4:	f000 80a3 	beq.w	800e4fe <_svfiprintf_r+0x1b2>
 800e3b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e3ba:	4453      	add	r3, sl
 800e3bc:	9309      	str	r3, [sp, #36]	; 0x24
 800e3be:	783b      	ldrb	r3, [r7, #0]
 800e3c0:	2b00      	cmp	r3, #0
 800e3c2:	f000 809c 	beq.w	800e4fe <_svfiprintf_r+0x1b2>
 800e3c6:	2300      	movs	r3, #0
 800e3c8:	f04f 32ff 	mov.w	r2, #4294967295
 800e3cc:	9304      	str	r3, [sp, #16]
 800e3ce:	9307      	str	r3, [sp, #28]
 800e3d0:	9205      	str	r2, [sp, #20]
 800e3d2:	9306      	str	r3, [sp, #24]
 800e3d4:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800e3d8:	931a      	str	r3, [sp, #104]	; 0x68
 800e3da:	2205      	movs	r2, #5
 800e3dc:	7821      	ldrb	r1, [r4, #0]
 800e3de:	4850      	ldr	r0, [pc, #320]	; (800e520 <_svfiprintf_r+0x1d4>)
 800e3e0:	f7f1 ff16 	bl	8000210 <memchr>
 800e3e4:	1c67      	adds	r7, r4, #1
 800e3e6:	9b04      	ldr	r3, [sp, #16]
 800e3e8:	b9d8      	cbnz	r0, 800e422 <_svfiprintf_r+0xd6>
 800e3ea:	06d9      	lsls	r1, r3, #27
 800e3ec:	bf44      	itt	mi
 800e3ee:	2220      	movmi	r2, #32
 800e3f0:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800e3f4:	071a      	lsls	r2, r3, #28
 800e3f6:	bf44      	itt	mi
 800e3f8:	222b      	movmi	r2, #43	; 0x2b
 800e3fa:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800e3fe:	7822      	ldrb	r2, [r4, #0]
 800e400:	2a2a      	cmp	r2, #42	; 0x2a
 800e402:	d016      	beq.n	800e432 <_svfiprintf_r+0xe6>
 800e404:	9a07      	ldr	r2, [sp, #28]
 800e406:	2100      	movs	r1, #0
 800e408:	200a      	movs	r0, #10
 800e40a:	4627      	mov	r7, r4
 800e40c:	3401      	adds	r4, #1
 800e40e:	783b      	ldrb	r3, [r7, #0]
 800e410:	3b30      	subs	r3, #48	; 0x30
 800e412:	2b09      	cmp	r3, #9
 800e414:	d951      	bls.n	800e4ba <_svfiprintf_r+0x16e>
 800e416:	b1c9      	cbz	r1, 800e44c <_svfiprintf_r+0x100>
 800e418:	e011      	b.n	800e43e <_svfiprintf_r+0xf2>
 800e41a:	2b25      	cmp	r3, #37	; 0x25
 800e41c:	d0c0      	beq.n	800e3a0 <_svfiprintf_r+0x54>
 800e41e:	4627      	mov	r7, r4
 800e420:	e7b9      	b.n	800e396 <_svfiprintf_r+0x4a>
 800e422:	4a3f      	ldr	r2, [pc, #252]	; (800e520 <_svfiprintf_r+0x1d4>)
 800e424:	1a80      	subs	r0, r0, r2
 800e426:	fa0b f000 	lsl.w	r0, fp, r0
 800e42a:	4318      	orrs	r0, r3
 800e42c:	9004      	str	r0, [sp, #16]
 800e42e:	463c      	mov	r4, r7
 800e430:	e7d3      	b.n	800e3da <_svfiprintf_r+0x8e>
 800e432:	9a03      	ldr	r2, [sp, #12]
 800e434:	1d11      	adds	r1, r2, #4
 800e436:	6812      	ldr	r2, [r2, #0]
 800e438:	9103      	str	r1, [sp, #12]
 800e43a:	2a00      	cmp	r2, #0
 800e43c:	db01      	blt.n	800e442 <_svfiprintf_r+0xf6>
 800e43e:	9207      	str	r2, [sp, #28]
 800e440:	e004      	b.n	800e44c <_svfiprintf_r+0x100>
 800e442:	4252      	negs	r2, r2
 800e444:	f043 0302 	orr.w	r3, r3, #2
 800e448:	9207      	str	r2, [sp, #28]
 800e44a:	9304      	str	r3, [sp, #16]
 800e44c:	783b      	ldrb	r3, [r7, #0]
 800e44e:	2b2e      	cmp	r3, #46	; 0x2e
 800e450:	d10e      	bne.n	800e470 <_svfiprintf_r+0x124>
 800e452:	787b      	ldrb	r3, [r7, #1]
 800e454:	2b2a      	cmp	r3, #42	; 0x2a
 800e456:	f107 0101 	add.w	r1, r7, #1
 800e45a:	d132      	bne.n	800e4c2 <_svfiprintf_r+0x176>
 800e45c:	9b03      	ldr	r3, [sp, #12]
 800e45e:	1d1a      	adds	r2, r3, #4
 800e460:	681b      	ldr	r3, [r3, #0]
 800e462:	9203      	str	r2, [sp, #12]
 800e464:	2b00      	cmp	r3, #0
 800e466:	bfb8      	it	lt
 800e468:	f04f 33ff 	movlt.w	r3, #4294967295
 800e46c:	3702      	adds	r7, #2
 800e46e:	9305      	str	r3, [sp, #20]
 800e470:	4c2c      	ldr	r4, [pc, #176]	; (800e524 <_svfiprintf_r+0x1d8>)
 800e472:	7839      	ldrb	r1, [r7, #0]
 800e474:	2203      	movs	r2, #3
 800e476:	4620      	mov	r0, r4
 800e478:	f7f1 feca 	bl	8000210 <memchr>
 800e47c:	b138      	cbz	r0, 800e48e <_svfiprintf_r+0x142>
 800e47e:	2340      	movs	r3, #64	; 0x40
 800e480:	1b00      	subs	r0, r0, r4
 800e482:	fa03 f000 	lsl.w	r0, r3, r0
 800e486:	9b04      	ldr	r3, [sp, #16]
 800e488:	4303      	orrs	r3, r0
 800e48a:	9304      	str	r3, [sp, #16]
 800e48c:	3701      	adds	r7, #1
 800e48e:	7839      	ldrb	r1, [r7, #0]
 800e490:	4825      	ldr	r0, [pc, #148]	; (800e528 <_svfiprintf_r+0x1dc>)
 800e492:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800e496:	2206      	movs	r2, #6
 800e498:	1c7e      	adds	r6, r7, #1
 800e49a:	f7f1 feb9 	bl	8000210 <memchr>
 800e49e:	2800      	cmp	r0, #0
 800e4a0:	d035      	beq.n	800e50e <_svfiprintf_r+0x1c2>
 800e4a2:	4b22      	ldr	r3, [pc, #136]	; (800e52c <_svfiprintf_r+0x1e0>)
 800e4a4:	b9fb      	cbnz	r3, 800e4e6 <_svfiprintf_r+0x19a>
 800e4a6:	9b03      	ldr	r3, [sp, #12]
 800e4a8:	3307      	adds	r3, #7
 800e4aa:	f023 0307 	bic.w	r3, r3, #7
 800e4ae:	3308      	adds	r3, #8
 800e4b0:	9303      	str	r3, [sp, #12]
 800e4b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e4b4:	444b      	add	r3, r9
 800e4b6:	9309      	str	r3, [sp, #36]	; 0x24
 800e4b8:	e76c      	b.n	800e394 <_svfiprintf_r+0x48>
 800e4ba:	fb00 3202 	mla	r2, r0, r2, r3
 800e4be:	2101      	movs	r1, #1
 800e4c0:	e7a3      	b.n	800e40a <_svfiprintf_r+0xbe>
 800e4c2:	2300      	movs	r3, #0
 800e4c4:	9305      	str	r3, [sp, #20]
 800e4c6:	4618      	mov	r0, r3
 800e4c8:	240a      	movs	r4, #10
 800e4ca:	460f      	mov	r7, r1
 800e4cc:	3101      	adds	r1, #1
 800e4ce:	783a      	ldrb	r2, [r7, #0]
 800e4d0:	3a30      	subs	r2, #48	; 0x30
 800e4d2:	2a09      	cmp	r2, #9
 800e4d4:	d903      	bls.n	800e4de <_svfiprintf_r+0x192>
 800e4d6:	2b00      	cmp	r3, #0
 800e4d8:	d0ca      	beq.n	800e470 <_svfiprintf_r+0x124>
 800e4da:	9005      	str	r0, [sp, #20]
 800e4dc:	e7c8      	b.n	800e470 <_svfiprintf_r+0x124>
 800e4de:	fb04 2000 	mla	r0, r4, r0, r2
 800e4e2:	2301      	movs	r3, #1
 800e4e4:	e7f1      	b.n	800e4ca <_svfiprintf_r+0x17e>
 800e4e6:	ab03      	add	r3, sp, #12
 800e4e8:	9300      	str	r3, [sp, #0]
 800e4ea:	462a      	mov	r2, r5
 800e4ec:	4b10      	ldr	r3, [pc, #64]	; (800e530 <_svfiprintf_r+0x1e4>)
 800e4ee:	a904      	add	r1, sp, #16
 800e4f0:	4640      	mov	r0, r8
 800e4f2:	f3af 8000 	nop.w
 800e4f6:	f1b0 3fff 	cmp.w	r0, #4294967295
 800e4fa:	4681      	mov	r9, r0
 800e4fc:	d1d9      	bne.n	800e4b2 <_svfiprintf_r+0x166>
 800e4fe:	89ab      	ldrh	r3, [r5, #12]
 800e500:	065b      	lsls	r3, r3, #25
 800e502:	f53f af38 	bmi.w	800e376 <_svfiprintf_r+0x2a>
 800e506:	9809      	ldr	r0, [sp, #36]	; 0x24
 800e508:	b01d      	add	sp, #116	; 0x74
 800e50a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e50e:	ab03      	add	r3, sp, #12
 800e510:	9300      	str	r3, [sp, #0]
 800e512:	462a      	mov	r2, r5
 800e514:	4b06      	ldr	r3, [pc, #24]	; (800e530 <_svfiprintf_r+0x1e4>)
 800e516:	a904      	add	r1, sp, #16
 800e518:	4640      	mov	r0, r8
 800e51a:	f000 fb6f 	bl	800ebfc <_printf_i>
 800e51e:	e7ea      	b.n	800e4f6 <_svfiprintf_r+0x1aa>
 800e520:	0801005c 	.word	0x0801005c
 800e524:	08010062 	.word	0x08010062
 800e528:	08010066 	.word	0x08010066
 800e52c:	00000000 	.word	0x00000000
 800e530:	0800e295 	.word	0x0800e295

0800e534 <_sungetc_r>:
 800e534:	b538      	push	{r3, r4, r5, lr}
 800e536:	1c4b      	adds	r3, r1, #1
 800e538:	4614      	mov	r4, r2
 800e53a:	d103      	bne.n	800e544 <_sungetc_r+0x10>
 800e53c:	f04f 35ff 	mov.w	r5, #4294967295
 800e540:	4628      	mov	r0, r5
 800e542:	bd38      	pop	{r3, r4, r5, pc}
 800e544:	8993      	ldrh	r3, [r2, #12]
 800e546:	f023 0320 	bic.w	r3, r3, #32
 800e54a:	8193      	strh	r3, [r2, #12]
 800e54c:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800e54e:	6852      	ldr	r2, [r2, #4]
 800e550:	b2cd      	uxtb	r5, r1
 800e552:	b18b      	cbz	r3, 800e578 <_sungetc_r+0x44>
 800e554:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800e556:	429a      	cmp	r2, r3
 800e558:	da08      	bge.n	800e56c <_sungetc_r+0x38>
 800e55a:	6823      	ldr	r3, [r4, #0]
 800e55c:	1e5a      	subs	r2, r3, #1
 800e55e:	6022      	str	r2, [r4, #0]
 800e560:	f803 5c01 	strb.w	r5, [r3, #-1]
 800e564:	6863      	ldr	r3, [r4, #4]
 800e566:	3301      	adds	r3, #1
 800e568:	6063      	str	r3, [r4, #4]
 800e56a:	e7e9      	b.n	800e540 <_sungetc_r+0xc>
 800e56c:	4621      	mov	r1, r4
 800e56e:	f000 feed 	bl	800f34c <__submore>
 800e572:	2800      	cmp	r0, #0
 800e574:	d0f1      	beq.n	800e55a <_sungetc_r+0x26>
 800e576:	e7e1      	b.n	800e53c <_sungetc_r+0x8>
 800e578:	6921      	ldr	r1, [r4, #16]
 800e57a:	6823      	ldr	r3, [r4, #0]
 800e57c:	b151      	cbz	r1, 800e594 <_sungetc_r+0x60>
 800e57e:	4299      	cmp	r1, r3
 800e580:	d208      	bcs.n	800e594 <_sungetc_r+0x60>
 800e582:	f813 1c01 	ldrb.w	r1, [r3, #-1]
 800e586:	428d      	cmp	r5, r1
 800e588:	d104      	bne.n	800e594 <_sungetc_r+0x60>
 800e58a:	3b01      	subs	r3, #1
 800e58c:	3201      	adds	r2, #1
 800e58e:	6023      	str	r3, [r4, #0]
 800e590:	6062      	str	r2, [r4, #4]
 800e592:	e7d5      	b.n	800e540 <_sungetc_r+0xc>
 800e594:	63e3      	str	r3, [r4, #60]	; 0x3c
 800e596:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800e59a:	6363      	str	r3, [r4, #52]	; 0x34
 800e59c:	2303      	movs	r3, #3
 800e59e:	63a3      	str	r3, [r4, #56]	; 0x38
 800e5a0:	4623      	mov	r3, r4
 800e5a2:	6422      	str	r2, [r4, #64]	; 0x40
 800e5a4:	f803 5f46 	strb.w	r5, [r3, #70]!
 800e5a8:	6023      	str	r3, [r4, #0]
 800e5aa:	2301      	movs	r3, #1
 800e5ac:	e7dc      	b.n	800e568 <_sungetc_r+0x34>

0800e5ae <__ssrefill_r>:
 800e5ae:	b510      	push	{r4, lr}
 800e5b0:	460c      	mov	r4, r1
 800e5b2:	6b49      	ldr	r1, [r1, #52]	; 0x34
 800e5b4:	b169      	cbz	r1, 800e5d2 <__ssrefill_r+0x24>
 800e5b6:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800e5ba:	4299      	cmp	r1, r3
 800e5bc:	d001      	beq.n	800e5c2 <__ssrefill_r+0x14>
 800e5be:	f7fe fe01 	bl	800d1c4 <_free_r>
 800e5c2:	6c23      	ldr	r3, [r4, #64]	; 0x40
 800e5c4:	6063      	str	r3, [r4, #4]
 800e5c6:	2000      	movs	r0, #0
 800e5c8:	6360      	str	r0, [r4, #52]	; 0x34
 800e5ca:	b113      	cbz	r3, 800e5d2 <__ssrefill_r+0x24>
 800e5cc:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 800e5ce:	6023      	str	r3, [r4, #0]
 800e5d0:	bd10      	pop	{r4, pc}
 800e5d2:	6923      	ldr	r3, [r4, #16]
 800e5d4:	6023      	str	r3, [r4, #0]
 800e5d6:	2300      	movs	r3, #0
 800e5d8:	6063      	str	r3, [r4, #4]
 800e5da:	89a3      	ldrh	r3, [r4, #12]
 800e5dc:	f043 0320 	orr.w	r3, r3, #32
 800e5e0:	81a3      	strh	r3, [r4, #12]
 800e5e2:	f04f 30ff 	mov.w	r0, #4294967295
 800e5e6:	bd10      	pop	{r4, pc}

0800e5e8 <__ssvfiscanf_r>:
 800e5e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e5ec:	f5ad 7d25 	sub.w	sp, sp, #660	; 0x294
 800e5f0:	f10d 080c 	add.w	r8, sp, #12
 800e5f4:	9301      	str	r3, [sp, #4]
 800e5f6:	2300      	movs	r3, #0
 800e5f8:	9346      	str	r3, [sp, #280]	; 0x118
 800e5fa:	9347      	str	r3, [sp, #284]	; 0x11c
 800e5fc:	4ba0      	ldr	r3, [pc, #640]	; (800e880 <__ssvfiscanf_r+0x298>)
 800e5fe:	93a2      	str	r3, [sp, #648]	; 0x288
 800e600:	f8df 9284 	ldr.w	r9, [pc, #644]	; 800e888 <__ssvfiscanf_r+0x2a0>
 800e604:	4b9f      	ldr	r3, [pc, #636]	; (800e884 <__ssvfiscanf_r+0x29c>)
 800e606:	f8cd 8120 	str.w	r8, [sp, #288]	; 0x120
 800e60a:	4606      	mov	r6, r0
 800e60c:	460c      	mov	r4, r1
 800e60e:	93a3      	str	r3, [sp, #652]	; 0x28c
 800e610:	4692      	mov	sl, r2
 800e612:	270a      	movs	r7, #10
 800e614:	f89a 3000 	ldrb.w	r3, [sl]
 800e618:	2b00      	cmp	r3, #0
 800e61a:	f000 812f 	beq.w	800e87c <__ssvfiscanf_r+0x294>
 800e61e:	f7ff fda1 	bl	800e164 <__locale_ctype_ptr>
 800e622:	f89a b000 	ldrb.w	fp, [sl]
 800e626:	4458      	add	r0, fp
 800e628:	7843      	ldrb	r3, [r0, #1]
 800e62a:	f013 0308 	ands.w	r3, r3, #8
 800e62e:	d143      	bne.n	800e6b8 <__ssvfiscanf_r+0xd0>
 800e630:	f1bb 0f25 	cmp.w	fp, #37	; 0x25
 800e634:	f10a 0501 	add.w	r5, sl, #1
 800e638:	f040 8099 	bne.w	800e76e <__ssvfiscanf_r+0x186>
 800e63c:	9345      	str	r3, [sp, #276]	; 0x114
 800e63e:	9343      	str	r3, [sp, #268]	; 0x10c
 800e640:	f89a 3001 	ldrb.w	r3, [sl, #1]
 800e644:	2b2a      	cmp	r3, #42	; 0x2a
 800e646:	d103      	bne.n	800e650 <__ssvfiscanf_r+0x68>
 800e648:	2310      	movs	r3, #16
 800e64a:	9343      	str	r3, [sp, #268]	; 0x10c
 800e64c:	f10a 0502 	add.w	r5, sl, #2
 800e650:	7829      	ldrb	r1, [r5, #0]
 800e652:	f1a1 0230 	sub.w	r2, r1, #48	; 0x30
 800e656:	2a09      	cmp	r2, #9
 800e658:	46aa      	mov	sl, r5
 800e65a:	f105 0501 	add.w	r5, r5, #1
 800e65e:	d941      	bls.n	800e6e4 <__ssvfiscanf_r+0xfc>
 800e660:	2203      	movs	r2, #3
 800e662:	4889      	ldr	r0, [pc, #548]	; (800e888 <__ssvfiscanf_r+0x2a0>)
 800e664:	f7f1 fdd4 	bl	8000210 <memchr>
 800e668:	b138      	cbz	r0, 800e67a <__ssvfiscanf_r+0x92>
 800e66a:	eba0 0309 	sub.w	r3, r0, r9
 800e66e:	2001      	movs	r0, #1
 800e670:	4098      	lsls	r0, r3
 800e672:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 800e674:	4318      	orrs	r0, r3
 800e676:	9043      	str	r0, [sp, #268]	; 0x10c
 800e678:	46aa      	mov	sl, r5
 800e67a:	f89a 3000 	ldrb.w	r3, [sl]
 800e67e:	2b67      	cmp	r3, #103	; 0x67
 800e680:	f10a 0501 	add.w	r5, sl, #1
 800e684:	d84a      	bhi.n	800e71c <__ssvfiscanf_r+0x134>
 800e686:	2b65      	cmp	r3, #101	; 0x65
 800e688:	f080 80b7 	bcs.w	800e7fa <__ssvfiscanf_r+0x212>
 800e68c:	2b47      	cmp	r3, #71	; 0x47
 800e68e:	d82f      	bhi.n	800e6f0 <__ssvfiscanf_r+0x108>
 800e690:	2b45      	cmp	r3, #69	; 0x45
 800e692:	f080 80b2 	bcs.w	800e7fa <__ssvfiscanf_r+0x212>
 800e696:	2b00      	cmp	r3, #0
 800e698:	f000 8082 	beq.w	800e7a0 <__ssvfiscanf_r+0x1b8>
 800e69c:	2b25      	cmp	r3, #37	; 0x25
 800e69e:	d066      	beq.n	800e76e <__ssvfiscanf_r+0x186>
 800e6a0:	2303      	movs	r3, #3
 800e6a2:	9349      	str	r3, [sp, #292]	; 0x124
 800e6a4:	9744      	str	r7, [sp, #272]	; 0x110
 800e6a6:	e045      	b.n	800e734 <__ssvfiscanf_r+0x14c>
 800e6a8:	9947      	ldr	r1, [sp, #284]	; 0x11c
 800e6aa:	3101      	adds	r1, #1
 800e6ac:	9147      	str	r1, [sp, #284]	; 0x11c
 800e6ae:	6861      	ldr	r1, [r4, #4]
 800e6b0:	3301      	adds	r3, #1
 800e6b2:	3901      	subs	r1, #1
 800e6b4:	6061      	str	r1, [r4, #4]
 800e6b6:	6023      	str	r3, [r4, #0]
 800e6b8:	6863      	ldr	r3, [r4, #4]
 800e6ba:	2b00      	cmp	r3, #0
 800e6bc:	dd0b      	ble.n	800e6d6 <__ssvfiscanf_r+0xee>
 800e6be:	f7ff fd51 	bl	800e164 <__locale_ctype_ptr>
 800e6c2:	6823      	ldr	r3, [r4, #0]
 800e6c4:	7819      	ldrb	r1, [r3, #0]
 800e6c6:	4408      	add	r0, r1
 800e6c8:	7841      	ldrb	r1, [r0, #1]
 800e6ca:	070d      	lsls	r5, r1, #28
 800e6cc:	d4ec      	bmi.n	800e6a8 <__ssvfiscanf_r+0xc0>
 800e6ce:	f10a 0501 	add.w	r5, sl, #1
 800e6d2:	46aa      	mov	sl, r5
 800e6d4:	e79e      	b.n	800e614 <__ssvfiscanf_r+0x2c>
 800e6d6:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 800e6d8:	4621      	mov	r1, r4
 800e6da:	4630      	mov	r0, r6
 800e6dc:	4798      	blx	r3
 800e6de:	2800      	cmp	r0, #0
 800e6e0:	d0ed      	beq.n	800e6be <__ssvfiscanf_r+0xd6>
 800e6e2:	e7f4      	b.n	800e6ce <__ssvfiscanf_r+0xe6>
 800e6e4:	9b45      	ldr	r3, [sp, #276]	; 0x114
 800e6e6:	fb07 1303 	mla	r3, r7, r3, r1
 800e6ea:	3b30      	subs	r3, #48	; 0x30
 800e6ec:	9345      	str	r3, [sp, #276]	; 0x114
 800e6ee:	e7af      	b.n	800e650 <__ssvfiscanf_r+0x68>
 800e6f0:	2b5b      	cmp	r3, #91	; 0x5b
 800e6f2:	d061      	beq.n	800e7b8 <__ssvfiscanf_r+0x1d0>
 800e6f4:	d80c      	bhi.n	800e710 <__ssvfiscanf_r+0x128>
 800e6f6:	2b58      	cmp	r3, #88	; 0x58
 800e6f8:	d1d2      	bne.n	800e6a0 <__ssvfiscanf_r+0xb8>
 800e6fa:	9a43      	ldr	r2, [sp, #268]	; 0x10c
 800e6fc:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800e700:	9243      	str	r2, [sp, #268]	; 0x10c
 800e702:	2210      	movs	r2, #16
 800e704:	9244      	str	r2, [sp, #272]	; 0x110
 800e706:	2b6f      	cmp	r3, #111	; 0x6f
 800e708:	bfb4      	ite	lt
 800e70a:	2303      	movlt	r3, #3
 800e70c:	2304      	movge	r3, #4
 800e70e:	e010      	b.n	800e732 <__ssvfiscanf_r+0x14a>
 800e710:	2b63      	cmp	r3, #99	; 0x63
 800e712:	d05c      	beq.n	800e7ce <__ssvfiscanf_r+0x1e6>
 800e714:	2b64      	cmp	r3, #100	; 0x64
 800e716:	d1c3      	bne.n	800e6a0 <__ssvfiscanf_r+0xb8>
 800e718:	9744      	str	r7, [sp, #272]	; 0x110
 800e71a:	e7f4      	b.n	800e706 <__ssvfiscanf_r+0x11e>
 800e71c:	2b70      	cmp	r3, #112	; 0x70
 800e71e:	d042      	beq.n	800e7a6 <__ssvfiscanf_r+0x1be>
 800e720:	d81d      	bhi.n	800e75e <__ssvfiscanf_r+0x176>
 800e722:	2b6e      	cmp	r3, #110	; 0x6e
 800e724:	d059      	beq.n	800e7da <__ssvfiscanf_r+0x1f2>
 800e726:	d843      	bhi.n	800e7b0 <__ssvfiscanf_r+0x1c8>
 800e728:	2b69      	cmp	r3, #105	; 0x69
 800e72a:	d1b9      	bne.n	800e6a0 <__ssvfiscanf_r+0xb8>
 800e72c:	2300      	movs	r3, #0
 800e72e:	9344      	str	r3, [sp, #272]	; 0x110
 800e730:	2303      	movs	r3, #3
 800e732:	9349      	str	r3, [sp, #292]	; 0x124
 800e734:	6863      	ldr	r3, [r4, #4]
 800e736:	2b00      	cmp	r3, #0
 800e738:	dd61      	ble.n	800e7fe <__ssvfiscanf_r+0x216>
 800e73a:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 800e73c:	0659      	lsls	r1, r3, #25
 800e73e:	d56f      	bpl.n	800e820 <__ssvfiscanf_r+0x238>
 800e740:	9b49      	ldr	r3, [sp, #292]	; 0x124
 800e742:	2b02      	cmp	r3, #2
 800e744:	dc7c      	bgt.n	800e840 <__ssvfiscanf_r+0x258>
 800e746:	ab01      	add	r3, sp, #4
 800e748:	4622      	mov	r2, r4
 800e74a:	a943      	add	r1, sp, #268	; 0x10c
 800e74c:	4630      	mov	r0, r6
 800e74e:	f000 fb75 	bl	800ee3c <_scanf_chars>
 800e752:	2801      	cmp	r0, #1
 800e754:	f000 8092 	beq.w	800e87c <__ssvfiscanf_r+0x294>
 800e758:	2802      	cmp	r0, #2
 800e75a:	d1ba      	bne.n	800e6d2 <__ssvfiscanf_r+0xea>
 800e75c:	e01d      	b.n	800e79a <__ssvfiscanf_r+0x1b2>
 800e75e:	2b75      	cmp	r3, #117	; 0x75
 800e760:	d0da      	beq.n	800e718 <__ssvfiscanf_r+0x130>
 800e762:	2b78      	cmp	r3, #120	; 0x78
 800e764:	d0c9      	beq.n	800e6fa <__ssvfiscanf_r+0x112>
 800e766:	2b73      	cmp	r3, #115	; 0x73
 800e768:	d19a      	bne.n	800e6a0 <__ssvfiscanf_r+0xb8>
 800e76a:	2302      	movs	r3, #2
 800e76c:	e7e1      	b.n	800e732 <__ssvfiscanf_r+0x14a>
 800e76e:	6863      	ldr	r3, [r4, #4]
 800e770:	2b00      	cmp	r3, #0
 800e772:	dd0c      	ble.n	800e78e <__ssvfiscanf_r+0x1a6>
 800e774:	6823      	ldr	r3, [r4, #0]
 800e776:	781a      	ldrb	r2, [r3, #0]
 800e778:	4593      	cmp	fp, r2
 800e77a:	d17f      	bne.n	800e87c <__ssvfiscanf_r+0x294>
 800e77c:	3301      	adds	r3, #1
 800e77e:	6862      	ldr	r2, [r4, #4]
 800e780:	6023      	str	r3, [r4, #0]
 800e782:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 800e784:	3a01      	subs	r2, #1
 800e786:	3301      	adds	r3, #1
 800e788:	6062      	str	r2, [r4, #4]
 800e78a:	9347      	str	r3, [sp, #284]	; 0x11c
 800e78c:	e7a1      	b.n	800e6d2 <__ssvfiscanf_r+0xea>
 800e78e:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 800e790:	4621      	mov	r1, r4
 800e792:	4630      	mov	r0, r6
 800e794:	4798      	blx	r3
 800e796:	2800      	cmp	r0, #0
 800e798:	d0ec      	beq.n	800e774 <__ssvfiscanf_r+0x18c>
 800e79a:	9846      	ldr	r0, [sp, #280]	; 0x118
 800e79c:	2800      	cmp	r0, #0
 800e79e:	d163      	bne.n	800e868 <__ssvfiscanf_r+0x280>
 800e7a0:	f04f 30ff 	mov.w	r0, #4294967295
 800e7a4:	e066      	b.n	800e874 <__ssvfiscanf_r+0x28c>
 800e7a6:	9a43      	ldr	r2, [sp, #268]	; 0x10c
 800e7a8:	f042 0220 	orr.w	r2, r2, #32
 800e7ac:	9243      	str	r2, [sp, #268]	; 0x10c
 800e7ae:	e7a4      	b.n	800e6fa <__ssvfiscanf_r+0x112>
 800e7b0:	2308      	movs	r3, #8
 800e7b2:	9344      	str	r3, [sp, #272]	; 0x110
 800e7b4:	2304      	movs	r3, #4
 800e7b6:	e7bc      	b.n	800e732 <__ssvfiscanf_r+0x14a>
 800e7b8:	4629      	mov	r1, r5
 800e7ba:	4640      	mov	r0, r8
 800e7bc:	f000 fcde 	bl	800f17c <__sccl>
 800e7c0:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 800e7c2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e7c6:	9343      	str	r3, [sp, #268]	; 0x10c
 800e7c8:	4605      	mov	r5, r0
 800e7ca:	2301      	movs	r3, #1
 800e7cc:	e7b1      	b.n	800e732 <__ssvfiscanf_r+0x14a>
 800e7ce:	9b43      	ldr	r3, [sp, #268]	; 0x10c
 800e7d0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800e7d4:	9343      	str	r3, [sp, #268]	; 0x10c
 800e7d6:	2300      	movs	r3, #0
 800e7d8:	e7ab      	b.n	800e732 <__ssvfiscanf_r+0x14a>
 800e7da:	9a43      	ldr	r2, [sp, #268]	; 0x10c
 800e7dc:	06d0      	lsls	r0, r2, #27
 800e7de:	f53f af78 	bmi.w	800e6d2 <__ssvfiscanf_r+0xea>
 800e7e2:	f012 0f01 	tst.w	r2, #1
 800e7e6:	9a01      	ldr	r2, [sp, #4]
 800e7e8:	9b47      	ldr	r3, [sp, #284]	; 0x11c
 800e7ea:	f102 0104 	add.w	r1, r2, #4
 800e7ee:	9101      	str	r1, [sp, #4]
 800e7f0:	6812      	ldr	r2, [r2, #0]
 800e7f2:	bf14      	ite	ne
 800e7f4:	8013      	strhne	r3, [r2, #0]
 800e7f6:	6013      	streq	r3, [r2, #0]
 800e7f8:	e76b      	b.n	800e6d2 <__ssvfiscanf_r+0xea>
 800e7fa:	2305      	movs	r3, #5
 800e7fc:	e799      	b.n	800e732 <__ssvfiscanf_r+0x14a>
 800e7fe:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 800e800:	4621      	mov	r1, r4
 800e802:	4630      	mov	r0, r6
 800e804:	4798      	blx	r3
 800e806:	2800      	cmp	r0, #0
 800e808:	d097      	beq.n	800e73a <__ssvfiscanf_r+0x152>
 800e80a:	e7c6      	b.n	800e79a <__ssvfiscanf_r+0x1b2>
 800e80c:	9a47      	ldr	r2, [sp, #284]	; 0x11c
 800e80e:	3201      	adds	r2, #1
 800e810:	9247      	str	r2, [sp, #284]	; 0x11c
 800e812:	6862      	ldr	r2, [r4, #4]
 800e814:	3a01      	subs	r2, #1
 800e816:	2a00      	cmp	r2, #0
 800e818:	6062      	str	r2, [r4, #4]
 800e81a:	dd0a      	ble.n	800e832 <__ssvfiscanf_r+0x24a>
 800e81c:	3301      	adds	r3, #1
 800e81e:	6023      	str	r3, [r4, #0]
 800e820:	f7ff fca0 	bl	800e164 <__locale_ctype_ptr>
 800e824:	6823      	ldr	r3, [r4, #0]
 800e826:	781a      	ldrb	r2, [r3, #0]
 800e828:	4410      	add	r0, r2
 800e82a:	7842      	ldrb	r2, [r0, #1]
 800e82c:	0712      	lsls	r2, r2, #28
 800e82e:	d4ed      	bmi.n	800e80c <__ssvfiscanf_r+0x224>
 800e830:	e786      	b.n	800e740 <__ssvfiscanf_r+0x158>
 800e832:	9ba3      	ldr	r3, [sp, #652]	; 0x28c
 800e834:	4621      	mov	r1, r4
 800e836:	4630      	mov	r0, r6
 800e838:	4798      	blx	r3
 800e83a:	2800      	cmp	r0, #0
 800e83c:	d0f0      	beq.n	800e820 <__ssvfiscanf_r+0x238>
 800e83e:	e7ac      	b.n	800e79a <__ssvfiscanf_r+0x1b2>
 800e840:	2b04      	cmp	r3, #4
 800e842:	dc06      	bgt.n	800e852 <__ssvfiscanf_r+0x26a>
 800e844:	ab01      	add	r3, sp, #4
 800e846:	4622      	mov	r2, r4
 800e848:	a943      	add	r1, sp, #268	; 0x10c
 800e84a:	4630      	mov	r0, r6
 800e84c:	f000 fb5a 	bl	800ef04 <_scanf_i>
 800e850:	e77f      	b.n	800e752 <__ssvfiscanf_r+0x16a>
 800e852:	4b0e      	ldr	r3, [pc, #56]	; (800e88c <__ssvfiscanf_r+0x2a4>)
 800e854:	2b00      	cmp	r3, #0
 800e856:	f43f af3c 	beq.w	800e6d2 <__ssvfiscanf_r+0xea>
 800e85a:	ab01      	add	r3, sp, #4
 800e85c:	4622      	mov	r2, r4
 800e85e:	a943      	add	r1, sp, #268	; 0x10c
 800e860:	4630      	mov	r0, r6
 800e862:	f3af 8000 	nop.w
 800e866:	e774      	b.n	800e752 <__ssvfiscanf_r+0x16a>
 800e868:	89a3      	ldrh	r3, [r4, #12]
 800e86a:	f013 0f40 	tst.w	r3, #64	; 0x40
 800e86e:	bf18      	it	ne
 800e870:	f04f 30ff 	movne.w	r0, #4294967295
 800e874:	f50d 7d25 	add.w	sp, sp, #660	; 0x294
 800e878:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e87c:	9846      	ldr	r0, [sp, #280]	; 0x118
 800e87e:	e7f9      	b.n	800e874 <__ssvfiscanf_r+0x28c>
 800e880:	0800e535 	.word	0x0800e535
 800e884:	0800e5af 	.word	0x0800e5af
 800e888:	08010062 	.word	0x08010062
 800e88c:	00000000 	.word	0x00000000

0800e890 <__sfputc_r>:
 800e890:	6893      	ldr	r3, [r2, #8]
 800e892:	3b01      	subs	r3, #1
 800e894:	2b00      	cmp	r3, #0
 800e896:	b410      	push	{r4}
 800e898:	6093      	str	r3, [r2, #8]
 800e89a:	da09      	bge.n	800e8b0 <__sfputc_r+0x20>
 800e89c:	6994      	ldr	r4, [r2, #24]
 800e89e:	42a3      	cmp	r3, r4
 800e8a0:	db02      	blt.n	800e8a8 <__sfputc_r+0x18>
 800e8a2:	b2cb      	uxtb	r3, r1
 800e8a4:	2b0a      	cmp	r3, #10
 800e8a6:	d103      	bne.n	800e8b0 <__sfputc_r+0x20>
 800e8a8:	f85d 4b04 	ldr.w	r4, [sp], #4
 800e8ac:	f7ff b998 	b.w	800dbe0 <__swbuf_r>
 800e8b0:	6813      	ldr	r3, [r2, #0]
 800e8b2:	1c58      	adds	r0, r3, #1
 800e8b4:	6010      	str	r0, [r2, #0]
 800e8b6:	7019      	strb	r1, [r3, #0]
 800e8b8:	b2c8      	uxtb	r0, r1
 800e8ba:	f85d 4b04 	ldr.w	r4, [sp], #4
 800e8be:	4770      	bx	lr

0800e8c0 <__sfputs_r>:
 800e8c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800e8c2:	4606      	mov	r6, r0
 800e8c4:	460f      	mov	r7, r1
 800e8c6:	4614      	mov	r4, r2
 800e8c8:	18d5      	adds	r5, r2, r3
 800e8ca:	42ac      	cmp	r4, r5
 800e8cc:	d101      	bne.n	800e8d2 <__sfputs_r+0x12>
 800e8ce:	2000      	movs	r0, #0
 800e8d0:	e007      	b.n	800e8e2 <__sfputs_r+0x22>
 800e8d2:	463a      	mov	r2, r7
 800e8d4:	f814 1b01 	ldrb.w	r1, [r4], #1
 800e8d8:	4630      	mov	r0, r6
 800e8da:	f7ff ffd9 	bl	800e890 <__sfputc_r>
 800e8de:	1c43      	adds	r3, r0, #1
 800e8e0:	d1f3      	bne.n	800e8ca <__sfputs_r+0xa>
 800e8e2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0800e8e4 <_vfiprintf_r>:
 800e8e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800e8e8:	b09d      	sub	sp, #116	; 0x74
 800e8ea:	460c      	mov	r4, r1
 800e8ec:	4617      	mov	r7, r2
 800e8ee:	9303      	str	r3, [sp, #12]
 800e8f0:	4606      	mov	r6, r0
 800e8f2:	b118      	cbz	r0, 800e8fc <_vfiprintf_r+0x18>
 800e8f4:	6983      	ldr	r3, [r0, #24]
 800e8f6:	b90b      	cbnz	r3, 800e8fc <_vfiprintf_r+0x18>
 800e8f8:	f7ff fb5a 	bl	800dfb0 <__sinit>
 800e8fc:	4b7c      	ldr	r3, [pc, #496]	; (800eaf0 <_vfiprintf_r+0x20c>)
 800e8fe:	429c      	cmp	r4, r3
 800e900:	d157      	bne.n	800e9b2 <_vfiprintf_r+0xce>
 800e902:	6874      	ldr	r4, [r6, #4]
 800e904:	89a3      	ldrh	r3, [r4, #12]
 800e906:	0718      	lsls	r0, r3, #28
 800e908:	d55d      	bpl.n	800e9c6 <_vfiprintf_r+0xe2>
 800e90a:	6923      	ldr	r3, [r4, #16]
 800e90c:	2b00      	cmp	r3, #0
 800e90e:	d05a      	beq.n	800e9c6 <_vfiprintf_r+0xe2>
 800e910:	2300      	movs	r3, #0
 800e912:	9309      	str	r3, [sp, #36]	; 0x24
 800e914:	2320      	movs	r3, #32
 800e916:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 800e91a:	2330      	movs	r3, #48	; 0x30
 800e91c:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 800e920:	f04f 0b01 	mov.w	fp, #1
 800e924:	46b8      	mov	r8, r7
 800e926:	4645      	mov	r5, r8
 800e928:	f815 3b01 	ldrb.w	r3, [r5], #1
 800e92c:	2b00      	cmp	r3, #0
 800e92e:	d155      	bne.n	800e9dc <_vfiprintf_r+0xf8>
 800e930:	ebb8 0a07 	subs.w	sl, r8, r7
 800e934:	d00b      	beq.n	800e94e <_vfiprintf_r+0x6a>
 800e936:	4653      	mov	r3, sl
 800e938:	463a      	mov	r2, r7
 800e93a:	4621      	mov	r1, r4
 800e93c:	4630      	mov	r0, r6
 800e93e:	f7ff ffbf 	bl	800e8c0 <__sfputs_r>
 800e942:	3001      	adds	r0, #1
 800e944:	f000 80c4 	beq.w	800ead0 <_vfiprintf_r+0x1ec>
 800e948:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800e94a:	4453      	add	r3, sl
 800e94c:	9309      	str	r3, [sp, #36]	; 0x24
 800e94e:	f898 3000 	ldrb.w	r3, [r8]
 800e952:	2b00      	cmp	r3, #0
 800e954:	f000 80bc 	beq.w	800ead0 <_vfiprintf_r+0x1ec>
 800e958:	2300      	movs	r3, #0
 800e95a:	f04f 32ff 	mov.w	r2, #4294967295
 800e95e:	9304      	str	r3, [sp, #16]
 800e960:	9307      	str	r3, [sp, #28]
 800e962:	9205      	str	r2, [sp, #20]
 800e964:	9306      	str	r3, [sp, #24]
 800e966:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 800e96a:	931a      	str	r3, [sp, #104]	; 0x68
 800e96c:	2205      	movs	r2, #5
 800e96e:	7829      	ldrb	r1, [r5, #0]
 800e970:	4860      	ldr	r0, [pc, #384]	; (800eaf4 <_vfiprintf_r+0x210>)
 800e972:	f7f1 fc4d 	bl	8000210 <memchr>
 800e976:	f105 0801 	add.w	r8, r5, #1
 800e97a:	9b04      	ldr	r3, [sp, #16]
 800e97c:	2800      	cmp	r0, #0
 800e97e:	d131      	bne.n	800e9e4 <_vfiprintf_r+0x100>
 800e980:	06d9      	lsls	r1, r3, #27
 800e982:	bf44      	itt	mi
 800e984:	2220      	movmi	r2, #32
 800e986:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800e98a:	071a      	lsls	r2, r3, #28
 800e98c:	bf44      	itt	mi
 800e98e:	222b      	movmi	r2, #43	; 0x2b
 800e990:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 800e994:	782a      	ldrb	r2, [r5, #0]
 800e996:	2a2a      	cmp	r2, #42	; 0x2a
 800e998:	d02c      	beq.n	800e9f4 <_vfiprintf_r+0x110>
 800e99a:	9a07      	ldr	r2, [sp, #28]
 800e99c:	2100      	movs	r1, #0
 800e99e:	200a      	movs	r0, #10
 800e9a0:	46a8      	mov	r8, r5
 800e9a2:	3501      	adds	r5, #1
 800e9a4:	f898 3000 	ldrb.w	r3, [r8]
 800e9a8:	3b30      	subs	r3, #48	; 0x30
 800e9aa:	2b09      	cmp	r3, #9
 800e9ac:	d96d      	bls.n	800ea8a <_vfiprintf_r+0x1a6>
 800e9ae:	b371      	cbz	r1, 800ea0e <_vfiprintf_r+0x12a>
 800e9b0:	e026      	b.n	800ea00 <_vfiprintf_r+0x11c>
 800e9b2:	4b51      	ldr	r3, [pc, #324]	; (800eaf8 <_vfiprintf_r+0x214>)
 800e9b4:	429c      	cmp	r4, r3
 800e9b6:	d101      	bne.n	800e9bc <_vfiprintf_r+0xd8>
 800e9b8:	68b4      	ldr	r4, [r6, #8]
 800e9ba:	e7a3      	b.n	800e904 <_vfiprintf_r+0x20>
 800e9bc:	4b4f      	ldr	r3, [pc, #316]	; (800eafc <_vfiprintf_r+0x218>)
 800e9be:	429c      	cmp	r4, r3
 800e9c0:	bf08      	it	eq
 800e9c2:	68f4      	ldreq	r4, [r6, #12]
 800e9c4:	e79e      	b.n	800e904 <_vfiprintf_r+0x20>
 800e9c6:	4621      	mov	r1, r4
 800e9c8:	4630      	mov	r0, r6
 800e9ca:	f7ff f96d 	bl	800dca8 <__swsetup_r>
 800e9ce:	2800      	cmp	r0, #0
 800e9d0:	d09e      	beq.n	800e910 <_vfiprintf_r+0x2c>
 800e9d2:	f04f 30ff 	mov.w	r0, #4294967295
 800e9d6:	b01d      	add	sp, #116	; 0x74
 800e9d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800e9dc:	2b25      	cmp	r3, #37	; 0x25
 800e9de:	d0a7      	beq.n	800e930 <_vfiprintf_r+0x4c>
 800e9e0:	46a8      	mov	r8, r5
 800e9e2:	e7a0      	b.n	800e926 <_vfiprintf_r+0x42>
 800e9e4:	4a43      	ldr	r2, [pc, #268]	; (800eaf4 <_vfiprintf_r+0x210>)
 800e9e6:	1a80      	subs	r0, r0, r2
 800e9e8:	fa0b f000 	lsl.w	r0, fp, r0
 800e9ec:	4318      	orrs	r0, r3
 800e9ee:	9004      	str	r0, [sp, #16]
 800e9f0:	4645      	mov	r5, r8
 800e9f2:	e7bb      	b.n	800e96c <_vfiprintf_r+0x88>
 800e9f4:	9a03      	ldr	r2, [sp, #12]
 800e9f6:	1d11      	adds	r1, r2, #4
 800e9f8:	6812      	ldr	r2, [r2, #0]
 800e9fa:	9103      	str	r1, [sp, #12]
 800e9fc:	2a00      	cmp	r2, #0
 800e9fe:	db01      	blt.n	800ea04 <_vfiprintf_r+0x120>
 800ea00:	9207      	str	r2, [sp, #28]
 800ea02:	e004      	b.n	800ea0e <_vfiprintf_r+0x12a>
 800ea04:	4252      	negs	r2, r2
 800ea06:	f043 0302 	orr.w	r3, r3, #2
 800ea0a:	9207      	str	r2, [sp, #28]
 800ea0c:	9304      	str	r3, [sp, #16]
 800ea0e:	f898 3000 	ldrb.w	r3, [r8]
 800ea12:	2b2e      	cmp	r3, #46	; 0x2e
 800ea14:	d110      	bne.n	800ea38 <_vfiprintf_r+0x154>
 800ea16:	f898 3001 	ldrb.w	r3, [r8, #1]
 800ea1a:	2b2a      	cmp	r3, #42	; 0x2a
 800ea1c:	f108 0101 	add.w	r1, r8, #1
 800ea20:	d137      	bne.n	800ea92 <_vfiprintf_r+0x1ae>
 800ea22:	9b03      	ldr	r3, [sp, #12]
 800ea24:	1d1a      	adds	r2, r3, #4
 800ea26:	681b      	ldr	r3, [r3, #0]
 800ea28:	9203      	str	r2, [sp, #12]
 800ea2a:	2b00      	cmp	r3, #0
 800ea2c:	bfb8      	it	lt
 800ea2e:	f04f 33ff 	movlt.w	r3, #4294967295
 800ea32:	f108 0802 	add.w	r8, r8, #2
 800ea36:	9305      	str	r3, [sp, #20]
 800ea38:	4d31      	ldr	r5, [pc, #196]	; (800eb00 <_vfiprintf_r+0x21c>)
 800ea3a:	f898 1000 	ldrb.w	r1, [r8]
 800ea3e:	2203      	movs	r2, #3
 800ea40:	4628      	mov	r0, r5
 800ea42:	f7f1 fbe5 	bl	8000210 <memchr>
 800ea46:	b140      	cbz	r0, 800ea5a <_vfiprintf_r+0x176>
 800ea48:	2340      	movs	r3, #64	; 0x40
 800ea4a:	1b40      	subs	r0, r0, r5
 800ea4c:	fa03 f000 	lsl.w	r0, r3, r0
 800ea50:	9b04      	ldr	r3, [sp, #16]
 800ea52:	4303      	orrs	r3, r0
 800ea54:	9304      	str	r3, [sp, #16]
 800ea56:	f108 0801 	add.w	r8, r8, #1
 800ea5a:	f898 1000 	ldrb.w	r1, [r8]
 800ea5e:	4829      	ldr	r0, [pc, #164]	; (800eb04 <_vfiprintf_r+0x220>)
 800ea60:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 800ea64:	2206      	movs	r2, #6
 800ea66:	f108 0701 	add.w	r7, r8, #1
 800ea6a:	f7f1 fbd1 	bl	8000210 <memchr>
 800ea6e:	2800      	cmp	r0, #0
 800ea70:	d034      	beq.n	800eadc <_vfiprintf_r+0x1f8>
 800ea72:	4b25      	ldr	r3, [pc, #148]	; (800eb08 <_vfiprintf_r+0x224>)
 800ea74:	bb03      	cbnz	r3, 800eab8 <_vfiprintf_r+0x1d4>
 800ea76:	9b03      	ldr	r3, [sp, #12]
 800ea78:	3307      	adds	r3, #7
 800ea7a:	f023 0307 	bic.w	r3, r3, #7
 800ea7e:	3308      	adds	r3, #8
 800ea80:	9303      	str	r3, [sp, #12]
 800ea82:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800ea84:	444b      	add	r3, r9
 800ea86:	9309      	str	r3, [sp, #36]	; 0x24
 800ea88:	e74c      	b.n	800e924 <_vfiprintf_r+0x40>
 800ea8a:	fb00 3202 	mla	r2, r0, r2, r3
 800ea8e:	2101      	movs	r1, #1
 800ea90:	e786      	b.n	800e9a0 <_vfiprintf_r+0xbc>
 800ea92:	2300      	movs	r3, #0
 800ea94:	9305      	str	r3, [sp, #20]
 800ea96:	4618      	mov	r0, r3
 800ea98:	250a      	movs	r5, #10
 800ea9a:	4688      	mov	r8, r1
 800ea9c:	3101      	adds	r1, #1
 800ea9e:	f898 2000 	ldrb.w	r2, [r8]
 800eaa2:	3a30      	subs	r2, #48	; 0x30
 800eaa4:	2a09      	cmp	r2, #9
 800eaa6:	d903      	bls.n	800eab0 <_vfiprintf_r+0x1cc>
 800eaa8:	2b00      	cmp	r3, #0
 800eaaa:	d0c5      	beq.n	800ea38 <_vfiprintf_r+0x154>
 800eaac:	9005      	str	r0, [sp, #20]
 800eaae:	e7c3      	b.n	800ea38 <_vfiprintf_r+0x154>
 800eab0:	fb05 2000 	mla	r0, r5, r0, r2
 800eab4:	2301      	movs	r3, #1
 800eab6:	e7f0      	b.n	800ea9a <_vfiprintf_r+0x1b6>
 800eab8:	ab03      	add	r3, sp, #12
 800eaba:	9300      	str	r3, [sp, #0]
 800eabc:	4622      	mov	r2, r4
 800eabe:	4b13      	ldr	r3, [pc, #76]	; (800eb0c <_vfiprintf_r+0x228>)
 800eac0:	a904      	add	r1, sp, #16
 800eac2:	4630      	mov	r0, r6
 800eac4:	f3af 8000 	nop.w
 800eac8:	f1b0 3fff 	cmp.w	r0, #4294967295
 800eacc:	4681      	mov	r9, r0
 800eace:	d1d8      	bne.n	800ea82 <_vfiprintf_r+0x19e>
 800ead0:	89a3      	ldrh	r3, [r4, #12]
 800ead2:	065b      	lsls	r3, r3, #25
 800ead4:	f53f af7d 	bmi.w	800e9d2 <_vfiprintf_r+0xee>
 800ead8:	9809      	ldr	r0, [sp, #36]	; 0x24
 800eada:	e77c      	b.n	800e9d6 <_vfiprintf_r+0xf2>
 800eadc:	ab03      	add	r3, sp, #12
 800eade:	9300      	str	r3, [sp, #0]
 800eae0:	4622      	mov	r2, r4
 800eae2:	4b0a      	ldr	r3, [pc, #40]	; (800eb0c <_vfiprintf_r+0x228>)
 800eae4:	a904      	add	r1, sp, #16
 800eae6:	4630      	mov	r0, r6
 800eae8:	f000 f888 	bl	800ebfc <_printf_i>
 800eaec:	e7ec      	b.n	800eac8 <_vfiprintf_r+0x1e4>
 800eaee:	bf00      	nop
 800eaf0:	0800ffb4 	.word	0x0800ffb4
 800eaf4:	0801005c 	.word	0x0801005c
 800eaf8:	0800ffd4 	.word	0x0800ffd4
 800eafc:	0800ff94 	.word	0x0800ff94
 800eb00:	08010062 	.word	0x08010062
 800eb04:	08010066 	.word	0x08010066
 800eb08:	00000000 	.word	0x00000000
 800eb0c:	0800e8c1 	.word	0x0800e8c1

0800eb10 <_printf_common>:
 800eb10:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800eb14:	4691      	mov	r9, r2
 800eb16:	461f      	mov	r7, r3
 800eb18:	688a      	ldr	r2, [r1, #8]
 800eb1a:	690b      	ldr	r3, [r1, #16]
 800eb1c:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800eb20:	4293      	cmp	r3, r2
 800eb22:	bfb8      	it	lt
 800eb24:	4613      	movlt	r3, r2
 800eb26:	f8c9 3000 	str.w	r3, [r9]
 800eb2a:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800eb2e:	4606      	mov	r6, r0
 800eb30:	460c      	mov	r4, r1
 800eb32:	b112      	cbz	r2, 800eb3a <_printf_common+0x2a>
 800eb34:	3301      	adds	r3, #1
 800eb36:	f8c9 3000 	str.w	r3, [r9]
 800eb3a:	6823      	ldr	r3, [r4, #0]
 800eb3c:	0699      	lsls	r1, r3, #26
 800eb3e:	bf42      	ittt	mi
 800eb40:	f8d9 3000 	ldrmi.w	r3, [r9]
 800eb44:	3302      	addmi	r3, #2
 800eb46:	f8c9 3000 	strmi.w	r3, [r9]
 800eb4a:	6825      	ldr	r5, [r4, #0]
 800eb4c:	f015 0506 	ands.w	r5, r5, #6
 800eb50:	d107      	bne.n	800eb62 <_printf_common+0x52>
 800eb52:	f104 0a19 	add.w	sl, r4, #25
 800eb56:	68e3      	ldr	r3, [r4, #12]
 800eb58:	f8d9 2000 	ldr.w	r2, [r9]
 800eb5c:	1a9b      	subs	r3, r3, r2
 800eb5e:	429d      	cmp	r5, r3
 800eb60:	db29      	blt.n	800ebb6 <_printf_common+0xa6>
 800eb62:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 800eb66:	6822      	ldr	r2, [r4, #0]
 800eb68:	3300      	adds	r3, #0
 800eb6a:	bf18      	it	ne
 800eb6c:	2301      	movne	r3, #1
 800eb6e:	0692      	lsls	r2, r2, #26
 800eb70:	d42e      	bmi.n	800ebd0 <_printf_common+0xc0>
 800eb72:	f104 0243 	add.w	r2, r4, #67	; 0x43
 800eb76:	4639      	mov	r1, r7
 800eb78:	4630      	mov	r0, r6
 800eb7a:	47c0      	blx	r8
 800eb7c:	3001      	adds	r0, #1
 800eb7e:	d021      	beq.n	800ebc4 <_printf_common+0xb4>
 800eb80:	6823      	ldr	r3, [r4, #0]
 800eb82:	68e5      	ldr	r5, [r4, #12]
 800eb84:	f8d9 2000 	ldr.w	r2, [r9]
 800eb88:	f003 0306 	and.w	r3, r3, #6
 800eb8c:	2b04      	cmp	r3, #4
 800eb8e:	bf08      	it	eq
 800eb90:	1aad      	subeq	r5, r5, r2
 800eb92:	68a3      	ldr	r3, [r4, #8]
 800eb94:	6922      	ldr	r2, [r4, #16]
 800eb96:	bf0c      	ite	eq
 800eb98:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 800eb9c:	2500      	movne	r5, #0
 800eb9e:	4293      	cmp	r3, r2
 800eba0:	bfc4      	itt	gt
 800eba2:	1a9b      	subgt	r3, r3, r2
 800eba4:	18ed      	addgt	r5, r5, r3
 800eba6:	f04f 0900 	mov.w	r9, #0
 800ebaa:	341a      	adds	r4, #26
 800ebac:	454d      	cmp	r5, r9
 800ebae:	d11b      	bne.n	800ebe8 <_printf_common+0xd8>
 800ebb0:	2000      	movs	r0, #0
 800ebb2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ebb6:	2301      	movs	r3, #1
 800ebb8:	4652      	mov	r2, sl
 800ebba:	4639      	mov	r1, r7
 800ebbc:	4630      	mov	r0, r6
 800ebbe:	47c0      	blx	r8
 800ebc0:	3001      	adds	r0, #1
 800ebc2:	d103      	bne.n	800ebcc <_printf_common+0xbc>
 800ebc4:	f04f 30ff 	mov.w	r0, #4294967295
 800ebc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800ebcc:	3501      	adds	r5, #1
 800ebce:	e7c2      	b.n	800eb56 <_printf_common+0x46>
 800ebd0:	18e1      	adds	r1, r4, r3
 800ebd2:	1c5a      	adds	r2, r3, #1
 800ebd4:	2030      	movs	r0, #48	; 0x30
 800ebd6:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 800ebda:	4422      	add	r2, r4
 800ebdc:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800ebe0:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 800ebe4:	3302      	adds	r3, #2
 800ebe6:	e7c4      	b.n	800eb72 <_printf_common+0x62>
 800ebe8:	2301      	movs	r3, #1
 800ebea:	4622      	mov	r2, r4
 800ebec:	4639      	mov	r1, r7
 800ebee:	4630      	mov	r0, r6
 800ebf0:	47c0      	blx	r8
 800ebf2:	3001      	adds	r0, #1
 800ebf4:	d0e6      	beq.n	800ebc4 <_printf_common+0xb4>
 800ebf6:	f109 0901 	add.w	r9, r9, #1
 800ebfa:	e7d7      	b.n	800ebac <_printf_common+0x9c>

0800ebfc <_printf_i>:
 800ebfc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800ec00:	4617      	mov	r7, r2
 800ec02:	7e0a      	ldrb	r2, [r1, #24]
 800ec04:	b085      	sub	sp, #20
 800ec06:	2a6e      	cmp	r2, #110	; 0x6e
 800ec08:	4698      	mov	r8, r3
 800ec0a:	4606      	mov	r6, r0
 800ec0c:	460c      	mov	r4, r1
 800ec0e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800ec10:	f101 0e43 	add.w	lr, r1, #67	; 0x43
 800ec14:	f000 80bc 	beq.w	800ed90 <_printf_i+0x194>
 800ec18:	d81a      	bhi.n	800ec50 <_printf_i+0x54>
 800ec1a:	2a63      	cmp	r2, #99	; 0x63
 800ec1c:	d02e      	beq.n	800ec7c <_printf_i+0x80>
 800ec1e:	d80a      	bhi.n	800ec36 <_printf_i+0x3a>
 800ec20:	2a00      	cmp	r2, #0
 800ec22:	f000 80c8 	beq.w	800edb6 <_printf_i+0x1ba>
 800ec26:	2a58      	cmp	r2, #88	; 0x58
 800ec28:	f000 808a 	beq.w	800ed40 <_printf_i+0x144>
 800ec2c:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800ec30:	f884 2042 	strb.w	r2, [r4, #66]	; 0x42
 800ec34:	e02a      	b.n	800ec8c <_printf_i+0x90>
 800ec36:	2a64      	cmp	r2, #100	; 0x64
 800ec38:	d001      	beq.n	800ec3e <_printf_i+0x42>
 800ec3a:	2a69      	cmp	r2, #105	; 0x69
 800ec3c:	d1f6      	bne.n	800ec2c <_printf_i+0x30>
 800ec3e:	6821      	ldr	r1, [r4, #0]
 800ec40:	681a      	ldr	r2, [r3, #0]
 800ec42:	f011 0f80 	tst.w	r1, #128	; 0x80
 800ec46:	d023      	beq.n	800ec90 <_printf_i+0x94>
 800ec48:	1d11      	adds	r1, r2, #4
 800ec4a:	6019      	str	r1, [r3, #0]
 800ec4c:	6813      	ldr	r3, [r2, #0]
 800ec4e:	e027      	b.n	800eca0 <_printf_i+0xa4>
 800ec50:	2a73      	cmp	r2, #115	; 0x73
 800ec52:	f000 80b4 	beq.w	800edbe <_printf_i+0x1c2>
 800ec56:	d808      	bhi.n	800ec6a <_printf_i+0x6e>
 800ec58:	2a6f      	cmp	r2, #111	; 0x6f
 800ec5a:	d02a      	beq.n	800ecb2 <_printf_i+0xb6>
 800ec5c:	2a70      	cmp	r2, #112	; 0x70
 800ec5e:	d1e5      	bne.n	800ec2c <_printf_i+0x30>
 800ec60:	680a      	ldr	r2, [r1, #0]
 800ec62:	f042 0220 	orr.w	r2, r2, #32
 800ec66:	600a      	str	r2, [r1, #0]
 800ec68:	e003      	b.n	800ec72 <_printf_i+0x76>
 800ec6a:	2a75      	cmp	r2, #117	; 0x75
 800ec6c:	d021      	beq.n	800ecb2 <_printf_i+0xb6>
 800ec6e:	2a78      	cmp	r2, #120	; 0x78
 800ec70:	d1dc      	bne.n	800ec2c <_printf_i+0x30>
 800ec72:	2278      	movs	r2, #120	; 0x78
 800ec74:	f884 2045 	strb.w	r2, [r4, #69]	; 0x45
 800ec78:	496e      	ldr	r1, [pc, #440]	; (800ee34 <_printf_i+0x238>)
 800ec7a:	e064      	b.n	800ed46 <_printf_i+0x14a>
 800ec7c:	681a      	ldr	r2, [r3, #0]
 800ec7e:	f101 0542 	add.w	r5, r1, #66	; 0x42
 800ec82:	1d11      	adds	r1, r2, #4
 800ec84:	6019      	str	r1, [r3, #0]
 800ec86:	6813      	ldr	r3, [r2, #0]
 800ec88:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800ec8c:	2301      	movs	r3, #1
 800ec8e:	e0a3      	b.n	800edd8 <_printf_i+0x1dc>
 800ec90:	f011 0f40 	tst.w	r1, #64	; 0x40
 800ec94:	f102 0104 	add.w	r1, r2, #4
 800ec98:	6019      	str	r1, [r3, #0]
 800ec9a:	d0d7      	beq.n	800ec4c <_printf_i+0x50>
 800ec9c:	f9b2 3000 	ldrsh.w	r3, [r2]
 800eca0:	2b00      	cmp	r3, #0
 800eca2:	da03      	bge.n	800ecac <_printf_i+0xb0>
 800eca4:	222d      	movs	r2, #45	; 0x2d
 800eca6:	425b      	negs	r3, r3
 800eca8:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 800ecac:	4962      	ldr	r1, [pc, #392]	; (800ee38 <_printf_i+0x23c>)
 800ecae:	220a      	movs	r2, #10
 800ecb0:	e017      	b.n	800ece2 <_printf_i+0xe6>
 800ecb2:	6820      	ldr	r0, [r4, #0]
 800ecb4:	6819      	ldr	r1, [r3, #0]
 800ecb6:	f010 0f80 	tst.w	r0, #128	; 0x80
 800ecba:	d003      	beq.n	800ecc4 <_printf_i+0xc8>
 800ecbc:	1d08      	adds	r0, r1, #4
 800ecbe:	6018      	str	r0, [r3, #0]
 800ecc0:	680b      	ldr	r3, [r1, #0]
 800ecc2:	e006      	b.n	800ecd2 <_printf_i+0xd6>
 800ecc4:	f010 0f40 	tst.w	r0, #64	; 0x40
 800ecc8:	f101 0004 	add.w	r0, r1, #4
 800eccc:	6018      	str	r0, [r3, #0]
 800ecce:	d0f7      	beq.n	800ecc0 <_printf_i+0xc4>
 800ecd0:	880b      	ldrh	r3, [r1, #0]
 800ecd2:	4959      	ldr	r1, [pc, #356]	; (800ee38 <_printf_i+0x23c>)
 800ecd4:	2a6f      	cmp	r2, #111	; 0x6f
 800ecd6:	bf14      	ite	ne
 800ecd8:	220a      	movne	r2, #10
 800ecda:	2208      	moveq	r2, #8
 800ecdc:	2000      	movs	r0, #0
 800ecde:	f884 0043 	strb.w	r0, [r4, #67]	; 0x43
 800ece2:	6865      	ldr	r5, [r4, #4]
 800ece4:	60a5      	str	r5, [r4, #8]
 800ece6:	2d00      	cmp	r5, #0
 800ece8:	f2c0 809c 	blt.w	800ee24 <_printf_i+0x228>
 800ecec:	6820      	ldr	r0, [r4, #0]
 800ecee:	f020 0004 	bic.w	r0, r0, #4
 800ecf2:	6020      	str	r0, [r4, #0]
 800ecf4:	2b00      	cmp	r3, #0
 800ecf6:	d13f      	bne.n	800ed78 <_printf_i+0x17c>
 800ecf8:	2d00      	cmp	r5, #0
 800ecfa:	f040 8095 	bne.w	800ee28 <_printf_i+0x22c>
 800ecfe:	4675      	mov	r5, lr
 800ed00:	2a08      	cmp	r2, #8
 800ed02:	d10b      	bne.n	800ed1c <_printf_i+0x120>
 800ed04:	6823      	ldr	r3, [r4, #0]
 800ed06:	07da      	lsls	r2, r3, #31
 800ed08:	d508      	bpl.n	800ed1c <_printf_i+0x120>
 800ed0a:	6923      	ldr	r3, [r4, #16]
 800ed0c:	6862      	ldr	r2, [r4, #4]
 800ed0e:	429a      	cmp	r2, r3
 800ed10:	bfde      	ittt	le
 800ed12:	2330      	movle	r3, #48	; 0x30
 800ed14:	f805 3c01 	strble.w	r3, [r5, #-1]
 800ed18:	f105 35ff 	addle.w	r5, r5, #4294967295
 800ed1c:	ebae 0305 	sub.w	r3, lr, r5
 800ed20:	6123      	str	r3, [r4, #16]
 800ed22:	f8cd 8000 	str.w	r8, [sp]
 800ed26:	463b      	mov	r3, r7
 800ed28:	aa03      	add	r2, sp, #12
 800ed2a:	4621      	mov	r1, r4
 800ed2c:	4630      	mov	r0, r6
 800ed2e:	f7ff feef 	bl	800eb10 <_printf_common>
 800ed32:	3001      	adds	r0, #1
 800ed34:	d155      	bne.n	800ede2 <_printf_i+0x1e6>
 800ed36:	f04f 30ff 	mov.w	r0, #4294967295
 800ed3a:	b005      	add	sp, #20
 800ed3c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800ed40:	f881 2045 	strb.w	r2, [r1, #69]	; 0x45
 800ed44:	493c      	ldr	r1, [pc, #240]	; (800ee38 <_printf_i+0x23c>)
 800ed46:	6822      	ldr	r2, [r4, #0]
 800ed48:	6818      	ldr	r0, [r3, #0]
 800ed4a:	f012 0f80 	tst.w	r2, #128	; 0x80
 800ed4e:	f100 0504 	add.w	r5, r0, #4
 800ed52:	601d      	str	r5, [r3, #0]
 800ed54:	d001      	beq.n	800ed5a <_printf_i+0x15e>
 800ed56:	6803      	ldr	r3, [r0, #0]
 800ed58:	e002      	b.n	800ed60 <_printf_i+0x164>
 800ed5a:	0655      	lsls	r5, r2, #25
 800ed5c:	d5fb      	bpl.n	800ed56 <_printf_i+0x15a>
 800ed5e:	8803      	ldrh	r3, [r0, #0]
 800ed60:	07d0      	lsls	r0, r2, #31
 800ed62:	bf44      	itt	mi
 800ed64:	f042 0220 	orrmi.w	r2, r2, #32
 800ed68:	6022      	strmi	r2, [r4, #0]
 800ed6a:	b91b      	cbnz	r3, 800ed74 <_printf_i+0x178>
 800ed6c:	6822      	ldr	r2, [r4, #0]
 800ed6e:	f022 0220 	bic.w	r2, r2, #32
 800ed72:	6022      	str	r2, [r4, #0]
 800ed74:	2210      	movs	r2, #16
 800ed76:	e7b1      	b.n	800ecdc <_printf_i+0xe0>
 800ed78:	4675      	mov	r5, lr
 800ed7a:	fbb3 f0f2 	udiv	r0, r3, r2
 800ed7e:	fb02 3310 	mls	r3, r2, r0, r3
 800ed82:	5ccb      	ldrb	r3, [r1, r3]
 800ed84:	f805 3d01 	strb.w	r3, [r5, #-1]!
 800ed88:	4603      	mov	r3, r0
 800ed8a:	2800      	cmp	r0, #0
 800ed8c:	d1f5      	bne.n	800ed7a <_printf_i+0x17e>
 800ed8e:	e7b7      	b.n	800ed00 <_printf_i+0x104>
 800ed90:	6808      	ldr	r0, [r1, #0]
 800ed92:	681a      	ldr	r2, [r3, #0]
 800ed94:	6949      	ldr	r1, [r1, #20]
 800ed96:	f010 0f80 	tst.w	r0, #128	; 0x80
 800ed9a:	d004      	beq.n	800eda6 <_printf_i+0x1aa>
 800ed9c:	1d10      	adds	r0, r2, #4
 800ed9e:	6018      	str	r0, [r3, #0]
 800eda0:	6813      	ldr	r3, [r2, #0]
 800eda2:	6019      	str	r1, [r3, #0]
 800eda4:	e007      	b.n	800edb6 <_printf_i+0x1ba>
 800eda6:	f010 0f40 	tst.w	r0, #64	; 0x40
 800edaa:	f102 0004 	add.w	r0, r2, #4
 800edae:	6018      	str	r0, [r3, #0]
 800edb0:	6813      	ldr	r3, [r2, #0]
 800edb2:	d0f6      	beq.n	800eda2 <_printf_i+0x1a6>
 800edb4:	8019      	strh	r1, [r3, #0]
 800edb6:	2300      	movs	r3, #0
 800edb8:	6123      	str	r3, [r4, #16]
 800edba:	4675      	mov	r5, lr
 800edbc:	e7b1      	b.n	800ed22 <_printf_i+0x126>
 800edbe:	681a      	ldr	r2, [r3, #0]
 800edc0:	1d11      	adds	r1, r2, #4
 800edc2:	6019      	str	r1, [r3, #0]
 800edc4:	6815      	ldr	r5, [r2, #0]
 800edc6:	6862      	ldr	r2, [r4, #4]
 800edc8:	2100      	movs	r1, #0
 800edca:	4628      	mov	r0, r5
 800edcc:	f7f1 fa20 	bl	8000210 <memchr>
 800edd0:	b108      	cbz	r0, 800edd6 <_printf_i+0x1da>
 800edd2:	1b40      	subs	r0, r0, r5
 800edd4:	6060      	str	r0, [r4, #4]
 800edd6:	6863      	ldr	r3, [r4, #4]
 800edd8:	6123      	str	r3, [r4, #16]
 800edda:	2300      	movs	r3, #0
 800eddc:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800ede0:	e79f      	b.n	800ed22 <_printf_i+0x126>
 800ede2:	6923      	ldr	r3, [r4, #16]
 800ede4:	462a      	mov	r2, r5
 800ede6:	4639      	mov	r1, r7
 800ede8:	4630      	mov	r0, r6
 800edea:	47c0      	blx	r8
 800edec:	3001      	adds	r0, #1
 800edee:	d0a2      	beq.n	800ed36 <_printf_i+0x13a>
 800edf0:	6823      	ldr	r3, [r4, #0]
 800edf2:	079b      	lsls	r3, r3, #30
 800edf4:	d507      	bpl.n	800ee06 <_printf_i+0x20a>
 800edf6:	2500      	movs	r5, #0
 800edf8:	f104 0919 	add.w	r9, r4, #25
 800edfc:	68e3      	ldr	r3, [r4, #12]
 800edfe:	9a03      	ldr	r2, [sp, #12]
 800ee00:	1a9b      	subs	r3, r3, r2
 800ee02:	429d      	cmp	r5, r3
 800ee04:	db05      	blt.n	800ee12 <_printf_i+0x216>
 800ee06:	68e0      	ldr	r0, [r4, #12]
 800ee08:	9b03      	ldr	r3, [sp, #12]
 800ee0a:	4298      	cmp	r0, r3
 800ee0c:	bfb8      	it	lt
 800ee0e:	4618      	movlt	r0, r3
 800ee10:	e793      	b.n	800ed3a <_printf_i+0x13e>
 800ee12:	2301      	movs	r3, #1
 800ee14:	464a      	mov	r2, r9
 800ee16:	4639      	mov	r1, r7
 800ee18:	4630      	mov	r0, r6
 800ee1a:	47c0      	blx	r8
 800ee1c:	3001      	adds	r0, #1
 800ee1e:	d08a      	beq.n	800ed36 <_printf_i+0x13a>
 800ee20:	3501      	adds	r5, #1
 800ee22:	e7eb      	b.n	800edfc <_printf_i+0x200>
 800ee24:	2b00      	cmp	r3, #0
 800ee26:	d1a7      	bne.n	800ed78 <_printf_i+0x17c>
 800ee28:	780b      	ldrb	r3, [r1, #0]
 800ee2a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800ee2e:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800ee32:	e765      	b.n	800ed00 <_printf_i+0x104>
 800ee34:	0801007e 	.word	0x0801007e
 800ee38:	0801006d 	.word	0x0801006d

0800ee3c <_scanf_chars>:
 800ee3c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800ee40:	4615      	mov	r5, r2
 800ee42:	688a      	ldr	r2, [r1, #8]
 800ee44:	4680      	mov	r8, r0
 800ee46:	460c      	mov	r4, r1
 800ee48:	b932      	cbnz	r2, 800ee58 <_scanf_chars+0x1c>
 800ee4a:	698a      	ldr	r2, [r1, #24]
 800ee4c:	2a00      	cmp	r2, #0
 800ee4e:	bf0c      	ite	eq
 800ee50:	2201      	moveq	r2, #1
 800ee52:	f04f 32ff 	movne.w	r2, #4294967295
 800ee56:	608a      	str	r2, [r1, #8]
 800ee58:	6822      	ldr	r2, [r4, #0]
 800ee5a:	06d1      	lsls	r1, r2, #27
 800ee5c:	bf5f      	itttt	pl
 800ee5e:	681a      	ldrpl	r2, [r3, #0]
 800ee60:	1d11      	addpl	r1, r2, #4
 800ee62:	6019      	strpl	r1, [r3, #0]
 800ee64:	6817      	ldrpl	r7, [r2, #0]
 800ee66:	2600      	movs	r6, #0
 800ee68:	69a3      	ldr	r3, [r4, #24]
 800ee6a:	b1db      	cbz	r3, 800eea4 <_scanf_chars+0x68>
 800ee6c:	2b01      	cmp	r3, #1
 800ee6e:	d107      	bne.n	800ee80 <_scanf_chars+0x44>
 800ee70:	682b      	ldr	r3, [r5, #0]
 800ee72:	6962      	ldr	r2, [r4, #20]
 800ee74:	781b      	ldrb	r3, [r3, #0]
 800ee76:	5cd3      	ldrb	r3, [r2, r3]
 800ee78:	b9a3      	cbnz	r3, 800eea4 <_scanf_chars+0x68>
 800ee7a:	2e00      	cmp	r6, #0
 800ee7c:	d132      	bne.n	800eee4 <_scanf_chars+0xa8>
 800ee7e:	e006      	b.n	800ee8e <_scanf_chars+0x52>
 800ee80:	2b02      	cmp	r3, #2
 800ee82:	d007      	beq.n	800ee94 <_scanf_chars+0x58>
 800ee84:	2e00      	cmp	r6, #0
 800ee86:	d12d      	bne.n	800eee4 <_scanf_chars+0xa8>
 800ee88:	69a3      	ldr	r3, [r4, #24]
 800ee8a:	2b01      	cmp	r3, #1
 800ee8c:	d12a      	bne.n	800eee4 <_scanf_chars+0xa8>
 800ee8e:	2001      	movs	r0, #1
 800ee90:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800ee94:	f7ff f966 	bl	800e164 <__locale_ctype_ptr>
 800ee98:	682b      	ldr	r3, [r5, #0]
 800ee9a:	781b      	ldrb	r3, [r3, #0]
 800ee9c:	4418      	add	r0, r3
 800ee9e:	7843      	ldrb	r3, [r0, #1]
 800eea0:	071b      	lsls	r3, r3, #28
 800eea2:	d4ef      	bmi.n	800ee84 <_scanf_chars+0x48>
 800eea4:	6823      	ldr	r3, [r4, #0]
 800eea6:	06da      	lsls	r2, r3, #27
 800eea8:	bf5e      	ittt	pl
 800eeaa:	682b      	ldrpl	r3, [r5, #0]
 800eeac:	781b      	ldrbpl	r3, [r3, #0]
 800eeae:	703b      	strbpl	r3, [r7, #0]
 800eeb0:	682a      	ldr	r2, [r5, #0]
 800eeb2:	686b      	ldr	r3, [r5, #4]
 800eeb4:	f102 0201 	add.w	r2, r2, #1
 800eeb8:	602a      	str	r2, [r5, #0]
 800eeba:	68a2      	ldr	r2, [r4, #8]
 800eebc:	f103 33ff 	add.w	r3, r3, #4294967295
 800eec0:	f102 32ff 	add.w	r2, r2, #4294967295
 800eec4:	606b      	str	r3, [r5, #4]
 800eec6:	f106 0601 	add.w	r6, r6, #1
 800eeca:	bf58      	it	pl
 800eecc:	3701      	addpl	r7, #1
 800eece:	60a2      	str	r2, [r4, #8]
 800eed0:	b142      	cbz	r2, 800eee4 <_scanf_chars+0xa8>
 800eed2:	2b00      	cmp	r3, #0
 800eed4:	dcc8      	bgt.n	800ee68 <_scanf_chars+0x2c>
 800eed6:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 800eeda:	4629      	mov	r1, r5
 800eedc:	4640      	mov	r0, r8
 800eede:	4798      	blx	r3
 800eee0:	2800      	cmp	r0, #0
 800eee2:	d0c1      	beq.n	800ee68 <_scanf_chars+0x2c>
 800eee4:	6823      	ldr	r3, [r4, #0]
 800eee6:	f013 0310 	ands.w	r3, r3, #16
 800eeea:	d105      	bne.n	800eef8 <_scanf_chars+0xbc>
 800eeec:	68e2      	ldr	r2, [r4, #12]
 800eeee:	3201      	adds	r2, #1
 800eef0:	60e2      	str	r2, [r4, #12]
 800eef2:	69a2      	ldr	r2, [r4, #24]
 800eef4:	b102      	cbz	r2, 800eef8 <_scanf_chars+0xbc>
 800eef6:	703b      	strb	r3, [r7, #0]
 800eef8:	6923      	ldr	r3, [r4, #16]
 800eefa:	441e      	add	r6, r3
 800eefc:	6126      	str	r6, [r4, #16]
 800eefe:	2000      	movs	r0, #0
 800ef00:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0800ef04 <_scanf_i>:
 800ef04:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 800ef08:	469a      	mov	sl, r3
 800ef0a:	4b74      	ldr	r3, [pc, #464]	; (800f0dc <_scanf_i+0x1d8>)
 800ef0c:	460c      	mov	r4, r1
 800ef0e:	4683      	mov	fp, r0
 800ef10:	4616      	mov	r6, r2
 800ef12:	e893 0007 	ldmia.w	r3, {r0, r1, r2}
 800ef16:	b087      	sub	sp, #28
 800ef18:	ab03      	add	r3, sp, #12
 800ef1a:	68a7      	ldr	r7, [r4, #8]
 800ef1c:	e883 0007 	stmia.w	r3, {r0, r1, r2}
 800ef20:	4b6f      	ldr	r3, [pc, #444]	; (800f0e0 <_scanf_i+0x1dc>)
 800ef22:	69a1      	ldr	r1, [r4, #24]
 800ef24:	4a6f      	ldr	r2, [pc, #444]	; (800f0e4 <_scanf_i+0x1e0>)
 800ef26:	2903      	cmp	r1, #3
 800ef28:	bf18      	it	ne
 800ef2a:	461a      	movne	r2, r3
 800ef2c:	1e7b      	subs	r3, r7, #1
 800ef2e:	f5b3 7fae 	cmp.w	r3, #348	; 0x15c
 800ef32:	bf84      	itt	hi
 800ef34:	f240 135d 	movwhi	r3, #349	; 0x15d
 800ef38:	60a3      	strhi	r3, [r4, #8]
 800ef3a:	6823      	ldr	r3, [r4, #0]
 800ef3c:	9200      	str	r2, [sp, #0]
 800ef3e:	f443 6350 	orr.w	r3, r3, #3328	; 0xd00
 800ef42:	bf88      	it	hi
 800ef44:	f46f 75ae 	mvnhi.w	r5, #348	; 0x15c
 800ef48:	f104 091c 	add.w	r9, r4, #28
 800ef4c:	6023      	str	r3, [r4, #0]
 800ef4e:	bf8c      	ite	hi
 800ef50:	197f      	addhi	r7, r7, r5
 800ef52:	2700      	movls	r7, #0
 800ef54:	464b      	mov	r3, r9
 800ef56:	f04f 0800 	mov.w	r8, #0
 800ef5a:	9301      	str	r3, [sp, #4]
 800ef5c:	6831      	ldr	r1, [r6, #0]
 800ef5e:	ab03      	add	r3, sp, #12
 800ef60:	2202      	movs	r2, #2
 800ef62:	f853 0028 	ldr.w	r0, [r3, r8, lsl #2]
 800ef66:	7809      	ldrb	r1, [r1, #0]
 800ef68:	f7f1 f952 	bl	8000210 <memchr>
 800ef6c:	9b01      	ldr	r3, [sp, #4]
 800ef6e:	b328      	cbz	r0, 800efbc <_scanf_i+0xb8>
 800ef70:	f1b8 0f01 	cmp.w	r8, #1
 800ef74:	d156      	bne.n	800f024 <_scanf_i+0x120>
 800ef76:	6862      	ldr	r2, [r4, #4]
 800ef78:	b92a      	cbnz	r2, 800ef86 <_scanf_i+0x82>
 800ef7a:	2208      	movs	r2, #8
 800ef7c:	6062      	str	r2, [r4, #4]
 800ef7e:	6822      	ldr	r2, [r4, #0]
 800ef80:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800ef84:	6022      	str	r2, [r4, #0]
 800ef86:	6822      	ldr	r2, [r4, #0]
 800ef88:	f422 62a0 	bic.w	r2, r2, #1280	; 0x500
 800ef8c:	6022      	str	r2, [r4, #0]
 800ef8e:	68a2      	ldr	r2, [r4, #8]
 800ef90:	1e51      	subs	r1, r2, #1
 800ef92:	60a1      	str	r1, [r4, #8]
 800ef94:	b192      	cbz	r2, 800efbc <_scanf_i+0xb8>
 800ef96:	6832      	ldr	r2, [r6, #0]
 800ef98:	1c51      	adds	r1, r2, #1
 800ef9a:	6031      	str	r1, [r6, #0]
 800ef9c:	7812      	ldrb	r2, [r2, #0]
 800ef9e:	701a      	strb	r2, [r3, #0]
 800efa0:	1c5d      	adds	r5, r3, #1
 800efa2:	6873      	ldr	r3, [r6, #4]
 800efa4:	3b01      	subs	r3, #1
 800efa6:	2b00      	cmp	r3, #0
 800efa8:	6073      	str	r3, [r6, #4]
 800efaa:	dc06      	bgt.n	800efba <_scanf_i+0xb6>
 800efac:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 800efb0:	4631      	mov	r1, r6
 800efb2:	4658      	mov	r0, fp
 800efb4:	4798      	blx	r3
 800efb6:	2800      	cmp	r0, #0
 800efb8:	d176      	bne.n	800f0a8 <_scanf_i+0x1a4>
 800efba:	462b      	mov	r3, r5
 800efbc:	f108 0801 	add.w	r8, r8, #1
 800efc0:	f1b8 0f03 	cmp.w	r8, #3
 800efc4:	d1c9      	bne.n	800ef5a <_scanf_i+0x56>
 800efc6:	6862      	ldr	r2, [r4, #4]
 800efc8:	b90a      	cbnz	r2, 800efce <_scanf_i+0xca>
 800efca:	220a      	movs	r2, #10
 800efcc:	6062      	str	r2, [r4, #4]
 800efce:	6862      	ldr	r2, [r4, #4]
 800efd0:	4945      	ldr	r1, [pc, #276]	; (800f0e8 <_scanf_i+0x1e4>)
 800efd2:	6960      	ldr	r0, [r4, #20]
 800efd4:	9301      	str	r3, [sp, #4]
 800efd6:	1a89      	subs	r1, r1, r2
 800efd8:	f000 f8d0 	bl	800f17c <__sccl>
 800efdc:	9b01      	ldr	r3, [sp, #4]
 800efde:	f04f 0800 	mov.w	r8, #0
 800efe2:	461d      	mov	r5, r3
 800efe4:	68a3      	ldr	r3, [r4, #8]
 800efe6:	2b00      	cmp	r3, #0
 800efe8:	d038      	beq.n	800f05c <_scanf_i+0x158>
 800efea:	6831      	ldr	r1, [r6, #0]
 800efec:	6960      	ldr	r0, [r4, #20]
 800efee:	780a      	ldrb	r2, [r1, #0]
 800eff0:	5c80      	ldrb	r0, [r0, r2]
 800eff2:	2800      	cmp	r0, #0
 800eff4:	d032      	beq.n	800f05c <_scanf_i+0x158>
 800eff6:	2a30      	cmp	r2, #48	; 0x30
 800eff8:	6822      	ldr	r2, [r4, #0]
 800effa:	d121      	bne.n	800f040 <_scanf_i+0x13c>
 800effc:	0510      	lsls	r0, r2, #20
 800effe:	d51f      	bpl.n	800f040 <_scanf_i+0x13c>
 800f000:	f108 0801 	add.w	r8, r8, #1
 800f004:	b117      	cbz	r7, 800f00c <_scanf_i+0x108>
 800f006:	3301      	adds	r3, #1
 800f008:	3f01      	subs	r7, #1
 800f00a:	60a3      	str	r3, [r4, #8]
 800f00c:	6873      	ldr	r3, [r6, #4]
 800f00e:	3b01      	subs	r3, #1
 800f010:	2b00      	cmp	r3, #0
 800f012:	6073      	str	r3, [r6, #4]
 800f014:	dd1b      	ble.n	800f04e <_scanf_i+0x14a>
 800f016:	6833      	ldr	r3, [r6, #0]
 800f018:	3301      	adds	r3, #1
 800f01a:	6033      	str	r3, [r6, #0]
 800f01c:	68a3      	ldr	r3, [r4, #8]
 800f01e:	3b01      	subs	r3, #1
 800f020:	60a3      	str	r3, [r4, #8]
 800f022:	e7df      	b.n	800efe4 <_scanf_i+0xe0>
 800f024:	f1b8 0f02 	cmp.w	r8, #2
 800f028:	d1b1      	bne.n	800ef8e <_scanf_i+0x8a>
 800f02a:	6822      	ldr	r2, [r4, #0]
 800f02c:	f402 61c0 	and.w	r1, r2, #1536	; 0x600
 800f030:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 800f034:	d1c2      	bne.n	800efbc <_scanf_i+0xb8>
 800f036:	2110      	movs	r1, #16
 800f038:	6061      	str	r1, [r4, #4]
 800f03a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800f03e:	e7a5      	b.n	800ef8c <_scanf_i+0x88>
 800f040:	f422 6210 	bic.w	r2, r2, #2304	; 0x900
 800f044:	6022      	str	r2, [r4, #0]
 800f046:	780b      	ldrb	r3, [r1, #0]
 800f048:	702b      	strb	r3, [r5, #0]
 800f04a:	3501      	adds	r5, #1
 800f04c:	e7de      	b.n	800f00c <_scanf_i+0x108>
 800f04e:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
 800f052:	4631      	mov	r1, r6
 800f054:	4658      	mov	r0, fp
 800f056:	4798      	blx	r3
 800f058:	2800      	cmp	r0, #0
 800f05a:	d0df      	beq.n	800f01c <_scanf_i+0x118>
 800f05c:	6823      	ldr	r3, [r4, #0]
 800f05e:	05d9      	lsls	r1, r3, #23
 800f060:	d50c      	bpl.n	800f07c <_scanf_i+0x178>
 800f062:	454d      	cmp	r5, r9
 800f064:	d908      	bls.n	800f078 <_scanf_i+0x174>
 800f066:	f815 1c01 	ldrb.w	r1, [r5, #-1]
 800f06a:	f8d4 317c 	ldr.w	r3, [r4, #380]	; 0x17c
 800f06e:	4632      	mov	r2, r6
 800f070:	4658      	mov	r0, fp
 800f072:	4798      	blx	r3
 800f074:	1e6f      	subs	r7, r5, #1
 800f076:	463d      	mov	r5, r7
 800f078:	454d      	cmp	r5, r9
 800f07a:	d02c      	beq.n	800f0d6 <_scanf_i+0x1d2>
 800f07c:	6822      	ldr	r2, [r4, #0]
 800f07e:	f012 0210 	ands.w	r2, r2, #16
 800f082:	d11e      	bne.n	800f0c2 <_scanf_i+0x1be>
 800f084:	702a      	strb	r2, [r5, #0]
 800f086:	6863      	ldr	r3, [r4, #4]
 800f088:	9e00      	ldr	r6, [sp, #0]
 800f08a:	4649      	mov	r1, r9
 800f08c:	4658      	mov	r0, fp
 800f08e:	47b0      	blx	r6
 800f090:	6822      	ldr	r2, [r4, #0]
 800f092:	f8da 3000 	ldr.w	r3, [sl]
 800f096:	f012 0f20 	tst.w	r2, #32
 800f09a:	d008      	beq.n	800f0ae <_scanf_i+0x1aa>
 800f09c:	1d1a      	adds	r2, r3, #4
 800f09e:	f8ca 2000 	str.w	r2, [sl]
 800f0a2:	681b      	ldr	r3, [r3, #0]
 800f0a4:	6018      	str	r0, [r3, #0]
 800f0a6:	e009      	b.n	800f0bc <_scanf_i+0x1b8>
 800f0a8:	f04f 0800 	mov.w	r8, #0
 800f0ac:	e7d6      	b.n	800f05c <_scanf_i+0x158>
 800f0ae:	07d2      	lsls	r2, r2, #31
 800f0b0:	d5f4      	bpl.n	800f09c <_scanf_i+0x198>
 800f0b2:	1d1a      	adds	r2, r3, #4
 800f0b4:	f8ca 2000 	str.w	r2, [sl]
 800f0b8:	681b      	ldr	r3, [r3, #0]
 800f0ba:	8018      	strh	r0, [r3, #0]
 800f0bc:	68e3      	ldr	r3, [r4, #12]
 800f0be:	3301      	adds	r3, #1
 800f0c0:	60e3      	str	r3, [r4, #12]
 800f0c2:	eba5 0509 	sub.w	r5, r5, r9
 800f0c6:	44a8      	add	r8, r5
 800f0c8:	6925      	ldr	r5, [r4, #16]
 800f0ca:	4445      	add	r5, r8
 800f0cc:	6125      	str	r5, [r4, #16]
 800f0ce:	2000      	movs	r0, #0
 800f0d0:	b007      	add	sp, #28
 800f0d2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800f0d6:	2001      	movs	r0, #1
 800f0d8:	e7fa      	b.n	800f0d0 <_scanf_i+0x1cc>
 800f0da:	bf00      	nop
 800f0dc:	0800f54c 	.word	0x0800f54c
 800f0e0:	0800f2fd 	.word	0x0800f2fd
 800f0e4:	0800d72d 	.word	0x0800d72d
 800f0e8:	0801009f 	.word	0x0801009f

0800f0ec <_putc_r>:
 800f0ec:	b570      	push	{r4, r5, r6, lr}
 800f0ee:	460d      	mov	r5, r1
 800f0f0:	4614      	mov	r4, r2
 800f0f2:	4606      	mov	r6, r0
 800f0f4:	b118      	cbz	r0, 800f0fe <_putc_r+0x12>
 800f0f6:	6983      	ldr	r3, [r0, #24]
 800f0f8:	b90b      	cbnz	r3, 800f0fe <_putc_r+0x12>
 800f0fa:	f7fe ff59 	bl	800dfb0 <__sinit>
 800f0fe:	4b13      	ldr	r3, [pc, #76]	; (800f14c <_putc_r+0x60>)
 800f100:	429c      	cmp	r4, r3
 800f102:	d112      	bne.n	800f12a <_putc_r+0x3e>
 800f104:	6874      	ldr	r4, [r6, #4]
 800f106:	68a3      	ldr	r3, [r4, #8]
 800f108:	3b01      	subs	r3, #1
 800f10a:	2b00      	cmp	r3, #0
 800f10c:	60a3      	str	r3, [r4, #8]
 800f10e:	da16      	bge.n	800f13e <_putc_r+0x52>
 800f110:	69a2      	ldr	r2, [r4, #24]
 800f112:	4293      	cmp	r3, r2
 800f114:	db02      	blt.n	800f11c <_putc_r+0x30>
 800f116:	b2eb      	uxtb	r3, r5
 800f118:	2b0a      	cmp	r3, #10
 800f11a:	d110      	bne.n	800f13e <_putc_r+0x52>
 800f11c:	4622      	mov	r2, r4
 800f11e:	4629      	mov	r1, r5
 800f120:	4630      	mov	r0, r6
 800f122:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 800f126:	f7fe bd5b 	b.w	800dbe0 <__swbuf_r>
 800f12a:	4b09      	ldr	r3, [pc, #36]	; (800f150 <_putc_r+0x64>)
 800f12c:	429c      	cmp	r4, r3
 800f12e:	d101      	bne.n	800f134 <_putc_r+0x48>
 800f130:	68b4      	ldr	r4, [r6, #8]
 800f132:	e7e8      	b.n	800f106 <_putc_r+0x1a>
 800f134:	4b07      	ldr	r3, [pc, #28]	; (800f154 <_putc_r+0x68>)
 800f136:	429c      	cmp	r4, r3
 800f138:	bf08      	it	eq
 800f13a:	68f4      	ldreq	r4, [r6, #12]
 800f13c:	e7e3      	b.n	800f106 <_putc_r+0x1a>
 800f13e:	6823      	ldr	r3, [r4, #0]
 800f140:	1c5a      	adds	r2, r3, #1
 800f142:	6022      	str	r2, [r4, #0]
 800f144:	701d      	strb	r5, [r3, #0]
 800f146:	b2e8      	uxtb	r0, r5
 800f148:	bd70      	pop	{r4, r5, r6, pc}
 800f14a:	bf00      	nop
 800f14c:	0800ffb4 	.word	0x0800ffb4
 800f150:	0800ffd4 	.word	0x0800ffd4
 800f154:	0800ff94 	.word	0x0800ff94

0800f158 <_read_r>:
 800f158:	b538      	push	{r3, r4, r5, lr}
 800f15a:	4c07      	ldr	r4, [pc, #28]	; (800f178 <_read_r+0x20>)
 800f15c:	4605      	mov	r5, r0
 800f15e:	4608      	mov	r0, r1
 800f160:	4611      	mov	r1, r2
 800f162:	2200      	movs	r2, #0
 800f164:	6022      	str	r2, [r4, #0]
 800f166:	461a      	mov	r2, r3
 800f168:	f000 f9c6 	bl	800f4f8 <_read>
 800f16c:	1c43      	adds	r3, r0, #1
 800f16e:	d102      	bne.n	800f176 <_read_r+0x1e>
 800f170:	6823      	ldr	r3, [r4, #0]
 800f172:	b103      	cbz	r3, 800f176 <_read_r+0x1e>
 800f174:	602b      	str	r3, [r5, #0]
 800f176:	bd38      	pop	{r3, r4, r5, pc}
 800f178:	2000c63c 	.word	0x2000c63c

0800f17c <__sccl>:
 800f17c:	b570      	push	{r4, r5, r6, lr}
 800f17e:	780b      	ldrb	r3, [r1, #0]
 800f180:	2b5e      	cmp	r3, #94	; 0x5e
 800f182:	bf13      	iteet	ne
 800f184:	1c4a      	addne	r2, r1, #1
 800f186:	1c8a      	addeq	r2, r1, #2
 800f188:	784b      	ldrbeq	r3, [r1, #1]
 800f18a:	2100      	movne	r1, #0
 800f18c:	bf08      	it	eq
 800f18e:	2101      	moveq	r1, #1
 800f190:	1e44      	subs	r4, r0, #1
 800f192:	f100 05ff 	add.w	r5, r0, #255	; 0xff
 800f196:	f804 1f01 	strb.w	r1, [r4, #1]!
 800f19a:	42a5      	cmp	r5, r4
 800f19c:	d1fb      	bne.n	800f196 <__sccl+0x1a>
 800f19e:	b913      	cbnz	r3, 800f1a6 <__sccl+0x2a>
 800f1a0:	3a01      	subs	r2, #1
 800f1a2:	4610      	mov	r0, r2
 800f1a4:	bd70      	pop	{r4, r5, r6, pc}
 800f1a6:	f081 0401 	eor.w	r4, r1, #1
 800f1aa:	54c4      	strb	r4, [r0, r3]
 800f1ac:	4611      	mov	r1, r2
 800f1ae:	780d      	ldrb	r5, [r1, #0]
 800f1b0:	2d2d      	cmp	r5, #45	; 0x2d
 800f1b2:	f101 0201 	add.w	r2, r1, #1
 800f1b6:	d006      	beq.n	800f1c6 <__sccl+0x4a>
 800f1b8:	2d5d      	cmp	r5, #93	; 0x5d
 800f1ba:	d0f2      	beq.n	800f1a2 <__sccl+0x26>
 800f1bc:	b90d      	cbnz	r5, 800f1c2 <__sccl+0x46>
 800f1be:	460a      	mov	r2, r1
 800f1c0:	e7ef      	b.n	800f1a2 <__sccl+0x26>
 800f1c2:	462b      	mov	r3, r5
 800f1c4:	e7f1      	b.n	800f1aa <__sccl+0x2e>
 800f1c6:	784e      	ldrb	r6, [r1, #1]
 800f1c8:	2e5d      	cmp	r6, #93	; 0x5d
 800f1ca:	d0fa      	beq.n	800f1c2 <__sccl+0x46>
 800f1cc:	42b3      	cmp	r3, r6
 800f1ce:	dcf8      	bgt.n	800f1c2 <__sccl+0x46>
 800f1d0:	3102      	adds	r1, #2
 800f1d2:	3301      	adds	r3, #1
 800f1d4:	429e      	cmp	r6, r3
 800f1d6:	54c4      	strb	r4, [r0, r3]
 800f1d8:	dcfb      	bgt.n	800f1d2 <__sccl+0x56>
 800f1da:	e7e8      	b.n	800f1ae <__sccl+0x32>

0800f1dc <strncmp>:
 800f1dc:	b510      	push	{r4, lr}
 800f1de:	b16a      	cbz	r2, 800f1fc <strncmp+0x20>
 800f1e0:	3901      	subs	r1, #1
 800f1e2:	1884      	adds	r4, r0, r2
 800f1e4:	f810 3b01 	ldrb.w	r3, [r0], #1
 800f1e8:	f811 2f01 	ldrb.w	r2, [r1, #1]!
 800f1ec:	4293      	cmp	r3, r2
 800f1ee:	d103      	bne.n	800f1f8 <strncmp+0x1c>
 800f1f0:	42a0      	cmp	r0, r4
 800f1f2:	d001      	beq.n	800f1f8 <strncmp+0x1c>
 800f1f4:	2b00      	cmp	r3, #0
 800f1f6:	d1f5      	bne.n	800f1e4 <strncmp+0x8>
 800f1f8:	1a98      	subs	r0, r3, r2
 800f1fa:	bd10      	pop	{r4, pc}
 800f1fc:	4610      	mov	r0, r2
 800f1fe:	bd10      	pop	{r4, pc}

0800f200 <_strtoul_l.isra.0>:
 800f200:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800f204:	4680      	mov	r8, r0
 800f206:	4689      	mov	r9, r1
 800f208:	4692      	mov	sl, r2
 800f20a:	461e      	mov	r6, r3
 800f20c:	460f      	mov	r7, r1
 800f20e:	463d      	mov	r5, r7
 800f210:	9808      	ldr	r0, [sp, #32]
 800f212:	f815 4b01 	ldrb.w	r4, [r5], #1
 800f216:	f7fe ffa1 	bl	800e15c <__locale_ctype_ptr_l>
 800f21a:	4420      	add	r0, r4
 800f21c:	7843      	ldrb	r3, [r0, #1]
 800f21e:	f013 0308 	ands.w	r3, r3, #8
 800f222:	d10a      	bne.n	800f23a <_strtoul_l.isra.0+0x3a>
 800f224:	2c2d      	cmp	r4, #45	; 0x2d
 800f226:	d10a      	bne.n	800f23e <_strtoul_l.isra.0+0x3e>
 800f228:	782c      	ldrb	r4, [r5, #0]
 800f22a:	2301      	movs	r3, #1
 800f22c:	1cbd      	adds	r5, r7, #2
 800f22e:	b15e      	cbz	r6, 800f248 <_strtoul_l.isra.0+0x48>
 800f230:	2e10      	cmp	r6, #16
 800f232:	d113      	bne.n	800f25c <_strtoul_l.isra.0+0x5c>
 800f234:	2c30      	cmp	r4, #48	; 0x30
 800f236:	d009      	beq.n	800f24c <_strtoul_l.isra.0+0x4c>
 800f238:	e010      	b.n	800f25c <_strtoul_l.isra.0+0x5c>
 800f23a:	462f      	mov	r7, r5
 800f23c:	e7e7      	b.n	800f20e <_strtoul_l.isra.0+0xe>
 800f23e:	2c2b      	cmp	r4, #43	; 0x2b
 800f240:	bf04      	itt	eq
 800f242:	782c      	ldrbeq	r4, [r5, #0]
 800f244:	1cbd      	addeq	r5, r7, #2
 800f246:	e7f2      	b.n	800f22e <_strtoul_l.isra.0+0x2e>
 800f248:	2c30      	cmp	r4, #48	; 0x30
 800f24a:	d125      	bne.n	800f298 <_strtoul_l.isra.0+0x98>
 800f24c:	782a      	ldrb	r2, [r5, #0]
 800f24e:	f002 02df 	and.w	r2, r2, #223	; 0xdf
 800f252:	2a58      	cmp	r2, #88	; 0x58
 800f254:	d14a      	bne.n	800f2ec <_strtoul_l.isra.0+0xec>
 800f256:	786c      	ldrb	r4, [r5, #1]
 800f258:	2610      	movs	r6, #16
 800f25a:	3502      	adds	r5, #2
 800f25c:	f04f 31ff 	mov.w	r1, #4294967295
 800f260:	2700      	movs	r7, #0
 800f262:	fbb1 f1f6 	udiv	r1, r1, r6
 800f266:	fb06 fe01 	mul.w	lr, r6, r1
 800f26a:	ea6f 0e0e 	mvn.w	lr, lr
 800f26e:	4638      	mov	r0, r7
 800f270:	f1a4 0230 	sub.w	r2, r4, #48	; 0x30
 800f274:	2a09      	cmp	r2, #9
 800f276:	d811      	bhi.n	800f29c <_strtoul_l.isra.0+0x9c>
 800f278:	4614      	mov	r4, r2
 800f27a:	42a6      	cmp	r6, r4
 800f27c:	dd1d      	ble.n	800f2ba <_strtoul_l.isra.0+0xba>
 800f27e:	2f00      	cmp	r7, #0
 800f280:	db18      	blt.n	800f2b4 <_strtoul_l.isra.0+0xb4>
 800f282:	4281      	cmp	r1, r0
 800f284:	d316      	bcc.n	800f2b4 <_strtoul_l.isra.0+0xb4>
 800f286:	d101      	bne.n	800f28c <_strtoul_l.isra.0+0x8c>
 800f288:	45a6      	cmp	lr, r4
 800f28a:	db13      	blt.n	800f2b4 <_strtoul_l.isra.0+0xb4>
 800f28c:	fb00 4006 	mla	r0, r0, r6, r4
 800f290:	2701      	movs	r7, #1
 800f292:	f815 4b01 	ldrb.w	r4, [r5], #1
 800f296:	e7eb      	b.n	800f270 <_strtoul_l.isra.0+0x70>
 800f298:	260a      	movs	r6, #10
 800f29a:	e7df      	b.n	800f25c <_strtoul_l.isra.0+0x5c>
 800f29c:	f1a4 0241 	sub.w	r2, r4, #65	; 0x41
 800f2a0:	2a19      	cmp	r2, #25
 800f2a2:	d801      	bhi.n	800f2a8 <_strtoul_l.isra.0+0xa8>
 800f2a4:	3c37      	subs	r4, #55	; 0x37
 800f2a6:	e7e8      	b.n	800f27a <_strtoul_l.isra.0+0x7a>
 800f2a8:	f1a4 0261 	sub.w	r2, r4, #97	; 0x61
 800f2ac:	2a19      	cmp	r2, #25
 800f2ae:	d804      	bhi.n	800f2ba <_strtoul_l.isra.0+0xba>
 800f2b0:	3c57      	subs	r4, #87	; 0x57
 800f2b2:	e7e2      	b.n	800f27a <_strtoul_l.isra.0+0x7a>
 800f2b4:	f04f 37ff 	mov.w	r7, #4294967295
 800f2b8:	e7eb      	b.n	800f292 <_strtoul_l.isra.0+0x92>
 800f2ba:	2f00      	cmp	r7, #0
 800f2bc:	da09      	bge.n	800f2d2 <_strtoul_l.isra.0+0xd2>
 800f2be:	2322      	movs	r3, #34	; 0x22
 800f2c0:	f8c8 3000 	str.w	r3, [r8]
 800f2c4:	f04f 30ff 	mov.w	r0, #4294967295
 800f2c8:	f1ba 0f00 	cmp.w	sl, #0
 800f2cc:	d107      	bne.n	800f2de <_strtoul_l.isra.0+0xde>
 800f2ce:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800f2d2:	b103      	cbz	r3, 800f2d6 <_strtoul_l.isra.0+0xd6>
 800f2d4:	4240      	negs	r0, r0
 800f2d6:	f1ba 0f00 	cmp.w	sl, #0
 800f2da:	d00c      	beq.n	800f2f6 <_strtoul_l.isra.0+0xf6>
 800f2dc:	b127      	cbz	r7, 800f2e8 <_strtoul_l.isra.0+0xe8>
 800f2de:	3d01      	subs	r5, #1
 800f2e0:	f8ca 5000 	str.w	r5, [sl]
 800f2e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800f2e8:	464d      	mov	r5, r9
 800f2ea:	e7f9      	b.n	800f2e0 <_strtoul_l.isra.0+0xe0>
 800f2ec:	2430      	movs	r4, #48	; 0x30
 800f2ee:	2e00      	cmp	r6, #0
 800f2f0:	d1b4      	bne.n	800f25c <_strtoul_l.isra.0+0x5c>
 800f2f2:	2608      	movs	r6, #8
 800f2f4:	e7b2      	b.n	800f25c <_strtoul_l.isra.0+0x5c>
 800f2f6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

0800f2fc <_strtoul_r>:
 800f2fc:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800f2fe:	4c06      	ldr	r4, [pc, #24]	; (800f318 <_strtoul_r+0x1c>)
 800f300:	4d06      	ldr	r5, [pc, #24]	; (800f31c <_strtoul_r+0x20>)
 800f302:	6824      	ldr	r4, [r4, #0]
 800f304:	6a24      	ldr	r4, [r4, #32]
 800f306:	2c00      	cmp	r4, #0
 800f308:	bf08      	it	eq
 800f30a:	462c      	moveq	r4, r5
 800f30c:	9400      	str	r4, [sp, #0]
 800f30e:	f7ff ff77 	bl	800f200 <_strtoul_l.isra.0>
 800f312:	b003      	add	sp, #12
 800f314:	bd30      	pop	{r4, r5, pc}
 800f316:	bf00      	nop
 800f318:	2000002c 	.word	0x2000002c
 800f31c:	200000d8 	.word	0x200000d8

0800f320 <strtoul>:
 800f320:	4b08      	ldr	r3, [pc, #32]	; (800f344 <strtoul+0x24>)
 800f322:	b537      	push	{r0, r1, r2, r4, r5, lr}
 800f324:	681c      	ldr	r4, [r3, #0]
 800f326:	4d08      	ldr	r5, [pc, #32]	; (800f348 <strtoul+0x28>)
 800f328:	6a23      	ldr	r3, [r4, #32]
 800f32a:	2b00      	cmp	r3, #0
 800f32c:	bf08      	it	eq
 800f32e:	462b      	moveq	r3, r5
 800f330:	9300      	str	r3, [sp, #0]
 800f332:	4613      	mov	r3, r2
 800f334:	460a      	mov	r2, r1
 800f336:	4601      	mov	r1, r0
 800f338:	4620      	mov	r0, r4
 800f33a:	f7ff ff61 	bl	800f200 <_strtoul_l.isra.0>
 800f33e:	b003      	add	sp, #12
 800f340:	bd30      	pop	{r4, r5, pc}
 800f342:	bf00      	nop
 800f344:	2000002c 	.word	0x2000002c
 800f348:	200000d8 	.word	0x200000d8

0800f34c <__submore>:
 800f34c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800f350:	460c      	mov	r4, r1
 800f352:	6b49      	ldr	r1, [r1, #52]	; 0x34
 800f354:	f104 0344 	add.w	r3, r4, #68	; 0x44
 800f358:	4299      	cmp	r1, r3
 800f35a:	d11e      	bne.n	800f39a <__submore+0x4e>
 800f35c:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800f360:	f7fd ff7e 	bl	800d260 <_malloc_r>
 800f364:	b918      	cbnz	r0, 800f36e <__submore+0x22>
 800f366:	f04f 30ff 	mov.w	r0, #4294967295
 800f36a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f36e:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800f372:	63a3      	str	r3, [r4, #56]	; 0x38
 800f374:	f894 3046 	ldrb.w	r3, [r4, #70]	; 0x46
 800f378:	6360      	str	r0, [r4, #52]	; 0x34
 800f37a:	f880 33ff 	strb.w	r3, [r0, #1023]	; 0x3ff
 800f37e:	f894 3045 	ldrb.w	r3, [r4, #69]	; 0x45
 800f382:	f880 33fe 	strb.w	r3, [r0, #1022]	; 0x3fe
 800f386:	f894 3044 	ldrb.w	r3, [r4, #68]	; 0x44
 800f38a:	f880 33fd 	strb.w	r3, [r0, #1021]	; 0x3fd
 800f38e:	f200 30fd 	addw	r0, r0, #1021	; 0x3fd
 800f392:	6020      	str	r0, [r4, #0]
 800f394:	2000      	movs	r0, #0
 800f396:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800f39a:	6ba6      	ldr	r6, [r4, #56]	; 0x38
 800f39c:	0077      	lsls	r7, r6, #1
 800f39e:	463a      	mov	r2, r7
 800f3a0:	f000 f85a 	bl	800f458 <_realloc_r>
 800f3a4:	4605      	mov	r5, r0
 800f3a6:	2800      	cmp	r0, #0
 800f3a8:	d0dd      	beq.n	800f366 <__submore+0x1a>
 800f3aa:	eb00 0806 	add.w	r8, r0, r6
 800f3ae:	4601      	mov	r1, r0
 800f3b0:	4632      	mov	r2, r6
 800f3b2:	4640      	mov	r0, r8
 800f3b4:	f7fd fc97 	bl	800cce6 <memcpy>
 800f3b8:	f8c4 8000 	str.w	r8, [r4]
 800f3bc:	6365      	str	r5, [r4, #52]	; 0x34
 800f3be:	63a7      	str	r7, [r4, #56]	; 0x38
 800f3c0:	e7e8      	b.n	800f394 <__submore+0x48>

0800f3c2 <__ascii_wctomb>:
 800f3c2:	b149      	cbz	r1, 800f3d8 <__ascii_wctomb+0x16>
 800f3c4:	2aff      	cmp	r2, #255	; 0xff
 800f3c6:	bf85      	ittet	hi
 800f3c8:	238a      	movhi	r3, #138	; 0x8a
 800f3ca:	6003      	strhi	r3, [r0, #0]
 800f3cc:	700a      	strbls	r2, [r1, #0]
 800f3ce:	f04f 30ff 	movhi.w	r0, #4294967295
 800f3d2:	bf98      	it	ls
 800f3d4:	2001      	movls	r0, #1
 800f3d6:	4770      	bx	lr
 800f3d8:	4608      	mov	r0, r1
 800f3da:	4770      	bx	lr

0800f3dc <__env_lock>:
 800f3dc:	4770      	bx	lr

0800f3de <__env_unlock>:
 800f3de:	4770      	bx	lr

0800f3e0 <_fstat_r>:
 800f3e0:	b538      	push	{r3, r4, r5, lr}
 800f3e2:	4c07      	ldr	r4, [pc, #28]	; (800f400 <_fstat_r+0x20>)
 800f3e4:	2300      	movs	r3, #0
 800f3e6:	4605      	mov	r5, r0
 800f3e8:	4608      	mov	r0, r1
 800f3ea:	4611      	mov	r1, r2
 800f3ec:	6023      	str	r3, [r4, #0]
 800f3ee:	f000 f86b 	bl	800f4c8 <_fstat>
 800f3f2:	1c43      	adds	r3, r0, #1
 800f3f4:	d102      	bne.n	800f3fc <_fstat_r+0x1c>
 800f3f6:	6823      	ldr	r3, [r4, #0]
 800f3f8:	b103      	cbz	r3, 800f3fc <_fstat_r+0x1c>
 800f3fa:	602b      	str	r3, [r5, #0]
 800f3fc:	bd38      	pop	{r3, r4, r5, pc}
 800f3fe:	bf00      	nop
 800f400:	2000c63c 	.word	0x2000c63c

0800f404 <_isatty_r>:
 800f404:	b538      	push	{r3, r4, r5, lr}
 800f406:	4c06      	ldr	r4, [pc, #24]	; (800f420 <_isatty_r+0x1c>)
 800f408:	2300      	movs	r3, #0
 800f40a:	4605      	mov	r5, r0
 800f40c:	4608      	mov	r0, r1
 800f40e:	6023      	str	r3, [r4, #0]
 800f410:	f000 f862 	bl	800f4d8 <_isatty>
 800f414:	1c43      	adds	r3, r0, #1
 800f416:	d102      	bne.n	800f41e <_isatty_r+0x1a>
 800f418:	6823      	ldr	r3, [r4, #0]
 800f41a:	b103      	cbz	r3, 800f41e <_isatty_r+0x1a>
 800f41c:	602b      	str	r3, [r5, #0]
 800f41e:	bd38      	pop	{r3, r4, r5, pc}
 800f420:	2000c63c 	.word	0x2000c63c

0800f424 <memmove>:
 800f424:	4288      	cmp	r0, r1
 800f426:	b510      	push	{r4, lr}
 800f428:	eb01 0302 	add.w	r3, r1, r2
 800f42c:	d803      	bhi.n	800f436 <memmove+0x12>
 800f42e:	1e42      	subs	r2, r0, #1
 800f430:	4299      	cmp	r1, r3
 800f432:	d10c      	bne.n	800f44e <memmove+0x2a>
 800f434:	bd10      	pop	{r4, pc}
 800f436:	4298      	cmp	r0, r3
 800f438:	d2f9      	bcs.n	800f42e <memmove+0xa>
 800f43a:	1881      	adds	r1, r0, r2
 800f43c:	1ad2      	subs	r2, r2, r3
 800f43e:	42d3      	cmn	r3, r2
 800f440:	d100      	bne.n	800f444 <memmove+0x20>
 800f442:	bd10      	pop	{r4, pc}
 800f444:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 800f448:	f801 4d01 	strb.w	r4, [r1, #-1]!
 800f44c:	e7f7      	b.n	800f43e <memmove+0x1a>
 800f44e:	f811 4b01 	ldrb.w	r4, [r1], #1
 800f452:	f802 4f01 	strb.w	r4, [r2, #1]!
 800f456:	e7eb      	b.n	800f430 <memmove+0xc>

0800f458 <_realloc_r>:
 800f458:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f45a:	4607      	mov	r7, r0
 800f45c:	4614      	mov	r4, r2
 800f45e:	460e      	mov	r6, r1
 800f460:	b921      	cbnz	r1, 800f46c <_realloc_r+0x14>
 800f462:	4611      	mov	r1, r2
 800f464:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 800f468:	f7fd befa 	b.w	800d260 <_malloc_r>
 800f46c:	b922      	cbnz	r2, 800f478 <_realloc_r+0x20>
 800f46e:	f7fd fea9 	bl	800d1c4 <_free_r>
 800f472:	4625      	mov	r5, r4
 800f474:	4628      	mov	r0, r5
 800f476:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800f478:	f000 f814 	bl	800f4a4 <_malloc_usable_size_r>
 800f47c:	4284      	cmp	r4, r0
 800f47e:	d90f      	bls.n	800f4a0 <_realloc_r+0x48>
 800f480:	4621      	mov	r1, r4
 800f482:	4638      	mov	r0, r7
 800f484:	f7fd feec 	bl	800d260 <_malloc_r>
 800f488:	4605      	mov	r5, r0
 800f48a:	2800      	cmp	r0, #0
 800f48c:	d0f2      	beq.n	800f474 <_realloc_r+0x1c>
 800f48e:	4631      	mov	r1, r6
 800f490:	4622      	mov	r2, r4
 800f492:	f7fd fc28 	bl	800cce6 <memcpy>
 800f496:	4631      	mov	r1, r6
 800f498:	4638      	mov	r0, r7
 800f49a:	f7fd fe93 	bl	800d1c4 <_free_r>
 800f49e:	e7e9      	b.n	800f474 <_realloc_r+0x1c>
 800f4a0:	4635      	mov	r5, r6
 800f4a2:	e7e7      	b.n	800f474 <_realloc_r+0x1c>

0800f4a4 <_malloc_usable_size_r>:
 800f4a4:	f851 0c04 	ldr.w	r0, [r1, #-4]
 800f4a8:	2800      	cmp	r0, #0
 800f4aa:	f1a0 0004 	sub.w	r0, r0, #4
 800f4ae:	bfbc      	itt	lt
 800f4b0:	580b      	ldrlt	r3, [r1, r0]
 800f4b2:	18c0      	addlt	r0, r0, r3
 800f4b4:	4770      	bx	lr
	...

0800f4b8 <_close>:
 800f4b8:	4b02      	ldr	r3, [pc, #8]	; (800f4c4 <_close+0xc>)
 800f4ba:	2258      	movs	r2, #88	; 0x58
 800f4bc:	601a      	str	r2, [r3, #0]
 800f4be:	f04f 30ff 	mov.w	r0, #4294967295
 800f4c2:	4770      	bx	lr
 800f4c4:	2000c63c 	.word	0x2000c63c

0800f4c8 <_fstat>:
 800f4c8:	4b02      	ldr	r3, [pc, #8]	; (800f4d4 <_fstat+0xc>)
 800f4ca:	2258      	movs	r2, #88	; 0x58
 800f4cc:	601a      	str	r2, [r3, #0]
 800f4ce:	f04f 30ff 	mov.w	r0, #4294967295
 800f4d2:	4770      	bx	lr
 800f4d4:	2000c63c 	.word	0x2000c63c

0800f4d8 <_isatty>:
 800f4d8:	4b02      	ldr	r3, [pc, #8]	; (800f4e4 <_isatty+0xc>)
 800f4da:	2258      	movs	r2, #88	; 0x58
 800f4dc:	601a      	str	r2, [r3, #0]
 800f4de:	2000      	movs	r0, #0
 800f4e0:	4770      	bx	lr
 800f4e2:	bf00      	nop
 800f4e4:	2000c63c 	.word	0x2000c63c

0800f4e8 <_lseek>:
 800f4e8:	4b02      	ldr	r3, [pc, #8]	; (800f4f4 <_lseek+0xc>)
 800f4ea:	2258      	movs	r2, #88	; 0x58
 800f4ec:	601a      	str	r2, [r3, #0]
 800f4ee:	f04f 30ff 	mov.w	r0, #4294967295
 800f4f2:	4770      	bx	lr
 800f4f4:	2000c63c 	.word	0x2000c63c

0800f4f8 <_read>:
 800f4f8:	4b02      	ldr	r3, [pc, #8]	; (800f504 <_read+0xc>)
 800f4fa:	2258      	movs	r2, #88	; 0x58
 800f4fc:	601a      	str	r2, [r3, #0]
 800f4fe:	f04f 30ff 	mov.w	r0, #4294967295
 800f502:	4770      	bx	lr
 800f504:	2000c63c 	.word	0x2000c63c

0800f508 <_sbrk>:
 800f508:	4b04      	ldr	r3, [pc, #16]	; (800f51c <_sbrk+0x14>)
 800f50a:	6819      	ldr	r1, [r3, #0]
 800f50c:	4602      	mov	r2, r0
 800f50e:	b909      	cbnz	r1, 800f514 <_sbrk+0xc>
 800f510:	4903      	ldr	r1, [pc, #12]	; (800f520 <_sbrk+0x18>)
 800f512:	6019      	str	r1, [r3, #0]
 800f514:	6818      	ldr	r0, [r3, #0]
 800f516:	4402      	add	r2, r0
 800f518:	601a      	str	r2, [r3, #0]
 800f51a:	4770      	bx	lr
 800f51c:	200003cc 	.word	0x200003cc
 800f520:	2000c640 	.word	0x2000c640

0800f524 <_init>:
 800f524:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f526:	bf00      	nop
 800f528:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800f52a:	bc08      	pop	{r3}
 800f52c:	469e      	mov	lr, r3
 800f52e:	4770      	bx	lr

0800f530 <_fini>:
 800f530:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 800f532:	bf00      	nop
 800f534:	bcf8      	pop	{r3, r4, r5, r6, r7}
 800f536:	bc08      	pop	{r3}
 800f538:	469e      	mov	lr, r3
 800f53a:	4770      	bx	lr
